'From Squeak 2.2 of Sept 23, 1998 on 23 September 1998 at 6:04:30 pm'!I am a parser for AIFF (audio interchange file format) files. I can read uncompressed 8-bit and 16-bit mono, stereo, or multichannel AIFF files. I read the marker information used by the TransferStation utility to mark the loop points in sounds extracted from commercial sampled-sound CD-ROMs.!!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 16:27'!readFromFile: fileName	"Read the AIFF file of the given name."	"AIFFFileReader new readFromFile: 'test.aiff'"	self readFromFile: fileName		mergeIfStereo: false		skipDataChunk: false.! !!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 20:06'!readFromFile: fileName mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read the AIFF file of the given name. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."	"AIFFFileReader new readFromFile: 'test.aiff' mergeIfStereo: false skipDataChunk: true"	| f |	mergeIfStereo _ mergeFlag.	skipDataChunk _ skipDataFlag.	f _ (FileStream readOnlyFileNamed: fileName) binary.	self readFrom: f.	f close.! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!bitsPerSample	^ bitsPerSample! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!channelCount	^ channelCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!channelData	^ channelData! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!frameCount	^ frameCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!gain	^ gain! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:40'!isLooped	^ isLooped! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 20:02'!isStereo	^ channelData size = 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:26'!leftSamples	^ channelData at: 1! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopEnd	^ markers last last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopLength	^ markers last last - markers first last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!markers	^ markers! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:48'!pitch	^ pitch! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 19:34'!rightSamples	^ channelData at: 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:25'!samplingRate	^ samplingRate! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 8/17/1998 20:36'!edit	| ed |	ed _ WaveEditor new.	ed data: channelData first.	ed loopEnd: markers last last.	ed loopLength: (markers last last - markers first last) + 1.	ed openInWorld.! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 7/12/1998 01:44'!pitchForKey: midiKey	"Convert my MIDI key number to a pitch and return it."	| indexInOctave octave p |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"	p _ #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 8/2/1998 19:26'!play	"Play the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."	| snd rightSnd |	snd _ SampledSound		samples: (channelData at: 1)		samplingRate: samplingRate.	self isStereo ifTrue: [		rightSnd _ SampledSound			samples: (channelData at: 2)			samplingRate: samplingRate.		snd _ MixedSound new			add: snd pan: 0;			add: rightSnd pan: 1.0].	snd play.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 07:33'!readChunk: chunkType size: chunkSize	"Read a AIFF chunk of the given type. Skip unrecognized chunks. Leave the input stream positioned chunkSize bytes past its position when this method is called."	chunkType = 'COMM' ifTrue: [^ self readCommonChunk: chunkSize].	chunkType = 'SSND' ifTrue: [^ self readSamplesChunk: chunkSize].	chunkType = 'INST' ifTrue: [^ self readInstrumentChunk: chunkSize].	chunkType = 'MARK' ifTrue: [^ self readMarkerChunk: chunkSize].	in skip: chunkSize.  "skip unknown chunks"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 7/12/1998 18:24'!readCommonChunk: chunkSize	"Read a COMM chunk. All AIFF files have exactly one chunk of this type."	| compressionType |	channelCount _ in nextNumber: 2.	frameCount _ in nextNumber: 4.	bitsPerSample _ in nextNumber: 2.	samplingRate _ self readExtendedFloat.	chunkSize > 18 ifTrue: [		fileType = 'AIFF'			ifTrue: [self error: 'unexpectedly long COMM chunk size for AIFF file'].		compressionType _ (in next: 4) asString.		compressionType = 'NONE' ifFalse: [self error: 'cannot read compressed AIFF files'].		in skip: (chunkSize - 22)].  "skip the reminder of AIFF-C style chunk"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 11:43'!readExtendedFloat	"Read and answer an Apple extended-precision 80-bit floating point number from the input stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| signAndExp mantissa sign exp |	signAndExp _ in nextNumber: 2.	mantissa _ in nextNumber: 8.  "scaled by (2 raisedTo: -64) below"	(signAndExp bitAnd: 16r8000) = 0		ifTrue: [sign _ 1.0]		ifFalse: [sign _ -1.0].	exp _ (signAndExp bitAnd: 16r7FFF) - 16r4000 + 2.  "not sure why +2 is needed..."	^ (sign * mantissa asFloat * (2.0 raisedTo: exp - 64)) roundTo: 0.00000001! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 19:58'!readFrom: aBinaryStream	"Read AIFF data from the given binary stream."	"Details: An AIFF file consists of a header (FORM chunk) followed by a sequence of tagged data chunks. Each chunk starts with a header consisting of a four-byte tag (a string) and a four byte size. These eight bytes of chunk header are not included in the chunk size. For each chunk, the readChunk:size: method consumes chunkSize bytes of the input stream, parsing recognized chunks or skipping unrecognized ones. If chunkSize is odd, it will be followed by a padding byte. Chunks may occur in any order."	| sz end chunkType chunkSize p |	in _ aBinaryStream.	"read FORM chunk"	(in next: 4) asString = 'FORM' ifFalse: [^ self error: 'not an AIFF file'].	sz _ in nextNumber: 4.	end _ in position + sz.	fileType _ (in next: 4) asString.	[in atEnd not and: [in position < end]] whileTrue: [		chunkType _ (in next: 4) asString.		chunkSize _ in nextNumber: 4.		p _ in position.		self readChunk: chunkType size: chunkSize.		(in position = (p + chunkSize))			ifFalse: [self error: 'chunk size mismatch; bad AIFF file?'].		chunkSize odd ifTrue: [in skip: 1]].  "skip padding byte"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/5/1998 17:31'!readInstrumentChunk: chunkSize	| midiKey detune lowNote highNote lowVelocity highVelocity	  sustainMode sustainStartID sustainEndID	  releaseMode releaseStartID releaseEndID |	midiKey _ in next.	detune _ in next.	lowNote _ in next.	highNote _ in next.	lowVelocity _ in next.	highVelocity _ in next.	gain _ in nextNumber: 2.	sustainMode _ in nextNumber: 2.	sustainStartID _ in nextNumber: 2.	sustainEndID _ in nextNumber: 2.	releaseMode _ in nextNumber: 2.	releaseStartID _ in nextNumber: 2.	releaseEndID _ in nextNumber: 2.	isLooped _ sustainMode = 1.	(isLooped and: [markers notNil]) ifTrue: [		((markers first last > frameCount) or:		 [markers last last > frameCount]) ifTrue: [			"bad loop data; some sample CD files claim to be looped but aren't"			isLooped _ false]].	pitch _ self pitchForKey: midiKey.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 21:22'!readMarkerChunk: chunkSize	| markerCount id position labelBytes label |	markerCount _ in nextNumber: 2.	markers _ Array new: markerCount.	1 to: markerCount do: [:i |		id _ in nextNumber: 2.		position _ in nextNumber: 4.		labelBytes _ in next.		label _ (in next: labelBytes) asString.		labelBytes even ifTrue: [in skip: 1].		markers at: i put: (Array with: id with: label with: position)].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:58'!readMergedStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream, mixing the two channels to create a single monophonic channel. Each frame contains two samples."	| buf w1 w2 |	buf _ channelData at: 1.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w1 _ s next.				w1 > 127 ifTrue: [w1 _ w1 - 256].				w2 _ s next.				w2 > 127 ifTrue: [w2 _ w2 - 256].				buf at: i put: ((w1 + w2) bitShift: 7)]]		ifFalse: [			1 to: frameCount do: [:i |				w1 _ (s next bitShift: 8) + s next.				w1 > 32767 ifTrue: [w1 _ w1 - 65536].				w2 _ (s next bitShift: 8) + s next.				w2 > 32767 ifTrue: [w2 _ w2 - 65536].				buf at: i put: ((w1 + w2) bitShift: -1)]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:53'!readMonoChannelDataFrom: s	"Read monophonic channel data from the given stream. Each frame contains a single sample."	| buf w |	buf _ channelData at: 1.  "the only buffer"	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w _ s next.				w > 127 ifTrue: [w _ w - 256].				buf at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				buf at: i put: w]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:55'!readMultiChannelDataFrom: s	"Read multi-channel data from the given stream. Each frame contains channelCount samples."	| w |	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w _ s next.					w > 127 ifTrue: [w _ w - 256].					(channelData at: ch) at: i put: (w bitShift: 8)]]]		ifFalse: [			1 to: frameCount do: [:i |				1 to: channelCount do: [:ch |					w _ (s next bitShift: 8) + s next.					w > 32767 ifTrue: [w _ w - 65536].					(channelData at: ch) at: i put: w]]].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/3/1998 14:55'!readSamplesChunk: chunkSize	"Read a SSND chunk. All AIFF files with a non-zero frameCount contain exactly one chunk of this type."	| offset blockSize bytesOfSamples s |	skipDataChunk ifTrue: [in skip: chunkSize. ^ self].	offset _ in nextNumber: 4.	blockSize _ in nextNumber: 4.	((offset ~= 0) or: [blockSize ~= 0])		ifTrue: [^ self error: 'this AIFF reader cannot handle blocked sample chunks'].	bytesOfSamples _ chunkSize - 8.	bytesOfSamples = (channelCount * frameCount * (bitsPerSample // 8))		ifFalse: [self error: 'actual sample count does not match COMM chunk'].	(mergeIfStereo and: [channelCount = 2])		ifTrue: [			channelData _ Array with: (SoundBuffer newMonoSampleCount: frameCount)]		ifFalse: [			channelData _				(1 to: channelCount) collect: [:i | SoundBuffer newMonoSampleCount: frameCount]].	(bytesOfSamples < (Smalltalk garbageCollectMost - 300000))		ifTrue: [s _ ReadStream on: (in next: bytesOfSamples)]  "bulk-read, then process"		ifFalse: [s _ in].  "not enough space to buffer; read directly from file"	"mono and stereo are special-cased for better performance"	channelCount = 1 ifTrue: [^ self readMonoChannelDataFrom: s].	channelCount = 2 ifTrue: [		mergeIfStereo			ifTrue: [channelCount _ 1. ^ self readMergedStereoChannelDataFrom: s]			ifFalse: [^ self readStereoChannelDataFrom: s]].	self readMultiChannelDataFrom: s.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 8/2/1998 18:56'!readStereoChannelDataFrom: s	"Read stereophonic channel data from the given stream. Each frame contains two samples."	| left right w |	left _ channelData at: 1.	right _ channelData at: 2.	bitsPerSample = 8		ifTrue: [			1 to: frameCount do: [:i |				w _ s next.				w > 127 ifTrue: [w _ w - 256].				left at: i put: (w bitShift: 8).				w _ s next.				w > 127 ifTrue: [w _ w - 256].				right at: i put: (w bitShift: 8)]]		ifFalse: [			1 to: frameCount do: [:i |				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				left at: i put: w.				w _ (s next bitShift: 8) + s next.				w > 32767 ifTrue: [w _ w - 65536].				right at: i put: w]].! !!AbstractScoreEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	"Subclasses should override to return the ending time if the event has some duration."	^ time! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isControlChange	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isPitchBend	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isProgramChange	^ false! !!AbstractScoreEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port. This default implementation does nothing."! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:04'!nameOrNumberToPitch: aStringOrNumber	"Answer the pitch in cycles/second for the given pitch specification. The specification can be either a numeric pitch or pitch name such as 'c4'."	aStringOrNumber isNumber		ifTrue: [^ aStringOrNumber asFloat]		ifFalse: [^ AbstractSound pitchForName: aStringOrNumber]! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/19/1998 08:45'!setPitch: pitchNameOrNumber dur: d loudness: l	"Initialize my envelopes for the given parameters. Subclasses overriding this method should include a resend to super."	| p |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	envelopes do: [:e |		e volume: l.		e centerPitch: p].	self initialVolume: l.	self duration: d.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 17:11'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	^ self copy		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: l! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 16:58'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	^ self copy setPitch: pitchNameOrNumber dur: d loudness: l! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 8/18/1998 09:57'!removeAllEnvelopes	"Remove all envelopes from my envelopes list."	envelopes _ #().! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:37'!loudness	"Answer the current volume setting for this sound."	^ scaledVol asFloat / ScaleFactor asFloat! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:28'!volumeEnvelopeScaledTo: scalePoint	"Return a collection of values representing my volume envelope scaled by the given point. The scale point's x component is pixels/second and its y component is the number of pixels for full volume."	self error: 'not yet implemented'.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 15:09'!playAndWaitUntilDone	"Play this sound to the sound ouput port and wait until it has finished playing before returning."	SoundPlayer playSound: self.	[self samplesRemaining > 0] whileTrue.	(Delay forMilliseconds: 2 * SoundPlayer bufferMSecs) wait.  "ensure last buffer has been output"! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/18/1998 10:52'!playChromaticRunFrom: startPitch to: endPitch	"Play a fast chromatic run between the given pitches. Useful for auditioning a sound."	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 16:17'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index. Update the receiver's control parameters periodically."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol _ AbstractSound scaleFactor.	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just after the last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].		remainingSamples < count ifTrue: [count _ remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates].		i _ i + count].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 7/5/1998 17:53'!playSilently	"Compute the samples of this sound without outputting them. Used for performance analysis."	| bufSize buf |	self reset.	bufSize _ self samplingRate // 10.	buf _ SoundBuffer newStereoSampleCount: bufSize.	[self samplesRemaining > 0] whileTrue: [		buf primFill: 0.		self playSampleCount: bufSize into: buf startingAt: 1].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/19/1998 08:30'!viewSamples	| stereoBuf |	stereoBuf _ self computeSamplesForSeconds: self duration.	WaveEditor openOn: stereoBuf extractLeftChannel.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:34'!doControl	"Update the control parameters of this sound using its envelopes, if any."	"Note: This is only called at a small fraction of the sampling rate."	| pitchModOrRatioChange |	envelopes size > 0 ifTrue: [		pitchModOrRatioChange _ false.		1 to: envelopes size do: [:i |			((envelopes at: i) updateTargetAt: mSecsSinceStart)				ifTrue: [pitchModOrRatioChange _ true]].		pitchModOrRatioChange ifTrue: [self internalizeModulationAndRatio]].	mSecsSinceStart _ mSecsSinceStart + (1000 // self controlRate).! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 7/6/1998 06:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The leftVol and rightVol parameters determine the volume of the sound in each channel, where 0 is silence and ScaleFactor is full volume."	self subclassResponsibility.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:45'!reset	"Reset my internal state for a replay. Methods that override this method should do super reset."	mSecsSinceStart _ 0.	samplesUntilNextControl _ 0.	envelopes size > 0 ifTrue: [		1 to: envelopes size do: [:i | (envelopes at: i) reset]].! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:56'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds. This default implementation does nothing."! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:54'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	| decayInMs env |	envelopes isEmpty		ifTrue: [			self adjustVolumeTo: 0 overMSecs: 10.			decayInMs _ 10]		ifFalse: [			env _ envelopes first.			decayInMs _ env attackTime + env decayTime].	self duration: (mSecsSinceStart + decayInMs) / 1000.0.	self stopAfterMSecs: decayInMs.! !!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 8/3/1998 16:13'!initialize	"AbstractSound initialize" 	| bottomC |	ScaleFactor _ 2 raisedTo: 15.	FloatScaleFactor _ ScaleFactor asFloat.	MaxScaledValue _ ((2 raisedTo: 31) // ScaleFactor) - 1.  "magnitude of largest scaled value in 32-bits"	"generate pitches for c-1 through c0"	bottomC _ (440.0 / 32) * (2.0 raisedTo: -9.0 / 12.0).	PitchesForBottomOctave _ (0 to: 12) collect: [:i | bottomC * (2.0 raisedTo: i asFloat / 12.0)].	TopOfBottomOctave _ PitchesForBottomOctave last.! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:00'!noteSequenceOn: aSound from: anArray	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitch, duration, loudness) triples or (#rest duration) pairs.  Pitches can be given as names or as numbers."	| score pitch |	score _ SequentialSound new.	anArray do: [:el |		el size = 3			ifTrue: [				pitch _ el at: 1.				pitch isNumber ifFalse: [pitch _ self pitchForName: pitch].				score add: (					aSound						soundForPitch: pitch						dur: (el at: 2)						loudness: (el at: 3) / 1000.0)]			ifFalse: [				score add: (RestSound dur: (el at: 2))]].	^ score! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!indexOfBottomOctavePitch: p	"Answer the index of the first pitch in the bottom octave equal to or higher than the given pitch. Assume that the given pitch is below the top pitch of the bottom octave."	1 to: PitchesForBottomOctave size do: [:i |		(PitchesForBottomOctave at: i) >= p ifTrue: [^ i]].	self error: 'implementation error: argument pitch should be below or within the bottom octave'.! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!midiKeyForPitch: pitchNameOrNumber	"Answer the midiKey closest to the given pitch. Pitch may be a numeric pitch or a pitch name string such as 'c4'."	"AbstractSound midiKeyForPitch: 440.0"	| p octave i midiKey |	pitchNameOrNumber isNumber		ifTrue: [p _ pitchNameOrNumber asFloat]		ifFalse: [p _ AbstractSound pitchForName: pitchNameOrNumber].	octave _ -1.	[p >= TopOfBottomOctave] whileTrue: [		octave _ octave + 1.		p _ p / 2.0].	i _ self indexOfBottomOctavePitch: p.	(i > 1) ifTrue: [		(p - (PitchesForBottomOctave at: i - 1)) < ((PitchesForBottomOctave at: i) - p)			ifTrue: [i _ i - 1]].	midiKey _ ((octave * 12) + 11 + i).	midiKey > 127 ifTrue: [midiKey _ 127].	^ midiKey! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:43'!pitchForMIDIKey: midiKey	"Answer the pitch for the given MIDI key."	"(1 to: 127) collect: [:i | AbstractSound pitchForMIDIKey: i]"	| indexInOctave octave |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	^ (PitchesForBottomOctave at: indexInOctave) *		(#(1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0 1024.0) at: octave)! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 7/6/1998 15:47'!pitchTable	"AbstractSound pitchTable"	| out note i |	out _ WriteStream on: (String new: 1000).	i _ 12.	0 to: 8 do: [:octave |		#(c 'c#' d eb e f fs g 'g#' a bf b) do: [:noteName |			note _ noteName, octave printString.			out nextPutAll: note; tab.			out nextPutAll: i printString; tab.			out nextPutAll: (AbstractSound pitchForName: note) printString; cr.			i _ i + 1]].	^ out contents! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 6/30/1998 18:40'!chromaticPitchesFrom: aPitch	| halfStep pitch |	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	pitch _ aPitch isNumber			ifTrue: [aPitch]			ifFalse: [self pitchForName: aPitch].	pitch _ pitch / halfStep.	^ (0 to: 14) collect: [:i | pitch _ pitch * halfStep]! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/18/1998 11:32'!chromaticRunFrom: startPitch to: endPitch on: aSound	"Answer a composite sound consisting of a rapid chromatic run between the given pitches on the given sound."	"(AbstractSound chromaticRunFrom: 'c3' to: 'c#5' on: FMSound oboe1) play"	| scale halfStep pEnd p |	scale _ SequentialSound new.	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	endPitch isNumber		ifTrue: [pEnd _ endPitch asFloat]		ifFalse: [pEnd _ AbstractSound pitchForName: endPitch].	startPitch isNumber		ifTrue: [p _ startPitch asFloat]		ifFalse: [p _ AbstractSound pitchForName: startPitch].	[p <= pEnd] whileTrue: [		scale add: (aSound soundForPitch: p dur: 0.2 loudness: 0.5).		p _ p * halfStep].	^ scale! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/3/1998 17:00'!majorChordOn: aSound from: aPitch	"FMSound majorChord play"	| score majorScale leadingRest pan note |	majorScale _ self majorPitchesFrom: aPitch.	score _ MixedSound new.	leadingRest _ pan _ 0.	#(1 3 5 8) do: [:noteIndex |		note _ aSound			soundForPitch: (majorScale at: noteIndex)			dur: 2.0 - leadingRest			loudness: 0.3.		score add: (RestSound dur: leadingRest), note pan: pan.		leadingRest _ leadingRest + 0.2.		pan _ pan + 0.3].	^ score! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 7/13/1998 13:09'!majorScaleOn: aSound from: aPitch	"FMSound majorScale play"	^ self noteSequenceOn: aSound		from: ((self majorPitchesFrom: aPitch)			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:27'!initSounds	"AbstractSound initSounds"	Sounds _ Dictionary new.	(FMSound class organization listAtCategoryNamed: #instruments)		do: [:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:25'!soundNamed: soundName	^ Sounds at: soundName! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/19/1998 14:11'!soundNames	^ Sounds keys asSortedCollection asArray! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/4/1998 18:26'!sounds	^ Sounds! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 13:11'!fileInSoundLibrary	"Prompt the user for a file name and the file in the sound library with that name."	"AbstractSound fileInSoundLibrary"	| fileName |	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName ifNil: [^ self].	(fileName endsWith: '.sounds') ifFalse: [fileName _ fileName, '.sounds'].	self fileInSoundLibraryNamed: fileName.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!fileInSoundLibraryNamed: fileName	"File in the sound library with the given file name, and add its contents to the current sound library."	| s newSounds |	s _ FileStream oldFileNamed: fileName.	newSounds _ s fileInObjectAndCode.	s close.	newSounds associationsDo:		[:assoc | self storeFiledInSound: assoc value named: assoc key].	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 12:42'!fileOutSoundLibrary	"File out the current sound library."	"AbstractSound fileOutSoundLibrary"	self fileOutSoundLibrary: Sounds.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 13:50'!fileOutSoundLibrary: aDictionary	"File out the given dictionary, which is assumed to contain sound and instrument objects keyed by their names."	"Note: This method is separated out so that one can file out edited sound libraries, as well as the system sound library. To make such a collection, you can inspect AbstractSound sounds and remove the items you don't want. Then do: 'AbstractSound fileOutSoundLibrary: self' from the Dictionary inspector."	| fileName refStream |	(aDictionary isKindOf: Dictionary)		ifFalse: [self error: 'arg should be a dictionary of sounds'].	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName ifNil: [^ self].	refStream _ SmartRefStream fileNamed: fileName, '.sounds'.	refStream nextPut: aDictionary.	refStream close.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:35'!storeFiledInSound: snd named: sndName	"Store the given sound in the sound library. Use the given name if it isn't in use, otherwise ask the user what to do."	| menu choice i |	(Sounds includesKey: sndName) ifFalse: [  "no name clash"		Sounds at: sndName put: snd.		^ self].	(Sounds at: sndName) == UnloadedSnd ifTrue: [		"re-loading a sound that was unloaded to save space"		Sounds at: sndName put: snd.		^ self].	"the given sound name is already used"	menu _ SelectionMenu selections:		#('replace the existing sound' 'rename the new sound' 'skip it').	choice _ menu startUpWithCaption:		'"', sndName, '" has the same name as an existing sound'.	(choice beginsWith: 'replace') ifTrue: [		Sounds at: sndName put: snd.		^ self].	(choice beginsWith: 'rename') ifTrue: [		i _ 2.		[Sounds includesKey: (sndName, ' v', i printString)] whileTrue: [i _ i + 1].		Sounds at: (sndName, ' v', i printString) put: snd].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!unloadSampledTimbres	"This can be done to unload those bulky sampled timbres to shrink the image. The unloaded sounds are replaced by a well-known 'unloaded sound' object to enable the unloaded sounds to be detected when the process is reversed."	"AbstractSound unloadSampledTimbres"	Sounds keys copy do: [:soundName |		(((Sounds at: soundName) isKindOf: SampledInstrument) or:		 [(Sounds at: soundName) isKindOf: LoopedSampledSound]) ifTrue: [			Sounds at: soundName put: self unloadedSound]].	self updateScorePlayers.	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:47'!unloadSoundNamed: soundName	(Sounds includesKey: soundName) ifTrue: [		Sounds at: soundName put: self unloadedSound].	self updateScorePlayers.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:48'!unloadedSound	"Answer a sound to be used as the place-holder for sounds that have been unloaded."	UnloadedSnd ifNil: [UnloadedSnd _ UnloadedSound default copy].	^ UnloadedSnd! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:52'!updateScorePlayers	"Force all ScorePlayers to update their instrument list from the sound library. This may done after loading, unloading, or replacing a sound to make all ScorePlayers feel the change."	ScorePlayer allInstances do: [:p | p pause].	SoundPlayer shutDown.	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].! !!AbstractSound class methodsFor: 'primitive generation' stamp: 'jm 8/19/1998 14:22'!cCodeForSoundPrimitives	"Return a string containing the C code for the sound primitives. This string is pasted into a file, compiled, and linked into the virtual machine. Note that the virtual machine's primitive table must also be edited to make new primitives available."	"AbstractSound cCodeForSoundPrimitives"	^ CCodeGenerator new codeStringForPrimitives: #(		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(PluckedSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(SampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(ReverbSound applyReverbTo:startingAt:count:)	).! !!AcceptableCleanTextMorph methodsFor: 'all' stamp: 'di 6/22/1998 21:38'!accept	"Overridden to allow accept of clean text"	| textToAccept ok |	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 23:09'!byteReverseForm: aForm	"Byte-reverse the words of the given Form's bitmap. Supports porting a Squeak image to the Acorn."	| bits mask pixelDepth dstWord srcWord srcPix nPix |	(aForm isKindOf: Cursor)		ifFalse:[aForm unhibernate].	bits _ aForm bits.	pixelDepth _ aForm depth.	nPix _ 32 // pixelDepth.	1 to: bits size do: [:i |		srcWord _ bits at: i.		mask _ (1 << pixelDepth) - 1.		dstWord _ 0.		1 to: nPix do: [:p|			srcPix _ srcWord bitAnd: mask.			srcWord _ srcWord >> pixelDepth.			dstWord _ ((dstWord << pixelDepth) bitOr: srcPix)].		bits at: i put: dstWord].	(aForm isKindOf: Cursor)		ifFalse:[aForm hibernate]! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:48'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	On Acorn, the test is whether systemAttribute 1001 = 'RiscOS' (on newer VMs) or if the primPathNameDelimiter is $. (on older ones), which is what we would like to use for a dirsep if only it would work out. See pathNameDelimiter for more woeful details - then just get on and enjoy Squeak"	| attr |	attr _ Smalltalk getSystemAttribute: 1001.	attr isNil ifFalse:[^attr = 'RiscOS'].	^self primPathNameDelimiter = $.! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/10/1998 21:45'!pathNameDelimiter"Acorn RiscOS uses a dot as the directory separator and has no real concept of filename extensions. We tried to make code handle this, but there are just too many uses of dot as a filename extension - so fake it out by pretending to use a slash. The file prims do conversions instead.Sad, but pragmatic"	^ $/! !!ActiveSwikiAction methodsFor: 'as yet unclassified' stamp: 'mjg 9/1/199812:44'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage liveText|	liveText _ HTMLformatter evalEmbedded: (pageRef text)		with: request unlessContains: (self dangerSet).	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: liveText			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	request reply: ((self formatterFor: 'page') format: formattedPage).! !!ActiveSwikiAction methodsFor: 'as yet unclassified' stamp: 'mjg 9/10/199815:33'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!! -- but don't complain!! Could be for ActivePage!!""	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr."! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 21:27'!morph 	^ morph! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 20:09'!morph: m	morph _ m! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/4/1998 15:47'!occurAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick	(target == nil or: [selector == nil]) ifTrue:		[^ morph encounteredAtTime: ticks inScorePlayer: player atIndex: index inEventTrack: track secsPerTick: secsPerTick].	target perform: selector withArguments: arguments! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/6/1998 08:07'!relatedPlayer	(morph isMemberOf: MovieFrameSyncMorph)		ifFalse: [^ nil].	^ morph player.	! !!AmbientEvent methodsFor: 'all' stamp: 'di 8/3/1998 20:08'!target: t selector: s arguments: a	target _ t.	selector _ s.	arguments _ a.! !!AssignmentTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:17'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: ' assign', (assignmentSuffix copyWithout: $:), 'Getter: #'.	aStream nextPutAll: (Utilities getterSelectorFor: assignmentRoot).	aStream nextPutAll: ' setter: #'.	aStream nextPutAll: (Utilities setterSelectorFor: assignmentRoot).	aStream nextPutAll: ' amt: '.! !An asynchronous file allows simple file read and write operations to be performed in parallel with other processing. This is useful in multimedia applications that need to stream large amounts of sound or image data from or to a file while doing other work.!!AsyncFile methodsFor: 'all'!close	fileHandle ifNil: [^ self].  "already closed"	self primClose: fileHandle.	Smalltalk unregisterExternalObject: semaphore.	semaphore _ nil.	fileHandle _ nil.! !!AsyncFile methodsFor: 'all' stamp: 'di 7/6/1998 10:58'!fileHandle	^ fileHandle! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 07:54'!open: fullFileName forWrite: aBoolean	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise.	If openForWrite is true, then:		if there is no existing file with this name, then create one		else open the existing file in read-write mode	otherwise:		if there is an existing file with this name, then open it read-only		else answer nil."	"Note: if an exisiting file is opened for writing, it is NOT truncated. If truncation is desired, the file should be deleted before being opened as an asynchronous file."	"Note: On some platforms (e.g., Mac), a file can only have one writer at a time."	| semaIndex |	name _ fullFileName.	writeable _ aBoolean.	semaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	fileHandle _ self primOpen: name forWrite: writeable semaIndex: semaIndex.	fileHandle ifNil: [		Smalltalk unregisterExternalObject: semaphore.		semaphore _ nil.		^ nil].! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 08:28'!readByteCount: byteCount fromFilePosition: fPosition onCompletionDo: aBlock	"Start a read operation to read byteCount's from the given position in this file. and fork a process to await its completion. When the operation completes, evaluate the given block. Note that, since the completion block may run asynchronous, the client may need to use a SharedQueue or a semaphore for synchronization."	| buffer n |	buffer _ String new: byteCount.	self primReadStart: fileHandle fPosition: fPosition count: byteCount.	"here's the process that awaits the results:"	[		[	semaphore wait.		  	n _ self primReadResult: fileHandle intoBuffer: buffer at: 1 count: byteCount.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous read operation failed'].		aBlock value: buffer.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 10:07'!test: byteCount fileName: fileName	"AsyncFile new test: 10000 fileName: 'testData'"	| buf1 buf2 bytesWritten bytesRead |	buf1 _ String new: byteCount withAll: $x.	buf2 _ String new: byteCount.	self open: fileName forWrite: true.	self primWriteStart: fileHandle		fPosition: 0		fromBuffer: buf1		at: 1		count: byteCount.	semaphore wait.	bytesWritten _ self primWriteResult: fileHandle.	self close.		self open: fileName forWrite: false.	self primReadStart: fileHandle fPosition: 0 count: byteCount.	semaphore wait.	bytesRead _		self primReadResult: fileHandle			intoBuffer: buf2			at: 1			count: byteCount.	self close.	buf1 = buf2 ifFalse: [self error: 'buffers do not match'].	^ 'wrote ', bytesWritten printString, ' bytes; ',	   'read ', bytesRead printString, ' bytes'! !!AsyncFile methodsFor: 'all' stamp: 'di 7/6/1998 10:58'!waitForCompletion	semaphore wait! !!AsyncFile methodsFor: 'all' stamp: 'jm 6/25/1998 17:28'!writeBuffer: buffer atFilePosition: fPosition onCompletionDo: aBlock	"Start an operation to write the contents of the buffer at given position in this file, and fork a process to await its completion. When the write completes, evaluate the given block. Note that, since the completion block runs asynchronously, the client may need to use a SharedQueue or a semaphore for synchronization."	| n |	self primWriteStart: fileHandle		fPosition: fPosition		fromBuffer: buffer		at: 1		count: buffer size.	"here's the process that awaits the results:"	[		[	semaphore wait.		  	n _ self primWriteResult: fileHandle.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous write operation failed'].		n = buffer size ifFalse: [^ self error: 'did not write the entire buffer'].		aBlock value.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:42'!primClose: fHandle	"Close this file. Do nothing if primitive fails."	<primitive: 540>! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:54'!primOpen: fileName forWrite: openForWrite semaIndex: semaIndex	"Open a file of the given name, and return a handle for that file. Answer the receiver if the primitive succeeds, nil otherwise."	<primitive: 541>	^ nil! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:28'!primReadResult: fHandle intoBuffer: buffer at: startIndex count: count	"Copy the result of the last read operation into the given buffer starting at the given index. The buffer may be any sort of bytes or words object, excluding CompiledMethods. Answer the number of bytes read. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 542>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:36'!primReadStart: fHandle fPosition: fPosition count: count	"Start a read operation of count bytes starting at the given offset in the given file. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 543>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 07:27'!primWriteResult: fHandle	"Answer the number of bytes written. A negative result means:		-1 the last operation is still in progress		-2 the last operation encountered an error"	<primitive: 544>	self primitiveFailed! !!AsyncFile methodsFor: 'primitives' stamp: 'jm 6/25/1998 08:35'!primWriteStart: fHandle fPosition: fPosition fromBuffer: buffer at: startIndex count: count	"Start a write operation of count bytes starting at the given index in the given buffer. The buffer may be any sort of bytes or words object, excluding CompiledMethods. The contents of the buffer are copied into an internal buffer immediately, so the buffer can be reused after the write operation has been started. Fail if there is insufficient C heap to allocate an internal buffer of the requested size."	<primitive: 545>	writeable ifFalse: [^ self error: 'attempt to write a file opened read-only'].	self primitiveFailed! !!AsyncFile class methodsFor: 'class initialization' stamp: 'jm 6/25/1998 17:33'!initialize	"AsyncFile initialize"	"Possible abnormal I/O completion results."	Busy _ -1.	Error _ -2.! !!AtomMorph methodsFor: 'all' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p _ self position.	vx _ velocity x.		vy _ velocity y.	px _ p x + vx.		py _ p y + vy.	bounced _ false.	px > aRect right ifTrue: [		px _ aRect right - (px - aRect right).		vx _ velocity x negated.		bounced _ true].	py > aRect bottom ifTrue: [		py _  aRect bottom - (py - aRect bottom).		vy _ velocity y negated.		bounced _ true].	px < aRect left ifTrue: [		px _ aRect left - (px - aRect left).		vx _ velocity x negated.		bounced _ true].	py < aRect top ifTrue: [		py _  aRect top - (py - aRect top).		vy _ velocity y negated.		bounced _ true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !a stream on Text's which keeps track of the last attribute put; new characters are added with those attributes.instance vars:	characters - a WriteStream of the characters in the stream	attributeRuns - a RunArray with the attributes for the stream	currentAttributes - the attributes to be used for new text	attributesChanged - whether the attributes have changed since the last addition!!AttributedTextStream methodsFor: 'retrieving the text' stamp: 'ls 6/27/1998 15:04'!contents	| ans |	ans _ Text new: characters size.	ans setString: characters contents  setRuns: attributeRuns.   "this is declared private, but it's exactly what I need, and it's declared as exactly what I want it to do...."	^ans! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ls 6/27/1998 14:59'!nextPut: aChar	attributesChanged 		ifTrue: [ 			attributeRuns addLast: currentAttributes.			attributesChanged _ false ]		ifFalse: [			attributeRuns  repeatLastIfEmpty: [ OrderedCollection new ] ].	characters nextPut: aChar! !!AttributedTextStream methodsFor: 'stream protocol' stamp: 'ls 6/27/1998 15:02'!nextPutAll: aString	"add an entire string with the same attributes"	attributesChanged 		ifTrue: [ attributeRuns addLast: currentAttributes times: aString size.			attributesChanged _ false. ]		ifFalse: [ attributeRuns repeatLast: aString size  ifEmpty: [ OrderedCollection new ] ].	characters nextPutAll: aString.! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 6/27/1998 15:09'!currentAttributes	"return the current attributes"	^currentAttributes! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 7/28/1998 02:08'!currentAttributes: newAttributes	"set the current attributes"	attributesChanged _ currentAttributes ~= newAttributes.	currentAttributes _ newAttributes.! !!AttributedTextStream methodsFor: 'access' stamp: 'ls 9/10/1998 03:36'!size	"number of characters in the stream so far"	^characters size! !!AttributedTextStream methodsFor: 'private-initialization' stamp: 'ls 6/27/1998 15:08'!initialize	characters _ WriteStream on: String new.	currentAttributes _ OrderedCollection new.	attributesChanged _ true.	attributeRuns _ RunArray new.	! !!AttributedTextStream class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:07'!new	^super basicNew initialize! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 9/21/1998 08:23'!authorizer	"*** Do not use this method to add or delete users!!  The change will not be recorded on the disk!!  Instead call mapName:password:to: in this class.***"	^authorizer! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 7/6/1998 07:31'!checkAuthorization: request	^ authorizer ifNotNil: [authorizer user: request userID].! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/199815:32'!process: request	self checkAuthorization: request.	^(super process: request).! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 9/13/1998 20:45'!processSpecial: request	"Let SwikiAction process this with no authorization check."	^(super process: request).! !!AuthorizedSwikiAction methodsFor: 'URL processing' stamp: 'tk 6/22/1998 14:15'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct the url map."	| fName |	super restore: nameOfSwiki.	fName _ ServerAction serverDirectory, name, (ServerAction pathSeparator), 				'authorizer'.	(FileDirectory new fileExists: fName) ifTrue: [		authorizer _ (FileStream oldFileNamed: fName) fileInObjectAndCode].! !Allows anyone to read the pages of this Swiki, but only authorized users can edit or change pages.  Can have multiple users, each with a different password.  Each can modify the whole Swiki area.To restart an existing Authorized Swiki:	AuthorizedWriteSwiki new restore: 'SWSecure'.The front page URL is:  http://serverMachine:80/SWSecure.1To make a completely new one:	| a s |	a := Authorizer new.	a realm: 'SwikiArea'.	a mapName: 'viki' password: 'hard2guess' to: 'viki'.	AuthorizedWriteSwiki setUp: 'SWSecure'.	s := AuthorizedWriteSwiki new restore: 'SWSecure'.	s authorizer: a.!!AuthorizedWriteSwiki methodsFor: 'as yet unclassified' stamp: 'tk 9/13/1998 20:59'!process: request	"Only demand authorization of name and password when requesting the edit page, requesting the append page, receiving an edit, or receiving an append."	| command coreRef |	request fields ifNotNil: ["Are there input fields?"		coreRef _ request message size < 2			ifTrue: ['1']			ifFalse: [request message at: 2].		coreRef = 'searchresult' ifFalse: ["Must be text for an edit!!"			self checkAuthorization: request]].	request message size > 2 ifTrue:			["SearchResult, All, Versions, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[self checkAuthorization: request].			command = 'insert' ifTrue:					[self checkAuthorization: request]].	^(super processSpecial: request).		"all the way up to SwikiAction"! !A minimalist button-like object intended for use with the tile-scripting system.!!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 17:02'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change label...' action: #setLabel.! !!BasicButton methodsFor: 'all' stamp: 'sw 6/29/1998 20:57'!initialize	super initialize.	self borderWidth: 1.	self borderColor: Color yellow darker.	self color: Color yellow.	self label: 'Button'! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:49'!label	| s |	s _ ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s _ m contents]].	^ s! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:53'!label: aString	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ StringMorph new contents: aString.	self extent: m extent + (borderWidth + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:48'!label: aString font: aFont	| oldLabel m |	(oldLabel _ self findA: StringMorph)		ifNotNil: [oldLabel delete].	m _ aFont		ifNil:			[StringMorph contents: aString]		ifNotNil:			[StringMorph contents: aString font: aFont].	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!BasicButton methodsFor: 'all' stamp: 'sw 6/16/1998 16:48'!setLabel	| newLabel |	newLabel _ FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!BasicButton class methodsFor: 'all' stamp: 'sw 6/16/1998 16:58'!defaultNameStemForInstances	^ 'button'! !!Behavior methodsFor: 'copying' stamp: 'sw 6/16/1998 15:15'!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary"	^ methodDict copy! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 9/10/1998 14:37'!changeRecordsAt: selector	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."	"(Pen changeRecordsAt: #go:) collect: [:cRec | cRec string]"	| aList |	aList _ ChangeList new			scanVersionsOf: (self compiledMethodAt: selector ifAbsent: [^ nil])			class: self meta: self isMeta			category: (self whichCategoryIncludesSelector: selector)			selector: selector.	^ aList ifNotNil: [aList changeList]! !I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMapThe color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBlt methodsFor: 'copying' stamp: 'di 6/29/1998 20:27'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	<primitive: 96>	self primitiveFailed  "Later do nicer error recovery"! !!BitBlt methodsFor: 'private' stamp: 'di 9/11/1998 13:07'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm _ df.	sourceForm _ sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ cr.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ extent x.	height _ extent y.	aPoint _ clipRect origin.	clipX _ aPoint x.	clipY _ aPoint y.	aPoint _ clipRect corner.	clipWidth _ aPoint x - clipX.	clipHeight _ aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap _ sourceForm colormapIfNeededForDepth: destForm depth]! !This class implements BitBlt, much as specified in the Blue Book spec.Performance has been enhanced through the use of pointer variables such as sourceIndex and destIndex, and by separating several special cases of the inner loop.Operation has been extended to color, with support for 1, 2, 4, 8, 16, and 32-bit pixel sizes.  Conversion between different pixel sizes is facilitated by accepting an optional color map.In addition to the original 16 combination rules, this BitBlt supports	16	fail (for old paint mode)	17	fail (for old mask mode)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	OLDrgbDiff: sourceWord with: destinationWord	23	OLDtallyIntoMap: destinationWord -- old vers doesn't clip to bit boundary	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord	30	alphaBlendConst: sourceWord with: destinationWord -- alpha passed as an arg	31	alphaPaintConst: sourceWord with: destinationWord -- alpha passed as an arg	32	rgbDiff: sourceWord with: destinationWord	33	tallyIntoMap: destinationWordThis implementation has also been fitted with an experimental "warp drive" that allows abritrary scaling and rotation (and even limited affine deformations) with all BitBlt storage modes supported.!!BitBltSimulation methodsFor: 'interpreter interface' stamp: 'di 6/30/1998 11:13'!loadBitBltFrom: bbObj	"Load context from BitBlt instance.  Return false if anything is amiss"	"NOTE this should all be changed to minX/maxX coordinates for simpler clipping		-- once it works!!"	| destBitsSize destWidth destHeight sourceBitsSize sourcePixPerWord cmSize halftoneBits |	bitBltOop _ bbObj.	combinationRule _ interpreterProxy fetchInteger: BBRuleIndex ofObject: bitBltOop.	(interpreterProxy failed		or: [combinationRule < 0 or: [combinationRule > 33]])		 ifTrue: [^ false  "operation out of range"].	(combinationRule >= 16 and: [combinationRule <= 17])		 ifTrue: [^ false  "fail for old simulated paint, erase modes"].	sourceForm _ interpreterProxy fetchPointer: BBSourceFormIndex ofObject: bitBltOop.	noSource _ self ignoreSourceOrHalftone: sourceForm.	halftoneForm _ interpreterProxy fetchPointer: BBHalftoneFormIndex ofObject: bitBltOop.	noHalftone _ self ignoreSourceOrHalftone: halftoneForm.	destForm _ interpreterProxy fetchPointer: BBDestFormIndex ofObject: bitBltOop.		((interpreterProxy isPointers: destForm) and: [(interpreterProxy lengthOf: destForm) >= 4])			ifFalse: [^ false].		destBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: destForm.		destBitsSize _ interpreterProxy byteLengthOf: destBits.		destWidth _ interpreterProxy fetchInteger: FormWidthIndex ofObject: destForm.		destHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: destForm.		(destWidth >= 0 and: [destHeight >= 0])			ifFalse: [^ false].		destPixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: destForm.		pixPerWord _ 32 // destPixSize.		destRaster _ destWidth + (pixPerWord-1) // pixPerWord.		((interpreterProxy isWordsOrBytes: destBits)			and: [destBitsSize = (destRaster * destHeight * 4)])			ifFalse: [^ false].		destX _ interpreterProxy fetchIntegerOrTruncFloat: BBDestXIndex ofObject: bitBltOop.	destY _ interpreterProxy fetchIntegerOrTruncFloat: BBDestYIndex ofObject: bitBltOop.	width _ interpreterProxy fetchIntegerOrTruncFloat: BBWidthIndex ofObject: bitBltOop.	height _ interpreterProxy fetchIntegerOrTruncFloat: BBHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	noSource ifTrue:		[sourceX _ sourceY _ 0]		ifFalse: 		[((interpreterProxy isPointers: sourceForm) and: [(interpreterProxy lengthOf: sourceForm) >= 4])			ifFalse: [^ false].		sourceBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: sourceForm.		sourceBitsSize _ interpreterProxy byteLengthOf: sourceBits.		srcWidth _ interpreterProxy fetchIntegerOrTruncFloat: FormWidthIndex ofObject: sourceForm.		srcHeight _ interpreterProxy fetchIntegerOrTruncFloat: FormHeightIndex ofObject: sourceForm.		(srcWidth >= 0 and: [srcHeight >= 0])			ifFalse: [^ false].		sourcePixSize _ interpreterProxy fetchInteger: FormDepthIndex ofObject: sourceForm.		sourcePixPerWord _ 32 // sourcePixSize.		sourceRaster _ srcWidth + (sourcePixPerWord-1) // sourcePixPerWord.		((interpreterProxy isWordsOrBytes: sourceBits)			and: [sourceBitsSize = (sourceRaster * srcHeight * 4)])			ifFalse: [^ false].		colorMap _ interpreterProxy fetchPointer: BBColorMapIndex ofObject: bitBltOop.		"ColorMap, if not nil, must be longWords, and 		2^N long, where N = sourcePixSize for 1, 2, 4, 8 bits, 		or N = 9, 12, or 15 (3, 4, 5 bits per color) for 16 or 32 bits."		colorMap = interpreterProxy nilObject ifFalse:			[(interpreterProxy isWords: colorMap)			ifTrue:			[cmSize _ interpreterProxy lengthOf: colorMap.			cmBitsPerColor _ 0.			cmSize = 512 ifTrue: [cmBitsPerColor _ 3].			cmSize = 4096 ifTrue: [cmBitsPerColor _ 4].			cmSize = 32768 ifTrue: [cmBitsPerColor _ 5].			interpreterProxy primIndex ~= 147 ifTrue:				["WarpBlt has different checks on the color map"				sourcePixSize <= 8				ifTrue: [cmSize = (1 << sourcePixSize) ifFalse: [^ false] ]				ifFalse: [cmBitsPerColor = 0 ifTrue: [^ false] ]]			]			ifFalse: [^ false]].		sourceX _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceXIndex ofObject: bitBltOop.		sourceY _ interpreterProxy fetchIntegerOrTruncFloat: BBSourceYIndex ofObject: bitBltOop].	noHalftone ifFalse: 		[((interpreterProxy isPointers: halftoneForm) and: [(interpreterProxy lengthOf: halftoneForm) >= 4])		ifTrue:		["Old-style 32xN monochrome halftone Forms"		halftoneBits _ interpreterProxy fetchPointer: FormBitsIndex ofObject: halftoneForm.		halftoneHeight _ interpreterProxy fetchInteger: FormHeightIndex ofObject: halftoneForm.		(interpreterProxy isWords: halftoneBits)			ifFalse: [noHalftone _ true]]		ifFalse:		["New spec accepts, basically, a word array"		((interpreterProxy isPointers: halftoneForm) not			and: [interpreterProxy isWords: halftoneForm])			ifFalse: [^ false].		halftoneBits _ halftoneForm.		halftoneHeight _ interpreterProxy lengthOf: halftoneBits].	halftoneBase _ halftoneBits + 4].	clipX _ interpreterProxy fetchIntegerOrTruncFloat: BBClipXIndex ofObject: bitBltOop.	clipY _ interpreterProxy fetchIntegerOrTruncFloat: BBClipYIndex ofObject: bitBltOop.	clipWidth _ interpreterProxy fetchIntegerOrTruncFloat: BBClipWidthIndex ofObject: bitBltOop.	clipHeight _ interpreterProxy fetchIntegerOrTruncFloat: BBClipHeightIndex ofObject: bitBltOop.		interpreterProxy failed ifTrue: [^ false  "non-integer value"].	clipX < 0 ifTrue: [clipWidth _ clipWidth + clipX.  clipX _ 0].	clipY < 0 ifTrue: [clipHeight _ clipHeight + clipY.  clipY _ 0].	clipX+clipWidth > destWidth ifTrue: [clipWidth _ destWidth - clipX].	clipY+clipHeight > destHeight ifTrue: [clipHeight _ destHeight - clipY].	^ true! !!BitBltSimulation methodsFor: 'setup' stamp: 'di 6/29/1998 12:19'!checkSourceOverlap	| t |	"check for possible overlap of source and destination"	(sourceForm = destForm and: [dy >= sy]) ifTrue:		[dy > sy ifTrue:			["have to start at bottom"			vDir _ -1.			sy _ sy + bbH - 1.			dy _ dy + bbH - 1]		ifFalse:			[(dy = sy) & (dx > sx) ifTrue:				["y's are equal, but x's are backward"				hDir _ -1.				sx _ sx + bbW - 1.				"start at right"				dx _ dx + bbW - 1.				"and fix up masks"				nWords > 1 ifTrue: 					[t _ mask1.					mask1 _ mask2.					mask2 _ t]]].		"Dest inits may be affected by this change"		destIndex _ (destBits + 4) + (dy * destRaster + (dx // pixPerWord) *4).		destDelta _ 4 * ((destRaster * vDir) - (nWords * hDir))]! !!BitBltSimulation methodsFor: 'setup' stamp: 'di 6/30/1998 11:43'!copyBits	self clipRange.	(bbW <= 0 or: [bbH <= 0]) ifTrue:		["zero width or height; noop"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		^ nil]. 	self destMaskAndPointerInit.	bitCount _ 0.	(combinationRule = 30) | (combinationRule = 31) ifTrue:		["Check and fetch source alpha parameter for alpha blend"		interpreterProxy argCount = 1			ifTrue: [sourceAlpha _ interpreterProxy stackIntegerValue: 0.					(interpreterProxy failed not and: [(sourceAlpha >= 0) & (sourceAlpha <= 255)])						ifTrue: [interpreterProxy pop: 1]						ifFalse: [^ interpreterProxy primitiveFail]]			ifFalse: [^ interpreterProxy primitiveFail]].	noSource		ifTrue: [self copyLoopNoSource]		ifFalse: [self checkSourceOverlap.				(sourcePixSize ~= destPixSize					or: [colorMap ~= interpreterProxy nilObject])					ifTrue: [self copyLoopPixMap]					ifFalse: [self sourceSkewAndPointerInit.							self copyLoop]]. 	(combinationRule = 22) | (combinationRule = 32) ifTrue:		["zero width and height; return the count"		affectedL _ affectedR _ affectedT _ affectedB _ 0.		interpreterProxy pop: 1.		^ interpreterProxy pushInteger: bitCount]. 	hDir > 0		ifTrue: [affectedL _ dx.				affectedR _ dx + bbW]		ifFalse: [affectedL _ dx - bbW + 1.				affectedR _ dx + 1].	vDir > 0		ifTrue: [affectedT _ dy.				affectedB _ dy + bbH]		ifFalse: [affectedT _ dy - bbH + 1.				affectedB _ dy + 1]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/29/1998 12:27'!copyLoop	| prevWord thisWord skewWord halftoneWord mergeWord hInc y unskew skewMask notSkewMask mergeFnwith |	"This version of the inner loop assumes noSource = false."	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	hInc _ hDir*4.  "Byte delta"	"degenerate skew fixed for Sparc. 10/20/96 ikp"	skew == -32		ifTrue: [skew _ unskew _ skewMask _ 0]		ifFalse: [skew < 0			ifTrue:				[unskew _ skew+32.				skewMask _ AllOnes << (0-skew)]			ifFalse:				[skew == 0					ifTrue:						[unskew _ 0.						skewMask _ AllOnes]					ifFalse:						[unskew _ skew-32.						skewMask _ AllOnes >> skew]]].	notSkewMask _ skewMask bitInvert32.	noHalftone		ifTrue: [halftoneWord _ AllOnes.  halftoneHeight _ 0]		ifFalse: [halftoneWord _ interpreterProxy longAt: halftoneBase].	y _ dy.	1 to: bbH do: "here is the vertical loop"		[ :i |		halftoneHeight > 1 ifTrue:  "Otherwise, its always the same"			[halftoneWord _ interpreterProxy longAt:						(halftoneBase + (y \\ halftoneHeight * 4)).			y _ y + vDir].		preload ifTrue:			["load the 64-bit shifter"			prevWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc]			ifFalse:			[prevWord _ 0].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc.		"This central horizontal loop requires no store masking"		destMask _ AllOnes.combinationRule = 3ifTrue: [noHalftone & (notSkewMask = 0)		ifTrue:  		["Very special inner loop for STORE mode with no skew -- just move words"		2 to: nWords-1 do: 			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			interpreterProxy longAt: destIndex put: thisWord.			destIndex _ destIndex + hInc]]		ifFalse:		["Special inner loop for STORE mode -- no need to call merge"		2 to: nWords-1 do: 			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			interpreterProxy longAt: destIndex put: (skewWord bitAnd: halftoneWord).			destIndex _ destIndex + hInc]]] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge:"			[ :word |			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			prevWord _ thisWord.			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + hInc]].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			thisWord _ interpreterProxy longAt: sourceIndex.  "pick up next word"			sourceIndex _ sourceIndex + hInc.			skewWord _ ((prevWord bitAnd: notSkewMask) bitShift: unskew)							bitOr:  "32-bit rotate"						((thisWord bitAnd: skewMask) bitShift: skew).			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + hInc].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 18:05'!copyLoopNoSource	| halftoneWord mergeWord mergeFnwith |	"Faster copyLoop when source not used.  hDir and vDir are both	positive, and perload and skew are unused"	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].	"Note: the horizontal loop has been expanded into three parts for speed:"			"This first section requires masking of the destination store..."			destMask _ mask1.			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.		"This central horizontal loop requires no store masking"			destMask _ AllOnes.combinationRule = 3ifTrue: [2 to: nWords-1 do: "Special inner loop for STORE"			[ :word |			interpreterProxy longAt: destIndex put: halftoneWord.			destIndex _ destIndex + 4].] ifFalse: [2 to: nWords-1 do: "Normal inner loop does merge"			[ :word |			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex put: mergeWord.			destIndex _ destIndex + 4].].		"This last section, if used, requires masking of the destination store..."		nWords > 1 ifTrue:			[destMask _ mask2.			mergeWord _ self mergeFn: halftoneWord							with: (interpreterProxy longAt: destIndex).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr: (destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4].	destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 17:45'!copyLoopPixMap	"This version of the inner loop maps source pixels	to a destination form with different depth.  Because it is already	unweildy, the loop is not unrolled as in the other versions.	Preload, skew and skewMask are all overlooked, since pickSourcePixels	delivers its destination word already properly aligned.	Note that pickSourcePixels could be copied in-line at the top of	the horizontal loop, and some of its inits moved out of the loop."	| skewWord halftoneWord mergeWord srcPixPerWord scrStartBits nSourceIncs startBits endBits sourcePixMask destPixMask nullMap mergeFnwith |	self inline: false.	self var: #mergeFnwith declareC: 'int (*mergeFnwith)(int, int)'.	mergeFnwith _ self cCoerce: (opTable at: combinationRule+1) to: 'int (*)(int, int)'.	mergeFnwith.  "null ref for compiler"	"Additional inits peculiar to unequal source and dest pix size..."	srcPixPerWord _ 32//sourcePixSize.	"Check for degenerate shift values 4/28/97 ar"	sourcePixSize = 32 		ifTrue: [ sourcePixMask _ -1]		ifFalse: [ sourcePixMask _ (1 << sourcePixSize) - 1].	destPixSize = 32		ifTrue: [ destPixMask _ -1]		ifFalse: [ destPixMask _ (1 << destPixSize) - 1].	nullMap _ colorMap = interpreterProxy nilObject.	sourceIndex _ (sourceBits + 4) +					(sy * sourceRaster + (sx // srcPixPerWord) *4).	scrStartBits _ srcPixPerWord - (sx bitAnd: srcPixPerWord-1).	bbW < scrStartBits		ifTrue: [nSourceIncs _ 0]		ifFalse: [nSourceIncs _ (bbW - scrStartBits)//srcPixPerWord + 1].	sourceDelta _ (sourceRaster - nSourceIncs) * 4.	"Note following two items were already calculated in destmask setup!!"	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	endBits _ ((dx + bbW - 1) bitAnd: pixPerWord-1) + 1.	1 to: bbH do: "here is the vertical loop"		[ :i |		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		srcBitIndex _ (sx bitAnd: srcPixPerWord - 1)*sourcePixSize.		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self pickSourcePixels: bbW nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self pickSourcePixels: startBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask]. 		"Here is the horizontal loop..."		1 to: nWords do: "here is the inner horizontal loop"			[ :word |			mergeWord _ self mergeFn: (skewWord bitAnd: halftoneWord)							with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self pickSourcePixels: endBits nullMap: nullMap									srcMask: sourcePixMask destMask: destPixMask.					skewWord _ skewWord   "See note below"							bitShift: (pixPerWord-endBits)*destPixSize]]				ifFalse: 				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self pickSourcePixels: pixPerWord nullMap: nullMap srcMask: sourcePixMask destMask: destPixMask]].	sourceIndex _ sourceIndex + sourceDelta.	destIndex _ destIndex + destDelta]"NOTE: in both noted shifts above, we are shifting the right-justified output of pickSourcePixels so that it is aligned with the destination word.  Since it gets masked anyway, we could have just picked more pixels (startBits in the first case and destPixSize in the second), and it would have been simpler, but it is slower to run the pickSourcePixels loop.  CopyLoopAlphaHack takes advantage of this to avoid having to shift full-words in its alphaSource buffer" ! !!BitBltSimulation methodsFor: 'inner loop' stamp: 'di 6/8/1998 17:44'!warpLoop	| skewWord halftoneWord mergeWord startBits	  deltaP12x deltaP12y deltaP43x deltaP43y pAx pAy	  xDelta yDelta pBx pBy smoothingCount sourceMapOop nSteps t |	"This version of the inner loop traverses an arbirary quadrilateral	source, thus producing a general affine transformation." 	(interpreterProxy fetchWordLengthOf: bitBltOop) >= (BBWarpBase+12)		ifFalse: [^ interpreterProxy primitiveFail].	nSteps _ height-1.  nSteps <= 0 ifTrue: [nSteps _ 1].	pAx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+3 ofObject: bitBltOop.	deltaP12x _ self deltaFrom: pAx to: t nSteps: nSteps.	deltaP12x < 0 ifTrue: [pAx _ t - (nSteps*deltaP12x)].	pAy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+1 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+4 ofObject: bitBltOop.	deltaP12y _ self deltaFrom: pAy to: t nSteps: nSteps.	deltaP12y < 0 ifTrue: [pAy _ t - (nSteps*deltaP12y)].	pBx _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+9 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+6 ofObject: bitBltOop.	deltaP43x _ self deltaFrom: pBx to: t nSteps: nSteps.	deltaP43x < 0 ifTrue: [pBx _ t - (nSteps*deltaP43x)].	pBy _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+10 ofObject: bitBltOop.	t _ interpreterProxy fetchIntegerOrTruncFloat: BBWarpBase+7 ofObject: bitBltOop.	deltaP43y _ self deltaFrom: pBy to: t nSteps: nSteps.	deltaP43y < 0 ifTrue: [pBy _ t - (nSteps*deltaP43y)].	interpreterProxy failed ifTrue: [^ false].  "ie if non-integers above"	interpreterProxy argCount = 2		ifTrue: [smoothingCount _ interpreterProxy stackIntegerValue: 1.				sourceMapOop _ interpreterProxy stackValue: 0.				sourceMapOop = interpreterProxy nilObject				ifTrue: [sourcePixSize < 16 ifTrue:					["color map is required to smooth non-RGB dest"					^ interpreterProxy primitiveFail]]				ifFalse: [(interpreterProxy fetchWordLengthOf: sourceMapOop)							< (1 << sourcePixSize) ifTrue:					["sourceMap must be long enough for sourcePixSize"					^ interpreterProxy primitiveFail]]]		ifFalse: [smoothingCount _ 1.				sourceMapOop _ interpreterProxy nilObject].	startBits _ pixPerWord - (dx bitAnd: pixPerWord-1).	nSteps _ width-1.  nSteps <= 0 ifTrue: [nSteps _ 1]. 	destY to: clipY-1 do:		[ :i |	"Advance increments if there was clipping in y"		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y].	1 to: bbH do:		[ :i |		"here is the vertical loop..."		xDelta _ self deltaFrom: pAx to: pBx nSteps: nSteps. 		xDelta >= 0 ifTrue: [sx _ pAx] ifFalse: [sx _ pBx - (nSteps*xDelta)].		yDelta _ self deltaFrom: pAy to: pBy nSteps: nSteps. 		yDelta >= 0 ifTrue: [sy _ pAy] ifFalse: [sy _ pBy - (nSteps*yDelta)].		destX to: clipX-1 do:			[:word |	"Advance increments if there was clipping in x"			sx _ sx + xDelta.			sy _ sy + yDelta].		noHalftone			ifTrue: [halftoneWord _ AllOnes]			ifFalse: [halftoneWord _ interpreterProxy longAt: (halftoneBase + (dy+i-1 \\ halftoneHeight * 4))].		destMask _ mask1.		"pick up first word"		bbW < startBits			ifTrue: [skewWord _ self warpSourcePixels: bbW									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop.					skewWord _ skewWord							bitShift: (startBits - bbW)*destPixSize]			ifFalse: [skewWord _ self warpSourcePixels: startBits									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]. 		1 to: nWords do:			[ :word |		"here is the inner horizontal loop..."			mergeWord _ self merge: (skewWord bitAnd: halftoneWord)				with: ((interpreterProxy longAt: destIndex) bitAnd: destMask).			interpreterProxy longAt: destIndex				put: ((destMask bitAnd: mergeWord)					bitOr:					(destMask bitInvert32 bitAnd: (interpreterProxy longAt: destIndex))).			destIndex _ destIndex + 4.			word >= (nWords - 1) ifTrue:				[word = nWords ifFalse:					["set mask for last word in this row"					destMask _ mask2.					skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop]]				ifFalse:				["use fullword mask for inner loop"				destMask _ AllOnes.				skewWord _ self warpSourcePixels: pixPerWord									xDeltah: xDelta yDeltah: yDelta									xDeltav: deltaP12x yDeltav: deltaP12y									smoothing: smoothingCount sourceMap: sourceMapOop].			].		pAx _ pAx + deltaP12x.		pAy _ pAy + deltaP12y.		pBx _ pBx + deltaP43x.		pBy _ pBy + deltaP43y.		destIndex _ destIndex + destDelta]! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 11:08'!OLDrgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, XOR the two and return the number of differing pixels.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| diff pixMask |	self inline: false.	destPixSize < 16 ifTrue:		["Just xor and count differing bits if not RGB"		diff _ sourceWord bitXor: destinationWord.		pixMask _ (1 bitShift: destPixSize) - 1.		[diff = 0] whileFalse:			[(diff bitAnd: pixMask) ~= 0 ifTrue: [bitCount _ bitCount + 1].			diff _ diff >> destPixSize].		^ destinationWord "for no effect"]. 	destPixSize = 16		ifTrue:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F).		diff _ (self partitionedSub: sourceWord>>16 from: destinationWord>>16						nBits: 5 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16r1F)							+ (diff>>5 bitAnd: 16r1F)							+ (diff>>10 bitAnd: 16r1F)]		ifFalse:		[diff _ (self partitionedSub: sourceWord from: destinationWord						nBits: 8 nPartitions: 3).		bitCount _ bitCount + (diff bitAnd: 16rFF)							+ (diff>>8 bitAnd: 16rFF)							+ (diff>>16 bitAnd: 16rFF)].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 11:09'!OLDtallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Note that the source should be 	specified = destination, in order for the proper color map checks 	to be performed at setup.	Note that the region is not clipped to bit boundaries, but only to the	nearest (enclosing) word.  This is because copyLoop does not do	pre-merge masking.  For accurate results, you must subtract the	values obtained from the left and right fringes."	| mapIndex pixMask shiftWord |	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	destPixSize < 16 ifTrue:		["loop through all packed pixels."		pixMask _ (1<<destPixSize) - 1.		shiftWord _ destinationWord.		1 to: pixPerWord do:			[:i |			mapIndex _ shiftWord bitAnd: pixMask.			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.			shiftWord _ shiftWord >> destPixSize].		^ destinationWord].	destPixSize = 16 ifTrue:		["Two pixels  Tally the right half..."		mapIndex _ self rgbMap: (destinationWord bitAnd: 16rFFFF) from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1.		"... and then left half"		mapIndex _ self rgbMap: destinationWord>>16 from: 5 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1]	ifFalse:		["Just one pixel."		mapIndex _ self rgbMap: destinationWord from: 8 to: cmBitsPerColor.		interpreterProxy storeWord: mapIndex ofObject: colorMap			withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:55'!alphaBlendConst: sourceWord with: destinationWord	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: false! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/30/1998 00:29'!alphaBlendConst: sourceWord with: destinationWord paintMode: paintMode	"Blend sourceWord with destinationWord using a constant alpha.	Alpha is encoded as 0 meaning 0.0, and 255 meaning 1.0.	The blend produced is alpha*source + (1.0-alpha)*dest, with the	computation being performed independently on each color component.	This function could eventually blend into any depth destination,	using the same color averaging and mapping as warpBlt.	paintMode = true means do nothing if the source pixel value is zero."	"This first implementation works with dest depths of 16 and 32 bits only.	Normal color mapping will allow sources of lower depths in this case,	and results can be mapped directly by truncation, so no extra color maps are needed.	To allow storing into any depth will require subsequent addition of two other	colormaps, as is the case with WarpBlt."	| pixMask destShifted sourceShifted destPixVal rgbMask sourcePixVal unAlpha result pixBlend shift blend maskShifted bitsPerColor |	self inline: false.	destPixSize < 16 ifTrue: [^ destinationWord "no-op"].	unAlpha _ 255 - sourceAlpha.	pixMask _ (1<<destPixSize) - 1.	destPixSize = 16		ifTrue: [bitsPerColor _ 5]		ifFalse: [bitsPerColor _ 8].	rgbMask _ (1<<bitsPerColor) - 1.	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	result _ destinationWord.	1 to: pixPerWord do:		[:j |		sourcePixVal _ sourceShifted bitAnd: pixMask.		((maskShifted bitAnd: pixMask) = 0  "no effect if outside of dest rectangle"			or: [paintMode & (sourcePixVal = 0)  "or painting a transparent pixel"])		ifFalse:			[destPixVal _ destShifted bitAnd: pixMask.			pixBlend _ 0.			1 to: 3 do:				[:i | shift _ (i-1)*bitsPerColor.				blend _ (((sourcePixVal>>shift bitAnd: rgbMask) * sourceAlpha)							+ ((destPixVal>>shift bitAnd: rgbMask) * unAlpha))					 	+ 254 // 255 bitAnd: rgbMask.				pixBlend _ pixBlend bitOr: blend<<shift].			destPixSize = 16				ifTrue: [result _ (result bitAnd: (pixMask << (j-1*16)) bitInvert32)									bitOr: pixBlend << (j-1*16)]				ifFalse: [result _ pixBlend]].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ result! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 19:56'!alphaPaintConst: sourceWord with: destinationWord	sourceWord = 0 ifTrue: [^ destinationWord  "opt for all-transparent source"].	^ self alphaBlendConst: sourceWord with: destinationWord paintMode: true! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 16:41'!rgbDiff: sourceWord with: destinationWord	"Subract the pixels in the source and destination, color by color,	and return the sum of the absolute value of all the differences.	For non-rgb, return the number of differing pixels."	| pixMask destShifted sourceShifted destPixVal bitsPerColor rgbMask sourcePixVal diff maskShifted |	self inline: false.	pixMask _ (1<<destPixSize) - 1.	destPixSize = 16		ifTrue: [bitsPerColor _ 5.  rgbMask _ 16r1F]		ifFalse: [bitsPerColor _ 8.  rgbMask _ 16rFF].	maskShifted _ destMask.	destShifted _ destinationWord.	sourceShifted _ sourceWord.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			destPixVal _ destShifted bitAnd: pixMask.			sourcePixVal _ sourceShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [sourcePixVal = destPixVal							ifTrue: [diff _ 0]							ifFalse: [diff _ 1]]				ifFalse: [diff _ (self partitionedSub: sourcePixVal from: destPixVal								nBits: bitsPerColor nPartitions: 3).						diff _ (diff bitAnd: rgbMask)							+ (diff>>bitsPerColor bitAnd: rgbMask)							+ ((diff>>bitsPerColor)>>bitsPerColor bitAnd: rgbMask)].			bitCount _ bitCount + diff].		maskShifted _ maskShifted >> destPixSize.		sourceShifted _ sourceShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'combination rules' stamp: 'di 6/29/1998 11:27'!tallyIntoMap: sourceWord with: destinationWord	"Tally pixels into the color map.  Those tallied are exactly those	in the destination rectangle.  Note that the source should be 	specified == destination, in order for the proper color map checks 	to be performed at setup."	| mapIndex pixMask destShifted maskShifted pixVal |	self inline: false.	colorMap = interpreterProxy nilObject		ifTrue: [^ destinationWord "no op"].	pixMask _ (1<<destPixSize) - 1.	destShifted _ destinationWord.	maskShifted _ destMask.	1 to: pixPerWord do:		[:i |		(maskShifted bitAnd: pixMask) > 0 ifTrue:			["Only tally pixels within the destination rectangle"			pixVal _ destShifted bitAnd: pixMask.			destPixSize < 16				ifTrue: [mapIndex _ pixVal]				ifFalse: [destPixSize = 16					ifTrue: [mapIndex _ self rgbMap: pixVal from: 5 to: cmBitsPerColor]					ifFalse: [mapIndex _ self rgbMap: pixVal from: 8 to: cmBitsPerColor]].			interpreterProxy storeWord: mapIndex ofObject: colorMap				withValue: (interpreterProxy fetchWord: mapIndex ofObject: colorMap) + 1].		maskShifted _ maskShifted >> destPixSize.		destShifted _ destShifted >> destPixSize].	^ destinationWord  "For no effect on dest"! !!BitBltSimulation methodsFor: 'translation support' stamp: 'di 6/30/1998 11:12'!initBBOpTable	self cCode: 'opTable[0+1] = (int)clearWordwith'.	self cCode: 'opTable[1+1] = (int)bitAndwith'.	self cCode: 'opTable[2+1] = (int)bitAndInvertwith'.	self cCode: 'opTable[3+1] = (int)sourceWordwith'.	self cCode: 'opTable[4+1] = (int)bitInvertAndwith'.	self cCode: 'opTable[5+1] = (int)destinationWordwith'.	self cCode: 'opTable[6+1] = (int)bitXorwith'.	self cCode: 'opTable[7+1] = (int)bitOrwith'.	self cCode: 'opTable[8+1] = (int)bitInvertAndInvertwith'.	self cCode: 'opTable[9+1] = (int)bitInvertXorwith'.	self cCode: 'opTable[10+1] = (int)bitInvertDestinationwith'.	self cCode: 'opTable[11+1] = (int)bitOrInvertwith'.	self cCode: 'opTable[12+1] = (int)bitInvertSourcewith'.	self cCode: 'opTable[13+1] = (int)bitInvertOrwith'.	self cCode: 'opTable[14+1] = (int)bitInvertOrInvertwith'.	self cCode: 'opTable[15+1] = (int)destinationWordwith'.	self cCode: 'opTable[16+1] = (int)destinationWordwith'.	self cCode: 'opTable[17+1] = (int)destinationWordwith'.	self cCode: 'opTable[18+1] = (int)addWordwith'.	self cCode: 'opTable[19+1] = (int)subWordwith'.	self cCode: 'opTable[20+1] = (int)rgbAddwith'.	self cCode: 'opTable[21+1] = (int)rgbSubwith'.	self cCode: 'opTable[22+1] = (int)OLDrgbDiffwith'.	self cCode: 'opTable[23+1] = (int)OLDtallyIntoMapwith'.	self cCode: 'opTable[24+1] = (int)alphaBlendwith'.	self cCode: 'opTable[25+1] = (int)pixPaintwith'.	self cCode: 'opTable[26+1] = (int)pixMaskwith'.	self cCode: 'opTable[27+1] = (int)rgbMaxwith'.	self cCode: 'opTable[28+1] = (int)rgbMinwith'.	self cCode: 'opTable[29+1] = (int)rgbMinInvertwith'.	self cCode: 'opTable[30+1] = (int)alphaBlendConstwith'.	self cCode: 'opTable[31+1] = (int)alphaPaintConstwith'.	self cCode: 'opTable[32+1] = (int)rgbDiffwith'.	self cCode: 'opTable[33+1] = (int)tallyIntoMapwith'.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'di 6/29/1998 23:24'!initialize	"BitBltSimulation initialize"  	self initializeRuleTable.	"Mask constants"	AllOnes _ 16rFFFFFFFF.	BinaryPoint _ 14.	FixedPt1 _ 1 << BinaryPoint.  "Value of 1.0 in Warp's fixed-point representation" 	"Indices into stopConditions for scanning"	EndOfRun _ 257.	CrossedX _ 258. 	"Form fields"	FormBitsIndex _ 0.	FormWidthIndex _ 1.	FormHeightIndex _ 2.	FormDepthIndex _ 3. 	"BitBlt fields"	BBDestFormIndex _ 0.	BBSourceFormIndex _ 1.	BBHalftoneFormIndex _ 2.	BBRuleIndex _ 3.	BBDestXIndex _ 4.	BBDestYIndex _ 5.	BBWidthIndex _ 6.	BBHeightIndex _ 7.	BBSourceXIndex _ 8.	BBSourceYIndex _ 9.	BBClipXIndex _ 10.	BBClipYIndex _ 11.	BBClipWidthIndex _ 12.	BBClipHeightIndex _ 13.	BBColorMapIndex _ 14.	BBWarpBase _ 15.	BBLastIndex _ 15.	BBXTableIndex _ 16.! !!BitBltSimulation class methodsFor: 'initialization' stamp: 'di 6/30/1998 11:11'!initializeRuleTable	"BitBltSimulation initializeRuleTable"	"**WARNING** You MUST change initBBOpTable if you change this"	OpTable _ #(		"0" clearWord:with:		"1" bitAnd:with:		"2" bitAndInvert:with:		"3" sourceWord:with:		"4" bitInvertAnd:with:		"5" destinationWord:with:		"6" bitXor:with:		"7" bitOr:with:		"8" bitInvertAndInvert:with:		"9" bitInvertXor:with:		"10" bitInvertDestination:with:		"11" bitOrInvert:with:		"12" bitInvertSource:with:		"13" bitInvertOr:with:		"14" bitInvertOrInvert:with:		"15" destinationWord:with:		"16" destinationWord:with: "unused - was old paint"		"17" destinationWord:with: "unused - was old mask"		"18" addWord:with:		"19" subWord:with:		"20" rgbAdd:with:		"21" rgbSub:with:		"22" OLDrgbDiff:with:		"23" OLDtallyIntoMap:with:		"24" alphaBlend:with:		"25" pixPaint:with:		"26" pixMask:with:		"27" rgbMax:with:		"28" rgbMin:with:		"29" rgbMinInvert:with:		"30" alphaBlendConst:with:		"31" alphaPaintConst:with:		"32" rgbDiff:with:		"33" tallyIntoMap:with:	).	OpTableSize _ OpTable size + 1.  "0-origin indexing"! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:41'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 237>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	size _ bm size.	i _ self encodeInt: size in: ba at: 1.	k _ 1.	[k <= size] whileTrue:		[word _ bm at: k.		lowByte _ word bitAnd: 16rFF.		eqBytes _ ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j _ k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j _ j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i _ self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i _ i+1]				ifFalse: [i _ self encodeInt: j-k+1*4+2 in: ba at: i.						i _ self encodeBytesOf: word in: ba at: i].			k _ j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i _ self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i _ i+1.				k _ k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j _ j+1].				j = size ifTrue: [j _ j + 1].				"We have one or more unmatching words, ending at j-1"				i _ self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i _ self encodeBytesOf: (bm at: m) in: ba at: i].				k _ j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n _ rawBytes _ myBytes _ 0.Form allInstancesDo:	[:f | f unhibernate.	b _ f bits.	n _ n + 1.	rawBytes _ rawBytes + (b size*4).	myBytes _ myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:31'!compressToByteArray	"Return a run-coded compression of this bitmap into a byteArray"			| byteArray lastByte |	"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...	N >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)	N > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)	N > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.The worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 1984 (7936//4) or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 1984 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 (encoded size) + 2 (first run len) + (S//1984*3)."	"NOTE: This code is copied in Form hibernate for reasons given there."	byteArray _ ByteArray new: (self size*4) + 7 + (self size//1984*3).	lastByte _ self compress: self toByteArray: byteArray.	^ byteArray copyFrom: 1 to: lastByte! !!Bitmap methodsFor: 'filing' stamp: 'di 6/1/1998 20:35'!writeUncompressedOn: aStream 	"Store the array of bits onto the argument, aStream.	A leading byte ~= 16r80 identifies this as raw bits (uncompressed)."	aStream nextInt32Put: self size.	aStream nextPutAll: self! !!BlockContext methodsFor: 'evaluating' stamp: 'tk 6/24/1998 15:32'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver. If an error occurs the given is evaluated with the error message and the receiver as parameters. The error handler block may return a value to be used if the receiver block gets an error. The receiver should not contain an explicit return statement as this would leave an obsolete error handler hanging around."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | ^ 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'division by 0' = err				ifTrue: [^ Float infinity]				ifFalse: [self error: err]]"	| lastHandler val activeProcess |	activeProcess _ Processor activeProcess.	lastHandler _ activeProcess errorHandler.	activeProcess errorHandler: [:aString :aReceiver |		activeProcess errorHandler: lastHandler.		^ errorHandlerBlock value: aString value: aReceiver].	val _ self value.	activeProcess errorHandler: lastHandler.	^ val! !!BlockContext methodsFor: 'evaluating' stamp: 'jm 6/3/1998 14:25'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!BlockContext methodsFor: 'scheduling' stamp: 'di 9/12/1998 11:53'!fork	"Create and schedule a Process running the code in the receiver."	^ self newProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive]		priority: Processor activePriority! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcessWith: anArray 	"Answer a Process running the code in the receiver. The receiver's block 	arguments are bound to the contents of the argument, anArray. The 	process is not scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self valueWithArguments: anArray.			Processor terminateActive]		priority: Processor activePriority! !Allows one or another "page" to show; orchestrates the page transitions; offers control panel for navigating among pages and for adding and deleting pages.!!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:43'!initialize	super initialize.	self setInitialState.	pages _ OrderedCollection new.	self showPageControls.	self class turnOffSoundWhile: [self insertPage].! !!BookMorph methodsFor: 'initialization' stamp: 'sw 6/24/1998 09:23'!newPages: pageList	"Replace all my pages with the given list of BookPageMorphs.  After this call, currentPage may be invalid."	pages _ pages species new.	pages addAll: pageList! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:45'!removeEverything	currentPage _ nil.	pages _ OrderedCollection new.	self removeAllMorphs! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 17:03'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	pageSize _ 160@300.	openToDragNDrop _ true! !!BookMorph methodsFor: 'sorting' stamp: 'sw 6/25/1998 17:15'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| goodPages rejects existingCursor toAdd newCursor |	goodPages _ OrderedCollection new.	rejects _ OrderedCollection new.	existingCursor _ aHolder cursor.	aHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: PasteUpMorph) ifTrue: [toAdd _ m].		(m isKindOf: BookPageThumbnailMorph) ifTrue: [toAdd _ m page].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[goodPages add: toAdd.				i == existingCursor ifTrue: [newCursor _ goodPages size]]].	self newPages: goodPages.	goodPages size == 0 ifTrue: [self insertPage].	newCursor ifNil: [newCursor _ 1].	self goToPage: newCursor.	rejects size > 0 ifTrue: [self inform: rejects size printString, ' objects vanished in this process.']! !!BookMorph methodsFor: 'sorting' stamp: 'di 8/8/1998 15:02'!morphsForPageSorter	| i thumbnails |	'Assembling thumbnail images...'		displayProgressAt: Sensor cursorPoint		from: 0 to: pages size		during:			[:bar | i _ 0.			thumbnails _ pages collect:				[:p | bar value: (i_ i+1).				pages size > 40 					ifTrue: [p smallThumbnailForPageSorter]					ifFalse: [p thumbnailForPageSorter]]].	^ thumbnails! !!BookMorph methodsFor: 'sorting' stamp: 'jm 6/17/1998 21:35'!sortPages: evt	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: (pages indexOf: currentPage ifAbsent: [0]).	evt == nil		ifTrue: [self world addMorphFront: sorter]		ifFalse: [evt hand attachMorph: sorter].! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/4/1998 16:40'!beThoroughlyRepelling	submorphs do: [:m | m beRepelling].	self beRepelling! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/4/1998 17:12'!rootForGrabOf: aMorph	| root |	openToDragNDrop ifFalse: [^ super rootForGrabOf: aMorph].	(aMorph = currentPage or: [aMorph owner = self])		ifTrue: [^ self rootForGrabOf: self].	root _ aMorph.	[root = self] whileFalse:		[root owner == currentPage ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!BookMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/31/1998 00:04'!wantsDroppedMorph: aMorph event: evt	(currentPage bounds containsPoint: evt cursorPoint) ifFalse: [^ false].	^ super wantsDroppedMorph: aMorph event: evt! !!BookMorph methodsFor: 'insert and delete' stamp: 'sw 6/24/1998 18:50'!deletePage	| message |	message _ 'Are you certain that youwant to delete this page andeverything that is on it? '.	(self confirm: message) ifTrue: 			[self deletePageBasic].	! !!BookMorph methodsFor: 'insert and delete' stamp: 'tk 6/11/1998 17:42'!deletePageBasic	| oldPage |	oldPage _ currentPage.	self nextPage.	pages remove: oldPage.	oldPage delete.	currentPage = oldPage ifTrue: [self nextPage].	pages isEmpty ifTrue: [self insertPage].! !!BookMorph methodsFor: 'insert and delete' stamp: 'tk 6/14/1998 14:26'!insertPageColored: aColor	| sz newPage bw bc |	currentPage == nil		ifTrue:			[sz _ pageSize.			bw _ 0.			bc _ Color blue muchLighter]		ifFalse:			[sz _ currentPage extent.			bw _ currentPage borderWidth.			bc _ currentPage borderColor].	newPagePrototype		ifNil: [			newPage _ PasteUpMorph new extent: sz; color: aColor.			newPage borderWidth: bw; borderColor: bc]		ifNotNil: [Cursor wait showWhile: 				[newPage _ newPagePrototype veryDeepCopy]].	newPage resizeToFit: false.	pages isEmpty		ifTrue: [pages add: (currentPage _ newPage)]		ifFalse: [pages add: newPage after: currentPage].	self nextPage.! !!BookMorph methodsFor: 'zooming page turns' stamp: 'jm 7/10/1998 14:06'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	| image |	ascending ifNotNil: [		image _ currentPage imageForm.  "compute image before starting sound"		self playPageFlipSound.		(PageFlipSoundOn and: [oldOrigin ~~ nil]) ifTrue: [			Display wipeImage: image				at: oldOrigin				delta: (ascending ifTrue: [0@-4] ifFalse: [0@4])]].! !!BookMorph methodsFor: 'navigation' stamp: 'sw 7/15/1998 21:07'!goToPage: pageNumber	| pageIndex  oldOrigin aWorld oldRect oldPageNumber ascending newPage |	pages isEmpty ifTrue: [^ self].	pageIndex _ pageNumber asInteger.	pageNumber < 1 ifTrue: [pageIndex _ pages size].	pageNumber > pages size ifTrue: [pageIndex _ 1].	newPage _ pages at: pageIndex.	oldPageNumber _ pages indexOf: currentPage ifAbsent: [nil].	ascending _ ((oldPageNumber == nil) or: [newPage == currentPage])			ifTrue:				[nil]			ifFalse:				[oldPageNumber < pageIndex].	(aWorld _ self world) ifNotNil:		[self primaryHand newKeyboardFocus: nil].	currentPage ifNotNil:		[(oldRect _ currentPage screenRectangle) ifNotNil:			[oldOrigin _ oldRect origin].		self currentPlayerDo: [:aPlayer | aPlayer runAllClosingScripts].		currentPage releaseCachedState; delete].	currentPage _ pages at: pageIndex.	self addMorphBack: currentPage.	self snapToEdgeIfAppropriate.	aWorld ifNotNil:		[self world startSteppingSubmorphsOf: currentPage.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	self currentPlayerDo:		[:aPlayer | aPlayer runAllOpeningScripts].	(aWorld _ self world) ifNotNil: ["Nil at init time, for example" aWorld displayWorld]! !!BookMorph methodsFor: 'navigation' stamp: 'di 8/6/1998 23:49'!pageNumber.	^ pages indexOf: currentPage ifAbsent: [0]! !!BookMorph methodsFor: 'menu' stamp: 'sw 8/5/1998 00:23'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'previous page' action: #previousPage.	subMenu add: 'next page' action: #nextPage.	subMenu add: 'insert a page' action: #insertPage.	subMenu add: 'delete this page' action: #deletePage.	controlsShowing _ self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue: [subMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [subMenu add: 'show page controls' action: #showPageControls].	subMenu add: 'sort pages' action: #sortPages:.	subMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	subMenu add: 'make this be "My Parts Bin"' action: #saveAsMyPartsBin.	(aHandMorph classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'Book...' subMenu: subMenu! !!BookMorph methodsFor: 'menu' stamp: 'sw 7/4/1998 16:06'!indexOfCurrentPage	^ pages indexOf: currentPage ifAbsent: [0]! !!BookMorph methodsFor: 'menu' stamp: 'di 8/6/1998 23:24'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu sel |	aMenu _ MVCMenuMorph new.	aMenu addList:	#(			('sort pages'				sortPages)			('make bookmark'		bookmarkForThisPage)			('make thumbnail'		thumbnailForThisPage)			('remove control panel'	hidePageControls)		).	(self primaryHand classOfPasteBuffer isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page'	action: #pasteBookPage].	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu add: (openToDragNDrop ifTrue: ['close'] ifFalse: ['open']) , ' dragNdrop'			action: #openCloseDragNDrop.	sel _ aMenu invokeAt: self primaryHand position in: self world.	sel ifNotNil: [self perform: sel].! !!BookMorph methodsFor: 'menu' stamp: 'di 8/11/1998 12:47'!saveAsMyPartsBin	| aBin |	aBin _ self veryDeepCopy.	aBin pages do:		[:aPage | 			aPage isPartsBin: true.			aPage openToDragNDrop: false.			aPage submorphs do:				[:m | m markAsPartsDonor.				m suspendEventHandler]].	ScriptingSystem setPartsBinFrom: aBin! !!BookMorph methodsFor: 'menu' stamp: 'tk 8/13/1998 12:09'!setNewPagePrototype	"Record the current page as the prototype to be copied when inserting new pages."	currentPage ifNotNil:		[newPagePrototype _ currentPage veryDeepCopy].! !!BookMorph methodsFor: 'menu' stamp: 'di 8/6/1998 23:50'!thumbnailForThisPage	self primaryHand attachMorph:		(currentPage thumbnailForPageSorter pageNumber: self pageNumber inBook: self)! !!BookMorph methodsFor: 'other' stamp: 'tk 8/13/1998 12:49'!makeMinimalControlsWithColor: aColor title: aString	| aButton aColumn aRow but |	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: aColor; borderWidth: 0.	aColumn _ AlignmentMorph newColumn.	aColumn color: aButton color; borderWidth: 0; inset: 0.	aColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow _ AlignmentMorph newRow.	aRow color: aButton color; borderWidth: 0; inset: 0.	aRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow addTransparentSpacerOfSize: 40@0.	aRow addMorphBack: (but _ aButton fullCopy label: ' < ' ; actionSelector: #previousPage).		"fullCopy is OK, since we just made it and it can't own any Players"	but setBalloonText: 'Go to previous page'.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (StringMorph contents: aString) lock.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (but _ aButton fullCopy label: ' > ' ; actionSelector: #nextPage).	but setBalloonText: 'Go to next page'.	aRow addTransparentSpacerOfSize: 40@0.	aColumn addMorphBack: aRow.	aColumn setNameTo: 'Page Controls'.		^ aColumn! !!BookMorph methodsFor: 'other' stamp: 'sw 8/11/1998 16:50'!succeededInRevealing: aPlayer	currentPage ifNotNil: [currentPage player == aPlayer ifTrue: [^ true]].	pages do:		[:aPage |			(aPage succeededInRevealing: aPlayer) ifTrue:				[self goToPageMorph: aPage.				^ true]].	^ false! !!BookMorph class methodsFor: 'all' stamp: 'sw 7/4/1998 15:58'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: (Color gray: 0.9).	book borderWidth: 1; borderColor: Color black.	book beSticky.	book showPageControls; insertPage.	^ book! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:27'!acceptSort	book acceptSortedContentsFrom: pageHolder.	self delete.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:39'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:28'!book: aBookMorph morphsToSort: morphList	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs: morphList.	pageHolder extent: pageHolder width@pageHolder fullBounds height.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'jm 6/17/1998 21:42'!closeButtonOnly	"Replace my default control panel with one that has only a close button."	| b r |	self firstSubmorph delete.  "remove old control panel"	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Close'; actionSelector: #delete).	self addMorphFront: r.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'sw 7/1/1998 18:36'!forBook: aBookMorph	book _ aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs:		(book pages collect: [:p | p thumbnailForPageSorter]).	pageHolder extent: pageHolder width@pageHolder fullBounds height.! !!BookPageSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 12:36'!initialize	super initialize.	self extent: 440@400;		orientation: #vertical;		centering: #topLeft;		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 3;		color: Color lightGray;		borderWidth: 2.	pageHolder _ PasteUpMorph new behaveLikeHolder extent: self extent - borderWidth.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder.! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 6/25/1998 10:10'!computeThumbnail	| f scale |	f _ page imageForm.	page fullReleaseCachedState.	scale _ self height / f height.  "keep height invariant"	self form: (f magnify: f boundingBox by: scale@scale smoothing: 2).! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/6/1998 23:45'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Flip to this page with no extra sound"	BookMorph turnOffSoundWhile: [bookMorph goToPage: pageNumber]! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/8/1998 14:02'!initialize	| f |	super initialize.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f.! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'sw 6/26/1998 15:37'!page: aMorph	page _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/6/1998 23:45'!pageNumber: n inBook: b	pageNumber _ n.	bookMorph _ b! !!BookPageThumbnailMorph methodsFor: 'all' stamp: 'di 8/8/1998 14:06'!smaller	self form: (self form copy: (0@0 extent: self form extent//2)).! !A common superclass for BookMorph and WebBookMorph!!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 15:48'!fullControlSpecs	^ #(( '<--'		firstPage		'First page')		( '<-' 		previousPage	'Previous page')		('-'			deletePage		'Delete this page')		('<<>>'		invokeBookMenu 'Invoke menu')		('+'			insertPage		'Add a new page after this one')		('->'			nextPage		'Next page')		( '-->'		lastPage			'Final page'))! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:12'!hidePageControls	"Delete all submorphs answering to the property #pageControl"	self deleteSubmorphsWithProperty: #pageControl! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:16'!makePageControlsFrom: controlSpecs	| c aButton col row b |	c _ (color saturation > 0.1) ifTrue: [color lighter] ifFalse: [color darker].	aButton _ SimpleButtonMorph new target: self; borderColor: Color black; color: c.	col _ AlignmentMorph newColumn.	col color: c; borderWidth: 0; inset: 0.	col hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	row _ AlignmentMorph newRow.	row color: c; borderWidth: 0; inset: 0.	row hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	controlSpecs do: [:pair |		b _ aButton fullCopy			label: pair first;			actionSelector: pair second;			setBalloonText: pair third.		row addMorphBack: b.		(pair last asLowercase includesSubString: 'menu')			ifTrue: [b actWhen: #buttonDown]].  "pop up menu on mouseDown"	col addMorphBack: row.	^ col! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 17:48'!shortControlSpecs	^ #(( '<-'	previousPage	'Previous page')		('->'		nextPage		'Next page'))! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 7/4/1998 16:13'!showPageControls	| spacer pageControls |	self hidePageControls.	spacer _ Morph new color: color; extent: 0@10.	spacer  setProperty: #pageControl toValue: true.	self addMorph: spacer.	pageControls _ Preferences noviceMode		ifTrue: [self makePageControlsFrom: self shortControlSpecs]		ifFalse: [self makePageControlsFrom: self fullControlSpecs].	pageControls borderWidth: 1; inset: 4.	pageControls  setProperty: #pageControl toValue: true.	pageControls setNameTo: 'Page Controls'.	self addMorph: pageControls.! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:36'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"This factoring allows subclasses to have different menu yet still use the super call for the rest of the metamenu."	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self addBookMenuItemsTo: aCustomMenu hand: aHandMorph! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:39'!clearNewPagePrototype	newPagePrototype _ nil! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:40'!firstPage	self goToPage: 1! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 17:18'!insertPage	self insertPageColored: self color! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 16:08'!sortPages	| sorter |	sorter _ BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: self indexOfCurrentPage.	self presentResultMorph: sorter! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:56'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	(self hasSubmorphWithProperty: #pageControl)		ifTrue: [aCustomMenu add: 'hide page controls' action: #hidePageControls]		ifFalse: [aCustomMenu add: 'show page controls' action: #showPageControls]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 8/11/1998 16:51'!currentPlayerDo: aBlock	| aPlayer aPage |	(aPage _ self currentPage) ifNil: [^ self].	(aPlayer _ aPage player) ifNotNil:		[aBlock value: aPlayer]! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:36'!pageSize	^ pageSize! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:51'!pageSize: aPoint	pageSize _ aPoint! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 15:38'!playPageFlipSound	(self presenter soundsEnabled "user-controllable" and:		[PageFlipSoundOn])  "mechanism to suppress sounds at init time"			ifTrue: [self playSoundNamed: 'camera'].! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:09'!presentResultMorph: aMorph	"Add the given morph to the world."	self primaryHand attachMorph: aMorph"	aMorph position: self fullBounds topRight + (5@0).	self world addMorphFront: aMorph."! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 15:59'!initialize	"BooklikeMorph initialize"	PageFlipSoundOn _ true! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 16:43'!turnOffSoundWhile: aBlock	"Turn off page flip sound during the given block."	| old |	old _ PageFlipSoundOn.	PageFlipSoundOn _ false.	aBlock value.	PageFlipSoundOn _ old! !!Boolean methodsFor: 'copying' stamp: 'tk 6/26/1998 11:32'!clone 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !!Boolean methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !!BooleanScriptEditor methodsFor: 'all' stamp: 'jm 5/28/1998 19:17'!storeCodeOn: aStream indent: tabCount	((submorphs size > 0) and:	 [submorphs first submorphs size > 0]) ifTrue: [			aStream nextPutAll: '(('.			super storeCodeOn: aStream indent: tabCount.			aStream nextPutAll: ') ~~ false)'.			^ self].	aStream nextPutAll: ' true '.! !!BooleanScriptEditor methodsFor: 'all' stamp: 'sw 8/3/1998 17:15'!wantsDroppedMorph: aMorph	((aMorph isKindOf: PhraseTileMorph) and:		[submorphs size == 1]) ifTrue: [^ false].	^ aMorph isTileLike and: [aMorph resultType ~~ #command]! !A tile whose result type is boolean.!!BooleanTile methodsFor: 'all' stamp: 'sw 8/5/1998 17:52'!resultType	^ #boolean! !!BorderedMorph methodsFor: 'accessing' stamp: 'jm 6/2/1998 15:55'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	(color isColor and: [color alpha < 1.0]) ifTrue: [^ true].	(borderColor isColor and: [borderColor alpha < 1.0]) ifTrue: [^ true].	^ false! !!BorderedMorph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:25'!areasRemainingToFill: aRectangle	color isTransparent ifTrue: [^ Array with: aRectangle].	borderWidth = 0		ifTrue: [^ aRectangle areasOutside: self bounds]		ifFalse: [(borderColor isColor and: [borderColor isTransparent])					ifTrue: [^ aRectangle areasOutside: self innerBounds]					ifFalse: [^ aRectangle areasOutside: self bounds]]! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 6/25/1998 08:34'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	^ aNumber == 2		ifTrue: 			[#(			(color			color		readWrite	getColor				setColor:)			(borderWidth 		number		readWrite	getBorderWidth	setBorderWidth:)			(borderColor			color		readWrite	getBorderColor	setBorderColor:))]		ifFalse:			[super slotNamesAndTypesForBank: aNumber]! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'startInfection' action: #startInfection.	aCustomMenu add: 'set atom count' action: #setAtomCount.	aCustomMenu add: 'show infection history' action: #showInfectionHistory:.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:04'!setAtomCount	| countString count |	countString _ FillInTheBlank		request: 'Number of atoms?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 8/10/1998 18:32'!step	"Bounce those atoms!!"	| r bounces |	bounces _ 0.	r _ bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces _ bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 6/28/1998 18:10'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a _ AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph _ GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected _ false.		pair do: [:atom | atom infected ifTrue: [infected _ true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count _ 0.	self submorphsDo: [:m | m infected ifTrue: [count _ count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection _ false.		self stopStepping].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 8/10/1998 18:32'!updateTemperature: currentTemperature	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures == nil ifTrue: [		recentTemperatures _ OrderedCollection new.		20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature _ recentTemperatures sum asFloat / recentTemperatures size.! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:50'!openAsMorphEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window codePane aListMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu:)		frame: (0@0 extent: 0.25@0.4).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:)		frame: (0.25@0 extent: 0.25@0.3).	window addMorph: self buildMorphicSwitches		frame: (0.25@0.3 extent: 0.25@0.1).	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (0.5@0 extent: 0.25@0.4).	aListMorph _ PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0.75@0 extent: 0.25@0.4).	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@0.4 corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:08'!openEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| systemCategoryListView classListView 	messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphEditing: aString].	Sensor leftShiftDown ifTrue: [^ self openAsMorphEditing: aString "testing"].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategoryList		selected: #systemCategoryListIndex		changeSelected: #systemCategoryListIndex:		menu: #systemCategoryMenu:.	systemCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 50 @ 62).	topView addSubView: classListView toRightOf: systemCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	messageListView menuTitleSelector: #messageListSelectorTitle.	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@110).	topView addSubView: browserCodeView below: systemCategoryListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:17'!openMessageCatEditString: aString	"Create a pluggable version of the views for a Browser that just shows one message category."	| messageCategoryListView messageListView browserCodeView topView |	World ifNotNil: [^ self openAsMorphMsgCatEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	messageCategoryListView _ PluggableListView on: self		list: #messageCatListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: messageCategoryListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 200 @ 70).	topView addSubView: messageListView below: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(200-12-70)).	topView addSubView: browserCodeView below: messageListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:18'!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| classListView messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphClassEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	classListView _ PluggableListView on: self		list: #classListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 100 @ 12).	topView addSubView: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageCategoryListView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	switchView 		window: switchView window 		viewport: (classListView viewport topRight 					corner: messageListView viewport topRight).	topView addSubView: switchView toRightOf: classListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(200-12-70)).	topView addSubView: browserCodeView below: messageCategoryListView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:18'!openSystemCatEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers.  The top list view is of the currently selected system class category--a single item list."	| systemCategoryListView classListView messageCategoryListView messageListView browserCodeView topView switchView |	World ifNotNil: [^ self openAsMorphSysCatEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategorySingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #systemCategoryMenu:.	systemCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:.	classListView window: (0 @ 0 extent: 67 @ 62).	topView addSubView: classListView below: systemCategoryListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 66 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	switchView _ self buildInstanceClassSwitchView.	switchView 		window: switchView window 		viewport: (classListView viewport bottomLeft 					corner: messageCategoryListView viewport bottomLeft).	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 67 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@(110-12)).	topView addSubView: browserCodeView below: switchView.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'accessing' stamp: 'sw 9/2/1998 14:13'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories 		ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) 		ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [PopUpMenu notify: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText stamp: Utilities changeStamp. ^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage) 		ifTrue: [^ self defineMessage: aText notifying: aController].	editSelection == #none		ifTrue: [PopUpMenu notify: 'This text cannot be acceptedin this part of the browser.'.				^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'accessing' stamp: 'di 6/21/1998 22:20'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	self dependents		detect: [:d |			((d isKindOf: PluggableListView) or: [d isKindOf: PluggableListMorph]) and: 			[d getListSelector == #systemCategoryList]]		ifNone: [^ false].	^ true! !!Browser methodsFor: 'class functions' stamp: 'di 6/2/1998 13:58'!defineClass: defString notifying: aController 	"The receiver's textual content is a request to define a new class. The 	source code is defString. If any errors occur in compilation, notify 	aController."	| oldClass class newClassName |	oldClass _ self selectedClassOrMetaClass.	newClassName _ (defString findTokens: Character separators) third copyWithout: $#.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [Smalltalk includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	oldClass ifNil: [oldClass _ Object].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: 			[self changed: #classList.			self classListIndex: 				(self classList indexOf: 					((class isKindOf: Metaclass)						ifTrue: [class soleInstance name]						ifFalse: [class name])).			self clearUserEditFlag; editClass.			^true]		ifFalse: [^false]! !!Browser methodsFor: 'message list' stamp: 'di 9/21/1998 23:12'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector in: class method: method) decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue:		[contents _ class compilerClass new			format: contents in: class notifying: nil].	contents _ contents asText makeSelectorBoldIn: class.	^ contents copy! !!Browser methodsFor: 'message functions' stamp: 'di 5/27/1998 15:45'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that 	the currently selected message should be removed from the system. If so, 	remove it.  If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.  "In case organization not cached"	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !URLs that instruct a browser to do something.!!BrowserUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!BrowserUrl methodsFor: 'downloading' stamp: 'ls 7/26/1998 21:21'!retrieveContentsForBrowser: aBrowser	^aBrowser browserUrlContents: locator! !!ButtonMorph methodsFor: 'copying' stamp: 'tk 8/13/1998 12:53'!prepareToBeSaved	"SmartRefStream will not write any morph that is owned by someone outside the root being written.  (See DataStream.typeIDFor:)  Open Scripts are like that.  Make a private copy of the scriptEditor."	super prepareToBeSaved.	lastAcceptedScript ifNotNil: [		lastAcceptedScript owner ifNotNil: ["open on the screen"			lastAcceptedScript _ lastAcceptedScript fullCopy setMorph: self.			self flag: #noteToTed.  "What if some tile has a Player?  				Need an invariant that says no script part can have a Player.  Enforce it."			"lastAcceptedScript privateOwner: nil" "fullCopy does it"]].	"lastScriptEditor will not be written out"! !This class oversees the translation of a subset of Smalltalk to C, allowing the comforts of Smalltalk during development and the efficiency and portability of C for the resulting interpreter.  Executing	Interpreter translate: 'interp.c' doInlining: true.(with single quotes) will cause all the methods of Interpreter, ObjectMemory and BitBltSimulation to be translated to C, and stored in the named file.  This file together with the files emitted by InterpreterSupportCode (qv) should be adequate to produce a complete interpreter for the Macintosh environment.!!CCodeGenerator methodsFor: 'C code generator' stamp: 'ls 8/15/1998 08:36'!emitCHeaderForPrimitivesOn: aStream	"Write a C file header for compiled primitives onto the given stream."	aStream nextPutAll: '/* Automatically generated from Squeak on '.	aStream nextPutAll: Time dateAndTimeNow printString.	aStream nextPutAll: ' */'; cr; cr.	aStream nextPutAll: '#include "sq.h"'; cr; cr.	aStream nextPutAll: '/* Memory Access Macros */#define byteAt(i) (*((unsigned char *) (i)))#define byteAtput(i, val) (*((unsigned char *) (i)) = val)#define longAt(i) (*((int *) (i)))#define longAtput(i, val) (*((int *) (i)) = val)/*** Imported Functions/Variables ***/extern int stackValue(int);extern int successFlag;/* allows accessing Strings in both C and Smalltalk */#define asciiValue(c) c'.	aStream cr.! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 7/5/1998 18:17'!generateDivide: msgNode on: aStream indent: level	"Generate the C code for this message onto the given stream."	| rcvr arg divisor |	rcvr _ msgNode receiver.	arg _ msgNode args first.	(arg isConstant and:	 [UseRightShiftForDivide and:	 [(divisor _ arg value) isPowerOfTwo and:	 [divisor > 0 and:	 [divisor <= (1 bitShift: 31)]]]])	ifTrue: [		"use signed (arithmetic) right shift instead of divide"		aStream nextPutAll: '((int) '.		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' >> ', (divisor log: 2) asInteger printString.		aStream nextPutAll: ')'.	] ifFalse: [		self emitCExpression: rcvr on: aStream.		aStream nextPutAll: ' / '.		self emitCExpression: arg on: aStream].! !!CCodeGenerator methodsFor: 'C translation' stamp: 'jm 8/19/1998 09:56'!initializeCTranslationDictionary 	"Initialize the dictionary mapping message names to actions for C code generation."	| pairs |	translationDict _ Dictionary new: 200.	pairs _ #(	#&				#generateAnd:on:indent:	#|				#generateOr:on:indent:	#and:			#generateSequentialAnd:on:indent:	#or:			#generateSequentialOr:on:indent:	#not			#generateNot:on:indent:	#+				#generatePlus:on:indent:	#-				#generateMinus:on:indent:	#*				#generateTimes:on:indent:	#//				#generateDivide:on:indent:	#\\				#generateModulo:on:indent:	#<<				#generateShiftLeft:on:indent:	#>>				#generateShiftRight:on:indent:	#min:			#generateMin:on:indent:	#max:			#generateMax:on:indent:	#bitAnd:		#generateBitAnd:on:indent:	#bitOr:			#generateBitOr:on:indent:	#bitXor:			#generateBitXor:on:indent:	#bitShift:		#generateBitShift:on:indent:	#bitInvert32	#generateBitInvert32:on:indent:	#<				#generateLessThan:on:indent:	#<=				#generateLessThanOrEqual:on:indent:	#=				#generateEqual:on:indent:	#>				#generateGreaterThan:on:indent:	#>=				#generateGreaterThanOrEqual:on:indent:	#~=				#generateNotEqual:on:indent:	#==				#generateEqual:on:indent:	#~~				#generateNotEqual:on:indent:	#isNil			#generateIsNil:on:indent:	#notNil			#generateNotNil:on:indent:	#whileTrue: 	#generateWhileTrue:on:indent:	#whileFalse:	#generateWhileFalse:on:indent:	#to:do:			#generateToDo:on:indent:	#to:by:do:		#generateToByDo:on:indent:	#ifTrue:		#generateIfTrue:on:indent:	#ifFalse:		#generateIfFalse:on:indent:	#ifTrue:ifFalse:	#generateIfTrueIfFalse:on:indent:	#ifFalse:ifTrue:	#generateIfFalseIfTrue:on:indent:	#at:				#generateAt:on:indent:	#at:put:			#generateAtPut:on:indent:	#basicAt:		#generateAt:on:indent:	#basicAt:put:	#generateAtPut:on:indent:	#integerValueOf:	#generateIntegerValueOf:on:indent:	#integerObjectOf:	#generateIntegerObjectOf:on:indent:	#isIntegerObject: 	#generateIsIntegerObject:on:indent:	#cCode:				#generateInlineCCode:on:indent:	#cCoerce:to:			#generateCCoercion:on:indent:	#preIncrement		#generatePreIncrement:on:indent:	#preDecrement		#generatePreDecrement:on:indent:	#inline:				#generateInlineDirective:on:indent:	#sharedCodeNamed:inCase:	#generateSharedCodeDirective:on:indent:	).	1 to: pairs size by: 2 do: [:i |		translationDict at: (pairs at: i) put: (pairs at: i + 1)].! !!CCodeGenerator class methodsFor: 'class initialization' stamp: 'jm 8/19/1998 10:03'!initialize	"CCodeGenerator initialize"	UseRightShiftForDivide _ true.		"If UseRightShiftForDivide is true, the translator will generate a right-shift when it encounters a division by a constant that is a small power of two. For example, 'x / 8' will generate '((int) x >> 3)'. The coercion to int is done to make it clear that the C compiler should generate a signed shift."		"Note: The Kernighan and Ritchie 2nd Edition C manual, p. 49, leaves the semantics of right-shifting a negative number open to the discretion of the compiler implementor. However, it strongly suggests that most compilers should generate an arithmetic right shift (i.e., shifting in the sign bit), which is the same as dividing by a power of two. If your compiler does not generate or simulate an arithmetic shift, then make this class variable false and re-translate."! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/1/1998 12:44'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	request reply: (HTMLformatter evalEmbedded: (self fileContents:source ,'page.html')			with: formattedPage).! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'TPR 7/21/1998 18:14'!generate: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage peer cacheFile file|	(request isKindOf: PWS)	ifFalse: [(request isKindOf: String) ifTrue: [peer _ request]ifFalse: [peer _ ' ']]	ifTrue: [peer _ request peerName].	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (HTMLformatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: peer					storingTo: OrderedCollection new]).	cacheFile _ (self cacheDirectory),(self name),(ServerActionpathSeparator),(pageRef coreID),'.html'.	(StandardFileStream isAFileNamed: cacheFile)	ifTrue: [FileDirectory deleteFilePath: cacheFile].	file _ FileStream fileNamed: cacheFile.	file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents:source ,'page.html')			with: formattedPage).	file close.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'TPR 7/21/1998 18:15'!generateRecent	| file |	file _ FileStream fileNamed: (self cacheDirectory),(selfname),(ServerAction pathSeparator),'recent.html'.	file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents:source, 'recent.html')					with: urlmap recent).	file close.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/10/1998 15:34'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"		self generate: (urlmap atID: coreRef) from: request.		self generateRecent.			^ self]].		"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!CachedSwikiAction methodsFor: 'URL processing' stamp: 'BJP 9/9/1998 21:34'!pageURL: aPage	"make the url suited to aPage"	^(self url),(self name),'/',aPage coreID,'.html'! !!CachedSwikiAction methodsFor: 'access' stamp: 'TPR 7/21/1998 18:05'!url	^cacheURL! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!clipRect	^ clipRect translateBy: origin negated! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:38'!extent	^ Display extent! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:39'!form	^ Display! !!Canvas methodsFor: 'testing' stamp: 'jm 5/30/1998 21:10'!isVisible: aRectangle	"Optimization of: ^ clipRect intersects: (aRectangle translateBy: origin)"	(aRectangle right + origin x) < clipRect left	ifTrue: [^ false].	(aRectangle left + origin x) > clipRect right	ifTrue: [^ false].	(aRectangle bottom + origin y) < clipRect top	ifTrue: [^ false].	(aRectangle top + origin y) > clipRect bottom	ifTrue: [^ false].	^ true! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:59'!image: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self		image: aForm		at: aPoint		sourceRect: (0@0 extent: aForm extent)		rule: Form paint.! !!Canvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 06:48'!line: pt1 to: pt2 brushForm: brush	"Noop here; overridden by non-trivial canvases."! !I represent the organization of the mail database into set of message lists called "categories". Each category contains a collection of message ID's. The same message may be cross-filed quite cheaply by storing it's ID in multiple categories.The categories information is kept in a binary file on the disk. It is read into memory in its entirety when the mail database is opened. To make changes persist, the categories information must be saved out to disk. This should be done after fetching new mail and when the mail database is closed. It could also be done periodically by some sort of background process. Note that the categories file, unlike the index file, cannot be re-created from the messages file.!!CategoriesFile methodsFor: 'categories access'!addCategory: categoryName	"Add a new category, if it doesn't already exist."	(self categories includes: categoryName) ifFalse:		[categories at: categoryName put: Set new].! !!CategoriesFile methodsFor: 'categories access'!categories	"Answer a collection of my categories, including the pseudo-categories '.unclassified.' and '.all.'. '.unclassified.' contains the orphaned messages that would otherwise not appear in any category. '.all.' contains all the messages in the database. Since these pseudo-categories are computed on the fly, there may be a noticable delay when one of them is selected."	^(categories keys)		add: '.all.';		add: '.unclassified.';		yourself! !!CategoriesFile methodsFor: 'categories access'!file: messageID inCategory: categoryName	"Add the given message ID to the given category. The target category must be a real category, not a pseudo-category."	(categoryName = '.unclassified.' | categoryName = '.all.') ifTrue: [^self].	(categories includesKey: categoryName) ifFalse:		[categories at: categoryName put: Set new].	(categories at: categoryName) add: messageID.! !!CategoriesFile methodsFor: 'categories access'!isUnclassified: messageID	"Answer true if the given message ID does not appear in any of my real (not pseudo) categories."	categories do:		[: category | (category includes: messageID) ifTrue: [^false]].	^true! !!CategoriesFile methodsFor: 'categories access'!messagesIn: category	"Answer a collection of message ID's for the messages in the given category. The pseudo-categories are dynamically computed and so they cannot be accessed in this manner."	^categories at: category ifAbsent: [#()]! !!CategoriesFile methodsFor: 'categories access'!remove: messageID fromCategory: categoryName	"Remove the given message ID from the given category."	| msgList |	msgList _ categories at: categoryName ifAbsent: [^self].	msgList remove: messageID ifAbsent: [].! !!CategoriesFile methodsFor: 'categories access'!removeCategory: categoryName	"Remove the given category, if it exists."	categories removeKey: categoryName ifAbsent: [].! !!CategoriesFile methodsFor: 'categories access'!removeMessagesInCategory: categoryName butNotIn: indexFile	"Used to clean the dead wood out of a category."	| oldMsgs newMsgs |	oldMsgs _ categories at: categoryName ifAbsent: [^self].	newMsgs _ oldMsgs copy.	oldMsgs do:		[: msgID |		 (indexFile includesKey: msgID) ifFalse:			[newMsgs remove: msgID]].	categories at: categoryName put: newMsgs.! !!CategoriesFile methodsFor: 'categories access'!renameCategory: oldName to: newName	"Rename the given category."	| oldEntry |	(oldName = 'new' | oldName = '.unclassified.' | oldName = '.all.' |	 (self categories includes: newName)) ifTrue:		[^self].	"can't rename a special category or overwrite an existing one"	oldEntry _ categories removeKey: oldName ifAbsent: [Set new].	categories at: newName put: oldEntry.! !!CategoriesFile methodsFor: 'categories access'!unclassifiedFrom: messageIDs	"Answer the subset of the given set of message ID's that do not appear in any category."	^messageIDs select:		[: msgID | self isUnclassified: msgID]! !!CategoriesFile methodsFor: 'read-write' stamp: 'jm 8/18/1998 16:24'!readFrom: aFileStream	"Read the categories from the given FileStream."	| name categorySize messageIDs |	categories _ Dictionary new: 64.	aFileStream binary; position: 0.	[aFileStream atEnd] whileFalse:		[name _ aFileStream ascii; nextString.		 categorySize _ aFileStream binary; nextWord.		 messageIDs _ Set new: categorySize * 4.		 categorySize timesRepeat:			[messageIDs add: aFileStream nextInt32].		 categories at: name put: messageIDs].! !!CategoriesFile methodsFor: 'read-write'!writeOn: aFileStream	"Write the categories to the given FileStream. The categories data is stored in binary (as opposed to a human-readable form) to save space."	aFileStream binary; position: 0.	categories associationsDo:		[: category |		 "(category key) is the category name"		 "(category value) is the set of message ID's in that category"		 aFileStream nextStringPut: (category key).		 aFileStream nextWordPut: (category value) size.		 (category value) do:			[: messageID |			 aFileStream nextInt32Put: messageID]].! !A model for a morphic world view which will ask for confirmation before being closed, unless the corresponding preference is set to false. !!CautiousModel methodsFor: 'all' stamp: 'sw 9/15/1998 16:45'!okToChange	Preferences cautionBeforeClosing ifFalse: [^ true].	Sensor leftShiftDown ifTrue: [^ true].	self beep.	^ self confirm: 'Warning!!If you answer "yes" here, thiswindow will disappear andits contents will be lost!!Do you really want to do that?'"CautiousModel new okToChange"! !I am the core of a mail reading and organizing program. The name "Celeste" is a reference to an earlier mail reader named "Babar", which was written at Xerox PARC by Steve Putz and John Maloney.This object provides a user interface and some higher-level functionality for the application. The foundation of of the mail reader is really the mail database, implemented by the class MailDB.!!Celeste methodsFor: 'open-close' stamp: 'jm 9/21/1998 17:18'!close	"Close the mail database."	mailDB ifNotNil: [		mailDB close; release.		mailDB _ nil].! !!Celeste methodsFor: 'open-close' stamp: 'ls 9/13/1998 21:15'!openOnDatabase: aMailDB	"Initialize myself for the mail database with the given root filename."	mailDB _ aMailDB.	mailDB addDependent: self.	currentCategory _ 'new'.	lastCategory _ ''.	subjectFilter _ ''.	fromFilter _ ''.	dateFilter _ nil.	self setCategory: currentCategory.! !!Celeste methodsFor: 'open-close' stamp: 'jm 8/20/1998 18:37'!windowIsClosing	"Close the mail database when my window is closed."	self close.! !!Celeste methodsFor: 'categories pane'!addCategory	"Create a new category with the user-specified name. This does nothing if the category already exists."	| newCatName |	newCatName _ FillInTheBlank request: 'Name for new category?'.	(newCatName isEmpty) ifTrue: [^self].	"user aborted"	mailDB addCategory: newCatName.	currentCategory _ newCatName.	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 09:24'!categoriesKeystroke: aCharacter	aCharacter asciiValue = 30 ifTrue: [self previousCategory].	aCharacter asciiValue = 31 ifTrue: [self nextCategory].! !!Celeste methodsFor: 'categories pane'!category	"Answer the currently selected category or nil."	^currentCategory! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 10:25'!categoryList	"Answer a list of categories for the categories pane."	^ mailDB allCategories! !!Celeste methodsFor: 'categories pane' stamp: 'jm 9/21/1998 17:28'!categoryMenu: aMenu	"Answer the menu for the categories pane."	| labels lineSeparations selectors lines |	labels _ 'save\fetch mail\send queued mail\add category' withCRs.	lineSeparations _ #(1 2).	selectors _ #(save fetchMail sendQueuedMail addCategory).	"add extra commands if a normal category is selected"	((currentCategory notNil) and:	 [(currentCategory ~= '.all.') &	  (currentCategory ~= '.unclassified.')])		ifTrue: [			labels _ labels, '\rename category\remove category\export category' withCRs.			lineSeparations _ lineSeparations, #(4).			selectors _ selectors, #(renameCategory removeCategory exportCategory ). ]		ifFalse: [			lineSeparations _ lineSeparations, #(1) ].	labels _ labels, '\empty trash\compact\toggle headers\set user name\set cc: list\set POP server\set POP username\set SMTP server' withCRs.	lineSeparations _ lineSeparations, #(2 1 5).	selectors _ selectors, #(emptyTrash compact toggleSuppressHeaders setUserName setCCList setPopServer setPopUSername setSmtpServer).	"add toggle for whether to delete messages on download"	DeleteInboxAfterFetching		ifTrue: [ labels _ labels, '\leave messages on server' withCRs.			selectors _ selectors, #(keepMessagesOnServer) ]		ifFalse: [ labels _ labels, '\don''t leave messages on server' withCRs.			selectors _ selectors, #(deleteMessagesAfterFetching) ].	lineSeparations _ lineSeparations, #(1).	"convert lineSeperations into absolute line positions"	lines _ lineSeparations copyFrom: 1 to: (lineSeparations size - 1).	(2 to: lines size) do: [ :i |		lines at: i put: ((lines at: i) + (lines at: i-1)) ].	^aMenu labels: labels lines: lines  selections: selectors! !!Celeste methodsFor: 'categories pane'!compact	"Compact the messages file."	| stats |	Transcript cr; show: 'Compacting message file...'.	Cursor execute showWhile: [stats _ mailDB compact].	Transcript show: 'Done.'; cr.	Transcript show:		'Recovered ',		(stats at: 1) printString, ' message',		(((stats at: 1) > 1) ifTrue: ['s, '] ifFalse: [', ']),		(stats at: 2) printString, ' bytes.'; cr.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 01:45'!deleteMessagesAfterFetching	"start deleting messages off the server after POP-ing"	DeleteInboxAfterFetching _ true! !!Celeste methodsFor: 'categories pane'!emptyTrash	"Delete all messages in the '.trash.' category.	WARNING: The messages will be completely removed from the database."	| msgList |	msgList _ self filteredMessagesIn: '.trash.'.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB deleteAll: msgList.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:42'!exportCategory	"Store the filtered message list of the current category to another mail database. The user is prompted for the name of the other database."	| destDBName destDB |	currentCategory ifNil: [ ^self ].	destDBName _ FillInTheBlank		request: 'Destination mail database?'		initialAnswer: ''.	(destDBName isEmpty) ifTrue: [^self].	destDB _ MailDB openOn: destDBName.	(destDB isNil) ifTrue: [^self].	destDB mergeMessages: (self filteredMessagesIn: currentCategory) from: mailDB.	destDB saveDB.	destDB changed: #categoryList.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:42'!exportCategoryUnix	"Store the filtered message list of the current category into a Eudora/Unix database"	| destFileName destFile messageIds count |	currentCategory ifNil: [ ^self ].	destFileName _ FillInTheBlank		request: 'Destination mail file?'		initialAnswer: ''.	(destFileName isEmpty) ifTrue: [^self].	destFile _ FileStream fileNamed: destFileName.	destFile ifNil: [ ^self error: 'could not open file' ].	destFile setToEnd.	messageIds _ self filteredMessagesIn: currentCategory.	('exporting ', messageIds size printString, ' messages')		displayProgressAt: Sensor mousePoint		from: 0		to: messageIds size		during: [ :bar |			count _ 0.			messageIds do: [ :messageId |				destFile nextPutAll: Celeste eudoraSeparator.				(mailDB getMessage: messageId) text linesDo: [ :line |					(line beginsWith: 'From ') ifTrue: [ destFile nextPut: $> ].					destFile nextPutAll: line.					destFile cr ].				count _ count + 1.				bar value: count. ].		].	destFile close.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/15/1998 18:58'!fetchMail	"Add the messages from the mail inbox file into this mail database."	| count server userName password |	self checkTrash.	server _ self class popServer.	userName _ self class popUserName.	password _ self class popPassword.	[count _ mailDB POPMailFrom: server		userName: userName		password: password		doFormatting: FormatWhenFetching		deleteInbox: DeleteInboxAfterFetching		informingUser: true.	 self inform: count printString, ' messages fetched'.	 currentCategory _ 'new'. 	] ifError: [ :err :rcvr | 			Transcript show: err.			(self confirm: 'Error: ', err, String cr,'debug it?') ifTrue: [ self halt ]. ].	self changed: #categoryList.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:43'!fetchNews	"Add the messages from the news inbox file into this mail database."	| inboxPath count |	self halt: 'This is probably out of date.  Feel lucky?'.	inboxPath _ Celeste inOutFolder.	inboxPath size > 0		ifTrue: [ inboxPath _ inboxPath, ':newsInbox' ]		ifFalse: [ inboxPath _ 'newsInbox' ].	Transcript show: 'Fetching news from ', inboxPath.	count _ mailDB fetchNewsFrom: inboxPath		doFormatting: FormatWhenFetching		deleteInbox: DeleteInboxAfterFetching. 	Transcript nextPutAll: count printString, ' messages'; cr; endEntry.	count > 0 ifTrue: [		self changed: #categoryList.		self updateTOC].! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/15/1998 05:23'!findDuplicates	"find duplicate messages, and move them all to a given category"	|duplicatesCategory |	duplicatesCategory _ FillInTheBlank request: 'category to move duplicates to?' initialAnswer: '.duplicates.'.	duplicatesCategory isEmpty ifTrue:[ ^self ].	Utilities informUser: 'searching for duplicates...' during: [		mailDB fileDuplicatesIn: duplicatesCategory ].	self setCategory: duplicatesCategory.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:17'!importIntoCategory	"Add the messages from a Unix or Eudora format file into this category"	| inboxPath count |	currentCategory ifNil: [ ^self ].	"get the file to import from"	inboxPath _ ''.	[	inboxPath _ FillInTheBlank request: 'file to import from?\(should be Eudora or Unix format)' withCRs.		inboxPath isEmpty ifTrue: [ ^self ].		FileStream isAFileNamed: inboxPath 	] whileFalse: [		self inform: 'file does not exist' ].	Utilities informUser: 'Fetching mail from ', inboxPath during: [		count _ mailDB importMailFrom: inboxPath  intoCategory: currentCategory. ].	self inform: count printString, ' messages imported'.	self updateTOC.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 01:45'!keepMessagesOnServer	"start keeping messages on the server after POP-ing"	DeleteInboxAfterFetching _ false! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 13:05'!nextCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i < catList size		ifTrue: [self setCategory: (catList at: i + 1)]		ifFalse: [self setCategory: (catList at: 1)].	self changed: #category.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 13:06'!previousCategory	"Select the next category."	| catList i |	catList _ self categoryList.	(currentCategory isNil) ifTrue: [currentCategory _ catList last].	i _ catList indexOf: currentCategory.	i > 1		ifTrue: [self setCategory: (catList at: i - 1)]		ifFalse: [self setCategory: (catList at: catList size)].	self changed: #category.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:57'!removeCategory	"Remove the existing category with the user-specified name."	| msgList |	currentCategory ifNil: [ ^self ].	msgList _ mailDB messagesIn: currentCategory.	(mailDB messagesIn: '.trash.') do: [: id |		msgList remove: id ifAbsent: []].	msgList isEmpty ifFalse: [		(self confirm:'This category is not empty. Areyou sure you wish to remove it?') ifFalse: [^self]].	mailDB removeCategory: currentCategory.	self setCategory: nil.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/17/1998 05:45'!renameCategory	"Rename the category with the user-specified name."	| newCatName |	currentCategory ifNil: [ ^self ].	newCatName _ FillInTheBlank		request: 'New name?'		initialAnswer: currentCategory.	(newCatName isEmpty) ifTrue: [^self].	"user aborted"	mailDB renameCategory: currentCategory to: newCatName.	currentCategory _ newCatName.	self changed: #categoryList.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 18:34'!save	"Snapshot the database to disk."	mailDB saveDB.! !!Celeste methodsFor: 'categories pane'!setCCList	"Change the default cc: list for use in composing messages."	self class setCCList.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 9/21/1998 11:03'!setCategory: newCategory	"Change the currently selected category. We must also compute the table of contents and message list for the new category."	| s |	currentCategory _ newCategory.	(newCategory isNil)		ifTrue: [			currentMessages _ currentTOC _ currentMsgID _ nil]		ifFalse: [			currentMessages _ self filteredMessagesIn: newCategory.			currentTOC _ OrderedCollection new: currentMessages size.			1 to: currentMessages size do: [:i |				s _ WriteStream on: (String new: 200).				s nextPutAll: i printString; space.				[s position < 4] whileTrue: [s space].				s nextPutAll: (mailDB getTOCstring: (currentMessages at: i)).				currentTOC add: s contents].			currentTOC _ currentTOC asArray.			(currentMessages includes: currentMsgID) ifFalse: [currentMsgID _ nil]].	self changed: #category.	self changed: #tocEntryList.	self changed: #messageText.! !!Celeste methodsFor: 'categories pane'!setInOutFolder	"Change the folder used to store the inbox and outbox files."	self class setInOutFolder.! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 00:37'!setPopServer	^self class setPopServer! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/12/1998 00:39'!setPopUserName	^self class setPopUserName! !!Celeste methodsFor: 'categories pane' stamp: 'ls 9/13/1998 02:31'!setSmtpServer	^self class setSmtpServer! !!Celeste methodsFor: 'categories pane'!setUserName	"Change the user's email name for use in composing messages."	self class setUserName.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/20/1998 10:35'!toggleSuppressHeaders	SuppressWorthlessHeaderFields _ SuppressWorthlessHeaderFields not.	self changed: #messageText.! !!Celeste methodsFor: 'categories pane' stamp: 'jm 8/14/1998 16:50'!underConstruction	self halt: 'Sorry, that is still under construction!!'.! !!Celeste methodsFor: 'table of contents pane'!deleteAll	"Move all visible messages in the current category to '.trash.'."	| msgList |	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB fileAll: msgList inCategory: '.trash.'.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 16:32'!deleteMessage	"Move the current message to the '.trash.' category and select the next message. Deleted messages can later purged by invoking the 'deleteAll' command in the '.trash.' category."	currentMsgID isNil ifTrue: [^ self].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: '.trash.'.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileAgain	"File the current message in the same category as last time."	| newCatName |	(lastCategory isEmpty not)		ifTrue: [newCatName _ lastCategory]		ifFalse: [newCatName _ self getCategoryNameIfNone: [^self]].	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileAll	"File all visible messages in the current category in some other category as well."	| newCatName msgList |	newCatName _ self getCategoryNameIfNone: [^self].	msgList _ self filteredMessagesIn: currentCategory.	mailDB fileAll: msgList inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!fileMessage	"File the current message in another category."	| newCatName |	newCatName _ self getCategoryNameIfNone: [^self].	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 08:14'!getCategoryNameIfNone: aBlock	"Prompt the user for a category name, remembering it for the next time."	| catList categoryName |	catList _ self categoryList.	catList remove: '.all.' ifAbsent: [].	catList remove: '.trash.' ifAbsent: [].	catList remove: '.unclassified.' ifAbsent: [].	catList add: '<new category>'.	((lastCategoryList ~= catList) or: [lastCategoryMenu = nil])		ifTrue: [lastCategoryMenu _ CustomMenu selections: catList].	categoryName _ lastCategoryMenu startUp.	categoryName = nil ifTrue: [^aBlock value].	categoryName = '<new category>' ifTrue: [		categoryName _ FillInTheBlank			request: 'New category name?'			initialAnswer: ''.		(categoryName isEmpty) ifTrue: [^aBlock value].		lastCategoryMenu _ nil.		mailDB addCategory: categoryName.		self changed: #categoryList.	].	lastCategoryList _ catList.	^lastCategory _ categoryName! !!Celeste methodsFor: 'table of contents pane'!moveAgain	"Move the current message to the same category as last time."	| newCatName |	(lastCategory isEmpty not)		ifTrue: [newCatName _ lastCategory]		ifFalse: [newCatName _ self getCategoryNameIfNone: [^self]].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!moveAll	"Move all visible messages in the current category to another category."	| newCatName msgList |	newCatName _ self getCategoryNameIfNone: [^self].	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	mailDB fileAll: msgList inCategory: newCatName.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!moveMessage	"Move the current message to another category."	| newCatName |	newCatName _ self getCategoryNameIfNone: [^self].	mailDB remove: currentMsgID fromCategory: currentCategory.	mailDB file: currentMsgID inCategory: newCatName.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 13:10'!nextMessage	"Select the next message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index < currentMessages size		ifTrue: [self setTOCEntry: (currentTOC at: index + 1)]		ifFalse: [self setTOCEntry: (currentTOC at: 1)].	self changed: #tocEntry.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 08:14'!otherCategories	"Prompt the user with a menu of all other categories in which the currently selected message appears. If the user chooses a category from this menu, go to that category."	| otherCategories choice |	otherCategories _		(mailDB categoriesThatInclude: currentMsgID) asOrderedCollection.	otherCategories remove: currentCategory ifAbsent: [].	(otherCategories isEmpty) ifTrue: [^self].	choice _ (CustomMenu selections: otherCategories) startUp.	choice = nil ifFalse: [self setCategory: choice].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 13:13'!previousMessage	"Select the previous message."	| index |	(currentCategory isNil | currentMsgID isNil) ifTrue: [^ self].	index _ currentMessages indexOf: currentMsgID.	index > 1		ifTrue: [self setTOCEntry: (currentTOC  at: index - 1)]		ifFalse: [self setTOCEntry: (currentTOC  at: currentMessages size)].	self changed: #tocEntry.! !!Celeste methodsFor: 'table of contents pane'!removeAll	"Remove all messages from the current category."	| msgList |	msgList _ self filteredMessagesIn: currentCategory.	mailDB removeAll: msgList fromCategory: currentCategory.	currentMsgID _ nil.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!removeMessage	"Remove the current message from the current category."	mailDB remove: currentMsgID fromCategory: currentCategory.	self updateTOC.! !!Celeste methodsFor: 'table of contents pane'!search	| destCat matchString msgText |	destCat _ FillInTheBlank		request: 'In what category should the search results be filed?'		initialAnswer: '.search results.'.	(destCat isEmpty) ifTrue: [^self].	matchString _ FillInTheBlank		request: 'String sought in message text?'		initialAnswer: ''.	(self filteredMessagesIn: currentCategory) do:		[: msgID |		 msgText _ mailDB getText: msgID.		 ((msgText findString: matchString startingAt: 1) > 0) ifTrue:			[mailDB file: msgID inCategory: destCat]].	self changed: #categoryList.! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 10:35'!setTOCEntry: newTOCentry	"Change the currently selected message. This is done by finding the message ID corresponding to the selected table of contents entry."	| i |	(newTOCentry isNil | currentTOC isNil)		ifTrue: [currentMsgID _ nil]		ifFalse:			[i _ currentTOC indexOf: newTOCentry ifAbsent: [nil].			 (i isNil)				ifTrue: [currentMsgID _ nil]				ifFalse: [currentMsgID _ currentMessages at: i]].	self changed: #messageText.  "update the message pane"! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:56'!tocEntry	"Answer the table of contents entry for the currently selected message or nil."	(currentMsgID isNil)		ifTrue: [^nil]		ifFalse: [^currentTOC at: (currentMessages indexOf: currentMsgID)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:57'!tocEntryList	"Answer a collection of table-of-contents entries for the currently selected category or an empty collection if no category is selected."	currentCategory		ifNil: [^ #()]		ifNotNil: [^ currentTOC].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/14/1998 13:57'!tocKeystroke: aCharacter	aCharacter = Character backspace ifTrue: [self deleteMessage].	aCharacter asciiValue = 30 ifTrue: [self previousMessage].	aCharacter asciiValue = 31 ifTrue: [self nextMessage].! !!Celeste methodsFor: 'table of contents pane' stamp: 'jm 8/20/1998 10:49'!tocMenu: aMenu	"Answer the menu for the table of contents pane."	currentCategory ifNil: [^ nil].	currentMsgID		ifNil: [			^ aMenu				labels: 'compose\file all\move all\remove all\delete all\search' withCRs				lines: #(1 5)				selections: #(compose fileAll moveAll removeAll deleteAll search)]		ifNotNil: [			^ aMenu				labels: 'delete\compose\reply\forward\file again\move again\file\move\remove\file all\move all\remove all\delete all\other categories\search' withCRs				lines: #(1 4 6 9 13 14)				selections: #(deleteMessage compose reply forward fileAgain moveAgain fileMessage moveMessage removeMessage fileAll moveAll removeAll deleteAll otherCategories search)].! !!Celeste methodsFor: 'table of contents pane' stamp: 'ls 9/10/1998 02:19'!updateTOC	"Update the table of contents after a moving, removing, or deleting a message. Select a message near the removed message in the table of contents if possible."	| currentMsgIndex |	((currentCategory isNil) |	 (currentMsgID isNil) |	 (currentMessages size < 2))		ifTrue: [currentMsgIndex _ 1]		ifFalse: [currentMsgIndex _ currentMessages indexOf: currentMsgID].	currentMsgID _ nil.	self setCategory: currentCategory.  "update currentMessages, currentTOC"	currentMessages isEmpty ifFalse: [		(currentMsgIndex <= currentMessages size)			ifTrue: [currentMsgID _ currentMessages at: currentMsgIndex]			ifFalse: [currentMsgID _ currentMessages last].	].	self changed: #tocEntryList.	self changed: #messageText.! !!Celeste methodsFor: 'filtering'!customFilterOff	"Cancel custom filtering."	customFilterBlock _ nil.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/11/1998 19:37'!customFilterOn	"Select or define and activate a custom filter."	| filterList filterName filterExpr |	filterList _ CustomFilters keys asSortedCollection asOrderedCollection.	filterList addLast: '<define new filter...>'.	filterList addLast: '<edit exising filter...>'.	filterList addLast: '<delete a filter...>'.	filterName _ (CustomMenu selections: filterList)			startUpWithCaption: 'Select a filter:'.	filterName = nil ifTrue: [^self].	filterName = '<delete a filter...>' ifTrue: [^ self deleteFilter].	filterName = '<edit exising filter...>'		ifTrue: [filterExpr _ self editFilter]		ifFalse: [			filterName = '<define new filter...>'				ifTrue: [filterExpr _ self defineFilter]				ifFalse: [filterExpr _ CustomFilters at: filterName]].	filterExpr isEmpty ifTrue: [^self].	customFilterBlock _ Compiler evaluate: '[ :m | ', filterExpr, ']'.	self updateTOC.! !!Celeste methodsFor: 'filtering'!defineFilter	| filterName expr |	filterName _ FillInTheBlank request: 'Filter name?'.	filterName isEmpty ifTrue: [^''].	(CustomFilters includesKey: filterName)		ifTrue: [expr _ CustomFilters at: filterName]		ifFalse: [expr _ ''].	^self editFilterNamed: filterName filterExpr: expr! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 08:14'!deleteFilter	| filterList filterName |	CustomFilters isEmpty ifTrue: [^''].	filterList _ CustomFilters keys asOrderedCollection.	filterName _ (CustomMenu selections: filterList)		startUpWithCaption: 'Filter to delete?'.	filterName = nil ifTrue: [^''].	CustomFilters removeKey: filterName ifAbsent: [].! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 08:14'!editFilter	| filterList filterName |	CustomFilters isEmpty ifTrue: [^''].	filterList _ CustomFilters keys asOrderedCollection.	filterName _ (CustomMenu selections: filterList)		startUpWithCaption: 'Filter to edit?'.	filterName = nil ifTrue: [^''].	^self editFilterNamed: filterName filterExpr: (CustomFilters at: filterName)! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/15/1998 06:49'!editFilterNamed: filterName filterExpr: oldExpr	| newDefinition |	newDefinition _ FillInTheBlank		request:'Enter a filter definition where "m" is the message being testing. The expression can send"fromHas:", "toHas:", "ccHas:", "subjectHas:", "participantHas:", or "textHas:" to m to test forinclusion of a string--or one of an array of strings--in a field. It can also test m''s timeand/or date and can combine several tests with logical operators. Examples:      m fromHas: ''johnm''                       -- messages from johnm     m participantHas: ''johnm''                -- messages from, to, or cc-ing johnm     m textHas: #(squeak smalltalk java)      -- messages with any of these words     m subjectHas: #(0 1 2 3 4 5 6 7 8 9)       -- numbers in lists treated as strings NOTE: "textHas:" is very slow, since it must read the message from disk.'		initialAnswer: oldExpr.	newDefinition isEmpty ifTrue: [^''].	CustomFilters at: filterName put: newDefinition.	^newDefinition! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/14/1998 10:38'!filteredMessagesIn: categoryName	| msgList |	msgList _ mailDB messagesIn: categoryName.	(customFilterBlock notNil) ifTrue:		[msgList _ msgList select:			[: id | customFilterBlock value: (mailDB getTOCentry: id) ]].	(fromFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) from includesSubstring: fromFilter caseSensitive: false]].	(subjectFilter size > 0) ifTrue:		[msgList _ msgList select:			[: id | (mailDB getTOCentry: id) subject includesSubstring: subjectFilter caseSensitive: false]].	^msgList! !!Celeste methodsFor: 'filtering'!fromFilterOff	"Cancel from filtering."	fromFilter _ ''.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 12:46'!fromFilterOn	"Show only those messages from the same person as the currently selected message. The user is given a chance to edit the pattern string used to match 'From:' fields."	fromFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) from].	fromFilter _ FillInTheBlank		request: '''From:'' filter pattern?'		initialAnswer: fromFilter.	fromFilter _ self removeTrailingSeparators: fromFilter.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'jm 8/20/1998 12:46'!removeTrailingSeparators: aString	"Answer a new string that is aString with all trailing white space characters removed."	| i |	i _ aString size.	[(i > 0) and: [(aString at: i) isSeparator]] whileTrue: [i _ i - 1].	(i > 1)		ifTrue: [^ aString copyFrom: 1 to: i]		ifFalse: [^ ''].! !!Celeste methodsFor: 'filtering'!subjectFilterOff	"Cancel subject filter."	subjectFilter _ ''.	self updateTOC.! !!Celeste methodsFor: 'filtering' stamp: 'ls 9/12/1998 19:37'!subjectFilterOn	"Show only those messages whose subject matches the currently selected message. The user is given a chance to edit the pattern string used to match 'Subject:' fields."	subjectFilter _		(currentMsgID isNil)			ifTrue: ['']			ifFalse: [(mailDB getTOCentry: currentMsgID) subject].	subjectFilter _ subjectFilter withBlanksTrimmed.	(subjectFilter asLowercase beginsWith: 're:') ifTrue: [		subjectFilter _ subjectFilter copyFrom: 4 to: subjectFilter size.		subjectFilter _ subjectFilter withBlanksTrimmed ].	subjectFilter _ FillInTheBlank		request: '''Subject:'' filter pattern?'		initialAnswer: subjectFilter.	subjectFilter _ self removeTrailingSeparators: subjectFilter.	self updateTOC.! !!Celeste methodsFor: 'message text pane'!changeMessage: newText	"Accept an edited version of a message and store it away. Answer true if successful."	(currentCategory isNil | currentMsgID isNil)		ifTrue: [^false]		ifFalse: [			mailDB newText: newText asString for: currentMsgID.			self updateTOC.			^ true].! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 02:56'!compose	"Make a MailSendTool for composing a new message."	self openSender: self composeText.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/14/1998 22:23'!doItContext	^nil! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/14/1998 22:23'!doItReceiver	^nil! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 11:59'!format	messageTextView		editString: self formatedMessageText;		hasUnacceptedEdits: true.! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 11:25'!formatedMessageText	"Answer a string that is my formatted mail message."	(currentMsgID isNil)		ifTrue: [^'']		ifFalse: [^(mailDB getMessage: currentMsgID) formattedText].! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 02:57'!forward	"Make a MailSendTool for forwarding the current message."	(currentMsgID notNil) ifTrue:		[self openSender: (self forwardTextFor: currentMsgID)].! !!Celeste methodsFor: 'message text pane'!message	"Answer the text of the currently selected message or nil if there isn't one."	(currentMsgID isNil)		ifTrue: [^'']		ifFalse: [^(mailDB getText: currentMsgID) asText]! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 08:14'!messageMenu	"Answer the menu for the message text pane."	(currentMsgID notNil)		ifTrue: [^CustomMenu			labels: 'again\undo\copy\cut\paste\format\accept\cancelcompose\reply\forward' withCRs			lines: #(2 5 6 8)			selections: #(again undo copySelection cut paste format accept cancelcompose reply forward)]		ifFalse: [^SelectionMenu			labels: 'again\undo\copy\cut\paste\compose' withCRs			lines: #(2 5)			selections: #(again undo copySelection cut paste compose)].! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 11:28'!messageMenu: aMenu shifted: shifted	"Use the standard text menu."	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/8/1998 05:12'!messageText	(currentMsgID isNil) ifTrue: [^''].	(SuppressWorthlessHeaderFields and: [FormatWhenFetching not])		ifTrue: [^ self formatedMessageText]		ifFalse: [^ mailDB getText: currentMsgID].! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/20/1998 12:05'!messageText: aStringOrText	currentCategory isNil | currentMsgID isNil ifTrue: [^ self].	mailDB newText: aStringOrText asString for: currentMsgID.	self updateTOC.  "in case the message header was changed"	messageTextView hasUnacceptedEdits: false.	self changed: #messageText.	^ true! !!Celeste methodsFor: 'message text pane' stamp: 'jm 8/14/1998 15:13'!messageTextView: aView	messageTextView _ aView.! !!Celeste methodsFor: 'message text pane' stamp: 'ls 9/13/1998 03:08'!reply	"Make a MailSendTool for replying to the current message."	(currentMsgID notNil) ifTrue:		[self openSender: (self replyTextFor: currentMsgID)].! !!Celeste methodsFor: 'other' stamp: 'ls 9/15/1998 00:56'!checkTrash	"check the .trash. folder, and inform the user if it's getting excessively large"	| numTrash numTotal |	numTrash _ (mailDB messagesIn: '.trash.') size.	numTotal _ (mailDB messagesIn: '.all.') size.	(numTrash > 20 and: [ numTrash > (numTotal / 2)]) ifTrue: [		self inform: 'You have more deleted email than non-deleted.You might consider running "empty trash" and "compact"' ].! !!Celeste methodsFor: 'other' stamp: 'jm 8/14/1998 15:26'!clearUserEditFlag	messageTextView hasUnacceptedEdits: false.! !!Celeste methodsFor: 'other' stamp: 'jm 8/20/1998 08:14'!okToChange	"This message is sent when changing the selection in either the message cateory or message list panes. Eventually, this should ask the user if it is okay to throw away and unaccepted edits of the current message. For now, it always gives permission."	currentCategory isNil | currentMsgID isNil ifTrue: [		"no message selected; discard edits in message pane silently"		messageTextView hasUnacceptedEdits: false.		^ true].	messageTextView hasUnacceptedEdits ifFalse: [^ true].	(CustomMenu confirm: 'Discard changes to currently selected message?')		ifTrue: [messageTextView hasUnacceptedEdits: false. ^ true]		ifFalse: [^ false].! !!Celeste methodsFor: 'other' stamp: 'jm 8/20/1998 11:08'!perform: selector orSendTo: otherTarget	"Celeste handles all menu commands."	selector = #format ifTrue: [^ self perform: selector].	((#(yellowButtonActivity shiftedYellowButtonActivity) includes: selector) or:		[(PluggableTextController yellowButtonMessages includes: selector) or:		[PluggableTextController shiftedYellowButtonMessages includes: selector]])			ifTrue: [otherTarget perform: selector]			ifFalse: [self perform: selector].! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:55'!composeText	"Answer the template for a new message."	^String streamContents: [ :str |		str nextPutAll: 'From: '.		str nextPutAll: Celeste userName.		str cr.		str nextPutAll: 'To: '; cr.		str nextPutAll: 'Subject: '; cr.		Celeste ccList isEmpty ifFalse: [			str nextPutAll: 'Cc: '.			str nextPutAll: Celeste ccList.			str cr ].		str cr. ]! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/18/1998 05:10'!forwardTextFor: msgID	"Answer the template for forwarding the message with the given ID."	^self composeText, '---------- Forwarded ----------',	(mailDB getMessage: msgID) body, '-------------------------------'! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:56'!hasUsername: aString	"Answer true if the given string contains the user's name."	^((aString asLowercase)		findString: (Celeste userName) asLowercase		startingAt: 1) ~= 0! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/16/1998 00:18'!openSender: initialText	"open a message sender with the given initial text"	Smalltalk isMorphic ifTrue: [ ^self openSenderInMorphic: initialText ].	^self openSenderInMVC: initialText! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/16/1998 00:34'!openSenderInMVC: initialText	| topWindow textHolder textView sendButton  |	topWindow _ StandardSystemView new		label: 'Mister Postman';		minimumSize: 400@250.	textHolder _ StringHolder new .	textHolder contents: initialText.	textView _ PluggableTextView		on: textHolder		text: #contents		accept: #acceptContents:.	sendButton _ PluggableButtonView 		on: [			textView hasUnacceptedEdits ifTrue: [ textView controller accept ].			self queueMessageWithText: textHolder contents.			topWindow controller close. ] fixTemps		getState: nil		action: #value.	sendButton label: 'Send'.	sendButton borderWidth: 1.	sendButton window: (1@1 extent: 398@38).	topWindow addSubView: sendButton.	textView window: (0@40 corner: 400@250).	topWindow addSubView: textView below: sendButton.	topWindow controller open.		! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/14/1998 10:57'!openSenderInMorphic: initialText	"open an interface for sending a mail message with the given initial text"	| textHolder win textMorph buttonsList sendButton |	textHolder _ StringHolder new.	textHolder contents: initialText.	win _ SystemWindow labelled: 'Mister Postman'.		textMorph _ PluggableTextMorph on: textHolder text: #contents  accept: #acceptContents:.	win addMorph: textMorph  frame: (0@0.1 corner: 1@1).	buttonsList _ AlignmentMorph newRow.	sendButton _ PluggableButtonMorph on: [			textMorph hasUnacceptedEdits ifTrue: [ textMorph accept ].			self queueMessageWithText: textHolder contents.			win delete. ]		getState: nil		action: #value.	sendButton label: 'send mesage'.	sendButton onColor: Color white  offColor: Color white.	buttonsList addMorphBack: sendButton.		win addMorph: buttonsList  frame: (0@0 extent: 1@0.1).	win openInMVC.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 03:10'!queueMessageWithText: aStringOrText	"queue a message for sending.  Currently, this simply sticks it in .tosend."	"add a x-mailer line"	| messageText id |	messageText _		'X-Mailer: ',		Celeste versionString, 		String cr, 		aStringOrText asString.		"actually queue the message"	id _ mailDB addNewMessage: (MailMessage from: messageText) inCategory: '.tosend.'.	mailDB file: id inCategory: 'sent'.	self changed: #categoryList.	self changed: #tocEntryList.! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/13/1998 06:12'!replyTextFor: msgID	"Answer the template for a reply to the message with the given ID."	| msg s anyCCs |	msg _ mailDB getMessage: msgID.	s _ WriteStream on: (String new: 500).	"add From:"	s nextPutAll: 'From: ', Celeste userName; cr.	"add To:"	s nextPutAll: 'To: ', msg from; cr.	"add CC:s from the message and from the user's CC list"	s nextPutAll: 'CC: '.	anyCCs _ false.	(msg to isEmpty) ifFalse: [		anyCCs ifTrue:[ s nextPutAll: ', '] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg to ].	(msg cc isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].		s nextPutAll: msg cc ].	(Celeste ccList isEmpty) ifFalse: [		anyCCs ifTrue: [ s nextPutAll: ', ' ] ifFalse: [ anyCCs _ true ].			s nextPutAll: Celeste ccList ].	s cr.	"add Subject:"	((msg subject asLowercase indexOfSubCollection: 're:' startingAt: 1) ~= 0)		ifTrue: [s nextPutAll: 'Subject: ', msg subject]		ifFalse: [s nextPutAll: 'Subject: Re: ', msg subject].	s cr.	"add contents of previous message"	s cr.	s nextPutAll: msg from; nextPutAll: ' wrote:'; cr.	msg body linesDo: [ :line |		s nextPutAll: '> '.		s nextPutAll: line.		s cr ].	s cr.	^s contents! !!Celeste methodsFor: 'sending mail' stamp: 'ls 9/18/1998 06:34'!sendQueuedMail	"send queued mail out"	| msgIds msgNum message recipients bareFrom |	"compute the main part of the From: address"	bareFrom _ (MailAddressParser addressesIn: self class userName) first.	"gather up message IDs of messages to send"	msgIds _ mailDB messagesIn: '.tosend.'.	msgIds isEmpty ifTrue: [		^self inform: 'all messages have been sent' ].	msgNum _ 1.	('sending ', msgIds size printString, ' messages...')		displayProgressAt: Sensor mousePoint		from: 0		to: msgIds size		during: 	[ :bar | msgIds do: [ :id |		message _ mailDB getMessage: id.				"gather up the recipients"		recipients _ Set new.		recipients addAll: (MailAddressParser addressesIn: message to).		recipients addAll: (MailAddressParser addressesIn: message cc).		"send it out"		[(SMTPSocket 			deliverMailFrom: bareFrom			to: recipients 			text: message text 			usingServer: Celeste smtpServer) ifFalse: [ self error: 'error delivering mail' ].		] ifError: [ :a :b |			self error: 'error delivering message' ].			"inform the user we are starting a new message"		bar value: msgNum.		msgNum _ msgNum + 1.		].	"remove all these messages from the queue"	msgIds do: [ :id |		mailDB remove: id  fromCategory: '.tosend.' ].	].	mailDB saveDB.	"update any Celeste display windows to account for the changing .tosend. category"	self updateTOC.! !!Celeste class methodsFor: 'class initialization' stamp: 'ls 9/10/1998 23:36'!initialize	"Celeste initialize"	"user preferences"	InOutFolder _ nil.	UserName _ nil.	CCList _ nil.	SuppressWorthlessHeaderFields _ true.	EmailDBName _ 'EMAIL'.		"file to store user's EMAIL in"	QueueDBName _ 'QUEUE'.		"file to store outgoing email in"	"options with no UI; just set their values directly"	FormatWhenFetching _ false.	DeleteInboxAfterFetching _ false.	"dictionary of custom filters"	CustomFilters _ Dictionary new.! !!Celeste class methodsFor: 'class initialization' stamp: 'ls 9/13/1998 02:14'!versionString	"return a short string describing this version of Celeste"	^'Celeste 2.0'! !!Celeste class methodsFor: 'instance creation'!buildButtonsFor: model	"Answer a collection of handy buttons for the Celeste user interface."	| buttonViewClass buttons b |	Smalltalk isMorphic		ifTrue: [buttonViewClass _ PluggableButtonMorph]		ifFalse: [buttonViewClass _ PluggableButtonView].	buttons _ OrderedCollection new.	b _ buttonViewClass on:		(Switch new			onAction: [model subjectFilterOn];			offAction: [model subjectFilterOff]).	b	label: ('Subj. F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass on:		(Switch new			onAction: [model fromFilterOn];			offAction: [model fromFilterOff]).	b	label: ('From F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass on:		(Switch new			onAction: [model customFilterOn];			offAction: [model customFilterOff]).	b	label: ('Custom F.' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model reply]);		action: #turnOn;		label: ('Reply' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model forward]);		action: #turnOn;		label: ('Forward' asParagraph centered);		borderWidth: 1.	buttons add: b.	b _ buttonViewClass new		model: (Button new onAction: [model deleteMessage]);		action: #turnOn;		label: ('Delete' asParagraph centered);		borderWidth: 1.	buttons add: b.	^ buttons! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 9/21/1998 11:06'!buildViewsFor: model	"Answer a collection of window panes for the Celeste user interface."	| listViewClass textViewClass listFont views v |	Smalltalk isMorphic		ifTrue: [			listViewClass _ PluggableListMorphByItem.			textViewClass _ PluggableTextMorph]		ifFalse: [			listViewClass _ PluggableListViewByItem.			textViewClass _ PluggableTextView].	listFont _ StrikeFont allInstances		detect: [:f | (f name beginsWith: 'CourierFixed') and: [f height = 11]]		ifNone: [TextStyle default fontAt: 1].	views _ OrderedCollection new.	v _ listViewClass		on: model		list: #categoryList		selected: #category		changeSelected: #setCategory:		menu: #categoryMenu:		keystroke: #categoriesKeystroke:.	views add: v.	v _ listViewClass		on: model		list: #tocEntryList		selected: #tocEntry		changeSelected: #setTOCEntry:		menu: #tocMenu:		keystroke: #tocKeystroke:.	v font: listFont.	views add: v.	v _ textViewClass new		on: model		text: #messageText		accept: #messageText:		readSelection: nil		menu: #messageMenu:shifted:.	v borderWidth: 1.	model messageTextView: v.	views add: v.	^ views! !!Celeste class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 03:05'!openOn: rootFilename	"Open a MailReader on the mail database with the given root filename."	|database |	database _  MailDB openOn: rootFilename.	database ifNotNil: [ ^ self openOnDatabase: database ].! !!Celeste class methodsFor: 'instance creation' stamp: 'jm 9/21/1998 10:46'!openOnDatabase: aMailDB	"Open a MailReader on the given mail database."	| model views buttons topWindow |	model _ self new openOnDatabase: aMailDB.	views _ self buildViewsFor: model.	buttons _ self buildButtonsFor: model.	Smalltalk isMorphic		ifTrue: [			topWindow _ (SystemWindow labelled: 'Celeste') model: model.			topWindow addMorph: (buttons at: 1) frame: (0.0@0.0 extent: 0.16@0.05).			topWindow addMorph: (buttons at: 2) frame: (0.16@0.0 extent: 0.17@0.05).			topWindow addMorph: (buttons at: 3) frame: (0.33@0.0 extent: 0.17@0.05).			topWindow addMorph: (buttons at: 4) frame: (0.50@0.0 extent: 0.16@0.05).			topWindow addMorph: (buttons at: 5) frame: (0.66@0.0 extent: 0.17@0.05).			topWindow addMorph: (buttons at: 6) frame: (0.83@0.0 extent: 0.17@0.05).			topWindow addMorph: (views at: 1) frame: (0.0@0.05 extent: 0.2@0.25).			topWindow addMorph: (views at: 2) frame: (0.2@0.05 extent: 0.8@0.25).			topWindow addMorph: (views at: 3) frame: (0.0@0.30 extent: 1.0@0.70).			buttons do: [:b | b onColor: Color lightGray offColor: Color white].			topWindow openInWorld]		ifFalse: [			topWindow _ StandardSystemView new				model: model;				label: 'Celeste';				minimumSize: 400@250.			(views at: 1) window: (0@0 extent: 20@25).			(views at: 2) window: (0@0 extent: 80@25).			(views at: 3) window: (0@0 extent: 100@70).			(buttons at: 1) window: (0@0 extent: 17@5).			(buttons at: 2) window: (0@0 extent: 17@5).			(buttons at: 3) window: (0@0 extent: 16@5).			(buttons at: 4) window: (0@0 extent: 17@5).			(buttons at: 5) window: (0@0 extent: 17@5).			(buttons at: 6) window: (0@0 extent: 16@5).			topWindow				addSubView: (buttons at: 1);				addSubView: (buttons at: 2) toRightOf: (buttons at: 1);				addSubView: (buttons at: 3) toRightOf: (buttons at: 2);				addSubView: (buttons at: 4) toRightOf: (buttons at: 3);				addSubView: (buttons at: 5) toRightOf: (buttons at: 4);				addSubView: (buttons at: 6) toRightOf: (buttons at: 5);				addSubView: (views at: 1) below: (buttons at: 1);				addSubView: (views at: 2) toRightOf: (views at: 1);				addSubView: (views at: 3) below: (views at: 1).			topWindow controller open].! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:46'!ccList	"Answer the default cc list to be used in composing messages."	CCList isNil ifTrue: [CCList _ ''].	^CCList! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:52'!inOutFolder	"Answer the folder for the inbox/outbox files."	self halt: 'someone asked for InOutFolder'.	InOutFolder isNil ifTrue: [self setInOutFolder].	^InOutFolder! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:51'!popPassword	"answer the password to use when retrieving mail via POP"	"theoretically, this could remember the password for a little while.  But let's keep it simple for now"	^FillInTheBlank request: 'POP password'! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:51'!popServer	"Answer the server for downloading email via POP"	(PopServer isNil or: [PopServer isEmpty])		ifTrue: [self setPopServer].	PopServer isEmpty ifTrue: [		self error: 'POP server not specified' ].	^PopServer! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:51'!popUserName	"Answer the user's username on the POP server"	(PopUserName isNil or: [PopUserName isEmpty])		ifTrue: [self setPopUserName].	PopUserName isEmpty ifTrue: [ 		self error: 'no POP user name specified' ].	^PopUserName! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:46'!setCCList	"Change the list of names used in the default cc list. Items in the list should be valid mail addresses and should be separated by commas."	| newList |	(CCList isNil) ifTrue: [CCList _ ''].	newList _ FillInTheBlank		request: 'addresses to automatically add to CC: fields?'		initialAnswer: CCList.	CCList _ newList.! !!Celeste class methodsFor: 'user preferences'!setInOutFolder	"Change the folder used to store the inbox and outbox files."	(InOutFolder isNil) ifTrue: [InOutFolder _ ''].	InOutFolder _ FillInTheBlank		request: 'Where are the inbox and outbox files kept?'		initialAnswer: InOutFolder.	((InOutFolder size > 0) and:	 [(InOutFolder last = $:) or: [InOutFolder last = $/]]) ifTrue: [		"remove folder or directory delimitor"		InOutFolder _ InOutFolder copyFrom: 1 to: InOutFolder size - 1.	].! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setPopServer	"Change the user's email name for use in composing messages."	(PopServer isNil) ifTrue: [PopServer _ ''].	PopServer _ FillInTheBlank		request: 'What is your POP server''s hostname?'		initialAnswer: PopServer.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setPopUserName	"set the POP server used for downloading email"	(PopUserName isNil) ifTrue: [PopUserName _ ''].	PopUserName _ FillInTheBlank		request: 'What is your username on your POP server?'		initialAnswer: PopUserName.	"be kind, if they include the host name here"	(PopUserName includes: $@) ifTrue: [		PopUserName _ PopUserName copyFrom: 1 to: (PopUserName indexOf: $@)-1 ].! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:48'!setSmtpServer	"Set the SMTP server used to send outgoing messages via"	(SmtpServer isNil) ifTrue: [		PopServer isNil			ifTrue: [ SmtpServer _ '' ]			ifFalse: [ SmtpServer _ PopServer ] ].	SmtpServer _ FillInTheBlank		request: 'What is your mail server for outgoing mail?'		initialAnswer: SmtpServer.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:49'!setUserName	"Change the user's email name for use in composing messages."	(UserName isNil) ifTrue: [UserName _ ''].	UserName _ FillInTheBlank		request: 'What is your email address?\(This is the address other people will reply to you)' withCRs		initialAnswer: UserName.! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:50'!smtpServer	"Answer the server for sending email"	(SmtpServer isNil or: [SmtpServer isEmpty])		ifTrue: [self setSmtpServer].	SmtpServer isEmpty ifTrue: [		self error: 'no SMTP server specified' ].	^SmtpServer! !!Celeste class methodsFor: 'user preferences' stamp: 'ls 9/17/1998 05:50'!userName	"Answer the user name to be used in composing messages."	(UserName isNil or: [UserName isEmpty])		ifTrue: [self setUserName].	UserName isEmpty ifTrue: [ self error: 'no user name specified' ].	^UserName! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/20/1998 11:48'!addMVCMailSenderButtons: topView textView: mailTextView	"Add some handy buttons to the mail sender window."	| sendButton sendAndKeepButton doneButton |	sendButton _		PluggableButtonView new			model: (Button new onAction:					[mailTextView controller accept.					 mailTextView controller controlTerminate.					 Celeste postMessage: mailTextView model contents]);			action: #turnOn;			label: ('Send' asParagraph centered);			window: (0@0 extent: 34@10);			borderWidth: 1.	sendAndKeepButton _		PluggableButtonView new			model: (Button new onAction:					[mailTextView controller accept.					 mailTextView controller controlTerminate.					 Celeste postMessage: mailTextView model contents.					 Celeste addMessageToInbox: mailTextView model contents]);			action: #turnOn;			label: ('Send&Keep' asParagraph centered);			window: (0@0 extent: 33@10);			borderWidth: 1.	doneButton _		PluggableButtonView new			model: (Button new onAction: [topView controller close]);			action: #turnOn;			label: ('Done' asParagraph centered);			window: (0@0 extent: 33@10);			borderWidth: 1.	topView		addSubView: sendButton above: topView firstSubView;		addSubView: sendAndKeepButton toRightOf: sendButton;		addSubView: doneButton toRightOf: sendAndKeepButton.! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/18/1998 15:50'!addMessageToInbox: msgString	"Append a copy of the given message to the inbox file."	| mailBox |	mailBox _ FileStream fileNamed: Celeste inOutFolder, ':inbox'.	mailBox setToEnd.	"append this message to inbox"	mailBox nextPutAll: 'From local Sun 1990' ; cr.	mailBox nextPutAll: 'Date: ', Date today printString, ' ', Time now printString; cr.	mailBox nextPutAll: msgString; cr.	mailBox close.! !!Celeste class methodsFor: 'sending'!eudoraSeparator	"Return a Eudora-style message separator string."	| s today dateString |	s _ WriteStream on: (String new: 50).	today _ Date today.	dateString _ today printFormat: #(2 1 3 32 2 1).	dateString _ dateString copyFrom: 1 to: dateString size - 4.	s nextPutAll: 'From ???@??? '.	s nextPutAll: (today weekday copyFrom: 1 to: 3); space.	s nextPutAll: dateString.	Time now print24: true on: s.	s space.	s print: today year; cr.	^s contents! !!Celeste class methodsFor: 'sending' stamp: 'jm 8/18/1998 15:50'!postToEudoraOutbox: msgString	"Append the given message to a Eudora outbox."	| mailBox |	mailBox _ FileStream fileNamed: self inOutFolder, ':outbox'.	mailBox setToEnd.	mailBox nextPutAll: self eudoraSeparator.	mailBox nextPutAll: (MailMessage from: msgString) eudoraOutboxText.	mailBox cr.	mailBox close.! !!Celeste class methodsFor: 'sending'!postToUnixOutbox: msgString	"Append the given message to a Unix shell-script outbox."	| mailBox |	mailBox _ FileStream fileNamed: self inOutFolder, ':outbox'.	mailBox setToEnd.	"append this message to outbox"	mailBox nextPutAll: 'cat - >outgoingMsg <<\endmsg'; cr.	mailBox nextPutAll: msgString; cr.	mailBox nextPutAll: 'endmsg'; cr.	mailBox nextPutAll: '/usr/lib/sendmail -v -t <outgoingMsg'; cr.	mailBox close.! !!ChangeList methodsFor: 'scanning' stamp: 'sw 9/10/1998 15:17'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		stamp _ ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens _ Scanner new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ prevPos // 16r1000000.						prevPos _ prevPos \\ 16r1000000]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos _ tokens at: tokens size-2.						prevFileIndex _ tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size]]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue:			[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!ChangeList class methodsFor: 'public access' stamp: 'di 6/12/1998 16:33'!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !!ChangeList class methodsFor: 'public access' stamp: 'sw 9/10/1998 15:17'!browseVersionsOf: method class: class meta: meta		category: category selector: selector 	| changeList |	Cursor read showWhile:		[changeList _ self new			scanVersionsOf: method class: class meta: meta			category: category selector: selector].	changeList		ifNil:			[self inform: 'No versions available']		ifNotNil:			[self open: changeList name: 'Recent versions of ' , selector multiSelect: false]! !!ChangeList class methodsFor: 'public access' stamp: 'sw 9/10/1998 15:18'!browseVersionsOf: method class: class meta: meta		category: category selector: selector lostMethodPointer: sourcePointer	| changeList |	Cursor read showWhile:		[changeList _ self new			scanVersionsOf: method class: class meta: meta			category: category selector: selector].	changeList		ifNil:			[self inform: 'No versions available']		ifNotNil:			[changeList setLostMethodPointer: sourcePointer.			self open: changeList name: 'Recent versions of ' , selector multiSelect: false]! !!ChangeList class methodsFor: 'public access' stamp: 'sw 9/10/1998 15:39'!versionCountForSelector: aSelector class: aClass	"Answer the number of versions known to the system for the given class and method, including the current version.  A result of greater than one means that there is at least one superseded version.  6/28/96 sw"		| method aChangeList |	method _ aClass compiledMethodAt: aSelector.	aChangeList _ self new			scanVersionsOf: method class: aClass meta: aClass isMeta			category: nil selector: aSelector.	^ aChangeList ifNil: [0] ifNotNil: [aChangeList list size]! !!ChangeList class methodsFor: 'instance creation' stamp: 'di 6/22/1998 21:40'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window listView |	window _ (SystemWindow labelled: labelString) model: aChangeList.	window addMorph: (listView _ PluggableListMorph on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: #changeListMenu: keystroke: #messageListKey:from:)		frame: (0@0 corner: 1@0.3)."	multiSelect ifTrue: [listView controller: PluggableListControllerOfMany new]."	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window openInWorld! !!ChangeRecord methodsFor: 'access' stamp: 'sw 8/24/1998 08:16'!fileIn	| methodClass |	Cursor read showWhile:		[(methodClass _ self methodClass) notNil ifTrue:			[methodClass compile: self text classified: category withStamp: stamp notifying: nil].		(type == #doIt) ifTrue:			[Compiler evaluate: self string].		(type == #classComment) ifTrue:			[(Smalltalk at: class asSymbol) comment: self text stamp: stamp]]! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemove	^ self okayToRemoveInforming: true! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName _ self name.	self == Smalltalk changes ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/17/1998 16:05'!expungeEmptyClassChangeEntries	| toRemove |	toRemove _ OrderedCollection new.	classChanges associationsDo:		[:assoc | assoc value isEmpty ifTrue:			[toRemove add: assoc key]]. 	toRemove do:		[:aKey | classChanges removeKey: aKey ifAbsent: []]! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/17/1998 14:36'!forgetAllChangesFoundIn: aChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner.	sw 8/14/1998 17:30:  This method somehow became very badly, and damagingly, broken since I originally wrote it.  Below is an attempt to bring it back to health, or at least to remove the most damaging of its bugs."	| cls itsMethodChanges myClassChange |	aChangeSet == self ifTrue: [^ self].	aChangeSet changedClassNames do: 		[:className |			(cls _ Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges _ aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo:					[:assoc | self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange _ self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]]]].	classRemoves removeAllFoundIn: aChangeSet classRemoves.	"names of them"	self expungeEmptyClassChangeEntries! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/14/1998 17:22'!removeAllMemoryOfChangesTo: class	"Remove all memory of changes associated with this class"	classChanges removeKey: class name ifAbsent: [].	methodChanges removeKey: class name ifAbsent: [].	classRemoves remove: class name ifAbsent: [].! !!ChangeSet methodsFor: 'change management' stamp: 'sw 8/22/1998 21:12'!removeAllMemoryOfChangesToClassNamed: className	"Remove all memory of changes associated with this class"	classChanges removeKey: className ifAbsent: [].	methodChanges removeKey: className ifAbsent: [].	classRemoves remove: className ifAbsent: [].! !!ChangeSet methodsFor: 'change management' stamp: 'ls 8/12/1998 23:47'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	classChanges removeKey:  cname ifAbsent: [].	methodChanges removeKey:  cname ifAbsent: [].	classRemoves remove:  cname ifAbsent: [].! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 8/14/1998 17:16'!forgetChange: actionToSubtract forSelector: selector class: class 	"If the receiver records a change that can be subsumed by the change given by the parameters, which characterize a change in another change set which is being 'subtracted' from the receiver, remove it from the receiver."	| myChangeDictionaryForClass methodCurrentlyExists |	myChangeDictionaryForClass _ methodChanges at: class name ifAbsent: [^ self].	methodCurrentlyExists _ class includesSelector: selector.	((#(add change) includes: actionToSubtract) and: [methodCurrentlyExists])		ifTrue:			[myChangeDictionaryForClass removeKey: selector ifAbsent: []].	((#(remove addedThenRemoved) includes: actionToSubtract) and: [methodCurrentlyExists not])			ifTrue:				[myChangeDictionaryForClass removeKey: selector ifAbsent: []].	myChangeDictionaryForClass isEmpty ifTrue: [methodChanges removeKey: class name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/11/1998 16:13'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 8/10/1998 07:13'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips changes method |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		changes _ methodChanges at: aClass name ifAbsent: [nil].		changes ifNotNil:			[changes associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[method hasReportableSlip							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].	^ slips! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 9/15/1998 16:52'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and of the date and the time."	"wod 5/12/1998: use #asFileName rather than #truncateTo:"	| file slips |	Cursor write showWhile:		[file _ FileStream newFileNamed:			(self name, FileDirectory dot, Utilities dateTimeSuffix, FileDirectory dot, 'cs') asFileName.		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close].	Preferences suppressCheckForSlips ifTrue: [^ self].	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 9/10/1998 12:37'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: Preferences defaultAuthorName.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"Smalltalk changes preambleTemplate"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/16/1998 09:36'!summaryString	"Answer the string summarizing this changeSet"	| ps s2 date author line |	^ String streamContents:		[:s |		s nextPutAll: self name.		(ps _ self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 _ ReadStream on: ps.			s2 match: 'Date:		'.  date _ s2 upTo: Character cr.			s2 match: 'Author:			'.  author _ s2 upTo: Character cr.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line _ s2 upTo: Character cr.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]]."To summarize all changeSets in this image...(FileStream newFileNamed: 'ChangeSummaries.txt') nextPutAll:(String streamContents:	[:s | ChangeSorter gatherChangeSets do:		[:cs | s nextPutAll: cs summaryString; cr]])"! !!ChangeSet methodsFor: 'private' stamp: 'sw 9/2/1998 14:24'!fileOutClassModifications: class on: stream 	"Write out class mod-- rename, comment, reorg, remove, on the given stream.  Differs from the superseded fileOutClassChanges:on: in that it does not deal with class definitions, and does not file out entire added classes."	| aClass |	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	(self atClass: class includes: #comment) ifTrue:		[(aClass _ class theNonMetaClass) organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: aClass].	(self atClass: class includes: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'accessing' stamp: 'di 5/25/1998 14:24'!editPostscript	"edit the receiver's postscript, in a separate window.  "	self assurePostscriptExists.	postscript openLabel: 'Postscript for ChangeSet named ', name! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 12:43'!oldOpenAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| buttonView col aListMorph |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	buttonView _ PluggableButtonMorph		on: self		getState: #mainButtonState		action: #changeSetMenuStart		label: #mainButtonName		menu: #changeSetMenu:.	col _ Color perform: self defaultBackgroundColor.	buttonView		label: myChangeSet name; 		onColor: col offColor: col;		triggerOnMouseDown: true; borderColor: window color.	window addMorph: buttonView		frame: (((0@0 extent: 1.0@0.06) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:)		frame: (((0@0.06 extent: 0.5@0.3) scaleBy: rect extent) translateBy: rect origin).	aListMorph _ PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (((0.5@0.06 extent: 0.5@0.3) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.36 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'tk 6/8/1998 17:35'!oldOpenView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView buttonView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	buttonView _ PluggableButtonView		on: self		getState: #mainButtonState		action: #changeSetMenuStart		label: #mainButtonName		menu: #changeSetMenu:.	buttonView		label: myChangeSet name;		triggerOnMouseDown: true; borderWidth: 1; 		window: ((0 @ 0 extent: 360 @ 20) translateBy: offset).	topView addSubView: buttonView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:.	classView window: (0 @ 0 extent: 180 @ 160).	topView addSubView: classView below: buttonView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView window: (0 @ 0 extent: 180 @ 160).	topView addSubView: messageView toRightOf: classView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: classView.! !!ChangeSorter methodsFor: 'creation' stamp: 'jm 7/5/1998 12:35'!openAsMorph	"ChangeSorter new openAsMorph"	|  window |	myChangeSet ifNil: [self myChangeSet: Smalltalk changes]. 	window _ (SystemWindow labelled: self labelString) model: self.	self openAsMorphIn: window rect: (0@0 extent: 1@1).	window openInWorld.! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 16:48'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| chgSetList aListMorph |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (chgSetList _ PluggableListMorphByItem on: self			list: #changeSetList			selected: #currentCngSet			changeSelected: #showChangeSetNamed:			menu: #changeSetMenu:)		frame: (((0@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	chgSetList autoDeselect: false.	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:)		frame: (((0.5@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	aListMorph _ PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph  menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (((0@0.25 extent: 1@0.25) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.5 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 8/18/1998 12:18'!openView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView cngSetListView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	cngSetListView _ PluggableListViewByItem on: self		list: #changeSetList		selected: #currentCngSet		changeSelected: #showChangeSetNamed:		menu: #changeSetMenu:.	cngSetListView window: ((0 @ 0 extent: 180 @ 100) translateBy: offset).	topView addSubView: cngSetListView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:.	classView window: (180 @ 0 extent: 180 @ 100).	topView addSubView: classView toRightOf: cngSetListView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView menuTitleSelector: #messageListSelectorTitle.	messageView window: (0 @ 100 extent: 360 @ 100).	topView addSubView: messageView below: cngSetListView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: messageView.! !!ChangeSorter methodsFor: 'access' stamp: 'di 6/15/1998 20:33'!modelWakeUp	"A window with me as model is being entered.  Make sure I am up-to-date with the changeSets."	self canDiscardEdits ifTrue: [self update]! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 08:15'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self setContents.	self changed: #contents.! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 07:38'!showChangeSetNamed: aName	aName ifNil: [^ self showChangeSet: nil].	self showChangeSet: 		(AllChangeSets detect: [:each | each name = aName]) ! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/12/1998 16:29'!changeSetList	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	^ AllChangeSets reversed collect: [:each | each name]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/17/1998 17:57'!chooseCngSet	"Put up a list of them"	| index |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	index _ (PopUpMenu labels: 		(AllChangeSets reversed collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (AllChangeSets at: (AllChangeSets size - index + 1))].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/5/1998 06:47'!currentCngSet	^ myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 9/4/1998 09:00'!newSet	"Create a new changeSet and show it., making it the current one.  Reject name if already in use."	| aSet |	self okToChange ifFalse: [^ self].	aSet _ self class newChangeSet.	aSet ifNotNil:		[self update.		self showChangeSet: aSet.		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 12:00'!remove	"Completely destroy my change set.  Check if it's OK first"	self okToChange ifFalse: [^ self].	self removePrompting: true.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 11:58'!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName _ FillInTheBlank request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size == 0]) ifTrue:			[^ self inform: 'No change made'].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	self update.	self changed: #mainButtonName.	self changed: #relabel.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:02'!update	"recompute all of my panes"	self updateIfNecessary.	parent ifNotNil: [(parent other: self) updateIfNecessary]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:19'!updateIfNecessary	"recompute all of my panes"	| newList |	self okToChange ifFalse: [^ self].	priorChangeSetList == nil		ifTrue: [priorChangeSetList _ self changeSetList.				self changed: #changeSetList]		ifFalse: [newList _ self changeSetList.				priorChangeSetList = newList ifFalse:					[priorChangeSetList _ newList.					self changed: #changeSetList]].	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 9/11/1998 16:07'!classMenu: aMenu	"Could be for a single or double changeSorter"	^ parent ifNotNil:		[aMenu labels: 'copy class chgs to other sidemove class chgs to other sidedelete class chgs from this change setbrowse fullinst var refs...inst var defs...class var refs...class variablesclass refs'		lines: #(3 4 )		selections: #(copyClassToOther moveClassToOther forgetClass browseMethodFull browseInstVarRefs browseInstVarDefs browseClassVarRefs browseClassVariables browseClassRefs)]	ifNil:		[ aMenu labels: 'delete class chgs from this change setbrowse fullinst var refs...inst var defs...class var refs...class variablesclass refs'		lines: #(1 2 )		selections: #(forgetClass browseMethodFull browseInstVarRefs browseInstVarDefs browseClassVarRefs browseClassVariables browseClassRefs)]! !!ChangeSorter methodsFor: 'class list' stamp: 'ls 8/12/1998 23:47'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: currentClassName.		currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 9/11/1998 16:17'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	| info cls otherSorter otherChangeSet |	self okToChange ifFalse: [^ self beep].	currentClassName ifNil: [^ self beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet == myChangeSet ifTrue: [^ self beep].	(myChangeSet classRemoves includes: currentClassName)		ifTrue:			[otherChangeSet noteRemovalOf: currentClassName]		ifFalse:			[info _ myChangeSet classChangeAt: (cls _ self selectedClassOrMetaClass) name.			info do: [:each | otherChangeSet atClass: cls add: each].			info _ myChangeSet methodChanges at: cls name ifAbsent: [Dictionary new].			info associationsDo: [:ass |				otherChangeSet atSelector: ass key class: cls put: ass value]].	otherSorter showChangeSet: otherChangeSet.	self forgetClass! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/22/1998 02:08'!forget	"Drop this method from the changeSet"	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 9/11/1998 15:57'!messageMenu: aMenu shifted: shifted	"Could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	parent ifNotNil:		[^ aMenu labels: 'copy method to other sidemove method to other sidedelete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(2 4 7 11)		selections: #(copyMethodToOther moveMethodToOtherforget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]	ifNil: [^ aMenu labels: 'delete method from change setremove method from systembrowse fullfileOutprintOutsenders of...implementors of...method inheritanceversionsmore...'		lines: #(2 5 9 )		selections: #( forget removeMessagebrowseMethodFull fileOutMessage printOutMessagebrowseSendersOfMessages browseMessages methodHierarchy browseVersions shiftedYellowButtonActivity )]! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 9/11/1998 15:56'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other info cls sel |	self okToChange ifFalse: [^ self beep].	currentSelector ifNotNil:		[other _ (parent other: self) changeSet.		other == myChangeSet ifTrue: [^ self beep].		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		info _ myChangeSet methodChanges at: cls name ifAbsent: [Dictionary new].		other atSelector: sel			class: cls 			put: (info at: sel).			(parent other: self) showChangeSet: other.		self forget "removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/21/1998 23:13'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	currentSelector _ nil.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/17/1998 11:44'!shiftedMessageMenu: aMenu	^ aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionrevert and forgetmore...' 	lines: #(5 7 9)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion revertAndForget		unshiftedYellowButtonActivity)! !!ChangeSorter methodsFor: 'code pane' stamp: 'di 9/21/1998 23:57'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ ''].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			Preferences browseWithPrettyPrint ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do: [:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Entire class was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr]].			^ contents _ strm contents].! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 9/4/1998 14:38'!newChangeSet	"Prompt the user for a name, and establish a new change set of that name (if ok), making it the current changeset.  Return nil of not ok, else return the actual changeset."	| newName newSet |	newName _ FillInTheBlank request: 'Please name the new change set:'			initialAnswer: ChangeSet defaultName.	newName isEmpty ifTrue:		[self inform: 'nothing done'.		^ nil].	(self changeSetNamed: newName) ifNotNil:			[self inform: 'Sorry that name is already used'.			^ nil].	newSet _ ChangeSet new initialize name: newName.	AllChangeSets add: newSet.	Smalltalk newChanges: newSet.	Transcript cr; show: newName, ' is now the current change set'.	^ newSet! !!ChangeSorter class methodsFor: 'all' stamp: 'sw 8/3/1998 16:26'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed, and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| aCount |	aCount _ 0.	AllChangeSets copy do:		[:aChangeSet | ((aChangeSet name beginsWith: 'Unnamed') and:			[(aChangeSet okayToRemoveInforming: false) and: [aChangeSet isEmpty]])				ifTrue:					[aCount _ aCount + 1.					AllChangeSets remove: aChangeSet.					aChangeSet wither]].	self inform: aCount printString, ' change set(s) removed.'! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 17:42'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message list is the list of methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic.  "	| messageSet |	messageSet _ aChangeSet changedMessageListAugmented.	self openMessageList: messageSet name: ('Methods in Change Set ', aChangeSet name) autoSelect: nil changeSet: aChangeSet! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 17:42'!openMessageList: messageList name: labelString autoSelect: autoSelectString changeSet: aChangeSet	| messageSet |	messageSet _ self messageList: messageList.	messageSet changeSet: aChangeSet.	messageSet autoSelectString: autoSelectString.	World		ifNotNil:			[self openAsMorph: messageSet name: labelString]		ifNil:			[ScheduledControllers scheduleActive:  (self open: messageSet name: labelString)]! !!Character methodsFor: 'testing' stamp: 'ls 7/26/1998 20:27'!isSafeForHTTP	"whether a character is 'safe', or needs to be escaped when used, eg, in a URL"	^self isAlphaNumeric or: [ '.~-_' includes: self ]! !!Character methodsFor: 'converting' stamp: 'ls 9/5/1998 01:18'!asIRCLowercase	"convert to lowercase, using IRC's rules"	self == $[ ifTrue: [ ^ ${ ].	self == $] ifTrue: [ ^ $} ].	self == $\ ifTrue: [ ^ $| ].	^self asLowercase! !!Character class methodsFor: 'instance creation' stamp: 'ls 8/15/1998 06:56'!allCharacters	^ (0 to: 255)		collect: [:v | Character value: v]	! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/8/1998 22:15'!lf	"Answer the Character representing a linefeed."	^self value: 10! !!Character class methodsFor: 'accessing untypeable characters' stamp: 'ls 9/14/1998 22:08'!nbsp	"non-breakable space.  It looks like a space, but it's not considered a separator"	#xxx. "the correct code for ISO 8859-1 is 160.  However, Squeak's character 160 doesn't look right.  If you value absolute correctness over looks, then change this back"	"Character value: 160"	^Character value: 0! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 18:55'!indentationLevel	"return the number of tabs that are currently being placed at the beginning of each line"	^indentationLevel isNil ifTrue: [ 0 ] ifFalse: [ indentationLevel ]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 18:54'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel _ anInteger! !!CharacterScanner methodsFor: 'scanning' stamp: 'di 7/1/1998 14:55'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	destX _ destX + (width _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + width) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	self setFont.  "Force recalculation of emphasis fo rnext run"	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'ls 6/22/1998 19:45'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta displaying: display 	"This method will perform text scanning with non-zero kerning.	It calls the faster primitive method, if the kern delta is zero.	Some day we may want to put kerning into the primitive."	| ascii nextDestX maxAscii fillBlt |	line first = startIndex ifTrue: [		"handle indentation"		self indentationLevel timesRepeat: [ self tab ] ].		kernDelta = 0 ifTrue:		[^ self scanCharactersFrom: startIndex to: stopIndex in: sourceString				rightX: rightX stopConditions: stops displaying: display].	display ifTrue: [fillBlt _ self fillBlt].	maxAscii _ xTable size-2.	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[ascii _ (sourceString at: lastIndex) asciiValue.			ascii > maxAscii ifTrue: [ascii _ maxAscii].			(stopConditions at: ascii + 1) == nil				ifFalse: [^stops at: ascii + 1].			sourceX _ xTable at: ascii + 1.			nextDestX _ destX + (width _ (xTable at: ascii + 2) - sourceX).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			display ifTrue:				[self copyBits				fillBlt == nil ifFalse:					[fillBlt destX: nextDestX destY: destY							width: kernDelta height: height;							copyBits]].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'private' stamp: 'ls 7/16/1998 01:39'!setFont	"Set the font and other emphasis."	self setFont: 1.	emphasisCode _ 0.	kern _ 0.	indentationLevel _ 0.	alignment _ textStyle alignment.	(text attributesAt: lastIndex) do: 		[:att | att emphasizeScanner: self].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space. 	sourceForm _ font glyphs.  "Should only be needed in DisplayScanner"	height _ font height.			" ditto "	xTable _ font xTable.	stopConditions _ font stopConditions.	stopConditions at: Space asciiValue + 1 put: #space.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX! !A set of characters.  Lookups for inclusion are very fast.!!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:33'!add: aCharacter	map at: aCharacter asciiValue+1  put: 1.! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:41'!do: aBlock	"evaluate aBlock with each character in the set"	Character allCharacters do: [ :c |		(self includes: c) ifTrue: [ aBlock value: c ] ]! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:31'!includes: aCharacter	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:34'!remove: aCharacter	map at: aCharacter asciiValue + 1  put: 0! !!CharacterSet methodsFor: 'conversion' stamp: 'ls 8/17/1998 20:39'!complement	"return a character set containing precisely the characters the receiver does not"	| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!= anObject	^self class == anObject class and: [		self byteArrayMap = anObject byteArrayMap ]! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!hash	^self byteArrayMap hash! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:35'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^map! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:30'!initialize	map _ ByteArray new: 256 withAll: 0.! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:42'!allCharacters	"return a set containing all characters"	| set |	set _ self empty.	0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].	^set! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:36'!empty 	"return an empty set of characters"	^super new initialize! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:31'!new	^super new initialize! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!nonSeparators	"return a set containing everything but the whitespace characters"	^self separators complement! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!separators	"return a set containing just the whitespace characters"	| set |	set _ self empty.	set addAll: Character separators.	^set! !!Class methodsFor: 'initialize-release' stamp: 'sw 8/11/1998 13:23'!removeFromSystemUnlogged	"Forget the receiver from the Smalltalk global dictionary. Any existing instances will refer to an obsolete version of the receiver.  Do not log the removal either to the current change set nor to the system changes log"	Smalltalk removeClassFromSystemUnlogged: self.	self obsolete! !!Class methodsFor: 'initialize-release' stamp: 'tk 8/21/1998 09:53'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver and redefine its subclasses if necessary."	super		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	self ~~ oldClass		ifTrue: 			[environ at: name put: self.			oldClass obsolete]! !!ClassDescription methodsFor: 'initialize-release' stamp: 'tk 8/21/1998 10:01'!validateFrom: oldClass in: environ instanceVariableNames: invalidFields methods: invalidMethods wasPresent: wasPresent	"Recompile the receiver, a class, and redefine its subclasses if necessary.	The parameter invalidFields is no longer really used"	| newSub invalidSubMethods |	oldClass becomeUncompact.  "Its about to be abandoned"	invalidMethods & self hasMethods		ifTrue: 			[Transcript show: 'recompiling ' , self name , '...'.			self compileAllFrom: oldClass.			Transcript show: ' done'; cr].	invalidSubMethods _ invalidMethods | (self instSize ~= oldClass instSize).	self == oldClass		ifTrue: [invalidSubMethods ifFalse: [^self]]		ifFalse: [wasPresent ifTrue: [self updateInstancesFrom: oldClass]].	oldClass subclasses do: 		[:sub | 		newSub _ sub copyForValidation.		newSub			subclassOf: self			oldClass: sub			instanceVariableNames: sub instVarNames			variable: sub isVariable			words: sub isBytes not			pointers: sub isBits not			ifBad: [self error: 'terrible problem in recompiling subclasses!!'].		newSub			validateFrom: sub			in: environ			instanceVariableNames: invalidFields			methods: invalidSubMethods			wasPresent: true]	"if false, no subclasses, does not get here"! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 9/2/1998 14:28'!comment	"Answer the receiver's comment. (If old format, not a Text, unpack the old way.) "	| aString |	aString _ self theNonMetaClass organization classComment.	(aString asString beginsWith: self name, ' comment:\''' withCRs) 		ifFalse: [^ aString]		ifTrue: ["old format"			aString size = 0 ifTrue: [^ ''].			"get string only of classComment, undoubling quotes"			^ String readFromString: aString]! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 9/8/1998 14:43'!comment: aStringOrText stamp: aStamp	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText stamp: aStamp.	Smalltalk changes commentClass: self theNonMetaClass! !!ClassDescription methodsFor: 'copying' stamp: 'sw 6/16/1998 15:01'!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver"	methodDict _ donorClass copyOfMethodDictionary.	organization _ donorClass organization deepCopy! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 08:40'!renameInstVar: oldName to: newName	(self confirm: 'WARNING: Renaming of instance variablesis subject to substitution ambiguities.Do you still wish to attempt it?') ifFalse: [self halt].	"...In other words, this does a dumb text search-and-replace,	which might improperly alter, eg, a literal string.  As long as	the oldName is unique, everything should work jes' fine. - di"	^ self renameSilentlyInstVar: oldName to: newName! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 15:30'!renameSilentlyInstVar: oldName to: newName	| i oldCode newCode parser header body sels |	(i _ instanceVariables indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	instanceVariables replaceFrom: i to: i with: (Array with: newName).	self withAllSubclasses do:		[:cls | sels _ cls selectors.		sels removeAllFoundIn: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode _ cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser _ cls parserClass new) parseSelector: oldCode.			header _ oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body _ header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode _ header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode _ cls comment.				newCode _ oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!ClassDescription methodsFor: 'method dictionary' stamp: 'sw 8/11/1998 12:52'!removeSelectorUnlogged: aSymbol 	"Remove the message whose selector is aSymbol from the method dictionary of the receiver, if it is there. Answer nil otherwise.  Do not log the action either to the current change set or to the changes log"	(methodDict includesKey: aSymbol) ifFalse: [^ nil].	super removeSelector: aSymbol.	self organization removeElement: aSymbol! !!ClassDescription methodsFor: 'compiling' stamp: 'di 8/21/1998 11:01'!compile: text classified: category withStamp: changeStamp notifying: requestor 	| selector priorMethod method methodNode newText |	method _ self		compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel.			priorMethod _ methodDict at: selector ifAbsent: [nil].			methodNode _ node].	self acceptsLoggingOfCompilation ifTrue:		[newText _ ((requestor == nil or: [requestor isKindOf: SyntaxError]) not						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [text askIfAddStyle: priorMethod req: requestor]			ifFalse: [text].		 method putSource: newText				fromParseNode: methodNode				class: self category: category withStamp: changeStamp 				inFile: 2 priorMethod: priorMethod].	self organization classify: selector under: category.	^selector! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 8/11/1998 14:40'!compileUnlogged: text classified: category notifying: requestor 	| selector  |	self compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^ nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel].	self organization classify: selector under: category.	^ selector! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/8/1998 14:44'!classComment: aString	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."	^ self classComment: aString stamp: '<historical>'! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 8/24/1998 12:30'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue: [^ organization classComment: aString].	oldCommentRemoteStr _ organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	aStamp size > 0 ifTrue: [self commentStamp: aStamp].	organization classComment: (RemoteString newString: aString onFileNumber: 2).	Smalltalk changes commentClass: self.	! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/2/1998 14:22'!commentStamp: changeStamp	self organization commentStamp: changeStamp.    ^ self commentStamp: changeStamp prior: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 22:02'!methodsFor: categoryName stamp: changeStamp prior: indexAndOffset	"Prior source link ignored when filing in."	^ ClassCategoryReader new setClass: self				category: categoryName asSymbol				changeStamp: changeStamp"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"!]style[(65 333 22 17)f1b,f1,f1LReadWriteStream fileIn;,f1! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 15:26'!reorganize	"During fileIn, !!Rectangle reorganize!! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"	Smalltalk changes reorganizeClass: self.	^self organization!]style[(10 156 22 80)f1b,f1,f1LReadWriteStream fileIn;,f1! !I represent method categorization information for classes.  The handling of class comments has gone through a tortuous evolution.   Grandfathered class comments (before late aug 98) have no time stamps, and historically, fileouts of class comments always substituted the timestamp reflecting the author and date/time at the moment of fileout; and historically any timestamps in a filed out class comment were dropped on the floor, with the author & time prevailing at the moment of filein being substituted.   Such grandfathered comments now go out on fileouts with '<historical>' timestamp; class comments created after the 8/98 changes will have their correct timestamps preserved, though there is not yet a decent ui for reading those stamps other than filing out and looking at the file; nor is there yet any ui for browsing and recovering past versions of such comments.  Everything in good time!!!!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 8/24/1998 12:29'!commentStamp	^ commentStamp! !!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 8/24/1998 12:29'!commentStamp: aStamp	commentStamp _ aStamp! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'sw 8/24/1998 12:33'!putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource forClass: aClass	"Store the comment about the class onto file, aFileStream."	| header |	globalComment ifNotNil:		[aFileStream cr; nextPut: $!!.		header _ String streamContents: [:strm | 				strm nextPutAll: aClass name;				nextPutAll: ' commentStamp: '.				commentStamp ifNil: [commentStamp _ '<historical>'].				commentStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: '0'].		aFileStream nextChunkPut: header.		aClass organization fileOutCommentOn: aFileStream				moveSource: moveSource toFile: sourceIndex.		aFileStream cr]! !!Color methodsFor: 'transformations' stamp: 'jm 6/25/1998 10:12'!darker	"Answer a darker shade of this color."	^ self mixed: 0.8333 with: Color black! !!Color methodsFor: 'transformations' stamp: 'jm 6/17/1998 11:23'!lighter	"Answer a lighter shade of this color."	^ self mixed: 0.8333 with: Color white! !!Color methodsFor: 'other' stamp: 'sw 6/10/1998 17:50'!newTileMorphRepresentative	^ ColorTileMorph new colorSwatchColor: self! !!Color methodsFor: 'conversions' stamp: 'jm 6/2/1998 14:56'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val rgbBlack32 |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		rgbBlack32 _ 16rFF000001.  "closest black for 32-bit depth, with opaque alpha"		"eight bits per component; top 8 bits set to all ones (opaque)"		val _ (((rgb bitShift: -6) bitAnd: 16rFF0000) bitOr:			 ((rgb bitShift: -4) bitAnd: 16r00FF00)) bitOr:			 ((rgb bitShift: -2) bitAnd: 16r0000FF).		^ val = 0 ifTrue: [rgbBlack32] ifFalse: [16rFF000000 + val]].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'copying' stamp: 'tk 8/19/1998 16:12'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:48'!indexOfColor: aColor	"Return the index of aColor in my color array"	self ensureColorArrayExists.	^ colors indexOf: aColor ifAbsent: [0]! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:49'!replaceColorAtIndex: index with: newColor	"Replace a color map entry with newColor."	self ensureColorArrayExists.	colors at: index put: newColor.	cachedColormap == nil ifFalse:		[cachedColormap at: index put: (newColor pixelValueForDepth: cachedDepth)]! !!ColorSeerTile methodsFor: 'as yet unclassified' stamp: 'jm 5/28/1998 19:19'!storeCodeOn: aStream indent: tabCount	"We have a hidden arg. Output two keywords with interspersed arguments."	| parts |	parts _ operatorOrExpression keywords.	"color:sees:"	^ aStream nextPutAll: (parts at: 1); space;		nextPutAll: colorSwatch color printString; space;		nextPutAll: (parts at: 2).! !!ColorTileMorph methodsFor: 'events' stamp: 'sw 9/10/1998 08:22'!mouseUp: evt	evt hand changeColorTarget: colorSwatch selector: #userSelectedColor:! !!ColorTileMorph methodsFor: 'other' stamp: 'sw 6/10/1998 17:49'!colorSwatchColor: aColor	colorSwatch color: aColor! !!ColorTileMorph methodsFor: 'other' stamp: 'jm 5/28/1998 19:02'!storeCodeOn: aStream indent: tabCount	aStream nextPutAll: colorSwatch color printString.! !!Comment class methodsFor: 'URL processing' stamp: 'mjg 9/1/1998 12:58'!process: request	"URLs are of the form Comment.commentKey or	Comment.commentKey.note of Comment.commentKey.gif.	If commentKey is accessed but not created, create an empty one.	If note is accessed, display it."	| commentKey noteIndex newNote |	(request message size > 1) ifTrue: [commentKey _ request message at: 2]	ifFalse: [^request reply: (self showAllComments: CommentsTable)].	(CommentsTable includesKey: commentKey)		ifFalse:			[CommentsTable at: commentKey put: Discussion new.			(CommentsTable at: commentKey)				title: commentKey.			(CommentsTable at: commentKey)				description: 'Discussion on ' , commentKey].	request fields isNil		ifFalse:			["Are there input fields?"			newNote _ self createComment: request.			newNote parent: commentKey.			(CommentsTable at: commentKey)				addNote: newNote.			newNote url: ('Comment.',commentKey,'.',				(CommentsTable at: commentKey) notes sizeprintString)].	request message size > 2		ifTrue:			["There's a note reference or a request for astatus image"			noteIndex _ request message at: 3.			noteIndex asUppercase = 'GIF'			ifTrue: [			request reply: (PWS success),(PWS content:'image/gif').			request reply: (HTMLformatter textToGIF:				(CommentsTable at: commentKey) status)]			ifFalse: [request reply: (self showNote:((CommentsTable at: commentKey)						at: noteIndex asNumber))]]		ifFalse: [request reply: (self showComment: (CommentsTableat: commentKey))]! !!Comment class methodsFor: 'URL processing' stamp: 'TPR 7/20/1998 18:07'!showAllComments: aDictionaryOfCommentSpaces	| fileName |	fileName := (ServerAction serverDirectory) , 'ShowAllComments.html'.	^HTMLformatter evalEmbedded: (FileStream fileNamed: fileName)contentsOfEntireFile with: aDictionaryOfCommentSpaces! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 6/2/1998 16:26'!numArgs	"Answer the number of arguments the receiver takes."	^ (self header bitShift: -24) bitAnd: 16r0F! !!CompiledMethod methodsFor: 'testing' stamp: 'sw 8/20/1998 09:31'!hasReportableSlip	"Answer whether the receiver contains anything that might be brought to the attention of the author when filing out.   Customize the lists to suit your preferences.  If slips do not get reported in spite of your best efforts here, make certain that the Preference 'suppressCheckForSlips' has not been hard-coded to true."	| assoc | 	#(halt halt: urgent hottest) do:		[:aLit | (self hasLiteral: aLit) ifTrue: [^ true]].	#(Transcript AA BB CC DD EE) do:		[:aSymbol | (assoc _ (Smalltalk associationAt: aSymbol ifAbsent: [nil])) ifNotNil:			[(self hasLiteral: assoc) ifTrue: [^ true]]].	^ false! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:14'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:11'!isReturnField	"Answer whether the receiver is a quick return of an instance variable."	^ self primitive between: 264 and: 519! !!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 8/19/1998 16:20'!veryDeepCopyWith: deepCopier	"Return self.  I am always shared.  Do not record me.  Only use this for blocks.  Normally methodDictionaries should not be copied this way."! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:13'!functionComponent2output	^functionComponent2output! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:13'!functionComponent2outputSet: newValue	functionComponent2output _ newValue.	self changed: #functionComponent2output! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:12'!listComponent2selectedItem	^listComponent2selectedItem! !!Component1 methodsFor: 'view access' stamp: 'di 9/15/1998 17:12'!listComponent2selectedItemSet: newValue	listComponent2selectedItem _ newValue.	self changed: #listComponent2selectedItem! !!Component1 methodsFor: 'functions' stamp: 'di 9/15/1998 17:10'!functionComponent2a: a 	^ Smalltalk at: a! !!CompositionScanner methodsFor: 'initialize-release' stamp: 'jm 5/29/1998 14:48'!forParagraph: aParagraph	"Initialize the receiver for scanning the given paragraph."	super		initializeFromParagraph: aParagraph		clippedBy: aParagraph clippingRectangle.! !!CompoundTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:42'!associatedPlayer	^ nil! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:07'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:50'!handlesMouseOverDragging: evt	^ true! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!CompoundTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/29/1998 10:26'!storeCodeBlockFor: scriptPart on: aStream indent: tabCount	| rows r |	rows _ scriptPart tileRows.	1 to: rows size do: [:i |		tabCount timesRepeat: [aStream tab].		r _ rows at: i.		r do: [:t | t storeCodeOn: aStream indent: tabCount].		i < rows size ifTrue: [aStream nextPut: $.; cr]].! !!CompoundTileMorph methodsFor: 'all' stamp: 'jm 5/29/1998 10:31'!storeCodeOn: aStream indent: tabCount	aStream nextPut: $(.	testPart storeCodeOn: aStream indent: 0.	aStream nextPut: $); cr.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: 'ifTrue: ['; cr.	self storeCodeBlockFor: yesPart on: aStream indent: tabCount + 2.	aStream nextPut: $]; cr.	tabCount + 1 timesRepeat: [aStream tab].	aStream nextPutAll: 'ifFalse: ['; cr.	self storeCodeBlockFor: noPart on: aStream indent: tabCount + 2.	aStream nextPut: $].! !!ContextPart methodsFor: 'printing' stamp: 'di 9/10/1998 09:19'!printOn: aStream 	| selector class |	self method == nil ifTrue: [^ super printOn: aStream].	selector _ 		(class _ self receiver class) 			selectorAtMethod: self method 			setClass: [:mclass].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector! !!ContextPart methodsFor: 'private' stamp: 'afr 9/11/1998 19:50'!doPrimitive: primitiveIndex receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message.""	NOTE: In order for perform:WithArguments: to work reliably here,	this method must be forced to invoke a large context.  This is done	by adding extra temps until the following expression evaluates as true:		(ContextPart compiledMethodAt: #doPrimitive:receiver:args:) frameSize > 20"	| value t1 t2 t3 |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ #simulatorFail"	(primitiveIndex = 19) ifTrue:[		Debugger 			openContext: self			label:'Code simulation error'			contents: self shortStack].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: 					((BlockContext new: receiver size)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	arguments size > 6 ifTrue: [^#simulatorFail].	value _ receiver tryPrimitive: primitiveIndex withArgs: arguments.	value == #simulatorFail		ifTrue: [^ #simulatorFail]		ifFalse: [^ self push: value]! !!ContextVariablesInspector methodsFor: 'selecting' stamp: 'ar 5/29/1998 18:32'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^''].	selectionIndex = 1 ifTrue: [^object].	selectionIndex = 2		ifTrue: [^object tempsAndValues]		ifFalse: [^object tempAt: selectionIndex - 2]! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!control	^ control! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!control: midiControl	control _ midiControl.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!control: midiControl value: midiControlValue channel: midiChannel	control _ midiControl.	value _ midiControlValue.	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:02'!value	^ value! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!value: midiControlValue	value _ midiControlValue.! !!ControlChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isControlChange	^ true! !!ControlChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rB0		channel: channel		byte: control		byte: value.! !!ControlChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:34'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': ctrl['.	control printOn: aStream.	aStream nextPutAll: ']='.	value printOn: aStream.	aStream nextPut: $).! !!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController _ aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess _ 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'scheduling' stamp: 'wod 6/17/1998 15:46'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically _ Sensor shiftPressed.	controllers _ OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse _ sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels _ String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index _ (PopUpMenu labels: labels) startUp.	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'di 6/20/1998 12:59'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess.				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:48'!scheduleActive: aController 	"Make aController be scheduled as the active controller. Presumably the 	active scheduling process asked to schedule this controller and that a 	new process associated this controller takes control. So this is the last act 	of the active scheduling process."	<primitive: 19> "Simulation guard"	self scheduleActiveNoTerminate: aController.	Processor terminateActive! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/11/1998 06:33'!controlLoop 	"Sent by Controller|startUp as part of the standard control sequence. 	Controller|controlLoop sends the message Controller|isControlActive to test 	for loop termination. As long as true is returned, the loop continues. 	When false is returned, the loop ends. Each time through the loop, the 	message Controller|controlActivity is sent."	[self isControlActive] whileTrue: [		self interActivityPause. self controlActivity. Processor yield]! !!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/13/1998 00:48'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait < MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime _ Time millisecondClockValue.! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!MinActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!initialize	"Controller initialize"	self MinActivityLapse: 10.! !!CrLfFileStream methodsFor: 'open/close' stamp: 'ar 1/20/98 16:15'!open: aFileName forWrite: writeMode 	"Open the receiver.  If writeMode is true, allow write, else access will be 	read-only. "	| result |	result _ super open: aFileName forWrite: writeMode.	result ifNotNil: [self detectLineEndConvention].	^ result! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!ascii	super ascii.	self detectLineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!binary	super binary.	lineEndConvention _ nil! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 7/10/1998 23:35'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead pos |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	lineEndConvention _ LineEndDefault.	"Default if nothing else found"	numRead _ 0.	pos _ super position.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char _ super next.			char = Lf				ifTrue: 					[super position: pos.					^ lineEndConvention _ #lf].			char = Cr				ifTrue: 					[super peek = Lf						ifTrue: [lineEndConvention _ #crlf]						ifFalse: [lineEndConvention _ #cr].					super position: pos.					^ lineEndConvention].			numRead _ numRead + 1].	super position: pos.	^ lineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:17'!next	| char |	char _ super next.	lineEndConvention ifNil: [^ char].	(LineEndStrings at: lineEndConvention) first = char		ifTrue: [lineEndConvention = #crlf				ifTrue: [self peek = Character lf						ifTrue: 							[super next.							^ Cr]						ifFalse: [^ char]]				ifFalse: [^ Cr]]		ifFalse: [^ char]! !!CrLfFileStream methodsFor: 'access' stamp: 'di 9/22/1998 16:34'!next: n 	| string |	string _ super next: n.	string size = 0 ifTrue: [^ string].	lineEndConvention ifNil: [^ string].	lineEndConvention == #crlf ifTrue:		["Special case for last character"		(string last = Cr and: [self peek = Lf]) ifTrue: [self next]].	string _ self convertStringToCr: string.	string size = n ifTrue: [^ string].	"string shrunk due to embedded crlfs; make up the difference"	^ string , (self next: n - string size)! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPut: char 	(lineEndConvention notNil and: [char = Cr])		ifTrue: [super nextPutAll: (LineEndStrings at: lineEndConvention)]		ifFalse: [super nextPut: char].	^ char! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPutAll: aString 	super nextPutAll: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!verbatim: aString 	super verbatim: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'private' stamp: 'ar 1/20/98 16:21'!convertStringFromCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream _ ReadStream on: aString.	outStream _ WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !!CrLfFileStream methodsFor: 'private' stamp: 'ar 1/20/98 16:21'!convertStringToCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Lf with: Cr].	"lineEndConvention == #crlf"	inStream _ ReadStream on: aString.	outStream _ WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: 					[outStream nextPut: Cr.					inStream peek = Lf ifTrue: [inStream next]]].	^ outStream contents! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCR	"CrLfFileStream defaultToCR"	LineEndDefault := #cr.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCRLF	"CrLfFileStream defaultToCRLF"	LineEndDefault := #crlf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToLF	"CrLfFileStream defaultToLF"	LineEndDefault := #lf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:13'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $: ifTrue:[^self defaultToCR].	FileDirectory pathNameDelimiter = $/ ifTrue:[^self defaultToLF].	FileDirectory pathNameDelimiter = $\ ifTrue:[^self defaultToCRLF].	"in case we don't know"	^self defaultToCR! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:14'!initialize	"CrLfFileStream initialize"	Cr := Character cr.	Lf := Character lf.	CrLf := String with: Cr with: Lf.	LineEndStrings := Dictionary new.	LineEndStrings at: #cr put: (String with: Character cr).	LineEndStrings at: #lf put: (String with: Character lf).	LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).	LookAheadCount := 2048.	self guessDefaultLineEndConvention.! !!Cursor methodsFor: 'displaying' stamp: 'jm 9/22/1998 23:33'!beCursorWithMask: maskForm	"Primitive. Tell the interpreter to use the receiver as the current cursor image with the given mask Form. Both the receiver and the mask should have extent 16@16 and a depth of one. The mask and cursor bits are combined as follow:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel""Essential. See Object documentation whatIsAPrimitive."	<primitive: 101>	self primitiveFailed! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:01'!title: aTitle	title _ aTitle! !!CustomMenu methodsFor: 'construction' stamp: 'jm 8/20/1998 08:34'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList _ (aString findTokens: String cr) asArray.	anArrayOrNil		ifNil: [linesArray _ #()]		ifNotNil: [linesArray _ anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font _ aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'di 8/20/1998 09:24'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 8/18/1998 12:01'!startUp: initialSelection	"Build and invoke this menu with the given initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: initialSelection withCaption: title! !!CustomMenu methodsFor: 'private' stamp: 'jm 8/20/1998 08:30'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream _ WriteStream on: (String new).	labels do: [: label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	super labels: stream contents		font: (TextStyle default fontAt: 1)		lines: dividers.! !!DataMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:46'!becomeField	| aStack slotNameChosen  |	aStack _ self pasteUpMorph assuredPlayer.	slotNameChosen _ aStack addSlotNamedLike: self externalName withValue: self valueFromContents.	self getSelector: (Utilities getterSelectorFor: slotNameChosen).	self putSelector: (Utilities setterSelectorFor: slotNameChosen).	self target: aStack.	status _ #field.	aStack updateAllViewers! !This is the save-to-disk facility. A DataStream can store one or more objects in a persistent form.To handle objects with sharing and cycles, you must use aReferenceStream instead of a DataStream.  (Or SmartRefStream.)  ReferenceStream is typicallyfaster and produces smaller files because it doesn't repeatedly write the same Symbols.Here is the way to use DataStream and ReferenceStream:	rr _ ReferenceStream fileNamed: 'test.obj'.	rr nextPut: <your object>.	rr close.To get it back:	rr _ ReferenceStream fileNamed: 'test.obj'.	<your object> _ rr next.	rr close.Each object to be stored has two opportunities to control what gets stored.  On the high level, objectToStoreOnDataStream allows you to substitute another object on the way out.  The low level hook is storeDataOn:. The read-in counterparts to these messages are comeFullyUpOnReload and (class) readDataFrom:size:. See these methods, and the class DiskProxy, for more information about externalizing and internalizing.NOTE: A DataStream should be treated as a write-stream for writing.  It is a read-stream for reading.  It is not a ReadWriteStream.!!DataStream methodsFor: 'all' stamp: 'tk 9/9/1998 14:10'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos |	type _ byteStream next.	type ifNil: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType _ self noteCurrentReference: type.	selector _ #(readNil readTrue readFalse readInteger			readStringOld readSymbol readByteArray			readArray readInstance readReference readBitmap			readClass readUser readFloat readRectangle readShortInst 			readString) at: type.	anObject _ self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].	"After reading the externalObject, internalize it.	 #readReference is a special case. Either:	   (1) We actually have to read the object, recursively calling		   next, which internalizes the object.	   (2) We just read a reference to an object already read and		   thus already interalized.	 Either way, we must not re-internalize the object here."	selector == #readReference ifFalse:		[anObject _ self internalize: anObject].	^ anObject! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:18'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject.	 NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectToStoreOnDataStream) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 : writeReference: -> errorWriteReference:."	| typeID selector objectToStore |	typeID _ self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore _ (self objectIfBlocked: anObject) objectToStoreOnDataStream.	objectToStore == anObject ifFalse: [typeID _ self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector _ #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "dummy 16" 		writeString:) at: typeID.	self perform: selector with: objectToStore.	^ anObject! !!DataStream methodsFor: 'all' stamp: 'jm 8/19/1998 17:00'!readByteArray	"PRIVATE -- Read the contents of a ByteArray."	| count |	count _ byteStream nextNumber: 4.	^ byteStream next: count  "assume stream is in binary mode"! !!DataStream methodsFor: 'all' stamp: 'tk 7/12/1998 13:32'!readShortRef	"Read an object reference from two bytes only.  Original object must be in first 65536 bytes of the file.  Relative to start of data.  vacantRef not a possibility."	^ self objectAt: (byteStream nextNumber: 2)! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:03'!readString	| str |	byteStream ascii.	str _ byteStream nextString.	byteStream binary.	^ str! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:27'!readStringOld   ^ byteStream nextStringOld! !!DataStream methodsFor: 'all' stamp: 'tk 8/18/1998 08:59'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	aStream binary.	basePos _ aStream position.	"Remember where we start.  Earlier part of file contains a class or method file-in.  Allow that to be edited.  We don't deal in absolute file locations."	byteStream _ aStream.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:13'!typeIDFor: anObject	"Return the typeID for anObject's class.  This is where the tangle of objects is clipped to stop everything from going out.  	Classes can control their instance variables by defining objectToStoreOnDataStream.	Any object in blockers is not written out.  See ReferenceStream.objectIfBlocked: and DataStream nextPut:.	Morphs do not write their owners.  See Morph.storeDataOn:   Each morph tells itself to 'prepareToBeSaved' before writing out."		^ TypeMap at: anObject class ifAbsent: [9 "instance of any normal class"]	"See DataStream initialize.  nil=1. true=2. false=3. a SmallInteger=4. (a String was 5). a Symbol=6.  a ByteArray=7. an Array=8. other = 9.  a Bitmap=11. a Metaclass=12. a Float=14.  a Rectangle=15. any instance that can have a short header=16.  a String=17 (new format)."! !!DataStream methodsFor: 'all' stamp: 'tk 7/12/1998 13:16'!vacantRef	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference	 position' to identify a reference that's not yet filled in. This must be a	 value that won't be used as an ordinary reference. Cf. outputReference: and	 readReference. -- 	 NOTE: We could use a different type ID for vacant-refs rather than writing		object-references with a magic value. (The type ID and value are		overwritten by ordinary object-references when weak refs are fullfilled.)"	^ SmallInteger maxVal! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:07'!writeBitmap: aBitmap	"PRIVATE -- Write the contents of a Bitmap."	aBitmap writeOn: byteStream	"Note that this calls (byteStream nextPutAll: aBitmap) which knows enough to put 4-byte quantities on the stream!!  Reader must know that size is in long words."! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:06'!writeByteArray: aByteArray	"PRIVATE -- Write the contents of a ByteArray."	byteStream nextNumber: 4 put: aByteArray size.	"May have to convert types here..."	byteStream nextPutAll: aByteArray.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 20:57'!writeString: aString	"PRIVATE -- Write the contents of a String."	byteStream nextStringPut: aString.! !!DataStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:23'!writeStringOld: aString	"PRIVATE -- Write the contents of a String."	| length |	aString size < 16384 		ifTrue: [			(length _ aString size) < 192				ifTrue: [byteStream nextPut: length]				ifFalse: 					[byteStream nextPut: (length // 256 + 192).					byteStream nextPut: (length \\ 256)].			aString do: [:char | byteStream nextPut: char asciiValue]]		ifFalse: [self writeByteArray: aString].	"takes more space"! !!DataStream class methodsFor: 'all' stamp: 'tk 6/8/1998 21:10'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes _ OrderedCollection new.	t _ TypeMap _ Dictionary new: 40. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: String put: 5.   refTypes add: 1.	t at: Symbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.		"Does anything use this?"	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	"t at:  put: 18.  refTypes add: 0."	ReferenceStream refTypes: refTypes.	"save it"! !!Date class methodsFor: 'instance creation' stamp: 'ls 7/25/1998 01:15'!fromSeconds: seconds	"Answer an instance of me which is 'seconds' seconds after January 1, 	1901."	^self fromDays: seconds // 86400! !!Date class methodsFor: 'instance creation' stamp: 'di 5/26/1998 11:53'!newDay: day month: month year: year 	"Note: day, month and year are all integers, except month may be a string"	"Answer an instance of me which is the day'th day of the month named 	 month in the year'th year. The year may be specified as the actual 	 number of years since the beginning of the Roman calendar or the 	 number of years since 1900.  **Note** two digit dates are always from 1900.		1/1/01 will NOT mean 2001."	"Tolerate a month index instead of a month name."	| monthIndex daysInMonth firstDayOfMonth |	year < 100 ifTrue: [^ self			newDay: day			month: month			year: 1900 + year].	monthIndex _ month isInteger	 ifTrue: [month] ifFalse: [self indexOfMonth: month].	monthIndex = 2		ifTrue: [daysInMonth _ (DaysInMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [daysInMonth _ DaysInMonth at: monthIndex].	monthIndex > 2		ifTrue: [firstDayOfMonth _ (FirstDayOfMonth at: monthIndex)						+ (self leapYear: year)]		ifFalse: [firstDayOfMonth _ FirstDayOfMonth at: monthIndex].	(day < 1 or: [day > daysInMonth])		ifTrue: [self error: 'illegal day in month']		ifFalse: [^self new day: day - 1 + firstDayOfMonth year: year]! !!Debugger methodsFor: 'initialize' stamp: 'sw 8/18/1998 12:22'!buildMVCDebuggerViewLabel: aString minSize: aPoint	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView |	self expandStack.	topView _ StandardSystemView new model: self.	topView borderWidth: 1.	stackListView _ PluggableListView on: self			list: #contextStackList			selected: #contextStackIndex			changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted:			keystroke: #contextStackKey:from:.		stackListView menuTitleSelector: #messageListSelectorTitle.		stackListView window: (0 @ 0 extent: 150 @ 50).		topView addSubView: stackListView.	stackCodeView _ PluggableTextView on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		stackCodeView window: (0 @ 0 extent: 150 @ 75).		topView addSubView: stackCodeView below: stackListView.	rcvrVarView _ PluggableListView on: self receiverInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		rcvrVarView window: (0 @ 0 extent: 25 @ 50).		topView addSubView: rcvrVarView below: stackCodeView.	rcvrValView _ PluggableTextView on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		rcvrValView window: (0 @ 0 extent: 50 @ 50).		topView addSubView: rcvrValView toRightOf: rcvrVarView.	ctxtVarView _ PluggableListView on: self contextVariablesInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		ctxtVarView window: (0 @ 0 extent: 25 @ 50).		topView addSubView: ctxtVarView toRightOf: rcvrValView.	ctxtValView _ PluggableTextView on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		ctxtValView window: (0 @ 0 extent: 50 @ 50).		topView addSubView: ctxtValView toRightOf: ctxtVarView.	topView label: aString.	topView minimumSize: aPoint.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'wod 5/26/1998 16:44'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window |	window _ (SystemWindow labelled: label) model: self.	notifyPane _ PluggableTextMorph on: self text: nil accept: nil		readSelection: nil menu: #debugProceedMenu:.	notifyPane editString: messageString;		askBeforeDiscardingEdits: false.	window addMorph: notifyPane frame: (0@0 corner: 1@1).	^ window openInWorldExtent: 350@116! !!Debugger methodsFor: 'initialize' stamp: 'sw 8/18/1998 12:44'!openFullMorphicLabel: labelString	| window aListMorph |	self expandStack.	window _ (SystemWindow labelled: labelString) model: self.	aListMorph _ PluggableListMorph on: self list: #contextStackList			selected: #contextStackIndex changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted: keystroke: #contextStackKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 corner: 1@0.3).	window addMorph: (PluggableTextMorph on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.3 corner: 1@0.7).	window addMorph: (PluggableListMorph on: self receiverInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0@0.7 corner: 0.2@1).	window addMorph: (PluggableTextMorph on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.2@0.7 corner: 0.5@1).	window addMorph: (PluggableListMorph on: self contextVariablesInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:)		frame: (0.5@0.7 corner: 0.7@1).	window addMorph: (PluggableTextMorph on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.7@0.7 corner: 1@1).	^ window openInWorld! !!Debugger methodsFor: 'initialize' stamp: 'di 6/20/1998 13:04'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	(label beginsWith: 'Space is low')		ifTrue: [msg _ self lowSpaceChoices, msgString]		ifFalse: [msg _ msgString].	World ifNotNil:		[self buildMorphicNotifierLabelled: label message: msg.		^ Project current spawnNewProcess].	Display fullScreen.	Cursor normal show.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:31'!release	self windowIsClosing.	super release.! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:30'!windowIsClosing	"My window is being closed; clean up. Restart the low space watcher."	interruptedProcess == nil ifTrue: [^ self].	interruptedProcess terminate.	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"! !!Debugger methodsFor: 'notifier menu' stamp: 'wod 5/26/1998 16:19'!debug	"Open a full DebuggerView."	| topView |	topView _ self topView.	topView model: nil.  "so close won't release me."	World ifNotNil:		[self breakDependents.		self openFullMorphicLabel: topView label.		^ topView delete].	topView controller controlTerminate.	topView deEmphasizeView; erase.	self openFullNoSuspendLabel: topView label.	topView controller closeAndUnscheduleNoErase.	Processor terminateActive.! !!Debugger methodsFor: 'context stack (message list)' stamp: 'di 9/22/1998 00:26'!selectedMessage	"Answer the source code of the currently selected context."	contents _ self selectedContext sourceCode.	Preferences browseWithPrettyPrint ifTrue: [contents _ self selectedClass compilerClass new					format: contents					in: self selectedClass					notifying: nil].	^ contents _ contents asText makeSelectorBoldIn: self selectedClass! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 8/18/1998 16:35'!contextStackMenu: aMenu shifted: shifted	^ shifted ifFalse: [aMenu labels: 'fullStack (f)restart (r)proceed (p)step (t)send (e)where (w)senders of...implementors of...method inheritanceversionsinst var refs...inst var defs...class var refs...class variablesclass refsbrowse fullmore...'	lines: #(6 10 12 15)	selections: #(fullStack restart proceed step send wherebrowseSendersOfMessages browseMessages methodHierarchy browseVersionsbrowseInstVarRefs browseInstVarDefsbrowseClassVarRefs browseClassVariables browseClassRefsbrowseMethodFullshiftedYellowButtonActivity)]	ifTrue: [aMenu labels: 'browse class hierarchybrowse classbrowse methodimplementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionremove from current change setrevert and forgetmore...' 	lines: #(5 7 10)	selections: #(classHierarchy browseClass 		buildMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion 		removeFromCurrentChanges revertAndForget		unshiftedYellowButtonActivity)]! !!Debugger methodsFor: 'context stack menu' stamp: 'ar 5/26/1998 16:26'!step	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext oldMethod |	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	self contextStackIndex > 1		ifTrue: 			[currentContext completeCallee: contextStackTop.			self resetContext: currentContext]		ifFalse: 			[currentContext stepToSendOrReturn.			currentContext willReturn				ifTrue: 					[oldMethod _ currentContext method.					currentContext _ currentContext step.					currentContext stepToSendOrReturn.					self resetContext: currentContext.					oldMethod == currentContext method "didnt used to update pc here"						ifTrue: [self changed: #contentsSelection]]				ifFalse: 					[currentContext completeCallee: currentContext step.					self changed: #contentsSelection.					self updateInspectors]]! !!Debugger methodsFor: 'code pane' stamp: 'di 9/22/1998 00:21'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| i methodNode pc end |	(selectingPC and: [contextStackIndex ~= 0])		ifFalse: [^1 to: 0].	sourceMap == nil ifTrue:		[methodNode _ self selectedClass compilerClass new			parse: contents			in: self selectedClass			notifying: nil.		sourceMap _ methodNode sourceMap.		tempNames _ methodNode tempNames.		self selectedContext method cacheTempNames: tempNames].	sourceMap size = 0 ifTrue: [^1 to: 0].	pc_ self selectedContext pc -		((externalInterrupt and: [contextStackIndex=1])			ifTrue: [1]			ifFalse: [2]).	i _ sourceMap indexForInserting: (Association key: pc value: nil).	i < 1 ifTrue: [^1 to: 0].	i > sourceMap size		ifTrue:			[end _ sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value! !!Debugger methodsFor: 'private' stamp: 'di 9/22/1998 00:21'!contextStackIndex: anInteger oldContextWas: oldContext	| newMethod |	contextStackIndex _ anInteger.	anInteger = 0		ifTrue:			[tempNames _ sourceMap _ contents _ nil.			self changed: #contextStackIndex.			self changed: #contents.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^self].	(newMethod _ oldContext == nil or:		[oldContext method ~~ self selectedContext method])		ifTrue:			[tempNames _ sourceMap _ nil.			contents _ self selectedMessage.			self changed: #contents.			self pcRange "will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	tempNames == nil		ifTrue: [tempNames _ 					self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod ifFalse: [self changed: #contentsSelection]! !!Debugger methodsFor: 'private' stamp: 'di 6/20/1998 14:48'!resumeProcess: aTopView	Smalltalk isMorphic ifFalse: [aTopView erase].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate) ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		Smalltalk isMorphic			ifTrue: [Project current resumeProcess: interruptedProcess]			ifFalse: [ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. "Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete. World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.  "restart low space handler"	Processor terminateActive! !!Debugger class methodsFor: 'instance creation' stamp: 'di 6/17/1998 14:39'!context: aContext 	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext! !!Debugger class methodsFor: 'opening' stamp: 'di 9/22/1998 00:35'!openContext: aContext label: aString contents: contentsString	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| f |	<primitive: 19> "Simulation guard"	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		self primitiveError: aString].	Preferences logDebuggerStackToFile ifTrue:		[FileDirectory default deleteFileNamed: 'SqueakDebug.log' ifAbsent: [].		f _ FileStream fileNamed: 'SqueakDebug.log'.		f nextPutAll: aString; cr.		aContext stack do: [:ctxt | f print: ctxt; cr].		f close].	ErrorRecursion _ true.	(Debugger context: aContext)		openNotifierContents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'di 6/30/1998 12:13'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.	^ debugger		openNotifierContents: debugger interruptedContext shortStack		label: aString! !I do veryDeepCopy.  I hold the dictionary of objects seen, and the correspondance (uniClass -> new uniClass).  See Object|veryDeepCopy which calls (self veryDeepCopyWith: aDeepCopier).Rule:  If a morph stores a uniClass class (Player 57) as an object in a field, the new uniClass will not be stored there.   All uniClass instances do have a new class created for them.  (fix this by putting the old class in references and allow lookup?  Wrong if encounter it before seeing an instance?)Rule: If object A has object C in a field, and A says (^ C) for the copy, but object B has A in a normal field and it gets deepcopied, and A in encountered first, then there will be two copies of C.  (just be aware of it)!!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/31/1998 15:47'!checkVariables	"Check that no indexed of inst vars have changed in certain classes.  If you get an error in this method, you MUST go the the method being checked (veryDeepCopyWith:) and update its code.  And then update the test here.""All classes that implements veryDeepCopyWith: for the purpose of not doing a veryDeepCopy on some inst var, must have a check here."	| str str2 |	str _ '|veryDeepCopyWith: is out of date.'.	Object instSize = 0 ifFalse: [self error: 'Many implementers of veryDeepCopyWith: are out of date'].	Morph superclass == Object ifFalse: [self error: 'Morph', str].	(Morph instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 			'fullBounds' 'color' 'extension') 		ifFalse: [self halt: 'Morph', str].	"added ones are OK"	str2 _ 'Player|copyUniClass and DeepCopier|mapUniClasses are out of date'.	Behavior instVarNames = #('superclass' 'methodDict' 'format' 'subclasses' )		ifFalse: [self error: str2].	ClassDescription instVarNames = #('instanceVariables' 'organization' )		ifFalse: [self error: str2].	Class instVarNames = #('name' 'classPool' 'sharedPools' )		ifFalse: [self error: str2].	Model superclass == Object ifFalse: [self error: str2].	Player superclass == Model ifFalse: [self error: str2].	Model class instVarNames = #() ifFalse: [self error: str2].	Player class instVarNames = #('scripts' 'slotInfo')		ifFalse: [self error: str2].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/22/1998 11:25'!initialize	references _ IdentityDictionary new: 4096.	uniClasses _ IdentityDictionary new.	"UniClass -> new UniClass"	(self identityHash // 16 bitAnd: 7) = 1 ifTrue: [self checkVariables].		"Just check once in a while"! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/31/1998 15:52'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321).""Uniclasses use class vars to hold onto siblings who are referred to in code"| pp |pp _ Object class instSize + 1.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+0"	"(pp+1) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+2 to: playersClass class instSize do: [:ii | 		playersClass instVarAt: ii put: 			((playersClass instVarAt: ii) veryDeepCopyWith: self)].	].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/20/1998 22:13'!references	^ references! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 8/19/1998 15:48'!uniClasses	^uniClasses! !!Dictionary methodsFor: 'user interface' stamp: 'di 9/23/1998 12:20'!inspectFormsWithLabel: aLabel	"Open a Form Dictionary inspector on the receiver, with the given label.  "	| viewClass |	viewClass _ PluggableTextView.	Smalltalk at: #FormInspectView		ifPresent: [:formInspectView | viewClass _ formInspectView].	^ DictionaryInspector openOn: self withEvalPane: true		withLabel: aLabel		valueViewClass: viewClass! !!DictionaryInspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:25'!contentsIsString	"Hacked so contents empty when deselected"	^ (selectionIndex = 0)! !an entry in a directory; a reference to either a file or a directory.!!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!creationTime	"time the entry was created.  (what's its type?)"	^creationTime! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:38'!fileSize	"size of the entry, if it's a file"	^fileSize! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:38'!isDirectory	"whether this entry represents a directory"	^dirFlag! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!modificationTime	"time the entry was last modified"	^modificationTime! !!DirectoryEntry methodsFor: 'access' stamp: 'ls 7/15/1998 21:37'!name	"name of the entry"	^name! !!DirectoryEntry methodsFor: 'access-compatibility' stamp: 'ls 7/15/1998 22:29'!at: index	"compatibility interface"	"self halt: 'old-style access to DirectoryEntry'"	index = 1 ifTrue: [ ^self name ].	index = 2 ifTrue: [ ^self creationTime ].	index = 3 ifTrue: [ ^self modificationTime ].	index = 4 ifTrue:[ ^self isDirectory ].	index = 5 ifTrue:[ ^self fileSize ].	self error: 'invalid index specified'.! !!DirectoryEntry methodsFor: 'access-compatibility' stamp: 'ls 7/15/1998 22:16'!size	^5! !!DirectoryEntry methodsFor: 'private-initialization' stamp: 'ls 7/15/1998 21:42'!privateName: name0  creationTime: creationTime0  modificationTime: modificationTime0  isDirectory: isDirectory0  fileSize: fileSize0	name _ name0.	creationTime _ creationTime0.	modificationTime _ modificationTime0.	dirFlag _ isDirectory0.	fileSize _ fileSize0.! !!DirectoryEntry class methodsFor: 'instance creation' stamp: 'ls 7/15/1998 21:42'!fromArray: array	^self name: (array at: 1) creationTime: (array at: 2) modificationTime: (array at: 3) isDirectory: (array at: 4) fileSize: (array at: 5) ! !!DirectoryEntry class methodsFor: 'instance creation' stamp: 'ls 7/15/1998 21:41'!name: name0  creationTime: creationTime  modificationTime: modificationTime   isDirectory: isDirectory  fileSize: fileSize	^self new privateName: name0  creationTime: creationTime  modificationTime: modificationTime  isDirectory: isDirectory  fileSize: fileSize! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:57'!author	^self description! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:57'!children	^#()! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:45'!timestamp	^String new:0! !!Discussion methodsFor: 'access' stamp: 'TPR 7/21/1998 10:53'!url	"fake the url as the title"	^'Comment.', self title! !!DisplayObject methodsFor: 'fileIn/Out' stamp: 'di 6/1/1998 20:31'!writeUncompressedOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode, depth, extent, offset, bits."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.  "file code = 2"	self writeUncompressedOn: file.	file close" | f |[(f _ Form fromUser) boundingBox area>25] whileTrue:	[f writeOnFileNamed: 'test.form'.	(Form newFromFileNamed: 'test.form') display]."! !!DisplayScanner methodsFor: 'scanning' stamp: 'di 7/1/1998 16:03'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph 		ifTrue: [anchoredMorph position: ((destX - width)@lineY) - morphicOffset]		ifFalse: [destY _ lineY.				height _ anchoredMorph height.				runX _ destX.				anchoredMorph displayOn: destForm at: destX - width@destY].	^ true! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:00'!primRetryShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. Do nothing if it fails. "	<primitive: 127>	"do nothing if primitive fails"! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:02'!primShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. If this fails, retry integer coordinates."	<primitive: 127>	"if this fails, coerce coordinates to integers and try again"	self primRetryShowRectLeft: l truncated		right: r rounded		top: t truncated		bottom: b rounded.! !!DosFileDirectory methodsFor: 'all' stamp: 'di 6/18/1998 08:57'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName badChars hasBadChars |	fName _ super checkName: aFileName fixErrors: fixing.	badChars _ #( $: $< $> $| $/ $\ $? $* $") asSet.	hasBadChars _ fName includesAnyOf: badChars.	(hasBadChars and:[fixing not]) ifTrue:[^self error:'Invalid file name'].	hasBadChars ifFalse:[^ fName].	^ fName collect:		[:char | (badChars includes: char) 				ifTrue:[$#] 				ifFalse:[char]]! !!DosFileDirectory methodsFor: 'all' stamp: 'di 9/11/1998 16:15'!fullNameFor: fileName	"Return the fully-qualified path name for the given file. Correct syntax errors in the file name."	FileDirectory splitName: fileName to: [:path :localName |		^ (path isEmpty ifFalse: [path] ifTrue: [			pathName = self pathNameDelimiter asString ifTrue: [''] ifFalse: [pathName]]),				self pathNameDelimiter asString, (self checkName: localName fixErrors: true)].! !a placeholder for an image that is downloading!!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 8/20/1998 09:12'!altText: aString	"set the text to be displayed while downloading"	altText _ aString.	self setContents! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/9/1998 06:59'!defaultExtent: aPoint	"set the size to use when the image hasn't yet downloaded"	defaultExtent _ aPoint! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/18/1998 05:40'!downloadState	"download the image"	| doc |	doc _ url retrieveContents.	downloadQueue nextPut: doc.! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:21'!initialize	super initialize.	altText _ '[image]'.	self color: Color transparent.	downloadQueue _ SharedQueue new.! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 21:43'!setContents	"set up our morphic contents"	| stringMorph imageMorph outlineMorph extent |	self removeAllMorphs.	image		ifNil: [ 			altText = '' ifTrue: [ self extent: 0@0. "don't display anything..." ^self ].			stringMorph _ StringMorph new.			stringMorph contents: altText.			stringMorph position: self position+(2@2).			self addMorph: stringMorph.			outlineMorph _ RectangleMorph new.			outlineMorph borderWidth: 1.			outlineMorph color: Color transparent.			outlineMorph position: self position.			"figure out how big to make the box"			extent _ defaultExtent ifNil: [ 0 @ 0 ].			stringMorph width + 4 > extent x ifTrue: [				extent _ (stringMorph width + 4) @ extent y ].			stringMorph height + 4 > extent y ifTrue: [				extent _ extent x @ (stringMorph height + 4) ].			outlineMorph extent: extent.			self addMorph: outlineMorph.			self extent: outlineMorph extent ]		ifNotNil: [			imageMorph _ ImageMorph new.			imageMorph image: image.			imageMorph position: self position.			self addMorph: imageMorph.			imageMorph extent ~= self extent ifTrue: [				self extent: imageMorph extent ] ].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/18/1998 05:42'!step	| doc |	downloadQueue size > 0 ifTrue: [		doc _ downloadQueue next.		doc mainType = 'image' 		ifTrue: [			image _ ImageReadWriter  formFromStream: doc contentStream binary.			self setContents ] ].! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/15/1998 19:19'!stepTime	"this check doesn't need to be frequent"	^500! !!DownloadingImageMorph methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 17:48'!url: aUrl	"set the url to download"	url _ aUrl asUrl.! !!DualChangeSorter methodsFor: 'all' stamp: 'jm 7/5/1998 12:37'!openAsMorph		| window |	leftCngSorter _ ChangeSorter new myChangeSet: Smalltalk changes.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	window _ (SystemWindow labelled: leftCngSorter label) model: self.	"topView minimumSize: 300 @ 200."	leftCngSorter openAsMorphIn: window rect: (0@0 extent: 0.5@1).	rightCngSorter openAsMorphIn: window rect: (0.5@0 extent: 0.5@1).	window openInWorld.! !!DummyStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:07'!nextPut: aByte	"do nothing"! !!DummyStream methodsFor: 'all' stamp: 'tk 6/8/1998 21:06'!nextPutAll: aByteArray	"do nothing"! !!DummyStream methodsFor: 'all' stamp: 'tk 7/12/1998 12:51'!position: anOffset	"Pretend to position wherever the caller says!!"! !!DynamicInterpreter methodsFor: 'contexts' stamp: 'jm 6/28/1998 13:57'!stackObjectValue: offset	"Ensures that the given object is a real object, not a SmallInteger."	| oop |	oop _ self longAt: self stackPointer - (offset * 4).	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^ oop! !!DynamicInterpreter methodsFor: 'primitive support' stamp: 'jm 8/22/1998 10:08'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| startTime |	self inline: false.	primitiveIndex > MaxPrimitiveIndex ifTrue: [^ false].	(nextWakeupTick ~= 0) ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	((nextWakeupTick ~= 0) and: [self ioLowResMSecs ~= startTime]) ifTrue: [		"primitive ran for more than a tick; check for possible timer interrupts"		((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [			successFlag				ifTrue: [  "process the interrupt now"					self checkForInterrupts]				ifFalse: [  "process the interrupt in primtive failure code"					interruptCheckCounter _ 0]]].	^ successFlag! !!DynamicInterpreter methodsFor: 'array and stream primitives' stamp: 'jm 9/22/1998 16:48'!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	arrayFmt < 4 ifTrue: [ "pointer type objects"		start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl).			srcIndex _ srcIndex + 1. ] ]	ifFalse: [		arrayFmt < 8  ifTrue: [ "long-word type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1 ] ]		ifFalse: [  "byte-type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1. ] ].	].	self pop: 4.  "leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 10:11'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:34'!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP].! !!DynamicInterpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:37'!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients that trigger interrupts should set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0)		ifTrue: [self checkForInterrupts].! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'jm 9/23/1998 00:14'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj maskBitsIndex maskObj bitsObj extentX extentY depth offsetObj offsetX offsetY cursorBitsIndex |	argumentCount = 0 ifTrue: [		cursorObj _ self stackTop.		maskBitsIndex _ nil].	argumentCount = 1 ifTrue: [		cursorObj _ self stackValue: 1.		maskObj _ self stackTop].	self success: (argumentCount < 2).	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		depth _ self fetchInteger: 3 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj].	self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize].	argumentCount = 1 ifTrue: [		self success: ((self isPointers: maskObj) and: [(self lengthOf: maskObj) >= 5]).		successFlag ifTrue: [			bitsObj _ self fetchPointer: 0 ofObject: maskObj.			extentX _ self fetchInteger: 1 ofObject: maskObj.			extentY _ self fetchInteger: 2 ofObject: maskObj.			depth _ self fetchInteger: 3 ofObject: maskObj].		successFlag ifTrue: [			self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).			self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).			maskBitsIndex _ bitsObj + BaseHeaderSize]].	successFlag ifTrue: [		argumentCount = 0			ifTrue: [self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)']			ifFalse: [self cCode: 'ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY)'].		self pop: argumentCount].! !!DynamicInterpreter methodsFor: 'I/O primitives' stamp: 'di 6/29/1998 22:58'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: argumentCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:58'!asyncFileValueOf: oop	"Return a pointer to the first byte of the async file record within the given Smalltalk bytes object, or nil if oop is not an async file record."	self returnTypeC: 'AsyncFile *'.	self success:		((self isIntegerObject: oop) not and:		 [(self isBytes: oop) and:		 [(self lengthOf: oop) = (self cCode: 'sizeof(AsyncFile)')]]).	successFlag ifFalse: [^ nil].	^ self cCode: '(AsyncFile *) (oop + 4)'! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:54'!primitiveAsyncFileClose	| f |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [self asyncFileClose: f].	successFlag ifTrue: [self pop: 1].  "pop f; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:54'!primitiveAsyncFileOpen	| semaIndex writeFlag fileName fmt fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	semaIndex	_ self stackIntegerValue: 0.	writeFlag	_ self booleanValueOf: (self stackValue: 1).	fileName	_ self stackObjectValue: 2.	successFlag ifFalse: [^ nil].	fmt _ self formatOf: fileName.	self success: (fmt >= 8 and: [fmt <= 11]).  "fileName is bytes, but not a CompiledMethod"	fileNameSize _ self lengthOf: fileName.	successFlag ifTrue: [		fOop _ self instantiateClass: (self splObj: ClassByteArray)					indexableSize: (self cCode: 'sizeof(AsyncFile)').		f _ self asyncFileValueOf: fOop].	successFlag ifTrue: [		self cCode: 'asyncFileOpen(f, fileName + 4, fileNameSize, writeFlag, semaIndex)'].	successFlag ifTrue: [		self pop: 4.  "pop fileName, writeFlag, semaIndex, and rcvr"		self push: fOop].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileReadResult	| f count startIndex buffer fmt bufferSize bufferPtr r |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	f			_ self asyncFileValueOf: (self stackValue: 3).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		r _ self cCode: 'asyncFileReadResult(f, bufferPtr, count)'].	successFlag ifTrue: [		self pop: 5.  "pop 4 args and rcvr"		self pushInteger: r].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileReadStart	| f fPosition count |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	fPosition	_ self stackIntegerValue: 1.	f			_ self asyncFileValueOf: (self stackValue: 2).	successFlag ifTrue: [self cCode: 'asyncFileReadStart(f, fPosition, count)'].	successFlag ifTrue: [self pop: 3].  "pop f, fPosition, count; leave rcvr on stack"! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileWriteResult	| f r |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [r _ self asyncFileWriteResult: f].	successFlag ifTrue: [		self pop: 2.  "pop f, rcvr"		self pushInteger: r].! !!DynamicInterpreter methodsFor: 'async file primitives' stamp: 'jm 6/28/1998 13:55'!primitiveAsyncFileWriteStart	| f count startIndex buffer fPosition fmt bufferSize bufferPtr |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	fPosition	_ self stackIntegerValue: 3.	f			_ self asyncFileValueOf: (self stackValue: 4).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		self cCode: 'asyncFileWriteStart(f, fPosition, bufferPtr, count)'].	successFlag ifTrue: [self pop: 5].  "pop 5 args; leave rcvr on stack"! !!DynamicInterpreterState class methodsFor: 'class initialization' stamp: 'jm 9/22/1998 16:58'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!EToySystem class methodsFor: 'development support' stamp: 'di 9/14/1998 10:02'!loadJanForms	"EToySystem loadJanForms"	| aReferenceStream newFormDict |	aReferenceStream _ ReferenceStream fileNamed: 'JanForms'.	newFormDict _ aReferenceStream next.	aReferenceStream close.	newFormDict associationsDo:		[:assoc | Smalltalk imageImports add: assoc]! !!EToySystem class methodsFor: 'external release' stamp: 'sw 9/15/1998 16:58'!methodsToStripForExternalRelease	"Answer a list of triplets #(className, class/instance, methodName) of methods to be stripped in an external release."	^ #(		(EToySystem			class		serverUrls)		(EToySystem			class		eToyDoItStrings)		(EToySystem			class		loadPurpleWalt)			(EToySystem			class		readCollagePic)			(EToySystem			class		prepareRelease)			(EToySystem			class		previewEToysOn:)		)! !!EToySystem class methodsFor: 'stripped' stamp: 'di 9/23/1998 17:54'!eToyDoItStrings	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 9/23/1998 17:54'!loadPurpleWalt	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 9/23/1998 17:54'!prepareRelease	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 9/23/1998 17:54'!previewEToysOn: arg1	self codeStrippedOut: '2.0BetaExternal'! !!EToySystem class methodsFor: 'stripped' stamp: 'di 9/23/1998 17:54'!readCollagePic	self codeStrippedOut: '2.0BetaExternal'! !!EllipseMorph methodsFor: 'all' stamp: 'di 6/24/1998 14:27'!areasRemainingToFill: aRectangle	"Could be improved by quick check of inner rectangle"	^ Array with: aRectangle! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/17/1998 15:20'!attackTime	"Return the time taken by the attack phase."	^ (points at: loopStartIndex) x! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:10'!centerPitch: aNumber	"Set the center pitch of a pitch-controlling envelope. This default implementation does nothing."! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/19/1998 09:07'!duration: seconds	"Set the note duration to the given number of seconds."	"Details: The duration is reduced by 19 mSec to ensure proper cutoffs even when the sound starts playing between doControl epochs."	"Note: This is a hack. With a little additional work on the envelope logic, it should be possible to reduce or eliminate this fudge factor. In particular, an envelope should use the time remaining, rather than time-since-start to determine when to enter its decay phase. In addition, an envelope must be able to cut off in minimum time (~5-10 msec) if there isn't enough time to do their normal decay. All of this is to allow instruments with leisurely decays to play very short notes if necessary (say, when fast-forwarding through a score)." 	| attack decay endTime |	endMSecs _ (seconds * 1000.0) asInteger - 19.	attack _ self attackTime.	decay _ self decayTime.	endMSecs > (attack + decay)		ifTrue: [endTime _ endMSecs - decay]		ifFalse: [			endMSecs >= attack				ifTrue: [endTime _ attack]				ifFalse: [endTime _ endMSecs]].	self sustainEnd: (endTime max: 0).! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:03'!name	^ self updateSelector allButLast! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:13'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope. This default implementation does nothing."! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 11:31'!editSound: aSound	| p |	sound _ aSound.	sound envelopes isEmpty ifTrue: [		"provide a default volume envelope"		p _ OrderedCollection new.		p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.		sound addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3)].	self editEnvelope: sound envelopes first.	keyboard soundPrototype: sound.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 10:40'!initOnSound: aSound title: title	sound _ aSound.	soundName _ title.	self initialize.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 11:02'!initialize	super initialize.	prevMouseDown _ false.	showAllEnvelopes _ true.	self editSound: (sound ifNil: [FMSound brass1 copy]).	soundName ifNil: [soundName _ 'test'].	sampleDuration _ 250.  sound duration: sampleDuration.	sound duration: sampleDuration / 1000.0.	denominator _ 7.	self extent: 10@10.  "ie the minimum"! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:59'!addControls	| chooser |	chooser _ PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'editing ' , envelope name;		target: self;		actionSelector: #chooseFrom:envelopeItem:;		getItemsSelector: #curveChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topLeft with: graphArea bounds bottomLeft + (0@5).	chooser _ PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'duration: ' , self durationName;		target: self;		actionSelector: #chooseFrom:durationItem:;		getItemsSelector: #durationChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topRight with: graphArea bounds bottomRight + (-50@5).! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:49'!addKeyboard	keyboard _ PianoKeyboardMorph new soundPrototype: sound.	keyboard align: keyboard bounds bottomCenter with: bounds bottomCenter - (0@4).	self addMorph: keyboard! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:56'!buildGraphAreaIn: frame	| r y |	graphArea _ RectangleMorph		newBounds: ((frame left + 40) @ (frame top + 40)		corner: (frame right+1) @ (frame bottom - 60))		color: Color lightGreen lighter lighter.	graphArea borderWidth: 1.	self addMorph: graphArea.	(envelope updateSelector = #pitch: and: [envelope scale <= 2.0]) ifTrue:		["Show half-steps"		r _ graphArea innerBounds.		0.0 to: 1.0 by: 1.0/12.0/envelope scale do:			[:val |			y _ self yFromValue: val.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].	(envelope updateSelector = #ratio: and: [denominator ~= 9999]) ifTrue:		["Show denominator gridding"		r _ graphArea innerBounds.		(0.0 to: 1.0 by: 1.0/denominator/envelope scale) do:			[:v |			y _ self yFromValue: v.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 13:16'!buildView	| frame |	self color: Color lightGreen.	self removeAllMorphs.	frame _ self innerBounds.	self buildGraphAreaIn: frame.	self buildScalesIn: frame.	self addHandlesIn: frame.	self addCurves.	line addHandles.	self addControls.	self addKeyboard! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:57'!durationChoices	^ #(	'125ms'	'250ms'	'500ms'	'1000ms'	'2000ms'	'other'	'held'	)! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 16:29'!durationName	self durationChoices do:		[:c | c asNumber = sampleDuration ifTrue: [^ c]].	sampleDuration = 9999 ifTrue: [^ 'held'].	^ sampleDuration printString! !!EnvelopeEditorMorph methodsFor: 'scaling' stamp: 'di 9/4/1998 16:03'!extent: newExtent	super extent: (newExtent max: (self maxTime//10*3+50 max: 355) @ 284).	self buildView! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 9/5/1998 10:45'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	menu addLine.	envelope updateSelector = #ratio: ifTrue:		[menu add: 'choose denominator...' action: #chooseDenominator:].	menu add: 'adjust scale...' action: #adjustScale:.	SoundPlayer isReverbOn		ifTrue: [menu add: 'turn reverb off' target: SoundPlayer selector: #stopReverb]		ifFalse: [menu add: 'turn reverb on' target: SoundPlayer selector: #startReverb].	menu addLine.	menu add: 'get sound from lib' action: #chooseSound:.	menu add: 'put sound in lib' action: #saveSound:.	menu add: 'read sound from disk...' action: #readFromDisk:.	menu add: 'save sound on disk...' action: #saveToDisk:.	menu add: 'save library on disk...' action: #saveLibToDisk:.! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 9/5/1998 10:49'!chooseFrom: chooserMorph durationItem: item	| str |	item asNumber ~= 0 ifTrue: [sampleDuration _ item asNumber].	item = 'other' ifTrue:		[str _ FillInTheBlank request: 'duration in milliseconds'						initialAnswer: sampleDuration printString.		sampleDuration _ str asNumber].	item = 'held' ifTrue: [sampleDuration _ 9999].	sound duration: sampleDuration / 1000.0.	chooserMorph contentsClipped: 'duration: ' , self durationName! !!EnvelopeEditorMorph methodsFor: 'stepping' stamp: 'di 9/5/1998 10:56'!step	| mouseDown hand |	hand _ self world hands first.	(bounds containsPoint: hand position) ifFalse: [^ self].	mouseDown _ hand lastEvent redButtonPressed.	mouseDown not & prevMouseDown ifTrue:		["Mouse just went up"		limitXs = (limits collect: [:i | (envelope points at: i) x]) ifFalse:			["Redisplay after changing limits"			self editEnvelope: envelope]].	prevMouseDown _ mouseDown! !!EventHandler methodsFor: 'initialization' stamp: 'di 9/15/1998 16:35'!forgetDispatchesTo: aSelector	"aSelector is no longer implemented by my corresponding Player, so don't call it any more"	mouseDownSelector == aSelector		ifTrue: [mouseDownRecipient _ mouseDownSelector _ nil].	mouseStillDownSelector == aSelector		ifTrue: [mouseStillDownRecipient _ mouseStillDownSelector _ nil].	mouseUpSelector == aSelector		ifTrue: [mouseUpRecipient _ mouseUpSelector _ nil].	mouseEnterSelector == aSelector		ifTrue: [mouseEnterRecipient _ mouseEnterSelector _ nil].	mouseLeaveSelector == aSelector		ifTrue: [mouseLeaveRecipient _ mouseLeaveSelector _ nil].	mouseEnterDraggingSelector == aSelector		ifTrue: [mouseEnterDraggingRecipient _ mouseEnterDraggingSelector _ nil].	mouseLeaveDraggingSelector == aSelector		ifTrue: [mouseLeaveDraggingRecipient _ mouseLeaveDraggingSelector _ nil].	keyStrokeSelector == aSelector		ifTrue: [keyStrokeRecipient _ keyStrokeSelector _ nil].! !!EventHandler methodsFor: 'initialization' stamp: 'di 9/15/1998 16:35'!on: eventName send: selector to: recipient	eventName = #mouseDown ifTrue:		[mouseDownRecipient _ recipient.  mouseDownSelector _ selector. ^ self].	eventName = #mouseStillDown ifTrue:		[mouseStillDownRecipient _ recipient.  mouseStillDownSelector _ selector. ^ self].	eventName = #mouseUp ifTrue:		[mouseUpRecipient _ recipient.  mouseUpSelector _ selector. ^ self].	eventName = #mouseEnter ifTrue:		[mouseEnterRecipient _ recipient.  mouseEnterSelector _ selector. ^ self].	eventName = #mouseLeave ifTrue:		[mouseLeaveRecipient _ recipient.  mouseLeaveSelector _ selector. ^ self].	eventName = #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient _ recipient.  mouseEnterDraggingSelector _ selector. ^ self].	eventName = #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient _ recipient.  mouseLeaveDraggingSelector _ selector. ^ self].	eventName = #keyStroke ifTrue:		[keyStrokeRecipient _ recipient.  keyStrokeSelector _ selector. ^ self].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'testing' stamp: 'di 9/15/1998 16:35'!handlesMouseOverDragging: evt	mouseEnterDraggingRecipient ifNotNil: [^ true].	mouseLeaveDraggingRecipient ifNotNil: [^ true].	^ false! !!EventHandler methodsFor: 'events' stamp: 'di 9/15/1998 16:35'!mouseEnterDragging: event fromMorph: sourceMorph	^ self send: mouseEnterDraggingSelector to: mouseEnterDraggingRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'di 9/15/1998 16:35'!mouseLeaveDragging: event fromMorph: sourceMorph	^ self send: mouseLeaveDraggingSelector to: mouseLeaveDraggingRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'access' stamp: 'di 9/15/1998 16:35'!firstMouseSelector	"Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"	mouseDownSelector ifNotNil: [^ mouseDownSelector].	mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].	mouseUpSelector ifNotNil: [^ mouseUpSelector].	mouseEnterSelector ifNotNil: [^ mouseEnterSelector].	mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].	mouseEnterDraggingSelector ifNotNil: [^ mouseEnterDraggingSelector].	mouseLeaveDraggingSelector ifNotNil: [^ mouseLeaveDraggingSelector].	^ nil! !!EventHandler methodsFor: 'access' stamp: 'di 9/15/1998 16:35'!messageList	"Return a list of 'Class selector' for each message I can send.  tk9/13/97"	| list |	list _ SortedCollection new.	mouseDownRecipient ifNotNil:		[list add: (mouseDownRecipient class classThatUnderstands:					mouseDownSelector) name , ' ', mouseDownSelector].	mouseStillDownRecipient ifNotNil:		[list add: (mouseStillDownRecipient class classThatUnderstands:					mouseStillDownSelector) name , ' ', mouseStillDownSelector].	mouseUpRecipient ifNotNil:		[list add: (mouseUpRecipient class classThatUnderstands:					mouseUpSelector) name , ' ', mouseUpSelector].	mouseEnterRecipient ifNotNil:		[list add: (mouseEnterRecipient class classThatUnderstands:					mouseEnterSelector) name , ' ', mouseEnterSelector].	mouseLeaveRecipient ifNotNil:		[list add: (mouseLeaveRecipient class classThatUnderstands:					mouseLeaveSelector) name , ' ', mouseLeaveSelector].	mouseEnterDraggingRecipient ifNotNil:		[list add: (mouseEnterDraggingRecipient class classThatUnderstands:					mouseEnterDraggingSelector) name , ' ', mouseEnterDraggingSelector].	mouseLeaveDraggingRecipient ifNotNil:		[list add: (mouseLeaveDraggingRecipient class classThatUnderstands:					mouseLeaveDraggingSelector) name , ' ', mouseLeaveDraggingSelector].	keyStrokeRecipient ifNotNil:		[list add: (keyStrokeRecipient class classThatUnderstands:					keyStrokeSelector) name , ' ', keyStrokeSelector].	^ list! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseDownSelector	^ mouseDownSelector! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseUpSelector	^ mouseUpSelector! !!EventHandler methodsFor: 'access' stamp: 'sw 9/21/1998 12:07'!printOn: aStream	| aVal |	super printOn: aStream.	#('mouseDownSelector' 'mouseStillDownSelector' 'mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingSelector' 'keyStrokeSelector') do:		[:aName | (aVal _ self instVarNamed: aName) ~~ nil ifTrue:			[aStream nextPutAll: '; ', aName, '=', aVal]]! !!EventHandler methodsFor: 'object fileIn' stamp: 'di 9/15/1998 16:35'!convertmmmmmmmmmmkkv0: varDict mmmmmmmmmmmmmmkkv0: smartRefStrm	"These variables are automatically stored into the new instance ('mouseDownRecipient' 'mouseDownSelector' 'mouseStillDownRecipient' 'mouseStillDownSelector' 'mouseUpRecipient' 'mouseUpSelector' 'mouseEnterRecipient' 'mouseEnterSelector' 'mouseLeaveRecipient' 'mouseLeaveSelector' 'keyStrokeRecipient' 'keyStrokeSelector' 'valueParameter' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('mouseEnterDraggingRecipient' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingRecipient' 'mouseLeaveDraggingSelector' ) and deal with the information in ()"! !!EventRecorder methodsFor: 'as yet unclassified' stamp: 'jm 5/29/1998 14:21'!testControl: anEvent	"See if it is a control event for me.  Control 1 = start recordingControl 2 = stop recording (or playing back)Control 3 = start playing back"	anEvent isKeystroke ifFalse: [^ self].	anEvent controlKeyPressed ifFalse: [^ self].	anEvent commandKeyPressed ifTrue: [^ self].	"not this"	anEvent macOptionKeyPressed ifTrue: [^ self].	"not this"	anEvent shiftPressed ifTrue: [^ self].	"not this"	anEvent keyCharacter = $1 ifTrue: ["start recording"		tape ifNil: [tape _ OrderedCollection new].		state _ #record].	anEvent keyCharacter = $2 ifTrue: ["stop recording (or playing back)"		state _ nil].	anEvent keyCharacter = $3 ifTrue: ["start playing back"		state _ #play.		tape ifNotNil: [			tape do: [:evt | 				anEvent hand world runStepMethods.				anEvent hand handleEvent: evt.				anEvent hand world displayWorld]].		state _ nil].! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!imagData	^ imagData! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!realData	^ realData! !!FFT methodsFor: 'testing' stamp: 'jm 8/16/1998 17:36'!samplesPerCycleForIndex: i	"Answer the number of samples per cycle corresponding to a power peak at the given index. Answer zero if i = 1, since an index of 1 corresponds to the D.C. component."	| windowSize |	windowSize _ 2 raisedTo: nu.	(i < 1 or: [i > (windowSize // 2)]) ifTrue: [^ self error: 'index is out of range'].	i = 1 ifTrue: [^ 0].  "the D.C. component"	^ windowSize asFloat / (i - 1)! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/5/1998 11:44'!initialize	super initialize.	waveTable _ SineTable.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: 440.0 dur: 1.0 loudness: 0.2.! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:08'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(FMSound pitch: 'a4' dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	modulation ifNil: [modulation _ 0.0].	multiplier ifNil: [multiplier _ 0.0].	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!FMSound methodsFor: 'initialization' stamp: 'jm 9/20/1998 10:10'!setWavetable: anArray	"(AbstractSound lowMajorScaleOn: (FMSound new setWavetable: AA)) play"	| samples p dur vol |	"copy the array into a SoundBuffer if necessary"	anArray class isPointers		ifTrue: [samples _ SoundBuffer fromArray: anArray]		ifFalse: [samples _ anArray].	p _ self pitch.	dur _ self duration.	vol _ self loudness.	waveTable _ samples.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: p dur: dur loudness: vol.! !!FMSound methodsFor: 'accessing' stamp: 'jm 9/9/1998 07:49'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!FMSound methodsFor: 'accessing' stamp: 'jm 8/7/1998 15:45'!pitch	^ (self samplingRate asFloat * scaledIndexIncr / ScaleFactor) asFloat / waveTable size! !!FMSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:55'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/6/1998 10:26'!initialize	"Build a sine wave table."	"FMSound initialize"	| tableSize radiansPerStep peak |	tableSize _ 4000.	SineTable _ SoundBuffer newMonoSampleCount: tableSize.	radiansPerStep _ (2.0 * Float pi) / tableSize asFloat.	peak _ ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: tableSize do: [:i |		SineTable at: i put: (peak * (radiansPerStep * (i - 1)) sin) rounded].! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/5/1998 14:22'!sineTable	"Answer a SoundBuffer containing one complete cycle of a sine wave."	^ SineTable! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:28'!bass1	"FMSound bass1 play"	"(FMSound lowMajorScaleOn: FMSound bass1) play"	| snd |	snd _ FMSound new modulation: 0 multiplier: 0.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.95).	^ snd setPitch: 220 dur: 1.0 loudness: 0.3! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:06'!brass1	"FMSound brass1 play"	"(FMSound lowMajorScaleOn: FMSound brass1) play"	| snd p env |	snd _ FMSound new modulation: 0 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 30@0.8; add: 90@1.0; add: 120@0.9; add: 220@0.7; add: 320@0.9; add: 360@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).	p _ OrderedCollection new.	p add: 0@0.5; add: 60@1.0; add: 120@0.8; add: 220@0.65; add: 320@0.8; add: 360@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env target: snd; updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:05'!brass2	"FMSound brass2 play"	"(FMSound lowMajorScaleOn: FMSound brass2) play"	| snd p env |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 20@1.0; add: 40@0.9; add: 100@0.7; add: 160@0.9; add: 200@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.5; add: 30@1.0; add: 40@0.8; add: 100@0.7; add: 160@0.8; add: 200@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute1	"FMSound flute1 play"	"(FMSound majorScaleOn: FMSound flute1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute2	"FMSound flute2 play"	"(FMSound majorScaleOn: FMSound flute2) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:26'!oboe1	"FMSound oboe1 play"	"(FMSound majorScaleOn: FMSound oboe1) play"	| snd p |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:26'!oboe2	"FMSound oboe2 play"	"(FMSound majorScaleOn: FMSound oboe2) play"	| snd p |	snd _ FMSound new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	snd addEnvelope: (RandomEnvelope for: #pitch:).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:01'!organ1	"FMSound organ1 play"	"(FMSound majorScaleOn: FMSound organ1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 60@1.0; add: 125@0.8; add: 200@1.0; add: 250@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:00'!randomWeird1	"FMSound randomWeird1 play"	| snd p |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	p _ Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.	snd addEnvelope: (PitchEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:57'!randomWeird2	"FMSound randomWeird2 play"	| snd |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	snd addEnvelope: (PitchEnvelope exponentialDecay: 0.98).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !A minimal FTP client program.  Could store all state in inst vars, and use an instance to represent the full state of a connection in progress.  But simpler to do all that in one method and have it be a complete transaction.Always operates in passive mode (PASV).  All connections are initiated from client in order to get through firewalls.See ServerDirectory openFTP, ServerDirectory getFileNamed:, ServerDirectory putFile:named: for examples of use.See TCP/IP, second edition, by Dr. Sidnie Feit, McGraw-Hill, 1997, Chapter 14, p311.!]style[(259 1 89 23 2 29 2 30 27 6 74)f1,f1-,f1,f1LServerDirectory openFTP;,f1,f1LServerDirectory getFileNamed:;,f1,f1LServerDirectory putFile:named:;,f1,f1b,f1!!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket	^ dataSocket! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket: dd	dataSocket _ dd! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 21:56'!getAllData	"Reel in all data until the server closes the connection.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:03'!getAllDataWhileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:05'!getDataTo: dataStream whileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf _ String new: 4000.	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	dataStream reset.	"position: 0."	^ dataStream! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/13/1998 09:54'!lookFor: beginning        "Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."        | resp what all |        readAhead size > 0                ifTrue: [resp _ readAhead removeFirst]  "response already came in"                ifFalse: [                        all _ self getResponseUpTo: CrLf.                        resp _ all at: 1.       "150 Opening binary mode data conn"                        readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].        Transcript show: resp; cr.        resp size > 0                 ifTrue: [                        resp first isDigit ifFalse: [ ^self lookFor: beginning ].  "we're in the middle of a line, not the end." #XXX. "this should be fixed..."                        (resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"                        (resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"                        "((resp at: 1) isDigit) & ((resp at: 1) digitValue < 4) ifTrue: [^ self lookFor: beginning]."                                "the way I used to detect comments"                        ]                ifFalse: [resp _ '[timeout]'].        what _ (PopUpMenu labels: 'OK\ debug ' withCRs)                 startUpWithCaption: 'Server reported this error:\' withCRs, resp.        what = 2 ifTrue: [self halt].        self destroy.        ^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum	^ portNum! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum: anInteger	portNum _ anInteger! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 11:59'!responseCheck	"If data is waiting, do a responseOK to catch any error reports."	self dataAvailable ifTrue: [^ self responseOK].	^ true	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 12:28'!responseError	"If data is waiting, Check it to catch any error reports.  Keep all responses in a queue for caller to examine later."	| all what |	self dataAvailable ifTrue: [		all _ self getResponseUpTo: CrLf.		readAhead ifNil: [readAhead _ OrderedCollection new].		readAhead addLast: (all at: 1).	"150 Opening binary mode data conn"		readAhead addAll: ((all at: 3) findBetweenSubStrs: (Array with: CrLf)).		readAhead do: [:resp |			((resp at: 1) == $5) | ((resp at: 1) == $4) ifTrue: [				what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 					startUpWithCaption: 'Server reported this error:\' withCRs, resp.				what = 2 ifTrue: [self halt].				self sendCommand: 'QUIT'.				readAhead _ nil.	"clear queue"				self responseOK.		"221"				self destroy.				^ true]]].	^ false	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 4/26/1998 09:33'!responseOK	"Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog and kill the socket.  Return true if OK, the error string if not."	| resp what all |	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	Transcript show: resp; cr.	resp size > 0 		ifTrue: [((resp at: 1) == $5) | ((resp at: 1) == $4) ifFalse: [^ true]]  "All is well"		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FileDirectory methodsFor: 'enumeration' stamp: 'wod 6/16/1998 15:07'!statsForDirectoryTree: rootedPathName	"Return the size statistics for the entire directory tree starting at the given root. The result is a three element array of the form: (<number of folders><number of files><total bytes in all files>). This method also serves as an example of how recursively enumerate a directory tree."	"wod 6/16/1998: add Cursor wait, and use 'self pathNameDelimiter asString' rather than hardwired ':' "	"FileDirectory default statsForDirectoryTree: '\smalltalk'"	| dirs files bytes todo p entries |	Cursor wait showWhile: [		dirs _ files _ bytes _ 0.		todo _ OrderedCollection with: rootedPathName.		[todo isEmpty] whileFalse: [			p _ todo removeFirst.			entries _ self directoryContentsFor: p.			entries do: [:entry |				(entry at: 4)					ifTrue: [						todo addLast: (p, self pathNameDelimiter asString, (entry at: 1)).						dirs _ dirs + 1]					ifFalse: [						files _ files + 1.						bytes _ bytes + (entry at: 5)]]]].	^ Array with: dirs with: files with: bytes! !!FileDirectory methodsFor: 'private' stamp: 'jm 8/14/1998 16:44'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	| entries index done entryArray |	entries _ OrderedCollection new: 200.	index _ 1.	done _ false.	[done] whileFalse: [		entryArray _ self primLookupEntryIn: fullPath index: index.		#badDirectoryPath = entryArray ifTrue: [^ OrderedCollection new].		entryArray == nil			ifTrue: [done _ true]			ifFalse: [entries addLast: (DirectoryEntry fromArray: entryArray)].		index _ index + 1].	^ entries asArray! !!FileDirectory methodsFor: 'private' stamp: 'jm 8/14/1998 16:43'!primLookupEntryIn: fullPath index: index	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty string enumerates the top-level files or drives. (For example, on Unix, the empty path enumerates the contents of '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 162>	^ #badDirectoryPath! !!FileDirectory methodsFor: 'file status' stamp: 'ls 5/7/98 21:54'!entryAt: fileName  	"find the entry with local name fileName"	^self entryAt: fileName ifAbsent: [ self error: 'file not indirectory: ', fileName ].! !!FileDirectory methodsFor: 'file status' stamp: 'ls 5/7/98 21:53'!entryAt: fileName  ifAbsent: aBlock	"find the entry with local namefileName"	^self entries 		detect: [ :entry | (entry at: 1) =fileName ] 		ifNone: [ aBlock value ]! !!FileDirectory class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 00:59'!forFileName: aString	| path |	path _ self dirPathFor: aString.	path isEmpty ifTrue: [^ self default].	^ self on: path! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:32'!changeSuffix"if 'changes' is not suitable, override this message to return something that is ok"	^'changes'! !!FileDirectory class methodsFor: 'name utilities' stamp: 'TPR 5/10/1998 21:31'!imageSuffix"if 'image' is not suitable, override this message to return something that is ok"	^'image'! !!FileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:49'!pathNameDelimiter"return the active directory class's directory seperator character"	^ DirectoryClass pathNameDelimiter! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:47'!activeDirectoryClass	"Return the concrete FileDirectory subclass for the platform on which we are currently running."	FileDirectory allSubclasses do: [:class |		class isActiveDirectoryClass ifTrue: [^ class]].	"no responding subclass; use FileDirectory"	^ FileDirectory! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:40'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	Default test is whether the primPathNameDelimiter matches the one for this class. Other tests are possible"	^self pathNameDelimiter = self primPathNameDelimiter! !I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!FileList methodsFor: 'initialization' stamp: 'di 5/25/1998 10:26'!directory: dir	"Set the path of the volume to be displayed."	sortMode == nil ifTrue: [sortMode _ #date].	self okToChange ifFalse: [^ self].	directory _ dir.	volList _ ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:05'!askServerInfo	"Get the user to create a ServerDirectory for a new server.  Fill in and say Accept."	| template |	template _ '"Please fill in the following info, then select all text and choose DoIt."| aa | aa _ ServerDirectory new.aa server: ''st.cs.uiuc.edu''.    "host"aa user: ''anonymous''.aa password: ''yourEmail@school.edu''.aa directory: ''/Smalltalk/Squeak/Goodies''.aa url: ''''.    "<- this is optional.  Only used when *writing* update files."ServerDirectory addServer: aa named: ''UIUCArchive''.  "<- known by this name in Squeak"'.	(StringHolder new contents: template) openLabel: 'FTP Server Form'	! !!FileList methodsFor: 'volume list and pattern' stamp: 'ls 7/25/1998 01:15'!fileNameFormattedFrom: entry sizePad: sizePad	"entry is a 5-element array of the form:		(name creationTime modificationTime dirFlag fileSize)"	| sizeStr nameStr dateStr |	nameStr _ (entry at: 4)		ifTrue: [entry first , self folderString]		ifFalse: [entry first].	dateStr _ ((Date fromSeconds: (entry at: 3) )					printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,				(String streamContents: [:s |					(Time fromSeconds: (entry at: 3) \\ 86400)						print24: true on: s]).	sizeStr _ (entry at: 5) asStringWithCommas.	sortMode = #name ifTrue:		[^ nameStr , '    (' , dateStr , ' ' , sizeStr , ')'].	sortMode = #date ifTrue:		[^ '(' , dateStr , ' ' , sizeStr , ') ' , nameStr].	sortMode = #size ifTrue:		[^ '(' , ((sizeStr size to: sizePad) collect: [:i | $ ]) , sizeStr , ' ' , dateStr , ') ' , nameStr].! !!FileList methodsFor: 'volume list and pattern' stamp: 'ls 7/15/1998 22:18'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles sortBlock |	entries _ directory entries.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	"create block to decide what order to display the entries"	sortBlock _ [ :x :y |			(x isDirectory = y isDirectory) 				ifTrue: [  					"sort by user-specified criterion"					sortMode = #name 						ifTrue: [(x name compare: y name) <= 2]						ifFalse: [ sortMode = #date							ifTrue: [ x modificationTime = y modificationTime									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x modificationTime > y modificationTime ] ]							ifFalse: [ "size"								x size = y size 									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x fileSize > y fileSize ] ] ] ]				ifFalse: [					"directories always precede files"					x isDirectory ] ].	newList _ (SortedCollection new: 30) sortBlock: sortBlock.	allFiles _ pat = '*'.	entries do:		[:entry | "<dirflag><name><creationTime><modificationTime><fileSize>"		(allFiles or: [pat match: entry first]) ifTrue:			[newList add: entry]].	newList _ newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList asArray.! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:08'!removeServer	| choice names |	names _ ServerDirectory serverNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	ServerDirectory removeServerNamed: choice! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 16:49'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex _ index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim _ directory pathNameDelimiter.				path _ String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState _ #FileList.	self changed: #fileList.	self changed: #contents.! !!FileList methodsFor: 'volume list and pattern' stamp: 'di 5/26/1998 21:07'!volumeMenu: aMenu	^ aMenu		labels:'add server...remove server...'		lines: # ()		selections: #(askServerInfo removeServer)! !!FileList methodsFor: 'file list' stamp: 'di 5/26/1998 20:22'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex _ anInteger.	listIndex = 0 		ifTrue: [fileName _ nil]		ifFalse:			[item _ self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name _ item copyFrom: 1 to: item size - self folderString size.					listIndex _ 0.					brevityState _ #FileList.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [self directory: (directory directoryNamed: name)]]				ifFalse: [fileName _ item]].  "open the file selected"	brevityState _ #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.! !!FileList methodsFor: 'file list menu' stamp: 'ls 7/15/1998 20:59'!addNewDirectory	"Add a new directory and update the list"	| newName index ending |	self okToChange ifFalse: [^ self].	newName _ (FillInTheBlank request: 'New Directory Name?' 					initialAnswer: 'DirectoryName') asFileName.	Cursor wait showWhile: [		(directory createDirectory: newName)].	self updateFileList.	index _ list indexOf: newName.	index = 0 ifTrue: [ending _ ') ',newName.		index _ list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/16/1998 12:22'!deleteFile	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].	(self confirm: 'Really delete ' , fileName , '?') ifFalse: [^ self].	directory deleteFileNamed: fileName.	self updateFileList.	brevityState _ #FileList.	self get! !!FileList methodsFor: 'file list menu' stamp: 'wod 5/24/1998 16:21'!fileAllIn	"File in all of the currently selected file, if any."	"wod 5/24/1998: open the file read only."	| ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: self fullName.	(self fileNameSuffix sameAs: 'html') ifTrue: [ff _ ff asHtml].	ff fileIn.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:06'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 |	firstItems _ self itemsForFileEnding: self fileNameSuffix asLowercase.	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems first size.	n2 _ n1 + secondItems first size.	n3 _ n2 + thirdItems first size.	^ aMenu		labels: firstItems first , secondItems first , thirdItems first , #('more...')		lines: firstItems second				, (Array with: n1 with: n2)				, (thirdItems second collect: [:n | n + n2])				, (Array with: n3)		selections: firstItems third , secondItems third , thirdItems third , #(offerAllFileOptions)! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 10:02'!importImage	"Import the given image file and store the resulting Form in the global dictionary	ImageImports, at a key consisting of the short filename up to the first period.  "	| key image |	key _ fileName sansPeriodSuffix.	image _ Form fromFileNamed: self fullName.	Smalltalk imageImports at: key put: image.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 15:30'!itemsForAnyFile	^ #(('copy name to clipboard' 'rename' 'delete')		()		(copyName renameFile deleteFile)		)! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 07:44'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(suffix = 'bmp') | (suffix = 'gif') | (suffix = 'jpg') | (suffix = 'form') | (suffix = '*') ifTrue:		[labels addAll: #('open image in a window' 'read image into ImageImports').		selectors addAll: #(openImageInWindow importImage)].	(suffix = 'morph') | (suffix = 'morphs') | (suffix = '*') ifTrue:		[labels add: 'load as morph'.		selectors add: #openMorphFromFile].	(suffix = 'mid') | (suffix = '*') ifTrue:		[labels add: 'play midi file'.		selectors add: #playMidiFile].	(suffix = 'movie') | (suffix = '*') ifTrue:		[labels add: 'open as movie'.		selectors add: #openAsMovie].	(suffix = 'st') | (suffix = 'cs') | (suffix = '*') ifTrue:		[suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'broadcast as update').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges putUpdate)].	(suffix = '*') ifTrue:		[labels addAll: #('generate HTML').		lines add: labels size - 1.		selectors addAll: #(renderFile)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 09:33'!itemsForNoFile	^ #(		('sort by name' 'sort by size' 'sort by date'		'add new file' 'add new directory')		(3)		(sortByName sortBySize sortByDate		addNewFile addNewDirectory)		)! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 09:34'!noFileSelectedMenu: aMenu	| items |	items _ self itemsForNoFile.	^ aMenu		labels: items first		lines: items second		selections: items third! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:05'!offerAllFileOptions	| items action |	items _ self itemsForFileEnding: '*'.	action _ (SelectionMenu labels: items first lines: items second selections: items third)			startUp.	action ifNotNil: [self perform: action]! !!FileList methodsFor: 'file list menu' stamp: 'di 8/17/1998 17:31'!openAsMovie	"Open a MoviePlayerMorph on the given file (must be in .movie format)." 	Smalltalk at: #Morph ifAbsent: [^ self beep].	(MoviePlayerMorph new openFileNamed: self fullName) openInWorld! !!FileList methodsFor: 'file list menu' stamp: 'di 9/15/1998 10:03'!openImageInWindow	"Handle four file formats: GIF, JPG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image |	image _ Form fromFileNamed: self fullName.	World		ifNil: [FormView open: image named: fileName]		ifNotNil: [World addMorph: (SketchMorph new form: image)].! !!FileList methodsFor: 'file list menu' stamp: 'sw 9/21/1998 10:59'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream _ directory oldFileNamed: self fullName.	morphOrList _ aFileStream fileInObjectAndCode.	World		ifNotNil:			[World addMorphsAndModel: morphOrList]		ifNil:			[(morphOrList isKindOf: Morph)				ifFalse:					[^ self inform: 'can only load a single morph into an mvc project via this mechanism'].				morphOrList openInWorld]! !!FileList methodsFor: 'file list menu' stamp: 'jm 5/29/1998 17:09'!playMidiFile	"Play a MIDI file." 	| f score |	Smalltalk at: #MIDIFileReader ifPresent: [:midiReader |		Smalltalk at: #ScorePlayerMorph ifPresent: [:scorePlayer |			f _ (directory oldFileNamed: self fullName) binary.			score _ (midiReader new readMIDIFrom: f) asScore.			f close.			scorePlayer openOn: score title: fileName]].! !!FileList methodsFor: 'file list menu' stamp: 'di 5/24/1998 14:09'!putUpdate	"Put this file out as an Update on the servers."	| names choice |	self canDiscardEdits ifFalse: [^ self changed: #flash].	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory groupNamed: choice) putUpdate: 				(directory oldFileNamed: self fullName).! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/3/1998 17:24'!renderFile	"Render the currently selected file"	| map action file renderedFile formatPage |	listIndex = 0 ifTrue: [^ self].	map _ URLmap new.	action _ RenderedSwikiAction new.	action name: '.'.  "For image references, refer to this directory"	map action: action.	map directory: directory.	(directory fileExists: 'glossary')	ifFalse: [Cursor wait showWhile: [		(directory newFileNamed: 'glossary') close].].	map readGlossary: (directory oldFileNamed: 'glossary').	formatPage _ SwikiPage new.	formatPage map: map.	formatPage coreID: (fileName allButFirst).	formatPage formatted: (HTMLformatter		evalEmbedded: (directory oldFileNamed: fileName)contentsOfEntireFile		with: formatPage		unlessContains: (Set new)).	formatPage name isNil		ifTrue: [self notify: 'You forgot to name the page!!<?request name: ''myname''?>'.				formatPage name: 'defaultName'.].	map pages at: (formatPage name asLowercase) put: formatPage.	formatPage formatted: (LessHTMLformatter swikify: (formatPageformatted)			linkhandler: [:link | map					linkFor: link					from: 'Nowhere'					storingTo: OrderedCollection new]).	"Make a template if one does not exist"	(directory fileExists: 'template.html')	ifFalse: [Cursor wait showWhile: [		(directory newFileNamed: 'template.html') nextPutAll: (selftemplateFile); close].].	renderedFile _ (directory pathName),(ServerActionpathSeparator),(formatPage coreID).	(directory fileExists: renderedFile)		ifTrue: [directory deleteFileNamed: renderedFile].	file _ FileStream fileNamed: renderedFile.	file nextPutAll: (HTMLformatter evalEmbedded:		(directory oldFileNamed: 'template.html') contentsOfEntireFile			with: formatPage).	file close.	FileDirectory default setMacFileNamed: renderedFile		type: 'TEXT'		creator: 'MOSS'.	map writeGlossary. "Directory is already in the map, so write tothe glossary there"	self updateFileList.! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/1/1998 14:10'!templateFile	^'<head><title><?request name?></title></head><body><?request formatted?></body>'! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:26'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:25'!defaultContents	contents _ list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED'; cr.					s nextPutAll: '  -- Folder Summary --'; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState _ #FileList.	^ contents! !!FileList methodsFor: 'private'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| i |	(i _ item indexOf: $( ifAbsent: [0]) = 0 ifTrue: [^ item withBlanksTrimmed].	^ (item copyReplaceFrom: i to: (item findFirst: [:c | c = $)]) with: '') withBlanksTrimmed! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:46'!put: aText	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [contents _ aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[PopUpMenu notify: 'No fileName is selected'.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	PopUpMenu notify: type , ' contents cannotmeaningfully be saved at present.'.	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:22'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 30000]) ifTrue:		[contents _ f contentsOfEntireFile.		brevityState _ #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 _ f next: 5000.	f close.	contents _ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', first5000 , '------------------------------------------... end of the first 5000 characters.'.	brevityState _ #briefFile.   "don't change till actually read"	^ contents.! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:20'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read'].	((size _ f size)) > 5000 & brevity		ifTrue: [data _ f next: 10000. f close. brevityState _ #briefHex]		ifFalse: [data _ f contentsOfEntireFile. brevityState _ #fullHex].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData _ s contents.	^ contents _ ((size > 5000) & brevity		ifTrue: ['File ''', fileName, ''' is ', size printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', hexData , '------------------------------------------... end of the first 5000 characters.']		ifFalse: [hexData]).! !!FileList methodsFor: 'private' stamp: 'ls 9/11/1998 04:15'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name _ self fileNameFromFormattedItem: (list at: listIndex)].	sortMode _ newMode.	self pattern: pattern.	name ifNotNil: [		fileName _ name.		listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = name. ].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [self changed: #contents]! !!FileList methodsFor: 'private' stamp: 'wod 5/27/1998 17:47'!updateFileList	"Update my files list with file names in the current directory that match the pattern."	"wod 5/27/1998: nil out the fileName."	Cursor execute showWhile:		[list _ (pattern includes: $*) | (pattern includes: $#)			ifTrue: [self listForPattern: pattern]			ifFalse: [				pattern isEmpty					ifTrue: [self listForPattern: '*']					ifFalse: [self listForPattern: '*', pattern, '*']].		listIndex _ 0.		volListIndex _ volList size.		fileName _ nil.		contents _ ''.		self changed: #volumeListIndex.		self changed: #fileList].! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/25/1998 10:23'!open	"Open a view of an instance of me on the default directory."	"FileList open"	| dir aFileList topView volListView templateView fileListView fileContentsView |	World ifNotNil: [^ self openAsMorph].	dir _ FileDirectory default.	aFileList _ self new directory: dir.	topView _ StandardSystemView new.	topView		model: aFileList;		label: dir pathName;		minimumSize: 200@200.	topView borderWidth: 1.	volListView _ PluggableListView on: aFileList		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: aFileList		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView _ PluggableListView on: aFileList		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	fileContentsView _ PluggableTextView on: aFileList		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 200@140).	topView addSubView: fileContentsView below: templateView.	topView controller open.! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/28/1998 10:37'!openAsMorph     "FileList openAsMorph openInMVC"	"Open a morphic view of a FileList on the default directory."	| dir aFileList window |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	window addMorph: ((PluggableListMorph on: aFileList list: #volumeList selected: #volumeListIndex				changeSelected: #volumeListIndex: menu: #volumeMenu:) autoDeselect: false)		frame: (0@0 corner: 0.3@0.2).	window addMorph: (PluggableTextMorph on: aFileList text: #pattern accept: #pattern:)		frame: (0@0.2 corner: 0.3@0.3).	window addMorph: (PluggableListMorph on: aFileList list: #fileList selected: #fileListIndex				changeSelected: #fileListIndex: menu: #fileListMenu:)		frame: (0.3@0 corner: 1@0.3).	window addMorph: (PluggableTextMorph on: aFileList text: #contents accept: #put:			readSelection: #contentsSelection menu: #fileContentsMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window! !!FileList class methodsFor: 'instance creation' stamp: 'di 5/25/1998 10:22'!openMorphOn: aFileStream editString: editString 	"Open a morphic view of a FileList on the given file."	| fileModel window fileContentsView |	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	window _ (SystemWindow labelled: aFileStream fullName) model: fileModel.	window addMorph: (fileContentsView _ PluggableTextMorph on: fileModel 			text: #contents accept: #put:			readSelection: #contentsSelection 			menu: #fileContentsMenu:shifted:)		frame: (0@0 corner: 1@1).	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	window openInWorld! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!close	"Close this file."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!closed	"Answer true if this file is closed."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:03'!flush	"When writing, flush the current buffer out to disk."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:04'!reopen	"Ensure that the receiver is open, re-open it if necessary."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!ascii	"Set this file to ascii (text) mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!binary	"Set this file to binary mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!readOnly	"Set this file's mode to read-only."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:00'!readWrite	"Set this file's mode to read-write."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!text	"Set this file to text (ascii) mode."	self ascii.! !!FileStream methodsFor: 'fileIn/Out' stamp: 'jm 8/19/1998 16:59'!fileInObjectAndCode	"Optimization: If the file is small, read the entire file into memory before processing."	| s |	self text.	((self size < 1000000) and: [Smalltalk garbageCollectMost > 3000000])		ifTrue: [			s _ RWBinaryOrTextStream with: (self contentsOfEntireFile).			s position: 0.			^ s fileInObjectAndCode]		ifFalse: [^ super fileInObjectAndCode].! !!FileStream class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 05:19'!isAFileNamed: fName	"return whether a file exists with the given name"	^self concreteStream isAFileNamed: fName! !!FileStream class methodsFor: 'concrete classes' stamp: 'ls 7/11/1998 02:58'!concreteStream	"Who should we really direct class queries to?  "	^ StandardFileStream  "may change this to CrLfFileStream"! !A reference to a local file.  The url itself uses the UNIX notation of %20 for space.  path has the tokens translated to ascii, except if we have a UNIX file system. path is OC of path parts.  If last is empty string, then referring to a directory.!!FileUrl methodsFor: 'parsing' stamp: 'tk 9/6/1998 13:05'!privateInitializeFromText: text	| bare schemeName pathString |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	path _ pathString findTokens: '/'.	path _ path collect: [:token | token unescapePercents].	(pathString endsWith: '/') ifTrue: [ path addLast: '' ].	isAbsolute _ pathString beginsWith: '/'.! !!FileUrl methodsFor: 'parsing' stamp: 'tk 9/6/1998 16:40'!privateInitializeFromText: aString relativeTo: aUrl	| bare |	bare _ aString.	(bare beginsWith: (self schemeName, ':')) ifTrue: [		bare _ bare copyFrom: (self schemeName size + 2) to: bare size ].	(bare beginsWith: '/') ifTrue: [ ^self privateInitializeFromText: aString ].	isAbsolute _ aUrl isAbsolute.	path _ aUrl path copy.	path removeLast.	"empty string that says its a directory"	(bare findTokens: '/') do: [ :token |		((token ~= '..') and: [token ~= '.']) ifTrue: [ 			path addLast: token unescapePercents ].		token = '..' ifTrue: [ 			path isEmpty ifFalse: [ 				path last = '..' ifFalse: [ path removeLast ] ] ].		"token = '.' do nothing" ].	(bare endsWith: '/') ifTrue: [ path add: '' ].! !!FileUrl methodsFor: 'printing' stamp: 'tk 9/6/1998 13:08'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	s nextPutAll: self pathString.	fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: fragment encodeForHTTP ].	^s contents! !!FileUrl methodsFor: 'access' stamp: 'ls 8/2/1998 05:39'!isAbsolute	^isAbsolute! !!FileUrl methodsFor: 'access' stamp: 'ls 7/23/1998 07:29'!path	"return an ordered collection of the path elements"	^path! !!FileUrl methodsFor: 'access' stamp: 'tk 9/19/1998 18:57'!path: anArray	path _ anArray! !!FileUrl methodsFor: 'access' stamp: 'tk 9/6/1998 00:35'!pathForFile	"Path using local file system's delimiter.  $\ or $:"	| first |	^String streamContents: [ :s |		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: FileDirectory default pathNameDelimiter ].			first _ false.			s nextPutAll: p ] ]! !!FileUrl methodsFor: 'access' stamp: 'tk 9/6/1998 13:03'!pathString	"Path as it appears in a URL with $/ as delimiter"	| first |	^String streamContents: [ :s |		isAbsolute ifTrue:[ s nextPut: $/ ].		first _ true.		self path do: [ :p |			first ifFalse: [ s nextPut: $/ ].			first _ false.			s nextPutAll: p encodeForHTTP ] ]! !!FileUrl methodsFor: 'downloading' stamp: 'tk 9/6/1998 00:36'!default	"Use the default local Squeak file directory"	| local |	local _ FileUrl new path: (FileDirectory default pathParts), #('')		isAbsolute: true.	self privateInitializeFromText: self pathString relativeTo: local.		"sets absolute also"! !!FileUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:42'!hasContents	^true! !!FileUrl methodsFor: 'downloading' stamp: 'tk 9/5/1998 20:42'!retrieveContents	| file pathString s dir |		pathString _ self pathForFile.	path last size > 0 ifTrue: [		file _ FileStream oldFileOrNoneNamed: pathString.		file ifNotNil: [ 			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: file contentsOfEntireFile ] ].	"assume it's a directory..."	s _ WriteStream on: String new.	dir _ FileDirectory on: pathString.	(pathString endsWith: '/') ifFalse: [ pathString _ pathString, '/' ].	s nextPutAll: '<title>Directory Listing for ', pathString, '</title>'.	s nextPutAll: '<h1>Directory Listing for ', pathString, '</h1>'.	s nextPutAll: '<ul>'.	s cr.	dir entries do: [ :entry |		s nextPutAll: '<li><a href="'.		s nextPutAll: entry name.		s nextPutAll: '">'.		s nextPutAll: entry name.		s nextPutAll: '</a>'.		s cr. ].	s nextPutAll: '</ul>'.	^MIMEDocument  contentType: 'text/html'  content: s contents  url: ('file:', pathString)! !!FileUrl methodsFor: 'private-initialization' stamp: 'ls 7/26/1998 20:43'!path: aCollection isAbsolute: aBoolean	path _ aCollection.	isAbsolute _ aBoolean! !!FileUrl methodsFor: 'classification' stamp: 'ls 7/26/1998 21:11'!schemeName	^'file'! !!FileUrl class methodsFor: 'parsing' stamp: 'tk 9/6/1998 22:48'!absoluteFromText: text	"(how does this method fit with FileUrl|privateInitializeFromText:?)"	| schemeName pathString bare thePath |	bare _ text withBlanksTrimmed.	schemeName _ Url schemeNameForString: bare.	schemeName		ifNil: [ pathString _ bare ]		ifNotNil: [ pathString _ bare copyFrom: (schemeName size + 2) to: bare size ].	thePath _ (pathString findTokens: '/') collect: [:token | token unescapePercents].	(pathString endsWith: '/') ifTrue: [ thePath add: '' ].	^self new path: thePath isAbsolute: (pathString beginsWith: '/')! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:01'!request: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph request: queryString"	^ self request: queryString		initialAnswer: ''		centerAt: Sensor cursorPoint.! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:02'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank		request: 'What is your favorite color?'		initialAnswer: 'red, no blue. Ahhh!!'"	^ self request: queryString		initialAnswer: defaultAnswer		centerAt: Sensor cursorPoint.! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:02'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| model fillInView savedArea |	World ifNotNil:		[^ FillInTheBlankMorph			request: queryString			initialAnswer: defaultAnswer			centerAt: aPoint].	model _ self new initialize.	model contents: defaultAnswer.	fillInView _		(Smalltalk at: #FillInTheBlankView)			on: model			message: queryString			centerAt: aPoint.	savedArea _ Form fromDisplay: fillInView displayBox.	fillInView display.	defaultAnswer isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: defaultAnswer size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ model contents! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'di 9/12/1998 09:26'!setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self extent: 200@70.	self addQuery: queryString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	self addLine.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hasUnacceptedEdits: true.	textPane retractableOrNot.	textPane acceptOnCR: true.	textPane extent: self innerBounds width@answerHeight.	textPane position: self innerBounds left@self lastSubmorph bottom.	self addMorphBack: textPane.	self addLine.	self addButtonRow.	self height: (self height max: (self lastSubmorph bottom - self top) + borderWidth).! !!Float methodsFor: 'truncation and round off' stamp: 'di 7/1/1998 23:01'!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	(self isInfinite or: [self isNaN]) ifTrue: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				^ (self quo: 1073741823.0) * 1073741823 + (self rem: 1073741823.0) truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]! !!Float methodsFor: 'converting' stamp: 'di 7/1/1998 22:20'!asTrueFraction	" Answer a fraction that EXACTLY represents self,	  a double precision IEEE floating point number.	  Floats are stored in the same form on all platforms.	  (Does not handle gradual underflow or NANs.)	  By David N. Smith with significant performance	  improvements by Luciano Esteban Notarfrancesco.	  (Version of 11April97)"	| shifty sign expPart exp fraction fractionPart result zeroBitsCount |	self isInfinite ifTrue: [self error: 'Cannot represent infinity as a fraction'].	self isNaN ifTrue: [self error: 'Cannot represent Not-a-Number as a fraction'].	" Extract the bits of an IEEE double float "	shifty := ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).	" Extract the sign and the biased exponent "	sign := (shifty bitShift: -63) = 0 ifTrue: [1] ifFalse: [-1].	expPart := (shifty bitShift: -52) bitAnd: 16r7FF.	" Extract fractional part; answer 0 if this is a true 0.0 value "	fractionPart := shifty bitAnd:  16r000FFFFFFFFFFFFF.	( expPart=0 and: [ fractionPart=0 ] ) ifTrue: [ ^ 0  ].	" Replace omitted leading 1 in fraction "	fraction := fractionPart bitOr: 16r0010000000000000.	"Unbias exponent: 16r3FF is bias; 52 is fraction width"	exp := 16r3FF + 52 - expPart.	" Form the result. When exp>52, the exponent is adjusted by	  the number of trailing zero bits in the fraction to minimize	  the (huge) time otherwise spent in #gcd:. "	exp negative		ifTrue: [			result := sign * fraction bitShift: exp negated ]		ifFalse:	[			zeroBitsCount _ fraction lowBit - 1.			exp := exp - zeroBitsCount.			exp <= 0				ifTrue: [					zeroBitsCount := zeroBitsCount + exp.					"exp := 0."   " Not needed; exp notrefernced again "					result := sign * fraction bitShift:zeroBitsCount negated ]				ifFalse: [					result := Fraction						numerator: (sign * fractionbitShift: zeroBitsCount negated)						denominator: (1 bitShift:exp) ] ].	"Low cost validation omitted after extensive testing"	"(result asFloat = self) ifFalse: [self error: 'asTrueFraction validation failed']."	^ result ! !!Float methodsFor: 'copying' stamp: 'tk 8/19/1998 16:08'!veryDeepCopyWith: deepCopier	"Return self.  Do not record me."	^ self clone! !!Form methodsFor: 'copying' stamp: 'tk 8/19/1998 16:11'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."	^ self! !!Form methodsFor: 'displaying' stamp: 'di 6/30/1998 21:48'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'displaying' stamp: 'di 6/30/1998 21:49'!paintBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 31		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f replaceColor: f peripheralColor withColor: Color transparent.f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 paintBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait]."! !!Form methodsFor: 'filling' stamp: 'di 6/21/1998 10:21'!anyShapeFill	"Fill the interior of the outtermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape: to paint a solid color.  See also convexShapeFill:"	| shape |	shape _ (self findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'filling' stamp: 'di 9/11/1998 16:25'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.  Typically aMask is Color black, to produce a solid fill. then the resulting form is used with fillShape: to paint a solid color.  See also anyShapeFill"	| destForm tempForm |	destForm _ Form extent: self extent.  destForm fillBlack.	tempForm _ Form extent: self extent.	(0@0) fourNeighbors do:		[:dir |  "Smear self in all 4 directions, and AND the result"		self displayOn: tempForm at: (0@0) - self offset.		tempForm smear: dir distance: (dir dotProduct: tempForm extent) abs.		tempForm displayOn: destForm at: 0@0			clippingBox: destForm boundingBox			rule: Form and fillColor: nil].	destForm displayOn: self at: 0@0		clippingBox: self boundingBox		rule: Form over fillColor: aMask! !!Form methodsFor: 'filling' stamp: 'di 6/11/1998 21:38'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'scaling, rotation' stamp: 'di 8/17/1998 22:17'!magnifyBy: scale 	"Answer a Form created as a scaling of the receiver.	Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: self boundingBox by: scale			smoothing: (scale < 1 ifTrue: [2] ifFalse: [1])! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:04'!peripheralColor  "Form fromUser peripheralColor"	"Return the dominant color as sampled at four corners"	^ (self boundingBox innerCorners collect:		[:p | self colorAt: p]) asBag sortedCounts first value! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!primCountBits	"Count the non-zero pixels of this form."	^ (BitBlt toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:24'!tallyPixelValues	"Return a Bitmap with tallies in it of the number of pixels in this Form that have each pixel value. Note that several Forms may be tallied into the same table by tallyPixelValuesPrimitive:into: with the same table. Also Forms of depth 16 or 32 can be tallied into a tables of size 512, 4096, or 32768 entries by making a direct call with a Bitmap of the given size."	^ self tallyPixelValuesInRect: self boundingBox		into: (Bitmap new: (1 bitShift: (self depth min: 15)))"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 08:24'!tallyPixelValuesInRect: destRect into: valueTable	"Tally the selected pixels of this form into the valueTable, which is	a bitmap similar to a color map.  Since the underlying BitBlt function	that performs the tally does not do bit-boundary clipping, the	tallies for any word-boundary fringes must be subtracted."	self tallyPixelValuesPrimitive: destRect into: valueTable.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:37'!tallyPixelValuesPrimitive: destRect into: valueTable	"Tally the selected pixels of this form into valueTable, a Bitmap similar to a color map, and return valueTable. Since the BitBlt function that performs the tally does not do bit-boundary clipping, the tallies for any word-boundary fringes must be subtracted by the sender."	(BitBlt toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		colorMap: valueTable;		combinationRule: 33;		destRect: destRect;		copyBits.	^ valueTable! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 01:00'!trimToPixelValue: pv orNot: not	"Return the smallest part of me that includes all pixels of value pv.	Note:  If orNot is true, then produce a copy that includes all pixels	that are DIFFERENT from the supplied (background) value"	^ self copy: (self innerPixelRectFor: pv orNot: not)"Try this to select all but the background...Form fromUser in: [:f |(f trimToPixelValue: (f peripheralColor pixelValueForDepth: f depth) orNot: true) display]Or this to select whatever is black...Form fromUser in: [:f |(f trimToPixelValue: (Color black pixelValueForDepth: f depth) orNot: false) display]"! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: 1@height.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Form methodsFor: 'image manipulation' stamp: 'di 6/30/1998 11:19'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: width@1.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 8/5/1998 11:37'!hibernate	"Replace my bitmap with a compactly encoded representation (a ByteArray).  It is vital that BitBlt and any other access to the bitmap (such as writing to a file) not be used when in this state.  Since BitBlt will fail if the bitmap size is wrong (not = bitsSize), we do not allow replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so that it can	nil out the old bits during the copy, thus avoiding 2x need for extra storage."	| compactBits lastByte |	(bits isMemberOf: Bitmap) ifFalse: [^ self  "already hibernated or weird state"].	compactBits _ ByteArray new: (bits size*4) + 7 + (bits size//1984*3).	lastByte _ bits compress: bits toByteArray: compactBits.	lastByte < (bits size*4) ifTrue:		[bits _ nil.  "Let GC reclaim the old bits before the copy if necessary"		bits _ compactBits copyFrom: 1 to: lastByte]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 7/6/1998 23:00'!writeOnMovie: file	"Write just my bits on the file."	self unhibernate.	bits writeUncompressedOn: file! !!Form methodsFor: 'fileIn/Out' stamp: 'di 6/1/1998 20:30'!writeUncompressedOn: file	"Write the receiver on the file in the format		depth, extent, offset, bits."	self unhibernate.	file nextPut: depth.	file nextWordPut: width.	file nextWordPut: height.	file nextWordPut: ((self offset x) >=0					ifTrue: [self offset x]					ifFalse: [self offset x + 65536]).	file nextWordPut: ((self offset y) >=0					ifTrue: [self offset y]					ifFalse: [self offset y + 65536]).	bits writeUncompressedOn: file! !!Form methodsFor: 'transitions' stamp: 'jm 6/1/1998 10:55'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize _ 10.	bb _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: bb extent).	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc _ starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta _ 1@0.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta _ -1@0.					maskLoc _ bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta _ 0@1.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta _ 0@-1.					maskLoc _ bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) in: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]			ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm _ (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect _ smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc _ maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form methodsFor: 'transitions' stamp: 'jm 6/18/1998 12:57'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock	| i clipRect t rectOrList waitTime |	i _ 0.	clipRect _ topLeft extent: otherImage extent.	clipBox ifNotNil: [clipRect _ clipRect intersect: clipBox].	[rectOrList _ rectForIndexBlock value: (i _ i + 1).	 rectOrList == nil]		whileFalse: [			t _ Time millisecondClockValue.			rectOrList asOrderedCollection do: [:r |				self copyBits: r from: otherImage at: topLeft + r topLeft					clippingBox: clipRect rule: Form over fillColor: nil].			Display forceDisplayUpdate.			waitTime _ 3 - (Time millisecondClockValue - t).			waitTime > 0 ifTrue:				["(Delay forMilliseconds: waitTime) wait"]].! !!Form methodsFor: 'as yet unclassified' stamp: 'di 7/8/1998 12:18'!baldMountainWorkspace"   -- Reset player, do this, then play -- 	|  file ff |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	ff _ Form extent: 320@240 depth: 16.	1 to: 338 by: 2 do:		[:i | file position: i-1*153613+1.		ff readFrom: file.		ff display.		[i*124>AA msecsSinceStart] whileTrue: [World doOneCycle].		Sensor yellowButtonPressed ifTrue: [^ file close]].	file close] -- Async version -- |  file ff byteCount nFrames bytesRead di |	file _ AsyncFile new open: 'Bald10fpsAll338.forms' forWrite: false.	ff _ Form extent: 320@240 depth: 16.	byteCount _ ff bits size * 4.	nFrames _ 338.	file primReadStart: file fileHandle fPosition: 1+13 count: byteCount.	1 to: nFrames by: (di_1) do:		[:i |		file waitForCompletion.		bytesRead _ file primReadResult: file fileHandle			intoBuffer: ff bits at: 1 count: byteCount//4.		Sensor anyButtonPressed ifTrue: [^ file close].		(i+di) <= nFrames ifTrue:			[file primReadStart: file fileHandle fPosition: (i-1+di)*(byteCount+13)+1+13 count: byteCount].		ff display.		[i*124>AA msecsSinceStart] whileTrue: [World doOneCycle].		].	file close.	waitTime	| ps zps f32 f16 |	1 to: 338 by: 1 do:		[:i | ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		f32 _ Form fromFile: (FileStream oldFileNamed:			'Macintosh HD:Shipping.Receiving:Bald10fps bmps:Bald' , zps , '.BMP').		f32 displayAt: 0@0.		f16 _ Form extent: f32 extent depth: 16.		f32 displayOn: f16 at: 0@0.		f16 displayAt: 330@0.		Transcript cr; show: i printString.		f16 writeUncompressedOnFileNamed:			'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald' , zps , '.form'.		Sensor anyButtonPressed ifTrue: [^ nil]]	| ps zps  file |	file _ FileStream newFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fpsAll338.forms'.	file binary.	file nextPut: 2.	1 to: 338 by: 1 do:		[:i | ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		(Form fromFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald' , zps , '.form') display; writeUncompressedOn: file.		Sensor anyButtonPressed ifTrue: [^ nil]].	file close	-- convert .forms file to .movie format --	|  out ps zps ff |	out _ FileStream newFileNamed: 'Bald2minAt10fps.movie'.	out binary.	ff _ Form extent: 320@240 depth: 16.	#(22 320 240 16 338) , (6 to: 32)		do: [:i | out nextInt32Put: i].			1 to: 1203 by: 1 do:		[:i | i printString displayAt: 400@0.		ps _ i printString. zps _ ('00000' copyFrom: 1 to: 5 - ps size) , ps.		(Form fromFileNamed: 'BackStreet HD:Bald Mt Disk:Bald2 10fps Proc:Bald10.' , zps) 			displayOn: ff.		ff display; writeOnMovie: out].	out close.	|  file ff |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	ff _ Form extent: 320@240 depth: 16.	1 to: 338 by: 1 do:		[:i | ff  readFrom: file.		ff display.		Sensor anyButtonPressed ifTrue: [^ file close]].	file close]	|  file ff byteCount nFrames filePosition bytesRead waitTime t |Array with: (Time millisecondsToRun: [	file _ AsyncFile new open: 'Bald10fpsAll338.forms' forWrite: false.	ff _ Form extent: 320@240 depth: 16.	waitTime _ 0.	byteCount _ ff bits size * 4.	filePosition _ 1.	nFrames _ 338.	file primReadStart: file fileHandle fPosition: filePosition+13 count: byteCount.	1 to: nFrames by: 1 do:		[:i |		t _ Time millisecondClockValue.		file waitForCompletion.		waitTime _ waitTime + (Time millisecondClockValue - t).		bytesRead _ file primReadResult: file fileHandle			intoBuffer: ff bits at: 1 count: byteCount//4.		filePosition _ filePosition+13 + bytesRead.		Sensor anyButtonPressed ifTrue: [^ file close].		i < nFrames ifTrue:			[file primReadStart: file fileHandle fPosition: filePosition+13 count: byteCount].		ff display].	file close])	with: waitTime (18400 9798 ) | ff | ff _ Form fromFileNamed: 'Macintosh HD:Shipping.Receiving:Bald10fps forms:Bald00338.form'. Time millisecondsToRun: [1 to: 100 do: [:i | ff display]] 100000//1359 73Try out on-the-fly pixel doubling [dummied for timing]... | file f1 f2 f2a pixMap bb1 bb2 |Time millisecondsToRun: [	file _ FileStream oldFileNamed: 'Bald10fpsAll338.forms'.	file binary.	file next = 2 ifFalse: [self halt].	f1 _ Form extent: 320@240 depth: 16.	f2 _ Form extent: 640@480 depth: 16.	f2a _ Form extent: 320@480 depth: 32.	f2a bits: f2 bits.	pixMap _ Bitmap new: 32768.	1 to: 32768 do: [:i | pixMap at: i put: (i bitOr: (i bitShift: 16))].	bb1 _ BitBlt destForm: f2a sourceForm: f1 halftoneForm: nil combinationRule: 3 destOrigin: 0@0 sourceOrigin: 0@0 extent: 320@1 clipRect: f2a boundingBox.	bb1 colorMap: pixMap.	bb2 _ BitBlt destForm: f2 sourceForm: f2 halftoneForm: nil combinationRule: 3 destOrigin: 0@0 sourceOrigin: 0@0 extent: 640@1 clipRect: f2 boundingBox.	1 to: 338 by: 1 do:		[:i | f1  readFrom: file.		bb1 destOrigin: 0@0; sourceOrigin: 0@0.		bb1 destOrigin: 0@0; sourceOrigin: 0@0.		0 to: 239 do:			[:j |			bb1 sourceY: j; destY: j*2; copyBits.			bb2 sourceY: j*2; destY: j*2+1; copyBits].		f2 display.		Sensor anyButtonPressed ifTrue: [^ nil]].	file close] 104512 53247 39812 338000.0/ 53247 6.34777546152835 6 6"! !!Form class methodsFor: 'instance creation' stamp: 'di 9/15/1998 09:47'!fromFileNamed: fileName	"Read a Form or ColorForm from given file in any of four formats."	| file fileCode |	file _ (FileStream readOnlyFileNamed: fileName) binary.	fileCode _ file next.	fileCode = 1 ifTrue:		["Old Squeakform format"		^ self new readFromOldFormat: file].	fileCode = 2 ifTrue:		["New Squeak form format"		^ self new readFrom: file].	fileCode = $B asciiValue ifTrue:		[file skip: - 1.		^ self fromBMPFile: file].	file close.	"Try for JPG, GIF, or PCX..."	^ Smalltalk imageReaderClass formFromFileNamed: fileName! !!FormCanvas methodsFor: 'drawing' stamp: 'di 6/26/1998 15:09'!fillColor: c	"Note: This always fills, even if the color is transparent."	port combinationRule: Form over.	port fillRect: form boundingBox color: (self drawColor: c) offset: 0@0.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:41'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	| rect fillC borderC |	rect _ r.	c isTransparent		ifTrue: [fillC _ nil]		ifFalse: [fillC _ self drawColor: c].	borderColor isTransparent		ifTrue: [			fillC == nil ifTrue: [^ self].  "both border and fill are transparent"			borderC _ nil.			rect _ rect insetBy: borderWidth]		ifFalse: [borderC _ self drawColor: borderColor].	port combinationRule:		(self drawRule: Form over color: c borderColor: borderColor).	port fillOval: (rect translateBy: origin)		color: fillC		borderWidth: borderWidth		borderColor: borderC.! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:33'!fillRectangle: r color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port fillRect: r color: (self drawColor: c) offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 15:41'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rule |	rule _ self drawRule: Form over color: fillColor borderColor: borderColor.	port combinationRule: rule.	borderColor isTransparent ifFalse: [		"draw border of rectangle"		(r area > 10000 or: [fillColor isTransparent or: [rule = Form blend]]) ifTrue: [			port frameRect: (r translateBy: origin)				borderWidth: borderWidth				borderColor: (self drawColor: borderColor).		] ifFalse: [			"for small rectangles, it's faster to fill the entire outer rectangle than to compute and fill the border rects"			port fillRect: r color: (self drawColor: borderColor) offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse: [		port 	fillRect: (r insetBy: borderWidth)				color: (self drawColor: fillColor)				offset: origin].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/3/1998 14:35'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| w h rect |	"First use quick code for top and left borders and fill"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom and right borders"	bottomRightColor isTransparent ifFalse: [		borderWidth isNumber			ifTrue: [w _ h _ borderWidth]			ifFalse: [w _ borderWidth x.   h _ borderWidth y].		rect _ r translateBy: origin.		port fillColor: (self drawColor: bottomRightColor);			 frameRectRight: rect width: w;			 frameRectBottom: rect height: h].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!frameRectangle: r width: w color: c	c isTransparent ifFalse: [		port combinationRule: (self drawRule: Form over color: c).		port frameRect: (r translateBy: origin)			borderWidth: w			borderColor: (self drawColor: c)].! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 brushForm: brush	| offset |	offset _ origin.	port sourceForm: brush; fillColor: nil;		combinationRule: (self drawRule: Form paint color: Color black);		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededForDepth: self depth);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!line: pt1 to: pt2 width: w color: c	| offset |	offset _ origin - (w // 2) asPoint.	port sourceForm: nil;		fillColor: (self drawColor: c);		combinationRule: (self drawRule: Form over color: c);		width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 6/2/1998 07:42'!paragraph: para bounds: bounds color: c	| scanner |	scanner _ port displayScannerFor: para		foreground: (self drawColor: c)		background: Color transparent		rule: (self drawRule: Form paint color: c)		halftone: (shadowDrawing ifTrue: [self drawColor: c] ifFalse: [nil]).	para displayOn: self using: scanner at: (bounds topLeft + origin).! !!FormCanvas methodsFor: 'drawing' stamp: 'di 11/3/97 14:36'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ QuickPrint newOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (shadowDrawing ifTrue: [shadowStipple] ifFalse: [c]).	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 15:27'!drawRule: defaultRule color: color	"Answer the BitBlt combination rule for the given default rule and color. If this canvas is in shadow-drawing mode, answer 'paint'. If the color is translucent, answer 'blend'. Otherwise, answer the given default rule."	shadowDrawing ifTrue: [^ Form paint].	form depth < 32 ifTrue: [^ defaultRule].	(color isColor and: [color alpha < 1.0])		ifTrue: [^ Form blend]		ifFalse: [^ defaultRule].! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 15:32'!drawRule: defaultRule color: color1 borderColor: color2	"Answer the BitBlt combination rule for the given default rule and colors. If this canvas is in shadow-drawing mode, answer 'paint'. If either color is translucent, answer 'blend'. Otherwise, answer the given default rule."	shadowDrawing ifTrue: [^ Form paint].	form depth < 32 ifTrue: [^ defaultRule].	(color1 isColor and: [color1 alpha < 1.0]) ifTrue: [^ Form blend].	(color2 isColor and: [color2 alpha < 1.0]) ifTrue: [^ Form blend].	^ defaultRule! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:40'!setOrigin: aPoint clipRect: aRectangle	super setOrigin: aPoint clipRect: aRectangle.	port clipRect: aRectangle.! !!FormCanvas methodsFor: 'private' stamp: 'jm 6/2/1998 06:41'!stipple: newStipple	shadowStipple _ newStipple.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:46'!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 100@100 color: (Color black).	canvas text: 'Hello, World!!' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red alpha: 0.2).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:11'!test2	"FormCanvas test2"	| baseCanvas p canvas |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		canvas _ baseCanvas copyOffset: (Sensor cursorPoint - p).		canvas fillColor: Color white.		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0].! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 6/2/1998 07:14'!test3	"FormCanvas test3"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: Color white.	canvas _ canvas copyForShadowDrawingOffset: 10@10.	canvas line: 10@10 to: 50@30 width: 1 color: Color red.	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.	canvas point: 100@100 color: Color black.	canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.	canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.	canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.	canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.	canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.	canvas showAt: 0@0.! !!FormEditor class methodsFor: 'private' stamp: 'di 9/12/1998 12:28'!createOnForm: aForm	"Create a StandardSystemView for a FormEditor on the form aForm."	| formView formEditor menuView aView topView extent topViewBorder |	topViewBorder _ 2.	formView _ FormHolderView new model: aForm.	formEditor _ formView controller.	menuView _ FormMenuView new makeFormEditorMenu model: formEditor.	formEditor model: aForm.	aView _ View new.	aView model: aForm.	aView addSubView: formView.	aView 		addSubView: menuView		align: menuView viewport topCenter		with: formView viewport bottomCenter + (0@16).	aView window: 		((formView viewport 			merge: (menuView viewport expandBy: (16 @ 0 corner: 16@16))) 		  expandBy: (0@topViewBorder corner: 0@0)).	topView _ StandardSystemView new.	topView backgroundColor: #veryLightGray.	topView addSubView: aView.	topView label: 'Form Editor'.	topView borderWidth: topViewBorder.	extent _ topView viewport extent.	topView minimumSize: extent.	topView maximumSize: extent.	^topView! !an input instance for a form.  A form takes its input from a collection of FormInputs; each FormInput has a name and can retrieve a textual value.  WHen a form is submitted, these name-value associations are gathered together and passed to an HTTP server.!!FormInput methodsFor: 'testing' stamp: 'ls 8/11/1998 20:43'!isRadioButtonSetInput	^false! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:11'!active	"whether this input is currently providing an input"	^true! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!name	"name associated with this input"	^self subclassResponsibility! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!reset	"reset to a default value"	! !!FormInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:20'!value	"value associated with this input"	^self subclassResponsibility! !Holds the inputs for an instance of an HTML Form.  It has a link to the browser it will be displayed in, and it has a link to each of the input PluggableTextMorph's that it input will read from.inputs - maps HtmlInput's into the text morphs which will input their value.!!FormInputSet methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 03:57'!form: f  browser: b	inputs _ OrderedCollection new.	form _ f.	browser _ b.! !!FormInputSet methodsFor: 'adding inputs' stamp: 'ls 8/5/1998 03:57'!addInput: anInput	inputs add: anInput! !!FormInputSet methodsFor: 'adding inputs' stamp: 'ls 8/11/1998 03:30'!inputs	"return a list of the list of inputs"	^inputs! !!FormInputSet methodsFor: 'action' stamp: 'ls 8/5/1998 03:58'!reset	"reset all inputs to their default value"	inputs do: [ :input | input reset ]! !!FormInputSet methodsFor: 'action' stamp: 'ls 8/11/1998 20:11'!submit	"collect inputs and instruct the browser to do a submission"	| inputValues |	inputValues _ Dictionary new.	inputs do: [ :input |		input active ifTrue: [			(inputValues includesKey: input name) ifFalse: [				inputValues at: input name  put: (OrderedCollection new: 1) ].			(inputValues at: input name)  add: input value ] ].	browser submitFormWithInputs: inputValues  url: form url method: form method.	^true! !!FormInputSet class methodsFor: 'instance creation' stamp: 'ls 7/16/1998 22:01'!forForm: form  andBrowser: browser	"create a FormData for the given form and browser"	^super new form: form  browser: browser! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'di 9/23/1998 10:55'!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex == 0 ifTrue: [^ self].	scale _ self insetDisplayBox extent / model selection extent.	scale _ (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self insetDisplayBox topLeft - model selection offset)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor! !!FormMenuView methodsFor: 'private' stamp: 'jrm 6/1/1998 21:57'!makeColorConnections: indexInterval	| connector buttonCache button aSwitchView |	connector _ Object new.  "a dummy model for connecting dependents"	indexInterval do: [:index |		buttonCache _ FormButtons at: index.		buttonCache initialState = #true			ifTrue: [button _ OneOnSwitch newOn]			ifFalse: [button _ OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView _ self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormMenuView methodsFor: 'private' stamp: 'jrm 6/1/1998 21:56'!makeConnections: indexInterval	| connector buttonCache button aSwitchView |	connector _ Object new.  "a dummy model for connecting dependents."	indexInterval do: [:index |		buttonCache _ FormButtons at: index.		buttonCache initialState = #true			ifTrue: [button _ OneOnSwitch newOn]			ifFalse: [button _ OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView _ self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!FormView class methodsFor: 'examples' stamp: 'di 9/12/1998 10:17'!open: aForm named: aString	"FormView open: ((Form extent: 100@100) borderWidth: 1) named: 'Squeak' "	"Open a window whose model is aForm and whose label is aString."	| topView aView |	topView _ StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: 80@80.	aView _ FormView new.	aView model: aForm.	aView window: (aForm boundingBox expandBy: 2).	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !a reference to a file which may be downloaded by anonymous ftp!!FtpUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 01:24'!retrieveContents	| server contents pathString listing |	"currently assumes directories end in /, and things that don't end in / are files.  Also, doesn't handle errors real well...."	server _ ServerDirectory new.	server server: self authority.	server directory: '/'.	server user: 'anonymous'.	server password: 'SqueakUser'.	pathString _ self pathString.	pathString _ pathString copyFrom: 2 to: pathString size. "remove the leading /"	self path last size = 0 ifFalse: [		"a file"		contents _ (server getFileNamed: pathString).		(contents respondsTo: #contents) ifTrue: [ 			"the file exists--return it"			^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: contents contents ]		ifFalse: [			"some error"			^nil ]. ].	"a directory?"	server directory: self pathString.	listing _ String streamContents: [ :stream |		stream nextPutAll: '<title>', self pathString, '</title>'; cr.		stream nextPutAll: '<h1>Listing for ', self pathString, '</h1>'; cr.		stream nextPutAll: '<ul>'; cr.		server entries do: [ :entry |			stream nextPutAll: '<li>';				nextPutAll: '<a href="', entry name encodeForHTTP.			entry isDirectory ifTrue: [ stream nextPut: $/ ].			stream nextPutAll: '">';				nextPutAll: entry name;				nextPutAll: '</a>';				cr ] ].	^MIMEDocument contentType: 'text/html' content: listing! !!FtpUrl methodsFor: 'access' stamp: 'ls 7/24/1998 00:18'!pathString	self path isEmpty ifTrue: [ ^'/' copy ].	^String streamContents: [ :s |		self path do: [ :p |		 	s nextPut: $/.			s nextPutAll: p ] ]! !!GIFReadWriter methodsFor: 'accessing' stamp: 'di 9/15/1998 09:53'!understandsImageFormat	^('abc' collect: [:x | stream next asCharacter]) = 'GIF'! !a URL type that can't be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.!!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString	schemeName _ Url schemeNameForString: aString.	schemeName ifNil: [ self error: 'opaque URL with no scheme--shouldn''t happen!!'. ].	locator _ aString copyFrom: (schemeName size+2) to: aString size.! !!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString relativeTo: aUrl	schemeName _ aUrl schemeName.	locator _ aString.! !!GenericUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:46'!locator	^locator! !!GenericUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:46'!schemeName	^schemeName! !!GenericUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName0  locator: locator0	schemeName _ schemeName0.	locator _ locator0.! !!GenericUrl methodsFor: 'printing' stamp: 'ls 8/4/1998 02:41'!toText	| s |	s _ WriteStream on: String new.	s nextPutAll: self schemeName.	s nextPut: $:.	s nextPutAll: self locator.	self fragment ifNotNil: [ s nextPut: $#.  s nextPutAll: self fragment ].	^s contents! !!GenericUrl class methodsFor: 'parsing' stamp: 'ls 7/26/1998 21:24'!absoluteFromText: aString	| schemeName locator |	schemeName _ Url schemeNameForString: aString.	schemeName ifNil: [ ^self schemeName: 'xnoscheme' locator: aString ].	locator _ aString copyFrom: (schemeName size + 2) to: aString size.	^self schemeName: schemeName locator: locator! !!GenericUrl class methodsFor: 'instance creation' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName  locator: locator	^self new schemeName: schemeName  locator: locator! !!GradientFillMorph methodsFor: 'drawing' stamp: 'jm 6/1/1998 19:24'!drawOn: aCanvas	"Note that this could run about 4 times faster if we got hold of	the canvas's port and just sent it copyBits with new coords and color" 	| r colors step |	super drawOn: aCanvas.	(color isKindOf: Color) ifFalse: [^ self].  "An InfiniteForm, for example"	(color = Color transparent) ifTrue: [^ self].  "Skip the gradient attempts, which will drop into debugger"	color = fillColor2 ifTrue: [^ self].  "same color; no gradient"	r _ self innerBounds intersect: aCanvas clipRect.	colors _ self colorArrayForDepth: aCanvas depth.	step _ self stepSize.	gradientDirection = #vertical		ifTrue:		[r top to: r bottom-1 by: step do:			[:y | aCanvas fillRectangle: (r left @ y corner: r right @ (y+step min: r bottom))					color: (colors at: y - bounds top //step+1)]]		ifFalse:		[r left to: r right-1 by: step do:			[:x | aCanvas fillRectangle: (x @ r top corner: (x+step min: r right) @ r bottom)					color: (colors at: x - bounds left //step+1)]]! !!GradientFillMorph methodsFor: 'all' stamp: 'jm 6/2/1998 15:57'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	(color isColor and: [color alpha < 1.0]) ifTrue: [^ true].	(fillColor2 isColor and: [fillColor2 alpha < 1.0]) ifTrue: [^ true].	^ false! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:55'!fillColor: aColorOrPattern	aColorOrPattern == lastColor ifTrue: [^ self].	super fillColor: aColorOrPattern.	lastColor _ aColorOrPattern.! !!GrafPort methodsFor: 'all' stamp: 'sw 8/5/1998 12:10'!fillRect: rect color: fillColor offset: aPoint	fillColor class == InfiniteForm ifTrue: 		[self fillColor: nil.		fillColor displayOnPort: ((self clippedBy: (rect translateBy: aPoint)) colorMap: nil) at: aPoint.		^ self].	sourceForm _ nil.	self fillColor: fillColor.	destX _ rect left + aPoint x.	destY _ rect top + aPoint y.	sourceX _ 0.	sourceY _ 0.	width _ rect width.	height _ rect height.	self copyBits.! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:36'!frameRectBottom: rect height: h	sourceForm _ nil.	destX _ rect left + 1.	destY _ rect bottom - 1.	width _ rect width - 2.	height _ 1.	1 to: h do: [:i |		self copyBits.		destX _ destX + 1.		destY _ destY - 1.		width _ width - 2].! !!GrafPort methodsFor: 'all' stamp: 'jm 5/30/1998 07:35'!frameRectRight: rect width: w	sourceForm _ nil.	width _ 1.	height _ rect height - 1.	destX _ rect right - 1.	destY _ rect top + 1.	1 to: w do: [:i |		self copyBits.		destX _ destX - 1.		destY _ destY + 1.		height _ height - 2].! !!GraphMorph methodsFor: 'initialization' stamp: 'jm 7/8/1998 20:31'!initialize	super initialize.	self color: (Color r: 0.8 g: 0.8 b: 0.6).	self extent: 365@80.	self borderWidth: 2.	dataColor _ Color darkGray.	cursor _ 1.0.  "may be fractional"	cursorColor _ Color red.	cursorColorAtZeroCrossings _ Color red.	startIndex _ 1.	self data:		((0 to: 360 - 1) collect:			[:x | (10000.0 * ((4.0 * x) degreesToRadians sin)) asInteger]).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/30/1998 12:17'!centerCursor	"Scroll so that the cursor is as close as possible to the center of my window."	| w |	w _ self width - (2 * borderWidth).	self startIndex: ((cursor - (w // 2)) max: 1).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossing	^ cursorColorAtZeroCrossings! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossings: aColor	cursorColorAtZeroCrossings _ aColor.	self flushCachedForm.! !!GraphMorph methodsFor: 'private' stamp: 'jm 7/8/1998 20:32'!drawPointerOn: aCanvas	| ptr x r c |	ptr _ (cursor asInteger max: 1) min: data size.	c _ cursorColor.	((ptr > 1) and: [ptr < data size]) ifTrue: [		(data at: ptr) sign ~= (data at: ptr + 1) sign			ifTrue: [c _ cursorColorAtZeroCrossings]].	r _ self innerBounds.	x _ r left + ptr - startIndex.	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x + 1@r bottom) color: c].! !!HTMLformatter methodsFor: 'formatting' stamp: 'ls 4/18/98 16:46'!format: requestObject	"format text with requestObject as the argument forthe code blocks"	^String streamContents: [ :stream |	formattingBlock value: requestObject value: stream ]! !!HTMLformatter methodsFor: 'private-initialization' stamp: 'ls 4/18/98 13:23'!formattingBlock: aBlock	formattingBlock _ aBlock! !!HTMLformatter methodsFor: 'private-initialization' stamp: 'mjg 8/28/199820:56'!initialize	specialCharacter = $*.! !!HTMLformatter methodsFor: 'translating' stamp: 'mjg 8/28/1998 21:03'!rangesOfAngleBrackets: sourceStrm	"Return an OrderedCollection of intervals of position within anglebrackets < and >.  Caller wants to avoid putting <br> in there."	| list char intervals start |	list _ OrderedCollection new: 10.	[sourceStrm atEnd] whileFalse: [		(char _ sourceStrm next) == $< ifTrue: [list add:sourceStrm position].	"a start"		char == $> ifTrue: [list add: sourceStrm positionnegated]].	"an end"	sourceStrm reset.	intervals _ OrderedCollection new: 10.	start _ nil.	list do: [:each |		(each > 0) & (start == nil) ifTrue: [start _ each].		(each < 0) & (start ~~ nil) ifTrue: [			intervals add: (start to: each negated). start _ nil]].	^ intervals"	HTMLformatter rangesOfAngleBrackets: (ReadStream on: '1234 <good><456 <good> 567> <ok>')	"! !!HTMLformatter methodsFor: 'translating' stamp: 'mjg 8/31/1998 12:48'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacterasString) startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to:start+1 with: specialCharacter.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection:(specialCharacter asString)  startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom:start to: end						with: (aBlock value: (aLinecopyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>']			ifFalse: [targetStream nextPutAll: aLine].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in aseparator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue:[ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStreamnextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>';cr.]]].	^targetStream contents.! !!HTMLformatter methodsFor: 'accessing' stamp: 'mjg 8/28/1998 21:00'!specialCharacter	^specialCharacter! !!HTMLformatter methodsFor: 'accessing' stamp: 'mjg 8/28/1998 21:01'!specialCharacter: someCharacter	specialCharacter _ someCharacter! !!HTMLformatter class methodsFor: 'translating' stamp: 'ls 4/18/98 16:23'!evalEmbedded: stringOrStream with: request	| formatter |	formatter _self forEvaluatingEmbedded: stringOrStream.	^formatter format: request! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 6/3/98 10:29'!fixForIE: text	| ch targetStream sourceStream |	targetStream := WriteStream on: String new.	sourceStream := ReadStream on: text.	[sourceStream atEnd] whileFalse:	[ch := sourceStream next.	ch = $> ifTrue: [targetStream nextPutAll: '&gt;']	ifFalse: [ch = $< ifTrue: [targetStream nextPutAll: '&lt;']		ifFalse: [targetStream nextPut: ch]].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'tk 7/15/1998 12:02'!forEvaluatingEmbedded: stringOrStream	"stringOrStream is text with <?expr?> expressions intermingled.This creates a HTLMLformatter instance which will substitute the <?expr?>expressions with the value of the argument (named request), and whichleaves all other text in stringOrStream alone"	| blockStream sourceStream doingEval ch |	blockStream _ WriteStream on: String new. 	blockStream nextPutAll: '[ :request :output | output nextPutAll: '''.	(stringOrStream isKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	doingEval _ false.	[sourceStream atEnd] whileFalse:  [		ch := sourceStream next.		(doingEval not and: [ ch = $<  and: [ sourceStream peek =$? ]]) ifTrue: [			"beginning of an <?...?> expression"			blockStream nextPutAll: '''.  output nextPutAll: ['.			sourceStream next.  "Skip the ?"			doingEval _ true]		ifFalse: [		(doingEval and: [ ch = $? and: [ sourceStream peek = $> ]])ifTrue: [			"end of a <?...?> expression"			blockStream nextPutAll: '] value asString.  outputnextPutAll: '''.			sourceStream next.  "Skip the >"			doingEval _ false.]		ifFalse: [			"normal char"			blockStream nextPut: ch.			(doingEval not and: [ ch = $' ]) ifTrue: [				 "double $' marks"  blockStream nextPut: $'] ] ] ].	"end the block"	doingEval		ifTrue: [ blockStream nextPutAll: '] value asString' ]		ifFalse: [ blockStream nextPutAll: '''' ].	blockStream nextPutAll: ']'.	^HTMLformatter new formattingBlock: (Compiler evaluate: blockStreamcontents)! !!HTMLformatter class methodsFor: 'translating' stamp: 'ls 4/18/98 16:38'!oldEvalEmbedded: stringOrStream with: request	| sourceStream targetStreamevalStream currentStream evalValue peekValue ch |	(stringOrStreamisKindOf: Stream)		ifTrue: [sourceStream := stringOrStream]		ifFalse: [sourceStream := ReadStream on: stringOrStream].	targetStream := WriteStream on: String new.	currentStream :=targetStream. 	[sourceStream atEnd] whileFalse: 		[ch :=sourceStream next.		ch = $< ifTrue:			[peekValue := sourceStream peek. (peekValue = $?) ifTrue:		[evalStream := WriteStream on: String new.		currentStream := evalStream.	sourceStream next. "Eat the ?"				ch :=sourceStream next.]].		((currentStream = evalStream) and: [ch =$?]) ifTrue:			[ peekValue := sourceStream peek.(peekValue = $>) ifTrue:				[sourceStream next."Eat the >"				currentStream := targetStream.			evalValue := (Compiler new evaluate: (evalStreamcontents) 					in: thisContext to: selfnotifying: nil ifFail: [^nil]).				(evalValueisKindOf: String)				ifFalse: [evalValue :=evalValue printString].				currentStreamnextPutAll: evalValue.]]			ifFalse: [currentStreamnextPut: ch].].	^targetStream contents! !!HTMLformatter class methodsFor: 'translating' stamp: 'mjg 9/3/1998 16:58'!swikify: aStringOrStream linkhandler: aBlock	| formatter |	formatter _ self new.	formatter specialCharacter: $*.	^formatter swikify: aStringOrStream linkhandler: aBlock! !!HTMLformatter class methodsFor: 'formatting' stamp: 'pm 6/6/1998 21:39'!textAreaStart: fieldName rows: rows cols: cols       ^ '<TEXTAREA NAME="', fieldName, '" ROWS=',rows,' COLS=',cols,'>' ! !HTTPSockets support HTTP requests, either directly or via an HTTP proxy server. An HTTPSocket saves the parse of the last ASCII header it saw, to avoid having to parse it repeatedly.The real action is in httpGet:accept:.  See the examples in the class, especially httpFileInNewChangeSet: and httpShowGif:.!]style[(206 15 45 23 5 13)f1,f1LHTTPSocket class httpGet:accept:;,f1,f1LHTTPSocket class httpFileInNewChangeSet:;,f1,f1LHTTPSocket class httpShowGif:;!!HTTPSocket methodsFor: 'all' stamp: 'ls 8/14/1998 10:17'!contentType	| type i |	type _ self getHeader: 'content-type' default: nil.	type ifNil: [ ^nil ].	type _ type withBlanksTrimmed.	i _ type indexOf: $;.	i = 0 ifTrue: [ ^type ].	^(type copyFrom: 1 to: i-1) withBlanksTrimmed	! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:23'!contentType: header	"extract the content type from the header.  Content-type: text/plain<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens ifNil: [ headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR) ].	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [#('content-type:' 'content type') includes: this asLowercase]) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/15/97 11:35'!contentsLength: header	"extract the data length from the header.  Content-length: 1234<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR).	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [this asLowercase = 'content-length:']) ifTrue: [			^ (headerTokens at: ii+1) asNumber]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:37'!getHeader: name 	^self getHeader: name  default: nil! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:36'!getHeader: name  default: defaultValue	^headers at: name  ifAbsent: [ defaultValue ]! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 11:39'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	[tester _ tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm _ mm + 1] ifFalse: [mm _ 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self isConnected | self dataAvailable)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 12:24'!getRestOfBuffer: beginning	"We don't know the length.  Keep going until connection is closed.  Part of it has already been received.  Response is of type text, not binary."	| buf response bytesRead |	response _ RWBinaryOrTextStream on: (String new: 2000).	response nextPutAll: beginning.	buf _ String new: 2000.	[self isConnected | self dataAvailable] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifTrue: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 				startingAt: 1 count: buf size. 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'tk 9/22/1998 14:35'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close.  Response is of type text, not binary."	| buf response bytesRead |	length ifNil: [^ self getRestOfBuffer: beginning].	buf _ String new: length.	response _ RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf _ String new: length.	[(response position < length) & (self isConnected | self dataAvailable)] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 				count: (length - response size). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed']). 	response position < length ifTrue: [^ 'server aborted early'].	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/13/1998 00:33'!header: headerText	"set the headers.  Then getHeader: can be used"	"divide into basic lines"	| lines foldedLines i statusLine |	lines _ headerText findTokens: (String with: Character cr  with: Character linefeed).	statusLine _ lines first.	lines _ lines copyFrom: 2 to: lines size.	"parse the status (pretty trivial right now)"	responseCode _ (statusLine findTokens: ' ') second.	"fold lines that start with spaces into the previous line"	foldedLines _ OrderedCollection new.	lines do: [ :line |		line first isSeparator ifTrue: [			foldedLines at: foldedLines size  put: (foldedLines last, line) ]		ifFalse: [ foldedLines add: line ] ].	"make a dictionary mapping headers to header contents"	headers _ Dictionary new.	foldedLines do: [ :line |		i _ line indexOf: $:.		i > 0 ifTrue: [			headers 			at: (line copyFrom: 1 to: i-1) asLowercase 			put: (line copyFrom: i+1 to: line size) withBlanksTrimmed ] ]..! !!HTTPSocket methodsFor: 'all' stamp: 'jm 9/26/97 18:28'!redirect	"See if the header has a 'Location: url CrLf' in it.  If so, return the new URL of this page.  tk 6/24/97 18:03"	| this |	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $l and: [this asLowercase = 'location:']) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'all' stamp: 'ls 8/12/1998 00:41'!responseCode	^responseCode! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'tk 9/21/1998 10:45'!blabEmail: aRequest	"Of the form 'From: me@isp.com <crlf>'"	HTTPBlabEmail _ aRequest! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'jm 9/15/97 11:30'!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxy _ nil.	HTTPBlabEmail _ ''.  "	'From: tedk@disney.com', CrLf	"! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 10/4/97 16:11'!httpFileIn: url	"Do a regular file-in of a file that is served from a web site.  If the file contains an EToy, then open it.  Might just be code instead.  tk 7/23/97 17:10"	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones.  The server does not have to know about the .sqo extension in order to send your file.  (We do not need a new MIME type and .sqo does not have to be registered with the server.)"	"	HTTPSocket httpFileIn: 'www.webPage.com/~kaehler2/sample.etoy'	 "	"	HTTPSocket httpFileIn: '206.18.68.12/squeak/car.sqo'	 "	"	HTTPSocket httpFileIn: 'jumbo/tedk/sample.etoy'	 "	| doc eToyHolder |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	eToyHolder _ doc fileInObjectAndCode.	eToyHolder ifNotNil: [eToyHolder open].	"Later may want to return it, instead of open it"! !!HTTPSocket class methodsFor: 'examples' stamp: 'di 5/6/1998 16:40'!httpFileInNewChangeSet: url	"Do a regular file-in of a file that is served from a web site.  Put it into a new changeSet."	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones."	"	HTTPSocket httpFileInNewChangeSet: '206.18.68.12/squeak/updates/83tk_test.cs'	 "	| doc |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	ChangeSorter newChangesFromStream: doc				named: (url findTokens: '/') last.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 11/4/97 08:25'!httpGet: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGet: url accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'examples' stamp: 'ls 9/15/1998 23:57'!httpGet: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGet: url  args: nil accept: mimeType! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/16/1998 10:31'!httpGet: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| document |	document _ self httpGetDocument: url  args: args  accept: mimeType.	(document isKindOf: String) ifTrue: [		"strings indicate errors"		^ document ].	^ (RWBinaryOrTextStream with: document content) reset! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:25'!httpGetDocument: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGetDocument: url args: nil accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	^self httpGetDocument: url args: nil accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url args: args	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGetDocument: url args: args accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 17:48'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	^ self httpGetDocument: url args: args accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 19:01'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, self argString: args ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; show: connectToHost; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: header; cr.	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode = '401' ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 10/15/97 12:07'!httpGif: url	"Fetch the given URL, parse it using the GIF reader, and return the resulting Form."	"	HTTPSocket httpShowGif: 'www.altavista.digital.com/av/pix/default/av-adv.gif'	 "	"	HTTPSocket httpShowGif: 'www.webPage.com/~kaehler2/ainslie.gif'	 "	| doc ggg |	doc _ self httpGet: url accept: 'image/gif'.	doc class == String ifTrue: [		self inform: 'The server with that GIF is not responding'.		^ ColorForm extent: 20@20 depth: 8].	doc binary; reset.	(ggg _ Smalltalk gifReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'examples' stamp: 'tao 10/26/97 23:21'!httpJpeg: url	"Fetch the given URL, parse it using the JPEG reader, and return the resulting Form."	| doc ggg |	doc _ self httpGet: url.	doc binary; reset.	(ggg _ Smalltalk jpegReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:27'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document _ self httpPostDocument: url  args: argsDict  accept: mimeType  request: ''.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 23:27'!httpPostDocument: url  args: argsDict	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^self httpPostDocument: url args: argsDict accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 20:16'!httpPostDocument: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^ self httpPostDocument: url args: argsDict accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 9/22/1998 20:16'!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxy ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: serverName; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf.	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	Transcript show: page; cr; show: argsStream contents; cr; show: header; cr.	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 5/4/1998 17:00'!httpShowChunk: url	"From a Swiki server, get a text chunk in the changes file.  Show its text in a window with style.  Vertical bar separates class and selector.  BE SURE TO USE ; instead of : in selectors!!"	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Socket|Comment'	 "	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Point|class|x;y;'	"	| doc text |	doc _ (self httpGet: url accept: 'application/octet-stream')."	doc size = 0 ifTrue: [doc _ 'The server does not seem to be responding']."	doc class == String ifTrue: [text _ doc] ifFalse: [text _ doc nextChunkText].	(StringHolder new contents: text) openLabel: url.! !!HTTPSocket class methodsFor: 'examples' stamp: 'di 9/15/1998 08:22'!httpShowGif: url	"Display the picture retrieved from the given URL, which is assumed to be a GIF file. See examples in httpGif:."	| nameTokens image |	nameTokens _ url findTokens: '/'.	image _ self httpGif: url.	World ifNil: [FormView open: image named: nameTokens last]		ifNotNil: [World addMorph: (SketchMorph new form: image)]! !!HTTPSocket class methodsFor: 'examples' stamp: 'tao 10/26/97 23:21'!httpShowJpeg: url	"Display the picture retrieved from the given URL, which is assumed to be a JPEG file. See examples in httpGif:."	| nameTokens |	nameTokens _ url findTokens: '/'.	FormView open: (self httpJpeg: url) named: nameTokens last.! !!HTTPSocket class methodsFor: 'examples' stamp: 'tk 5/4/1998 17:01'!httpShowPage: url	"Display the exact contents of the given URL as text. See examples in httpGet:"	| doc |	doc _ (self httpGet: url accept: 'application/octet-stream') contents.	doc size = 0 ifTrue: [^ self error: 'Document could not be fetched'].	(StringHolder new contents: doc) openLabel: url.! !!HTTPSocket class methodsFor: 'examples' stamp: 'jm 9/15/97 12:06'!proxyTestingComment	"Test Kevin's SmartCache on this machine"	"	HTTPSocket useProxyServerNamed: '127.0.0.1' port: 8080.		HTTPSocket httpShowPage: 'http://www.disneyblast.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test getting to outside world from DOL"	"	HTTPSocket useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080.		HTTPSocket httpShowPage: 'http://www.apple.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test Windows Machine in our cubicle at DOL"	"	HTTPSocket useProxyServerNamed: '206.18.67.150' port: 8080.		HTTPSocket httpShowPage: 'http://kids.online.disney.com/~kevin/squeak/k_t.morph'.		HTTPSocket stopUsingProxyServer.	"	"	HTTPSocket httpShowPage: 'kids.online.disney.com/'	"	"	HTTPSocket httpShowGif: 'kids.online.disney.com/~kevin/images/dlogo.gif'	"! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ls 9/17/1998 07:18'!stopUsingProxyServer	"Stop directing HTTP request through a proxy server."	HTTPProxyServer _ nil.	HTTPProxyPort _ 80.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ls 9/17/1998 07:17'!useProxyServerNamed: proxyServerName port: portNum	"Direct all HTTP requests to the HTTP proxy server with the given name and port number."	proxyServerName ifNil: [  "clear proxy settings"		HTTPProxyServer _ nil.		HTTPProxyPort _ 80.		^ self].	proxyServerName class == String		ifFalse: [self error: 'Server name must be a String or nil'].	HTTPProxy _ proxyServerName.	HTTPProxyPort _ portNum.	HTTPProxyPort class == String ifTrue: [HTTPPort _ portNum asNumber].	HTTPProxyPort ifNil: [HTTPProxyPort _ self defaultPort].! !!HTTPSocket class methodsFor: 'utilities' stamp: 'tk 9/22/1998 17:46'!argString: args	"Return the args in a long string, as encoded in a url"	| argsString first |	argsString _ WriteStream on: String new.	argsString nextPut: $?.	first _ true.	args associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].			argsString nextPutAll: assoc key encodeForHTTP.			argsString nextPut: $=.			argsString nextPutAll: value encodeForHTTP. ] ].	^ argsString contents! !!HTTPSocket class methodsFor: 'utilities' stamp: 'jm 9/15/97 11:10'!retry: tryBlock asking: troubleString ifGiveUp: abortActionBlock	"Execute the given block. If it evaluates to true, return true. If it evaluates to false, prompt the user with the given string to see if he wants to try again. If not, evaluate the abortActionBlock and return false."	| response |	[tryBlock value] whileFalse: [		response _ (PopUpMenu labels: 'Retry\Give Up' withCRs)			startUpWithCaption: troubleString.		response = 2 ifTrue: [abortActionBlock value. ^ false]].	^ true! !!HTTPSocket class methodsFor: 'magic numbers' stamp: 'ls 9/17/1998 07:17'!defaultPort	"default port to connect on"	^80! !!HaloMorph methodsFor: 'accessing' stamp: 'jm 5/22/1998 16:28'!innerTarget	^ innerTarget! !!HaloMorph methodsFor: 'stepping' stamp: 'jm 6/2/1998 13:51'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ target fullBoundsInWorld].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 11:55'!addHandleAt: aPoint color: aColor on: eventName send: selector to: recipient	"Add a handle centered at the given point with the given color, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle |	handle _ EllipseMorph		newBounds: (Rectangle center: aPoint extent: self handleSize asPoint)		color: aColor.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle).	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'sw 8/19/1998 11:58'!addHandles	| box s |	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	s _ self handleSize.	self bounds: target fullBoundsInWorld.  "update my size"	box _ (self fullBounds expandBy: s+1)			intersect: (self world bounds insetBy: 5@5).	self addHandleAt: box topLeft color: Color red		on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: innerTarget.	self addHandleAt: (box topLeft + ((s+2)@0) min: box topLeft + box topCenter // 2)		color: Color transparent		on: #mouseDown send: #dismiss to: self.	self addHandleAt: (box leftCenter) color: Color cyan		on: #mouseDown send: #openViewerForArgument to: innerTarget.	self addHandleAt: box topCenter color: Color black		on: #mouseDown send: #doGrab:with: to: self.	(self addHandleAt: (box topCenter + ((s+2)@0) min: box topCenter + box topRight // 2)		color: Color brown		on: #mouseDown send: #startDrag:with: to: self)		on: #mouseStillDown send: #doDrag:with: to: self.	self addHandleAt: box topRight color: Color green		on: #mouseDown send: #doDup:with: to: self.	Preferences showDebugHaloHandle ifTrue:		[self addHandleAt: (box rightCenter + (0 @ ((s+2) negated)) min: box rightCenter + box bottomRight // 2)			color: Color blue veryMuchLighter			on: #mouseDown send: #doDebug:with: to: self].	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget)			on: #mouseUp send: #deleteBalloon to: innerTarget].	(self addHandleAt: box bottomLeft color: Color blue		on: #mouseDown send: #startRot:with: to: self)		on: #mouseStillDown send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addHandleAt: box bottomRight color: Color lightOrange				on: #mouseDown send: #startScale:with: to: self)				on: #mouseStillDown send: #doScale:with: to: self]		ifFalse: [(self addHandleAt: box bottomRight color: Color yellow				on: #mouseDown send: #startGrow:with: to: self)				on: #mouseStillDown send: #doGrow:with: to: self].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: box string: target externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 12:34'!addHandlesForWorldHalos	| box s |	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box _ self world bounds insetBy: 9.	s _ self handleSize.	self addHandleAt: box topLeft color: Color red on: #mouseDown send: #doMenu:with: to: self.	self addHandleAt: (box leftCenter + (0 @ (s+2)) min: box leftCenter + box bottomLeft // 2)		color: Color lightBrown		on: #mouseDown send: #tearOffTile to: target.	self addHandleAt: box leftCenter color: Color cyan		on: #mouseDown send: #openViewerForArgument to: target.	target balloonText ifNotNil:		[(self addHandleAt: box bottomCenter color: Color lightBlue			on: #mouseDown send: #mouseDownOnHelpHandle: to: target)			on: #mouseUp send: #deleteBalloon to: target].	innerTarget addOptionalHandlesTo: self box: box.	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'sw 8/19/1998 11:46'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target."	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world doOneCycle.	menu _ evt hand buildDebugHandleMenuFor: innerTarget.	menu addTitle: innerTarget externalName.	evt hand invokeMenu: menu event: evt.! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/21/1998 12:25'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	evt hand setArgument: target.	self setTarget: evt hand duplicateMorph.	self removeAllHandlesBut: dupHandle! !!HaloMorph methodsFor: 'private' stamp: 'sw 7/1/1998 11:35'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable."	| degrees |	degrees _ (evt cursorPoint - target referencePosition) degrees.	degrees _ degrees - angleOffset degrees.	(degrees abs < 1.0) ifTrue: [degrees _ 0.0].	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	target rotationDegrees: (degrees						detentBy: 10.0						atMultiplesOf: 90.0 snap: false).	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'di 7/5/1998 11:54'!handleSize	^ 16! !!HaloMorph methodsFor: 'private' stamp: 'sw 7/1/1998 12:30'!maybeDoDup: evt with: dupHandle	^ target okayToDuplicate ifTrue:		[self doDup: evt with: dupHandle]! !!HandMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 12:23'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	dragOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	grid _ 4@4.	gridOn _ false.	remoteConnections _ OrderedCollection new.	lastEventTransmitted _ MorphicEvent new.	mouseOverTimes _ Dictionary new.	temporaryCursor _ nil.	temporaryCursorOffset _ 0@0.! !!HandMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 16:06'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching myBnds shadowCanvas |	self suppressDisplay ifTrue: [^ self].	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue: [		cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	myBnds _ super fullBounds.  "my full bounds without my shadow"	self updateCacheCanvasDepth: aCanvas depth.	cacheCanvas ifNil: [		"could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	shadowCanvas _ aCanvas copyForShadowDrawingOffset: self shadowOffset.	"Note: it's 3x faster to fill a rectangle rather than draw the shadow of a Form"	cachedCanvasHasHoles		ifTrue: [shadowCanvas image: cacheCanvas form at: myBnds origin]		ifFalse: [shadowCanvas fillRectangle: myBnds color: color].	"draw morphs in front of the shadow using the cached Form"	aCanvas image: cacheCanvas form at: myBnds origin.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'di 9/10/1998 16:20'!trailMorph	"You can't draw trails when picked up by the hand."	^ nil! !!HandMorph methodsFor: 'drawing' stamp: 'jm 6/2/1998 16:05'!updateCacheCanvasDepth: depth	"Update the cached image of the morphs being held by this hand."	| myBnds rectList c |	depth = 32 ifTrue: [		self allMorphsDo: [:m |			m hasTranslucentColor ifTrue: [				cacheCanvas _ nil.				cachedCanvasHasHoles _ nil.				^ self]]].	myBnds _ super fullBounds.  "my full bounds without my shadow"	(cacheCanvas == nil or: [cacheCanvas extent ~= myBnds extent]) ifTrue: [		cacheCanvas _ FormCanvas extent: myBnds extent depth: depth.		c _ cacheCanvas copyOffset: myBnds origin negated.		submorphs reverseDo: [:m | m fullDrawOn: c].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: myBnds extent).	damageRecorder reset.	rectList do: [:r |		c _ cacheCanvas copyOrigin: myBnds origin negated clipRect: r.		c fillColor: Color transparent.  "clear to transparent"		submorphs reverseDo: [:m | m fullDrawOn: c]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:48'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	owner ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesMouseOverDragging: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnterDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:18'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: (Sensor cursorPoint - owner viewBox topLeft)]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				mouseDownMorph _ m.				eventTransform _ m transformFrom: self.				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				"ensure that at least one mouseMove: is reported for each mouse transaction:"				m mouseMove: (localEvt copy setType: #mouseMove).				(m handlesMouseOverDragging: localEvt) ifTrue:					["If m also handles dragOver, enter it in the list"					dragOverMorphs add: m.					mouseOverMorphs remove: m ifAbsent: []]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab ifNotNil: [self grabMorph: rootForGrab]].		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: []]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/3/1998 15:58'!handleMouseMove: evt	"Dispatch a mouseMove event."	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].	submorphs isEmpty		ifTrue: [evt anyButtonPressed				ifTrue: [self handleDragOver: evt]				ifFalse: [self handleMouseOver: evt]]		ifFalse: [self handleDragOver: evt]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 13:46'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled mouseOverHalosEnabled |	owner ifNil: [^ self].  "this hand is not in a world"	balloonHelpEnabled _ self world balloonHelpEnabled & evt anyButtonPressed not.	mouseOverHalosEnabled _ self world mouseOverHalosEnabled & evt anyButtonPressed not.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | ((mouseOverHalosEnabled and: [m wantsHalo])			or: [balloonHelpEnabled and: [m wantsBalloon]])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes ifNotNil: [mouseOverTimes removeKey: m ifAbsent: [] ]].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes ifNotNil: [mouseOverTimes at: m put: now]]].mouseOverTimes ifNotNil:	[mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[(mouseOverHalosEnabled and: [m wantsHalo])					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHalo: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]]! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 9/14/1998 08:47'!handleMouseUp: evt	"Dispatch a mouseUp event."	| oldFocus |	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	"drop morphs being carried, if any"	self hasSubmorphs ifTrue: [self dropMorphsEvent: evt].	mouseDownMorph = nil ifTrue: [^ self].	oldFocus := mouseDownMorph.	"make sure that focus becomes nil."	mouseDownMorph _ nil.  "mouse focus transaction ends when mouse goes up"	oldFocus mouseUp: (self transformEvent: evt).	dragOverMorphs copy do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/3/1998 12:56'!mouseOverList: evt 	"Returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	| p roots mList mm r |	p _ evt cursorPoint.	roots _ self world rootMorphsAt: p.  "root morphs in world"	[roots size > 0 and: [roots first isPlayfieldLike]]		whileTrue:		[roots _ roots first rootMorphsAt: p].  "roots in innermost frame"	roots size > 0		ifTrue: [mList _ roots first unlockedMorphsAt: p.				mList size > 0 ifTrue:					["NOTE: We really only want the top morph and all its owners"					mm _ mList first.  r _ roots first.					mList _ OrderedCollection new.					[mm == r] whileFalse:						[mList addLast: mm.						mm _ mm owner].					mList add: r]]		ifFalse: [mList _ EmptyArray].	^ mList! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 5/29/1998 18:08'!newMouseFocus: aMorphOrNil	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'event dispatching' stamp: 'di 7/5/1998 14:05'!processEvents	"Process user input events from the local input devices."	| griddedPoint evt currentExtent |	griddedPoint _ Sensor cursorPoint - owner viewBox topLeft.	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	evt _ MorphicEvent new		setMousePoint: griddedPoint		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	remoteConnections size > 0 ifTrue: [		currentExtent _ self worldBounds extent.		lastWorldExtent ~= currentExtent ifTrue: [			self transmitEvent: (MorphicEvent newWorldExtent: currentExtent).			lastWorldExtent _ currentExtent].		self transmitEvent: evt].	(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue:		[eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]].	lastEvent _ evt.	self handleEvent: evt.	[Sensor keyboardPressed] whileTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: griddedPoint			buttons: Sensor primMouseButtons			hand: self.		lastEvent _ evt.		self handleEvent: evt.		remoteConnections size > 0 ifTrue: [self transmitEvent: evt]].! !!HandMorph methodsFor: 'event dispatching' stamp: 'jm 6/17/1998 08:57'!updateMouseDownTransform	"To help with, eg, autoscrolling"	mouseDownMorph		ifNil: [eventTransform _ MorphicTransform identity]		ifNotNil: [eventTransform _ mouseDownMorph transformFrom: self].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 8/4/1998 17:27'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| targetM toDrop |	owner ifNil: [^ self].	self changed.	self submorphsReverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		targetM _ self dropTargetFor: m event: evt.		targetM ifNil:  "Drop not allowed"			[^ self rejectDropMorph: m event: evt].		toDrop _ targetM morphToDropFrom: m. 		toDrop == m ifFalse: [submorphs size == 1 ifTrue:			[self privateRemoveMorph: m.			m privateOwner: nil]].		"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		targetM acceptDroppingMorph: toDrop event: evt.		toDrop justDroppedInto: targetM event: evt.		toDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 7/6/1998 16:37'!grabMorph: m	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| editor |	formerOwner _ m owner.	formerPosition _ m position.	m isTileLike ifTrue:		[editor _ m topEditor].	(m owner isKindOf: DropShadowMorph)		ifTrue:			[self grabMorph: m owner]		ifFalse:			[m aboutToBeGrabbedBy: self.			gridOn ifTrue: [m position: (m position grid: grid)].			self addMorphBack: m].	editor ifNotNil: [editor scriptEdited]! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 01:36'!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'previous project' target: owner action: #goBack.	menu add: 'jump to project...' action: #jumpToProject.	menu add: 'restore display' target: World action: #fullRepaintNeeded.	menu addLine.	menu add: 'new morph...' action: #newMorph.	menu add: 'scripting...' action: #scriptingDo.	menu add: 'remote...' action: #remoteDo.	menu add: 'debug...' action: #debugDo.	menu addLine.	menu add: 'open window...' action: #openWindow.	menu add: 'windows...' action: #windowsDo.	menu add: 'changes...' action: #changesDo.	menu add: 'help...' action: #helpDo.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	menu addLine.	menu add: 'save' action: #saveSession.	menu add: 'save as...' action: #saveAs.	menu add: 'save and quit' action: #saveAndQuit.	menu add: 'quit' action: #quitSession.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 00:54'!changesDo	"Build the changes menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Change management') defaultTarget: self.	menu addStayUpItem.	menu add: 'file out changes' target: ScreenController new action: #fileOutChanges.	menu add: 'create new change set...' target: ChangeSorter action: #newChangeSet.	menu add: 'browse changed methods' action: #browseChangedMessages.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'browse recent submissions' action: #openRecentChanges.	menu add: 'recent change log' action: #openChangesLog.	menu addLine.	menu add: 'save world as morph file' action: #saveWorldInFile.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 01:09'!debugDo	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Debugging...') defaultTarget: self.	menu addStayUpItem.	menu add: 'inspect world' target: owner action: #inspect.	menu add: 'inspect model' action: #inspectWorldModel.	menu add: 'start MessageTally' action: #startMessageTally.	menu add: 'call #tempCommand' action: #callTempCommand.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 02:08'!helpDo	"Build the help menu for the world."	| menu screenCtrl |	screenCtrl _ ScreenController new.	menu _ (MenuMorph entitled: 'General help') defaultTarget: self.	menu addStayUpItem.	menu add: 'edit preferences...' target: Preferences action: #openPreferencesInspector.	menu add: 'command-key help' target: Utilities action: #openCommandKeyHelp.	menu add: 'font size summary' target: Utilities action: #fontSizeSummary.	menu add: 'useful expressions' target: Utilities action: #openStandardWorkspace.	menu add: 'view image imports' target: Smalltalk action: #viewImageImports.	menu addLine.	menu add: 'full screen on' target: screenCtrl action: #fullScreenOn.	menu add: 'full screen off' target: screenCtrl action: #fullScreenOff.	menu add: 'set display depth...' action: #setDisplayDepth.	menu add: 'set desktop color...' action: #changeBackgroundColor.	menu add: 'use texture background' target: self world action: #setStandardTexture.	gridOn		ifTrue: [menu add: 'turn gridding off' action: #setGridding]		ifFalse: [menu add: 'turn gridding on' action: #setGridding].	menu add: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])		target: screenCtrl action: #soundOnOrOff.	menu addLine.	menu add: 'update code from server' action: #updateFromServer.	menu add: 'about this system' target: screenCtrl action: #aboutThisSystem.	menu add: 'set author initials...' target: screenCtrl action: #setAuthorInitials.	menu add: 'vm statistics' target: screenCtrl action: #vmStatistics.	menu add: 'space left' target: screenCtrl action: #garbageCollect.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 00:32'!newMorph	| menu subMenu catDict shortCat class |	menu _ (MenuMorph entitled: 'Add a new morph') defaultTarget: self.	menu addStayUpItem.	menu add: 'from paste buffer' action: #pasteMorph.	menu add: 'grab patch from screen' action: #grabDrawingFromScreen.	menu add: 'make new drawing' target: self presenter associatedMorph action: #makeNewDrawingWithin.	menu addLine.	catDict _ Dictionary new.	SystemOrganization categories do:		[:cat |		((cat beginsWith: 'Morphic-')				and: [(#('Morphic-Menus' 'Morphic-Support') includes: cat) not])		ifTrue:			[shortCat _ cat copyFrom: 'Morphic-' size+1 to: cat size.			(SystemOrganization listAtCategoryNamed: cat) do:				[:cName | class _ Smalltalk at: cName.				((class inheritsFrom: Morph)					and: [class includeInNewMorphMenu])					ifTrue:					[(catDict includesKey: shortCat) 					ifTrue: [(catDict at: shortCat) addLast: class]					ifFalse: [catDict at: shortCat put: (OrderedCollection with: class)]]]]].	catDict keys asSortedCollection do:		[:categ |		subMenu _ MenuMorph new.		((catDict at: categ) asSortedCollection: [:c1 :c2 | c1 name < c2 name]) do:			[:cl | subMenu add: cl name					target: self					selector: #newMorphOfClass:event:					argument: cl].		menu add: categ subMenu: subMenu].	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 02:15'!openWindow	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Open a new window') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' target: Transcript action: #open.	menu add: 'selector finder' target: ScreenController new action: #openSelectorBrowser.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'email reader' action: #openEmail.	menu add: 'web browser' action: #openWebBrowser.	menu add: 'IRC chat' action: #openIRC.	menu addLine.	menu add: 'project (mvc)' action: #openMVCProject.	menu add: 'project (morphic)' action: #openMorphicProject.	menu add: 'project (construction)' action: #openConstructionProject.	menu add: 'project link...' action: #projectThumbnail.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 00:48'!remoteDo	"Build the Telemorphic menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Telemorphic') defaultTarget: self.	menu addStayUpItem.	menu add: 'local host address' action: #reportLocalAddress.	menu add: 'connect remote user' action: #connectRemoteUser.	menu add: 'disconnect remote user' action: #disconnectRemoteUser.	menu add: 'disconnect all remote users' action: #disconnectAllRemoteUsers.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 01:02'!scriptingDo	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'scripting...') defaultTarget: self.	menu addStayUpItem.	menu add: 'detachable scripting space' target: self action: #detachableScriptingSpace.	menu add: 'default parts bin' target: self presenter action: #createStandardPartsBin.	menu add: 'custom parts bin' target: self presenter action: #launchMyPartsBin.	menu add: 'control panel' target: self presenter action: #createControlPanel.	menu add: 'add stop, step, and go buttons' target: self presenter action: #addStopStepGoButtons.	menu addLine.	menu add: 'flush viewer cache' action: #flushViewerCache.	menu add: 'unlock contents' action: #unlockWorldContents.	menu add: 'unhide hidden objects' action: #showHiders.	menu add: 'round up stray objects' action: #roundUpStrayObjects.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu' stamp: 'di 9/23/1998 01:35'!windowsDo	"Build the windows menu for the world."	| menu |	menu _ (MenuMorph entitled: 'Window management') defaultTarget: self.	menu addStayUpItem.	menu add: 'find window' action: #findWindow.	menu add: 'find changed browsers...' action: #findDirtyBrowsers.	menu add: 'find changed windows...' action: #findDirtyWindows.	menu addLine.	menu add: 'collapse all windows' action: #collapseAll.	menu add: 'expand all windows' action: #expandAll.	menu add: 'close unchanged windows' action: #closeUnchangedWindows.	menu addLine.	menu add: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows'])		target: ScreenController new action: #changeWindowPolicy.	menu popUpAt: self position forHand: self.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/5/1998 16:53'!browseChangedMessages	Smalltalk browseChangedMessages! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:52'!browsePlayerClass	Browser newOnClass: argument player class label: 'Compiled scripts for ', argument player externalName! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/19/1998 11:54'!buildDebugHandleMenuFor: argMorph	"Build the menu for the given morph's halo's debug handle."	argument _ argMorph.	^ argMorph debuggingMenuFor: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:51'!buildMorphHandleMenuFor: argMorph	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	argMorph == owner "i.e., the world" ifTrue:		[^ self buildWorldMenu].	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	argMorph addAddHandMenuItemsForHalo: menu hand: self.	menu defaultTarget: argMorph.	argMorph addCustomHaloMenuItems: menu hand: self.	argMorph player ifNotNil: [argMorph player addPlayerMenuItemsTo: menu hand: self].	menu defaultTarget: self.	Preferences noviceMode ifFalse:		[argMorph addDebuggingItemsTo: menu hand: self].	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 16:05'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'duplicate' action: #maybeDuplicateMorph.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	menu add: 'resize' action: #resizeMorph.	(argMorph isKindOf: SketchMorph)  ifFalse:		[menu add: 'fill color' action: #changeColor].	(argMorph morphsAt: targetOffset) size > 1 ifTrue:		[menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	menu add: 'inspect' action: #inspectMorph.	menu add: 'inspect in Morphic' action: #inspectMorphInMorphic.	menu add: 'browse' action: #browseMorphClass.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	menu add: 'name me' action: #nameMorph.	(argMorph isKindOf: MorphicModel) ifTrue:		[menu add: 'save morph as prototype' action: #saveAsPrototype.		(argMorph ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' action: #beThisWorldsModel]].	menu add: 'save morph in file' action: #saveOnFile.	menu add: 'show actions' action: #showActions.	menu addLine.	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:46'!changeVariableType	argument ifNotNil:		[argument assuredPlayer changeVariableType]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:46'!chooseNewCostumeForArgument	argument notNil ifTrue:		[argument assuredPlayer newCostume]! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/15/1998 07:58'!chooseNewFormForSketchMorph	"Only available when argument is a SketchMorph"	| reply |	reply _ (SelectionMenu selections: Smalltalk imageImports keys asSortedCollection) startUpWithCaption: 'Which element of ImageImports?'.	reply == nil ifTrue: [^ self].	argument form: (Smalltalk imageImports at: reply)! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/23/1998 01:33'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	(SystemWindow windowsIn: self world satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/1/1998 11:52'!copyToPasteBuffer	"Save this morph in the paste buffer. This is mostly useful for copying morphs between projects."	argument isMorph		ifTrue: [Cursor wait showWhile: 					[argument okayToDuplicate ifTrue:						[PasteBuffer _ argument topRendererOrSelf veryDeepCopy]]]		ifFalse: [PasteBuffer _ nil].! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/6/1998 13:26'!detachableScriptingSpace	| aPasteUp |	aPasteUp _ PasteUpMorph new color: Color white; borderWidth: 1; borderColor: Color green lighter; extent: 500@400.	self attachMorph: aPasteUp.	aPasteUp impartPrivatePresenter; setProperty: #automaticPhraseExpansion toValue: true; beSticky	! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/21/1998 11:54'!duplicateMorph	| newMorph aName usedNames |	newMorph _ argument veryDeepCopy.	(aName _ argument knownName) ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo:			(Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	self grabMorphFromMenu: newMorph.	newMorph player ifNotNil: [newMorph player startRunning].	^ newMorph! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/23/1998 01:29'!findDirtyBrowsers	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | (w model isKindOf: Browser) and: [w model canDiscardEdits not]])		do: [:w | menu add: w label target: w action: #activate].	self invokeMenu: menu event: lastEvent! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/23/1998 01:30'!findDirtyWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | w model canDiscardEdits not])		do: [:w | menu add: w label target: w action: #activate].	self invokeMenu: menu event: lastEvent! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:51'!inspectArgumentsPlayerInMorphic	self attachMorph: ((Inspector openAsMorphOn: argument player) extent: 300@200)! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:52'!inspectPlayer	argument player inspect! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/22/1998 22:07'!jumpToProject	(Project buildJumpToMenu: (MenuMorph new defaultTarget: Project))		popUpAt: self position forHand: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/6/1998 21:52'!makeAliasForArgument	| aThumbnailMorph |	(argument notNil and: [self playfield notNil]) ifTrue:		[aThumbnailMorph _ argument newThumbnailOfHeight: 40.		aThumbnailMorph  setNameTo: '^ ', argument externalName.		self attachMorph: aThumbnailMorph]! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 6/1/1998 19:15'!makeNewDrawing	"Make a new drawing in the standard playfield."	| aPlayfield bnds |	(aPlayfield _ self world playfield) ifNil: [aPlayfield _ self world].	bnds _ aPlayfield paintingBoundsAround: aPlayfield boundsInWorld center.	self makeNewDrawingInBounds: bnds pasteUpMorph: aPlayfield.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/1/1998 12:30'!maybeDuplicateMorph	argument okayToDuplicate ifTrue:		[self duplicateMorph]! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 6/14/1998 14:34'!objectToPaste	"It may need to be sent #startRunning by the client"	^ Cursor wait showWhile: [PasteBuffer veryDeepCopy]	"PasteBuffer usableDuplicateIn: self world"! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 6/12/1998 15:29'!openChangeSorter: oneOrTwo	oneOrTwo = 1		ifTrue: [ChangeSorter new open]		ifFalse: [DualChangeSorter new open]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 7/6/1998 11:29'!openConstructionProject	| aSystemWindow |	self world addMorph: (aSystemWindow _ ProjectViewMorph newMorphicConstruction).	aSystemWindow model "the Project itself" enter: false! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/8/1998 04:57'!openEmail	"open an email interface"	Celeste openOn: 'EMAIL'! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/4/1998 18:21'!openFileList	FileList openAsMorph openInWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/5/1998 01:22'!openIRC	"open an interface to Internet Relay Chat"	IRCConnection new openView; openDirectMessagesObserver! !!HandMorph methodsFor: 'world menu commands' stamp: 'ls 9/14/1998 23:21'!openWebBrowser	Scamper openAsMorph ! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/4/1998 18:21'!openWorkspace	Workspace new openAsMorphLabel: 'Workspace' inWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/11/1998 16:53'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: (aPastee _ self objectToPaste).	aPastee player ifNotNil: [aPastee player startRunning]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 15:49'!placeArgumentIn 	"Let the user choose a new layer in the core sample for the argument to reside in, but don't allow strange loops"	|  targetMorph |	targetMorph _ self selectEmbedTargetMorph: ('Place ', argument externalName, ' in...').	targetMorph ifNotNil:		[targetMorph addMorphFront: argument fromWorldPosition: argument position]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 15:44'!potentialEmbeddingTargets	"Answer a list of targets into which the hand's arguement could be embedded"	| possibleTargets |	possibleTargets _ self world morphsAt: menuTargetOffset.	argument ifNotNil:		[possibleTargets removeAllFoundIn: argument allMorphs].	^ possibleTargets! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 6/17/1998 16:27'!saveOnFile	"Save the guy we clicked on, not the hand"	argument saveOnFile! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 16:07'!selectEmbedTargetMorph: caption	"Put up a menu of morphs found in a core sample taken of the world at the receiver's menuTargetOffset, with the given caption"	|  menu |	menu _ CustomMenu new.	self potentialEmbeddingTargets  do: [:m | menu add: (self submorphNameFor: m) action: m].	^ caption size == 0		ifTrue:			[menu startUp]		ifFalse:			[menu startUpWithCaption: caption]! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/3/1998 08:40'!selectSubmorphToOperateOn: rootMorph sending: aSymbol event: evt	"Let the user select a submorph of the given root morph. When selected, the given selector is sent with the selected submorph as an argument."	| possibleTargets menu |	possibleTargets _ rootMorph morphsAt: targetOffset.	possibleTargets size = 1 ifTrue: [^ self perform: aSymbol with: possibleTargets first with: evt].	menu _ MenuMorph new.	possibleTargets do: [:m |		menu add: (self submorphNameFor: m)			target: self			selector: aSymbol			argumentList: (Array with: m with: evt)].	menu popUpAt: self position event: evt.! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 8/13/1998 12:56'!writeInitMethodForModel	| model |	model _ self world model.	model class chooseNewName.	model veryDeepCopy compileInitMethods.! !!HandMorph methodsFor: 'special gestures' stamp: 'di 7/5/1998 21:03'!specialDrag: evt	"Special drag (cmd-mouse on the Macintosh) allows a morph to be dragged without grabbing it and thus without removing it from its owner or changing its z-order." 	| halo |	self position ~= evt cursorPoint		ifTrue: [self position: evt cursorPoint].	mouseDownMorph		ifNil:    ["Waiting for more than 5 pixels move to start drag"				(self position dist: targetOffset) > 5					ifTrue: [(halo _ self world haloMorphOrNil) ifNil: [^ self].							mouseDownMorph _ halo target.							targetOffset _ targetOffset - mouseDownMorph position.							halo removeAllHandlesBut: nil]]		ifNotNil: [mouseDownMorph setConstrainedPositionFrom: self position - targetOffset].! !!HandMorph methodsFor: 'special gestures' stamp: 'di 7/5/1998 21:03'!specialGesture: evt	"Special gestures (cmd-mouse on the Macintosh) allow a mouse-sensitive morph to be grabbed or bring up a halo for the morph."	"Summary:		Cmd-mouse			pop up halo		Cmd-shift-mouse		grab morph"	mouseDownMorph _ nil.	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self position.	argument _ self argumentOrNil.	evt shiftPressed		ifTrue: [argument ifNotNil: [self grabMorph]]		ifFalse: [self popUpHaloFromClick: evt].! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 9/20/1998 22:28'!makeNewDrawingInBounds: rect pasteUpMorph: aPasteUpMorph	| w newSketch newPlayer sketchEditor aPaintBox aPalette |	aPalette _ aPasteUpMorph standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	newSketch _ self drawingClass new player: (newPlayer _ UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch form: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor _ SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: aPasteUpMorph.	sketchEditor		afterNewPicDo: [:aForm :aRect |			newSketch form: aForm.			newSketch position: aRect origin.			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch setupAngle: sketchEditor forwardDirection.			newSketch privateOwner: aPasteUpMorph.  "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			aPasteUpMorph addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			self presenter drawingJustCompleted: newSketch]		 ifNoBits:			[(aPaintBox _ self world paintBox) ifNotNil:				[aPaintBox delete].			aPalette ifNotNil: [aPalette showNoPalette].]! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 7/6/1998 13:30'!rejectDropMorph: aMorph event: evt	"aMorph has been rejected, and must be put back somewhere.  There are three cases:	(1)  It remembers its former owner and position, and goes right back there	(2)  It remembers its former position only, in which case it was torn off from a parts bin, and the UI is that it floats back to its donor position and then vanishes.	(3)  Neither former owner nor position is remembered, in which case it is whisked to the Trash"	(formerOwner notNil and: [formerOwner isPartsBin not]) ifTrue:		[^ aMorph slideBackToFormerSituation: evt].	formerPosition ifNotNil:  "Position but no owner -- can just make it vanish"		[^ aMorph vanishAfterSlidingTo: formerPosition event: evt].			aMorph slideToTrash: evt! !!HandMorph methodsFor: 'from EToyHand' stamp: 'sw 6/25/1998 09:28'!roundUpStrayObjects	self world roundUpStrays! !a "hidden" input.  It never actually appear on a formatted page, and the user can't change the input value.!!HiddenInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 06:37'!name: name0  value: value0	name _ name0.		value _ value0.! !!HiddenInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:37'!name	^name! !!HiddenInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:37'!value	^value! !!HiddenInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 06:38'!name: name0  value: value	^self new name: name0  value: value! !A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.!!HierarchicalUrl methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:44'!hasContents	"most of these do...."	^true! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 02:24'!privateInitializeFromText: aString	| remainder ind nextTok s specifiedSchemeName |	remainder _ aString.	schemeName ifNil: [ 		specifiedSchemeName _ Url schemeNameForString: remainder.		specifiedSchemeName ifNotNil: [ 			schemeName _ specifiedSchemeName.			remainder _ remainder copyFrom: (schemeName size+2) to: remainder size ].		schemeName ifNil: [ "assume HTTP"  schemeName _ 'http' ] ].	"remove leading // if it's there"	(remainder beginsWith: '//') ifTrue: [		remainder _ remainder copyFrom: 3 to: remainder size ].	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ].	"get the authority"	ind _ remainder indexOf: $/.	ind > 0 ifTrue: [		ind = 1 ifTrue: [ authority _ '' ] ifFalse: [			authority _ remainder copyFrom: 1 to: ind-1.			remainder _ remainder copyFrom: ind+1 to: remainder size. ] ]	ifFalse: [		authority _ remainder.		remainder _ ''. ].	"get the path"	path _ OrderedCollection new.	s _ ReadStream on: remainder.	[ 		s peek = $/ ifTrue: [ s next ].		nextTok _ WriteStream on: String new.		[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].		nextTok _ nextTok contents unescapePercents.		nextTok = '..' 			ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]			ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].		s atEnd 	] whileFalse.	path isEmpty ifTrue: [ path add: '' ].! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 9/10/1998 03:20'!privateInitializeFromText: aString relativeTo: aUrl	| remainder ind nextTok s |	remainder _ aString.	"set the scheme"	schemeName _ aUrl schemeName.	"a leading // means the authority is specified, meaning it is absolute"	(remainder beginsWith: '//') ifTrue: [		^self privateInitializeFromText: aString ].	"otherwise, use the same authority"	authority _ aUrl authority.	"get the query"	ind _ remainder indexOf: $?.	ind > 0 ifTrue: [		query _ (remainder copyFrom: ind+1 to: remainder size).		remainder _ remainder copyFrom: 1 to: ind-1 ]. 	"get the path"	remainder isEmpty ifTrue: [ 		path _ aUrl path ]	ifFalse: [		(remainder beginsWith: '/')			ifTrue: [ path _ OrderedCollection new ]			ifFalse: [ path _ aUrl path shallowCopy.				path size > 0 ifTrue: [ path removeLast ] ]. 				s _ ReadStream on: remainder.		[ 			s peek = $/ ifTrue: [ s next ].			nextTok _ WriteStream on: String new.			[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].			nextTok _ nextTok contents unescapePercents.			nextTok = '..' 				ifTrue: [ path size > 0 ifTrue: [ path removeLast ] ]				ifFalse: [ nextTok ~= '.' ifTrue: [ path add: nextTok ] ].			s atEnd 		] whileFalse.		path isEmpty ifTrue: [ path add: '' ]	. ].! !!HierarchicalUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName0  authority: authority0  path: path0  query: query0	"initialize a new instance"	schemeName _ schemeName0.	authority _ authority0.	path _ path0.	query _ query0.! !!HierarchicalUrl methodsFor: 'printing' stamp: 'ls 7/21/1998 07:23'!toText	| ans |	ans _ WriteStream on: String new.	ans nextPutAll: self schemeName.	ans nextPutAll: '://'.	ans nextPutAll: self authority.	path do: [ :pathElem |		ans nextPut: $/.		ans nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		ans nextPut: $?.		ans nextPutAll: self query. ].	self fragment isNil ifFalse: [		ans nextPut: $#.		ans nextPutAll: self fragment encodeForHTTP. ].		^ans contents! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!authority	^authority! !!HierarchicalUrl methodsFor: 'access' stamp: 'tk 9/6/1998 12:45'!isAbsolute		path size > 0 ifFalse: [^ false].	(path at: 1) size > 0 ifFalse: [^ false].	^ ((path at: 1) at: 1) ~~ $.! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!path	"return an ordered collection of the decoded path elements, as strings"	^path! !!HierarchicalUrl methodsFor: 'access' stamp: 'tk 9/19/1998 18:56'!path: anArray	path _ anArray! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:59'!query	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"	^query ! !!HierarchicalUrl methodsFor: 'access' stamp: 'ls 6/20/1998 19:58'!schemeName	^schemeName! !!HierarchicalUrl class methodsFor: 'instance creation' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName  authority: authority  path: path  query: query	^self new schemeName: schemeName  authority: authority  path: path  query: query! !!HtmlAnchor methodsFor: 'testing' stamp: 'ls 6/25/1998 03:04'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlAnchor methodsFor: 'testing' stamp: 'ls 6/25/1998 03:04'!tagName	^'a'! !!HtmlAnchor methodsFor: 'formatting' stamp: 'ls 9/10/1998 03:22'!addToFormatter: formatter	| href name |	name _ self getAttribute: 'name'.	name ifNotNil: [		formatter noteAnchorStart: name ].	href _ self getAttribute: 'href'.	href isNil		ifTrue: [ super addToFormatter: formatter ]		ifFalse: [ 				formatter startLink: href.			super addToFormatter: formatter.			formatter endLink: href. ].! !!HtmlAttributes methodsFor: 'printing' stamp: 'ls 7/23/1998 19:05'!printHtmlOn: aStream	self associationsDo: 		[:element | 		aStream 			space;			nextPutAll: element key asUppercase.		element value ifNotNil: [  				aStream nextPut: $=.				aStream print: element value withoutQuoting]. ]! !an entity which supposedly increases the font size of its constituents!a moderately high level entitiy.  This includes P, FORM, and UL, among others!!HtmlBlockEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^true! !!HtmlBlockQuote methodsFor: 'testing' stamp: 'ls 7/17/1998 20:27'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlBlockQuote methodsFor: 'testing' stamp: 'ls 7/17/1998 20:26'!tagName	^'blockquote'! !!HtmlBlockQuote methodsFor: 'formatting' stamp: 'ls 7/17/1998 20:26'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increaseIndent.	super addToFormatter: formatter.	formatter decreaseIndent.	formatter ensureNewlines: 1.! !!HtmlBody methodsFor: 'lint' stamp: 'ls 7/29/1998 00:24'!shouldContain: anEntity	"I don't *think* there are any elements that can be in both the header and the body..."	^anEntity isHeadElement not! !!HtmlBody methodsFor: 'testing' stamp: 'ls 7/4/1998 19:24'!mayContain: anEntity	"Body's can contain anything, so that even if we screw up the parsing, all the text will end up actually being included"	^true! !!HtmlBody methodsFor: 'testing' stamp: 'ls 6/25/1998 02:04'!tagName	^'body'! !an entity which displays its contents in boldface!!HtmlBoldEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 12:53'!addToFormatter: formatter	formatter increaseBold.	super addToFormatter: formatter.	formatter decreaseBold.! !!HtmlBreak methodsFor: 'testing' stamp: 'ls 7/4/1998 16:14'!mayContain: anEntity	^false! !!HtmlBreak methodsFor: 'testing' stamp: 'ls 7/4/1998 16:14'!tagName	^'br'! !!HtmlBreak methodsFor: 'formatting' stamp: 'ls 7/17/1998 19:21'!addToFormatter: formatter	formatter addChar: Character cr.! !!HtmlButton methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!mayContain: anEntity	^false! !!HtmlButton methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!tagName	^'button'! !A comment, eg <!!-- this is a comment -->Normally this is ignored, but it's included so that every byte in theinput gets put into one tag or another.!!HtmlComment methodsFor: 'parser support' stamp: 'ls 6/25/1998 02:37'!entityFor	^self shouldNotImplement! !!HtmlComment methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isComment	^true! !!HtmlComment methodsFor: 'access' stamp: 'ls 1/25/98 04:56'!text	"return the text of the comment, the part inside the <!!-- and -->"	^self notYetImplemented! !a comment from the page!!HtmlCommentEntity methodsFor: 'private-iniitialization' stamp: 'ls 7/28/1998 20:28'!initializeWithText: aString	super initialize.	commentText _ aString.! !!HtmlCommentEntity methodsFor: 'printing' stamp: 'ls 7/14/1998 22:30'!printOn: aStream  indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: '<!!-- '.	aStream nextPutAll: self commentText.	aStream nextPutAll: ' -->'.	aStream cr.! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!isComment	^true! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:27'!mayContain: anEntity	^false! !!HtmlCommentEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:30'!tagName		"return a bogus tag name"	^'x-comment'! !!HtmlCommentEntity methodsFor: 'formatting' stamp: 'ls 7/4/1998 12:27'!addToFormatter: formatter	"do nothing"! !!HtmlCommentEntity methodsFor: 'access' stamp: 'ls 7/4/1998 12:27'!commentText	^commentText! !!HtmlDefinitionDefinition methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:12'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increaseIndent.	super addToFormatter: formatter.	formatter decreaseIndent.! !!HtmlDefinitionDefinition methodsFor: 'testing' stamp: 'ls 7/4/1998 00:20'!mayContain: anEntity	^anEntity isBlockEntity or: [ anEntity isTextualEntity ] ! !!HtmlDefinitionDefinition methodsFor: 'testing' stamp: 'ls 7/4/1998 00:18'!tagName	^'dd'! !!HtmlDefinitionList methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!mayContain: anEntity	^anEntity isDefinitionListElement! !!HtmlDefinitionList methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!tagName	^'dl'! !!HtmlDefinitionList methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:14'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlDefinitionListElement methodsFor: 'testing' stamp: 'ls 6/25/1998 02:19'!isDefinitionListElement	^true! !!HtmlDefinitionTerm methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:14'!addToFormatter: formatter	formatter ensureNewlines: 1.	super addToFormatter: formatter.! !!HtmlDefinitionTerm methodsFor: 'testing' stamp: 'ls 7/4/1998 00:19'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlDefinitionTerm methodsFor: 'testing' stamp: 'ls 7/4/1998 00:17'!tagName	^'dt'! !an entire HTML document.  It should have exactly two sub-entities when completed: a HEAD and a BODY!!HtmlDocument methodsFor: 'testing' stamp: 'ls 6/25/1998 02:57'!mayContain: anElement	^true 	"not strictly true, but it makes the parser simpler"! !!HtmlDocument methodsFor: 'testing' stamp: 'ls 6/25/1998 02:06'!tagName	^'html'! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:38'!addToBody: anObject	"add an object to the Body entity of the receiver"	self body add: anObject! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:37'!addToHead: anObject	"add an object to the head entity of the receiver"	self head add: anObject! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:28'!body	^self contents at: 2! !!HtmlDocument methodsFor: 'access' stamp: 'djp 7/21/1998 18:28'!head	^self contents at: 1! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 6/25/1998 17:25'!formattedText	"return a version of this document as a formatted Text"	| formatter |	formatter _ HtmlFormatter new.	self addToFormatter: formatter.	^formatter text ! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/29/1998 03:01'!formattedTextForBrowser: browser  defaultBaseUrl: defaultBaseUrl	"return a version of this document as a formatted Text (which includes links and such)"	| formatter text |	"set up the formatter"	formatter _ HtmlFormatter new.	formatter browser: browser.	formatter baseUrl: defaultBaseUrl.  "should check if the document specifies something else"	"do the formatting"	self addToFormatter: formatter.	"get and return the result"	text _ formatter text.	^text! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/14/1998 00:35'!formattedTextMorph	"return a version of this document as a formatted TextMorph (which includes links and such)"	| formatter text textMorph |	formatter _ HtmlFormatter new.	self addToFormatter: formatter.	text _ formatter text .	textMorph _ TextMorph new initialize.	textMorph contentsWrapped: text.	^textMorph! !!HtmlDocument methodsFor: 'formatting' stamp: 'ls 7/16/1998 22:12'!formattedTextMorphForBrowser: browser  defaultBaseUrl: defaultBaseUrl	"return a version of this document as a formatted TextMorph (which includes links and such)"	| formatter textMorph |	"set up the formatter"	formatter _ HtmlFormatter new.	formatter browser: browser.	formatter baseUrl: defaultBaseUrl.  "should check if the document specifies something else"	"do the formatting"	self addToFormatter: formatter.	"get and return the result"	textMorph _ formatter textMorph .	^textMorph! !!HtmlDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 04:26'!emptyDocument	"return an empty document"	^super new add: HtmlHead new; add: HtmlBody new! !<html>When HtmlParser runs, it generates a tree whose nodes are in HtmlEntity's subclasses.  There is a separate class for most of the available elements in HTML, though some are grouped together under generic classes like HtmlBoldEntity.Methods of particular interest when modifying or adding subclasses are:<ul><li>initialize:<li>mayContain:<li>addToFormatter:</ul>!!HtmlEntity methodsFor: 'downloading' stamp: 'ls 7/29/1998 00:52'!downloadState: baseUrl	"download any state needed for full rendering.  eg, images need this"	! !!HtmlEntity methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrame	^false! !!HtmlEntity methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrameSet	^false! !!HtmlEntity methodsFor: 'user interface' stamp: 'djp 7/21/1998 18:35'!inspect	"Open an HtmlEntityInspector on the receiver.	Use basicInspect to get a normal type of inspector."	HtmlEntityInspector openOn: self withEvalPane: true! !!HtmlEntity methodsFor: 'user interface' stamp: 'djp 7/21/1998 18:35'!inspectWithLabel: aLabel	"Open a HtmlEntityInspector on the receiver. Use basicInspect to get a normal (less useful) type of inspector."	HtmlEntityInspector openOn: self withEvalPane: true withLabel: aLabel! !!HtmlEntity methodsFor: 'converting' stamp: 'djp 7/21/1998 11:58'!asHtml	| aStream |	aStream := WriteStream on: ''.	self printHtmlOn: aStream.	^aStream contents.! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 16:21'!add: anObject	"add an object to the receiver"	(anObject isKindOf: String)		ifTrue: [contents add: (HtmlTextEntity new text: anObject)]		ifFalse: [contents add: anObject]! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 13:51'!at: key put: anObject	self attributes ifNil: [self attributes: (HtmlAttributes new)].	(self attributes) at: key put: anObject! !!HtmlEntity methodsFor: 'accessing' stamp: 'djp 7/21/1998 16:28'!attributes	^attribs ifNil: [attribs := HtmlAttributes new]! !!HtmlEntity methodsFor: 'formatting' stamp: 'ls 6/25/1998 15:01'!addToFormatter: aFormatter	"by default, just format our childer"	contents do: [ :e | e addToFormatter: aFormatter ]! !!HtmlEntity methodsFor: 'formatting' stamp: 'ls 7/15/1998 18:31'!parsingFinished	"some entities need to make a final pass *after* parsing has finished and all the contents of each entity have been established; here is a place to do that"	contents do: [ :e | e parsingFinished ].! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 6/25/1998 02:03'!addEntity: anEntity	"add an entity to the receiver"	contents add: anEntity! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 6/25/1998 02:02'!contents	"return an ordered collection of this entity's contents"	^contents! !!HtmlEntity methodsFor: 'contents' stamp: 'ls 7/5/1998 00:37'!textualContents	"return a string with the concatenated contents of all textual sub-entities"	^String streamContents: [ :s |		contents do: [ :e | s nextPutAll: e textualContents ] ]! !!HtmlEntity methodsFor: 'private-initialization' stamp: 'ls 7/31/1998 02:57'!initialize	contents _ OrderedCollection new.	attribs _ HtmlAttributes new.! !!HtmlEntity methodsFor: 'private-initialization' stamp: 'djp 7/20/1998 20:52'!initialize: aTag	self initialize.	attribs _ HtmlAttributes newFrom: aTag attribs.! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!isComment	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:20'!isDefinitionListElement	"whether receiver can appear in a DefinitionList"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/16/1998 23:18'!isFormEntity	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:54'!isHeadElement	"whether this can appear in a header"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:55'!isHeader	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:18'!isListElement	"is this an HtmlListElement, ie can it appear in a (non-definition) list?"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:12'!isListItem	"is this an HtmlListItem, ie can it appear in a (non-definition) list?"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!isOption	"whether this is an <option> entity"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!isParagraph	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!isTableDataItem	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableItem	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableRow	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:20'!isTextualEntity	"is receiver either text, or some low-level text-like entity such as <b> or <em>"	^false! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:09'!lint	^String streamContents: [ :s | self lint: s ]! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:37'!lint: aStream	"do a lint check, reporting to aStream"	self lintAttributes: aStream.	contents do: [ :c |		(c isComment not   and:  [ (self shouldContain: c) not ]) ifTrue: [ 			aStream nextPutAll: '<', self tagName, '> should not contain <', c tagName, '>'.			aStream cr. ] ].	contents do: [ :c  | c lint: aStream ]! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:07'!lintAttributes: aStream	"check that our attributes are okay.  Print any anomalies to aStream"	! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:03'!mayContain: anEntity	"whether we can contain the given entity"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:01'!mayContainEntity: anEntity	"whether we can contain the given entity"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:35'!shouldContain: anEntity	"whether, according to the HTML DTD, this element should actually contain anEntity.  Used for checking the quality of a pages HTML"	^self mayContain: anEntity! !!HtmlEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:02'!tagName	"tag name for ourself"	^self subclassResponsibility! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/26/1998 19:59'!attributes: newAttributes	"set all of the attributes at once.  newAttributes should not be modified after passing it in"	^attribs _ newAttributes! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/31/1998 02:55'!doesNotUnderstand: aMessage	"treat the message as an attribute name"	| selector |	selector _ aMessage selector.	selector asLowercase = selector ifFalse: [		"attribute accesses must be in all lowercase.  This should cut down on some false doesNotUnderstand: traps"		^super doesNotUnderstand: aMessage ].	selector numArgs == 0 ifTrue: [		"return the named attribute"		^self getAttribute: selector asString default: nil ].	selector numArgs == 1 ifTrue: [		"set the named attribute"		self setAttribute: (selector asString copyFrom: 1 to: (selector size-1)) to: aMessage argument.		^self ].	^super doesNotUnderstand: aMessage! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 8/5/1998 07:20'!getAttribute: name	^self getAttribute: name  default: nil! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/15/1998 18:52'!getAttribute: name  default: anObject	^self getAttribute: name  ifAbsent: [anObject]! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/15/1998 18:51'!getAttribute: name  ifAbsent: aBlock	^attribs at: name ifAbsent: aBlock! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/17/1998 19:04'!name	^self getAttribute: 'name' default: nil! !!HtmlEntity methodsFor: 'attributes' stamp: 'ls 7/31/1998 03:00'!setAttribute: name  to: value	"set the given attribute to the given value"	attribs at: name asLowercase  put: value! !!HtmlEntity methodsFor: 'printing' stamp: 'djp 7/20/1998 21:12'!printHtmlOn: aStream	^self printHtmlOn: aStream  indent: 0! !!HtmlEntity methodsFor: 'printing' stamp: 'djp 7/21/1998 17:43'!printHtmlOn: aStream indent: indent	aStream 		next: indent put: $ ;		nextPut: $<;		nextPutAll: self tagName asUppercase;		printHtml: self attributes;		nextPut: $>;		cr.	contents do: [ :entity | entity printHtmlOn: aStream indent: indent+3 ].	aStream		next: indent put: $ ;		nextPutAll: '</';		nextPutAll: self tagName asUppercase;		nextPut: $>;		cr.! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 6/25/1998 03:13'!printOn: aStream	^self printOn: aStream  indent: 0! !!HtmlEntity methodsFor: 'printing' stamp: 'ls 8/11/1998 03:16'!printOn: aStream  indent: indent	aStream		next: indent put: $ ;		nextPut: $<;		print: self tagName.	self attributes associationsDo: [ :assoc |		aStream			space;			nextPutAll: assoc key;			nextPutAll: '=';			nextPutAll: assoc value ].	aStream		nextPut: $>;		cr.	contents do: [ :entity | entity printOn: aStream indent: indent+1 ].! !!HtmlEntity methodsFor: 'enumeration' stamp: 'ls 7/16/1998 23:17'!allSubentitiesDo: aBlock	"perform the block recursively on all sub-entities"	contents do: [ :e | 		aBlock value: e .		e allSubentitiesDo: aBlock.	].	! !!HtmlEntity class methodsFor: 'instance creation' stamp: 'ls 7/29/1998 01:27'!forTag: aTag	"create a new entity based on the given tag"	^self new initialize: aTag! !!HtmlEntity class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 13:17'!new	^super new initialize! !!HtmlEntityInspector methodsFor: 'accessing' stamp: 'djp 7/21/1998 17:21'!fieldList	^ super fieldList, (Array with: 'asHtml')! !!HtmlEntityInspector methodsFor: 'accessing' stamp: 'ls 7/24/1998 01:40'!initialExtent	"Answer the desired extent for the receiver when it is first opened on the screen.  "	^ 300 @ 300! !!HtmlEntityInspector methodsFor: 'selecting' stamp: 'ls 7/23/1998 07:37'!selection	selectionIndex = self fieldList size 		ifTrue: [^object asHtml]		ifFalse: [^super selection]! !An entity that (supposedly) displays its contents in a fixed-width font.  I don't know how to do this, though.  -ls!an entity whose effect is to change the font its constituents are displayed in in some way.  Multiple tags might generate almost any of the subclasses, so the tag name is stored explicitly.!!HtmlFontChangeEntity methodsFor: 'testing' stamp: 'ls 7/5/1998 01:58'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlFontChangeEntity methodsFor: 'testing' stamp: 'ls 6/27/1998 12:51'!tagName	"must be stored in an i-var, because these classes work for different tags"	^tagName! !!HtmlFontChangeEntity methodsFor: 'private-initialization' stamp: 'ls 6/27/1998 15:34'!initialize: aTag	super initialize: aTag.	tagName _ aTag name! !the <font> tag.  it's here for future expansion....!!HtmlForm methodsFor: 'testing' stamp: 'ls 7/4/1998 19:51'!isBlockElement	^true! !!HtmlForm methodsFor: 'testing' stamp: 'ls 7/15/1998 00:24'!mayContain: anEntity	"allow anything.  People probably always put </form> anyway at the end of their forms.  And furthermore, it has no effect on the display, even if this is gotten wrong"	^true! !!HtmlForm methodsFor: 'testing' stamp: 'ls 7/3/1998 23:30'!tagName	^'form'! !!HtmlForm methodsFor: 'formatting' stamp: 'ls 7/17/1998 00:26'!addToFormatter: formatter	formatter startForm: self.	super addToFormatter: formatter.	formatter currentFormData reset.	formatter endForm.! !!HtmlForm methodsFor: 'parsing' stamp: 'ls 7/16/1998 23:16'!parsingFinished	"figure out who our constituents are"	self allSubentitiesDo: [ :e |		e isFormEntity ifTrue: [ e form: self ] ].	super parsingFinished.	formEntities _ OrderedCollection new.	self allSubentitiesDo: [ :e |		(e isFormEntity and: [ e form == self ])			ifTrue: [ formEntities add: e ] ].! !!HtmlForm methodsFor: 'attributes' stamp: 'ls 7/17/1998 00:40'!method	"method to submit with"	^self getAttribute: 'method' default: 'get'! !!HtmlForm methodsFor: 'attributes' stamp: 'ls 7/17/1998 00:40'!url	"url to submit to"	^self getAttribute: 'action' default: nil.  ! !!HtmlForm methodsFor: 'access' stamp: 'ls 7/16/1998 23:29'!formEntities	^formEntities! !Abstract superclass for elements that only appear in forms!!HtmlFormEntity methodsFor: 'access' stamp: 'ls 7/15/1998 00:22'!form	"return which form we are in"	^form! !!HtmlFormEntity methodsFor: 'access' stamp: 'ls 7/15/1998 00:22'!form: aForm	"set which form we are part of"	form _ aForm! !!HtmlFormEntity methodsFor: 'testing' stamp: 'ls 7/15/1998 00:22'!isFormEntity	^true! !!HtmlFormEntity methodsFor: 'testing' stamp: 'ls 7/29/1998 00:15'!lint: aStream	form ifNil: [ aStream nextPutAll: '<', self tagName, '> not within a form'.		aStream cr. ].	super lint: aStream.! !a filter which formats HTML into a Text with attributes!!HtmlFormatter methodsFor: 'forms' stamp: 'ls 7/16/1998 22:07'!currentFormData	"return the current form data, or nil if we aren't inside a form"	formDatas size > 0 		ifTrue: [ ^formDatas last ]		ifFalse: [ ^nil ].! !!HtmlFormatter methodsFor: 'forms' stamp: 'ls 7/16/1998 22:06'!endForm	formDatas size > 0 ifTrue: [ 		formDatas removeLast. ]	ifFalse: [ self halt: 'HtmlFormatter: ended more forms that started!!?' ].! !!HtmlFormatter methodsFor: 'forms' stamp: 'ls 8/5/1998 07:14'!startForm: form	"a form is beginning"	formDatas addLast: (FormInputSet forForm: form  andBrowser: browser).! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 9/10/1998 03:20'!anchorLocations	"return a dictionary mapping lowercase-ed anchor names into the integer positions they are located at in the text"	^anchorLocations! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:08'!baseUrl	"return the base URL for the document we are formatting, if known"	^baseUrl! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:09'!baseUrl: url	"set the base url.  All relative URLs will be determined relative to it"	baseUrl _ url.! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:07'!browser	"return the browser we are formatting for, or nil if none"	^browser! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 7/16/1998 22:08'!browser: b	"set what browser we are formatting for"	browser _ b.! !!HtmlFormatter methodsFor: 'access' stamp: 'ls 9/5/1998 18:08'!incompleteMorphs	"list of morphs needing to download some more state"	^incompleteMorphs! !!HtmlFormatter methodsFor: 'private-initialization' stamp: 'ls 9/10/1998 03:17'!initialize	outputStream _ AttributedTextStream new.	preformattedLevel _ 0.	indentLevel _ boldLevel _ italicsLevel _ underlineLevel _ strikeLevel _ centerLevel _ 0.	listLengths _ OrderedCollection new.	listTypes _ OrderedCollection new.	formDatas _ OrderedCollection new.	precedingSpaces _ 0.	precedingNewlines _ 1000.   "more than will ever be asked for"	morphsToEmbed _ OrderedCollection new.	incompleteMorphs _ OrderedCollection new.	anchorLocations _ Dictionary new.	outputStream nextPut: Character cr.! !!HtmlFormatter methodsFor: 'private-formatting' stamp: 'ls 8/5/1998 01:41'!setAttributes	"set attributes on the output stream"	| attribs |	attribs _ OrderedCollection new.	indentLevel > 0 ifTrue: [ attribs add: (TextIndent tabs: indentLevel) ].	boldLevel > 0 ifTrue: [ attribs add: TextEmphasis bold ].	italicsLevel >  0 ifTrue: [ attribs add: TextEmphasis italic ].	underlineLevel > 0 ifTrue: [ attribs add: TextEmphasis underlined ].	strikeLevel > 0 ifTrue: [ attribs add: TextEmphasis struckOut ].	urlLink isNil ifFalse: [ attribs add: (TextURL new url: urlLink) ].	outputStream currentAttributes: attribs! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/12/1998 00:14'!addChar: c	"add a single character, updating all the tallies"	"add the character to the output"	outputStream nextPut: c.	"update counters for preceeding spaces and preceding newlines"	(c = Character space or: [ c = Character tab ]) 	ifTrue: [ precedingSpaces _ precedingSpaces+1.  precedingNewlines _ 0 ]	ifFalse: [		(c = Character cr) ifTrue: [			precedingSpaces _ 0.			precedingNewlines _ precedingNewlines + 1 ]		ifFalse: [			precedingSpaces _ precedingNewlines _ 0 ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/5/1998 18:09'!addIncompleteMorph: aMorph	"add a morph, and note that it needs to download some more state before reaching its ultimate state"	self addMorph: aMorph.	incompleteMorphs add: aMorph.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 02:51'!addLink: text  url: url	"add a link with the given url and text"	| savedAttributes linkAttribute  |	"set up the link attribute"	linkAttribute _ TextURL new.	linkAttribute url: url.	"add the link to the stream"	savedAttributes _ outputStream currentAttributes.	outputStream currentAttributes: (savedAttributes, linkAttribute).	outputStream nextPutAll: text.	outputStream currentAttributes: savedAttributes.	"reset counters"	precedingSpaces _ precedingNewlines _ 0.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/29/1998 07:39'!addMorph: aMorph	"add a morph to the output"	| savedAttributes |	self addChar: Character space.	savedAttributes _ outputStream currentAttributes.	outputStream currentAttributes: (savedAttributes copyWith: (TextAnchor new anchoredMorph: aMorph)).	self addChar: $*.	outputStream currentAttributes: savedAttributes.	self addChar: Character space.	morphsToEmbed add: aMorph.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/25/1998 06:10'!addString: aString	"adds the text in the given string.  It collapses spaces unless we are in a preformatted region"	| space compacted lastC i |	aString isEmpty ifTrue: [ ^self ].	space _ Character space.	preformattedLevel > 0 ifTrue: [		"add all the characters as literals"		outputStream nextPutAll: aString.		"update the counters"		lastC _ aString last.		(lastC = space or: [ lastC = Character cr ]) ifTrue: [			"how many of these are there?"			i _ aString size - 1.			[ i >= 1 and: [ (aString at: i) = lastC ] ] whileTrue: [ i _ i - 1 ].			i = 0 ifTrue: [				"the whole string is the same character!!"				lastC = space ifTrue: [					precedingSpaces _ precedingSpaces + aString size.					precedingNewlines _ 0.					^self ]				ifFalse: [					precedingSpaces _ 0.					precedingNewlines _ precedingNewlines + aString size.					^self ]. ].			lastC = space ifTrue: [				precedingSpaces _ aString size - i.				precedingNewlines _ 0 ]			ifFalse: [				precedingSpaces _ 0.				precedingNewlines _ aString size - i ] ] ]	ifFalse: [		compacted _ aString withSeparatorsCompacted.		compacted = ' ' ifTrue: [			"no letters in the string--just white space!!"			(precedingNewlines = 0 and: [precedingSpaces = 0]) ifTrue: [				precedingSpaces _ 1.				outputStream nextPut: space. ].			^self ].		(compacted first = Character space and: [			(precedingSpaces > 0) or: [ precedingNewlines > 0] ])		ifTrue: [ compacted _ compacted copyFrom: 2 to: compacted size ].		outputStream nextPutAll: compacted.		"update counters"		precedingNewlines _ 0.		compacted last = space 			ifTrue: [ precedingSpaces _ 1 ]			ifFalse: [ precedingSpaces _ 0 ]. ]! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseBold	boldLevel _ boldLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseIndent	indentLevel _ indentLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!decreaseItalics	italicsLevel _ italicsLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/16/1998 22:58'!decreasePreformatted	preformattedLevel _ preformattedLevel - 1! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 02:03'!decreaseStrike	strikeLevel _ strikeLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 01:39'!decreaseUnderline	underlineLevel _ underlineLevel - 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 03:17'!endLink: url	urlLink _ nil.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/20/1998 11:34'!endListItem	"end a list item"	self ensureNewlines: 1.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 13:17'!endOrderedList	"end an ordered list"	listLengths removeLast.	listTypes removeLast.	indentLevel _ indentLevel - 1.	self setAttributes. 	self ensureNewlines: 1.	! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 13:18'!endUnorderedList	"end an unordered list"	listLengths removeLast.	listTypes removeLast.	indentLevel _ indentLevel - 1.	self setAttributes. 		self ensureNewlines: 1.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/25/1998 17:21'!ensureNewlines: number	"make sure there are at least number preceding newlines"	number > precedingNewlines ifTrue: [		(number - precedingNewlines) timesRepeat: [ self addChar: Character cr ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 8/16/1998 11:34'!ensureSpaces: number	"make sure there are at least number preceding spaces, unless we're at the beginning of a new line"	precedingNewlines > 0 ifTrue: [ ^ self ].	number > precedingSpaces ifTrue: [		(number - precedingSpaces) timesRepeat: [ self addChar: Character space ] ].! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/12/1998 00:15'!hr	"add an (attempt at a) horizontal rule"	self ensureNewlines: 1.	25 timesRepeat: [ self addChar: $- ].	self ensureNewlines: 1.	precedingSpaces _ 0.	precedingNewlines _ 1000.    "pretend it's the top of a new page"! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!increaseBold	boldLevel _ boldLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:12'!increaseIndent	indentLevel _ indentLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/27/1998 15:13'!increaseItalics	italicsLevel _ italicsLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/16/1998 22:58'!increasePreformatted	preformattedLevel _ preformattedLevel + 1! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 02:03'!increaseStrike	strikeLevel _ strikeLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/5/1998 01:40'!increaseUnderline	underlineLevel _ underlineLevel + 1.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 9/10/1998 03:26'!noteAnchorStart: anchorName	"note that an anchor starts at this point in the output"	anchorLocations at: anchorName asLowercase put: outputStream size! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 6/30/1998 03:17'!startLink: url	urlLink _ url.	self setAttributes.! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/13/1998 23:19'!startListItem	"begin a new list item"	listTypes size = 0 ifTrue: [ ^self ].	self ensureNewlines: 1.	listTypes last = #unordered		ifTrue: [ self addString: 'o ' ]		ifFalse: [ self addString: (listLengths last + 1) printString.			self addString: '. ' ].	listLengths at: (listLengths size) put: (listLengths last + 1).! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/4/1998 19:44'!startOrderedList	"begin an ordered list"	listLengths add: 0.	listTypes add: #ordered.	indentLevel _ indentLevel + 1.	self setAttributes.	! !!HtmlFormatter methodsFor: 'formatting commands' stamp: 'ls 7/4/1998 19:44'!startUnorderedList	"begin an unordered list"	listLengths add: 0.	listTypes add: #unordered.	indentLevel _ indentLevel + 1.	self setAttributes.	! !!HtmlFormatter methodsFor: 'formatting' stamp: 'ls 6/30/1998 01:13'!text	| text |	text _ outputStream contents.	^text! !!HtmlFormatter methodsFor: 'formatting' stamp: 'ls 7/16/1998 21:55'!textMorph	| text textMorph |	text _ outputStream contents.	textMorph _ TextMorph new contents: text.	morphsToEmbed do:[ :m | textMorph addMorph: m ].	^textMorph! !!HtmlFormatter class methodsFor: 'instance creation' stamp: 'ls 6/25/1998 17:25'!new	^super new initialize! !!HtmlFormatter class methodsFor: 'example' stamp: 'ls 7/14/1998 00:42'!example1	"(HtmlFormatter example1 asParagraph compositionRectangle: (0@0 extent: 300@500) ) displayAt: 0@0"	| input |	input _ ReadStream on: '<html><head><title>The Gate of Chaos</title></head><body><h1>Chaos</h1><h2>Into the Maelstrom</h2>Direction is useless in the ever-changing Maelstrom.  However,if you wander with purpose, you might be able to find....<ul><li><a href="/cgi-bin/w">see who''s logged in</a><li><a href="/Telnet/connect.html">log in, if you (oooh) have an account</a><li><a href="http://chaos.resnet.gatech.edu:9000/sw">The Chaos Swiki</a>--scribble on chaos<li>the original <a href="/cgi-bin/guestlog-print">Visitor Sands</a><li>my old <a href="rant.html">Rant Page</a><li>neverending <a href="/cgi-bin/bread">poll</a>: do you have an opinion on bread?<li>a <a href="http://www.cc.gatech.edu/~lex/linux.html">Linux page</a>-- free UNIX for PC''s!!<li><a href="english.au">Hear Linus Himself speak!!!!</a><li><a href="/doc/">some docs on all kinds of computer stuff</a></ul><hr><h2>Paths of Retreat</h2>Several commonly travelled ways have left paths leading <em>away</em> from the maelstrom, too:<p><ul><li><a href="friends.html">Friends of Chaos</a><li><a href="http://www.apache.org/">The <em>Apache</em> home page</a> --         <em>Chaos</em>''s WWW server!!<li><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html">Notscape</a>the <a href="http://www.eskimo.com/%7Eirving/anti-ns/">Anti-NetscapePage</a> -- fight the tyranny!!</ul><hr><a href="/analog/usage.html">usage stats</a> for this server<hr><a href="http://www.eff.org/blueribbon.html"><img src="blueribbon.gif" alt="[blue ribbon campaign]"></a><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html"><img src="notscape.gif" alt="[NOTscape]"></a><a href="http://www.anybrowser.org/campaign/"><img src="anybrowser3.gif" alt="[Best Viewed With Any Browser"]></a></body></html>'.	^(HtmlParser on: input) formattedText! !!HtmlFormatter class methodsFor: 'initialization' stamp: 'ls 8/20/1998 06:05'!initialize	"HtmlFormatter initialize"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!HtmlFrame methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:25'!isFrame	^true! !!HtmlFrame methodsFor: 'formatting' stamp: 'ls 7/26/1998 21:53'!addToFormatter: formatter	| src |	src _ self getAttribute: 'src' default: nil.	formatter ensureNewlines: 1.	src ifNotNil: [ formatter startLink: src ].	formatter addString: 'frame '.	formatter addString: (self name ifNil: ['(unnamed)']).	src ifNotNil:  [ formatter endLink: src ].	formatter ensureNewlines: 1.! !!HtmlFrame methodsFor: 'testing' stamp: 'ls 7/26/1998 21:46'!mayContain: anEntity	^false! !!HtmlFrame methodsFor: 'testing' stamp: 'ls 7/26/1998 21:46'!tagName	^'frame'! !!HtmlFrameSet methodsFor: 'lint' stamp: 'ls 7/29/1998 00:25'!shouldContain: anEntity	^anEntity isFrame or: [ anEntity isFrameSet ]! !!HtmlFrameSet methodsFor: 'categorization' stamp: 'ls 7/29/1998 00:26'!isFrameSet	^true! !!HtmlFrameSet methodsFor: 'testing' stamp: 'ls 7/29/1998 00:26'!mayContain: anEntity	^true! !!HtmlFrameSet methodsFor: 'testing' stamp: 'ls 7/26/1998 21:45'!tagName	^'frameset'! !!HtmlHead methodsFor: 'metainformation' stamp: 'ls 7/5/1998 01:03'!title	"return the title, or nil if there isn't one"	| te |	te _ self titleEntity.	te ifNil: [ ^nil ].	^te textualContents! !!HtmlHead methodsFor: 'metainformation' stamp: 'ls 7/5/1998 01:02'!titleEntity	"return the title entity, or nil if there isn't one"	contents do: [ :e | e tagName = 'title' ifTrue: [ ^e ] ].	^nil! !!HtmlHead methodsFor: 'testing' stamp: 'ls 7/28/1998 20:25'!mayContain: anEntity	^anEntity isHeadElement or: [ anEntity isComment ]! !!HtmlHead methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'head'! !abstract superclass for entities that may appear in the HEAD section!!HtmlHeadEntity methodsFor: 'testing' stamp: 'ls 6/27/1998 15:37'!isHeadElement	^true! !!HtmlHeadEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:38'!addToFormatter: formatter	"head elements are normally just meta-information, and thus don't add anything to the formatter"! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 7/4/1998 12:55'!isHeader	^true! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 6/27/1998 15:58'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlHeader methodsFor: 'testing' stamp: 'ls 7/23/1998 05:42'!tagName	^'h', level printString! !!HtmlHeader methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:14'!addToFormatter: formatter	formatter ensureNewlines: 3.	formatter increaseBold.	super addToFormatter: formatter.	formatter decreaseBold.	formatter ensureNewlines: 2.! !!HtmlHeader methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 05:42'!initialize: aTag	super initialize: aTag.	level _ aTag name last digitValue.! !!HtmlHorizontalRule methodsFor: 'testing' stamp: 'ls 6/27/1998 15:52'!mayContain: anEntity	^false! !!HtmlHorizontalRule methodsFor: 'testing' stamp: 'ls 6/25/1998 02:22'!tagName	^'hr'! !!HtmlHorizontalRule methodsFor: 'formatting' stamp: 'ls 6/27/1998 15:57'!addToFormatter: formatter	formatter hr! !!HtmlImage methodsFor: 'downloading' stamp: 'ls 8/8/1998 03:47'!downloadState: baseUrl 	|  sourceUrl imageSource |	image ifNil: [ 		sourceUrl _ self src.		sourceUrl ifNotNil: [ 			imageSource _ HTTPSocket httpGetDocument: (sourceUrl asUrlRelativeTo: baseUrl asUrl) toText.			imageSource contentType = 'image/gif'  ifTrue: [				[image _ (GIFReadWriter on: (RWBinaryOrTextStream with: imageSource content) reset binary) nextImage ]				ifError: [ :a :b |  "could not decode--ignore it"  image _ nil ] ].			 ] ].! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 8/4/1998 21:58'!alt	^(self getAttribute: 'alt') ifNil: ['[image]']! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 9/9/1998 07:01'!imageExtent	"the image extent, according to the WIDTH and HEIGHT attributes.  returns nil if either WIDTH or HEIGHT is not specified"	| widthText heightText |	widthText _ self getAttribute: 'width' ifAbsent: [ ^nil ].	heightText _ self getAttribute: 'height' ifAbsent: [ ^nil ].	^ widthText asNumber @ heightText asNumber! !!HtmlImage methodsFor: 'attributes' stamp: 'ls 7/29/1998 00:56'!src	^self getAttribute: 'src' default: nil! !!HtmlImage methodsFor: 'formatting' stamp: 'ls 9/9/1998 07:05'!addToFormatter: formatter	| morph url |	self src isNil ifTrue: [ ^self ].	url _ self src.	formatter baseUrl ifNotNil: [ 		url _ url asUrlRelativeTo: formatter baseUrl ].	morph _ DownloadingImageMorph new.	morph defaultExtent: self imageExtent.	morph altText: self alt.	morph url: url.	formatter addIncompleteMorph: morph.! !!HtmlImage methodsFor: 'initializing' stamp: 'ls 7/27/1998 02:17'!initialize: aTag		super initialize: aTag.! !!HtmlImage methodsFor: 'testing' stamp: 'ls 7/1/1998 02:30'!mayContain: anEntity	^false! !!HtmlImage methodsFor: 'testing' stamp: 'ls 6/25/1998 02:22'!tagName	^'img'! !result of an <input> tag!!HtmlInput methodsFor: 'attributes' stamp: 'ls 9/18/1998 08:22'!defaultValue	^(self getAttribute: 'value' default: '') replaceHtmlCharRefs! !!HtmlInput methodsFor: 'attributes' stamp: 'ls 7/23/1998 19:09'!type	^(self getAttribute: 'type' default: 'text') asLowercase! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:15'!isTextualEntity	^true! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:14'!mayContain: anEntity	^false! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/21/1998 06:51'!suppliesInput	"whether we actually have input to supply"	self type = 'text' ifTrue: [ ^true ].	^false! !!HtmlInput methodsFor: 'testing' stamp: 'ls 7/5/1998 02:14'!tagName	^'input'! !!HtmlInput methodsFor: 'formatting' stamp: 'ls 8/11/1998 20:47'!addRadioButtonToFormatter: formatter	| name formData checked buttonSet button buttonInput |	"dig up relevant attributes"	name _ self getAttribute: 'name'.	name ifNil: [ ^self ].	value _ self getAttribute: 'value'.	value ifNil: [ ^value ].		formData _ formatter currentFormData.	formData ifNil:  [ ^self ].	checked _ self getAttribute: 'checked'.	"find or create the set of buttons with our same name"	buttonSet _ formData inputs detect: [ :i | i isRadioButtonSetInput and: [ i name = name ] ] ifNone: [ nil ].	buttonSet ifNil: [ 		"create a new button set"		buttonSet _ RadioButtonSetInput name: name.		formData addInput: buttonSet. ].	"set up the form input"	buttonInput _ RadioButtonInput  inputSet: buttonSet value: value.	buttonSet addInput: buttonInput.	checked ifNotNil: [		buttonSet  defaultButton: buttonInput ].	"create the actual button"	button _ PluggableButtonMorph on: buttonInput getState: #pressed  action: #toggle.	button label: 'X'.	formatter addMorph: button.! !!HtmlInput methodsFor: 'formatting' stamp: 'ls 9/11/1998 23:42'!addToFormatter: formatter	"is it a submit button?"	| inputMorph formData size |	self type = 'submit' ifTrue: [		formatter addMorph: ((PluggableButtonMorph on: formatter currentFormData getState: nil action: #submit) label: (self getAttribute: 'value' default: 'Submit')).		^self ].	self type = 'image' ifTrue: [		"fake it"		value _ self getAttribute: 'value' default: 'Submit'.		formData _ formatter currentFormData.		formatter addMorph: ((PluggableButtonMorph on: formData getState: nil action: #submit) label: value).		formData addInput: (HiddenInput name: (value,'.x') value: '0').		formData addInput: (HiddenInput name: (value,'.y') value: '0').			^self ].	self type = 'text' ifTrue: [		inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.		size _ self getAttribute: 'size' default: '12'.		size _ size asNumber.		inputMorph extent: (size*10@20).		formatter addMorph: inputMorph.		formatter currentFormData addInput: (TextInput name: self name  defaultValue: self defaultValue  textMorph: inputMorph).		^self ].	self type = 'hidden' ifTrue: [		formatter currentFormData addInput: (HiddenInput name: self name  value: self defaultValue).		^self ].	self type = 'radio' ifTrue: [ 		^self addRadioButtonToFormatter: formatter ].	formatter addString: '[form input of type: ', self type, ']'.! !an entity which displays its contents in italics!!HtmlItalicsEntity methodsFor: 'formatting' stamp: 'ls 6/27/1998 13:16'!addToFormatter: formatter	formatter increaseItalics.	super addToFormatter: formatter.		formatter decreaseItalics.! !!HtmlList methodsFor: 'testing' stamp: 'ls 7/17/1998 19:20'!mayContain: anElement	"lists may only contain LI elements"	"^anElement isListItem"	"except that people write some sucky HTML out there!!!!  well, let's assume they always put the end tag.  Much safer assumption than that they only put list-items in their lists"	^true! !!HtmlList methodsFor: 'testing' stamp: 'ls 7/28/1998 20:40'!shouldContain: anEntity	^anEntity isListItem! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 02:10'!isListItem	^true! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!mayContain: anEntity	^anEntity isBlockEntity or: [ anEntity isTextualEntity ]! !!HtmlListItem methodsFor: 'testing' stamp: 'ls 6/25/1998 02:09'!tagName	^'li'! !!HtmlListItem methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:49'!addToFormatter: formatter	formatter startListItem.	super addToFormatter: formatter.	formatter endListItem.! !some result of a meta tag; unimplemented so far!!HtmlMeta methodsFor: 'testing' stamp: 'ls 7/5/1998 02:22'!mayContain: anEntity	^false! !!HtmlMeta methodsFor: 'testing' stamp: 'ls 7/5/1998 02:22'!tagName	^'meta'! !!HtmlMeta methodsFor: 'formatting' stamp: 'ls 8/12/1998 05:44'!addToFormatter: formatter	| httpEquiv |	httpEquiv _ self getAttribute: 'http-equiv'.	httpEquiv ifNil: [ ^self ].	httpEquiv asLowercase = 'refresh' ifTrue: [		formatter addString: '{refresh: ', (self getAttribute:  'content' default: ''), '}' ].! !!HtmlMeta methodsFor: 'initialization' stamp: 'ls 7/5/1998 02:23'!initialize: aTag	super initialize: aTag.	theTag _ aTag.! !!HtmlMeta methodsFor: 'printing' stamp: 'ls 7/5/1998 02:24'!printOn: aStream indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: 'meta: '.	theTag printOn: aStream.	aStream cr.! !!HtmlOption methodsFor: 'attributes' stamp: 'ls 8/5/1998 07:19'!label	"label to be displayed for this morph"	^self getAttribute: 'label' ifAbsent: [self textualContents]! !!HtmlOption methodsFor: 'attributes' stamp: 'ls 8/5/1998 08:42'!value	"value to pass if this option is selected"	^self getAttribute: 'value' default: '(unspecified)'! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!isOption	^true! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlOption methodsFor: 'testing' stamp: 'ls 7/21/1998 07:04'!tagName	^'option'! !!HtmlOptionGroup methodsFor: 'testing' stamp: 'ls 7/21/1998 07:33'!mayContain: anEntity	^anEntity isOption! !!HtmlOptionGroup methodsFor: 'testing' stamp: 'ls 7/21/1998 07:05'!tagName	^'optgroup'! !!HtmlOrderedList methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:50'!addToFormatter: formatter	formatter startOrderedList.	super addToFormatter: formatter.	formatter endOrderedList.! !!HtmlOrderedList methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'ol'! !!HtmlParagraph methodsFor: 'formatting' stamp: 'ls 7/4/1998 01:16'!addToFormatter: formatter	formatter ensureNewlines: 2.	super addToFormatter: formatter.! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 03:02'!isBlockEntity	^true! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 03:03'!isParagraph	^true! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlParagraph methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!tagName	^'p'! !parses a stream of HtmlToken's into an HtmlDocument.  All token become an entity of some sort in the resulting document; some things are left only as comments, though.!!HtmlParser class methodsFor: 'parsing' stamp: 'ls 7/28/1998 02:02'!parse: aStream	^self parseTokens: (HtmlTokenizer on: aStream)! !!HtmlParser class methodsFor: 'parsing' stamp: 'ls 7/29/1998 03:13'!parseTokens: tokenStream	|  entityStack document head token matchesAnything entity body |	entityStack _ OrderedCollection new.	"set up initial stack"	document _ HtmlDocument new.	entityStack add: document.		head _ HtmlHead new.	document addEntity: head.	entityStack add: head.	"go through the tokens, one by one"	[ token _ tokenStream next.  token = nil ] whileFalse: [		(token isTag and: [ token isNegated ]) ifTrue: [			"a negated token"			(token name ~= 'html' and: [ token name ~= 'body' ]) ifTrue: [				"see if it matches anything in the stack"				matchesAnything _ (entityStack detect: [ :e | e tagName = token name ] ifNone: [ nil ]) isNil not.				matchesAnything ifTrue: [					"pop the stack until we find the right one"					[ entityStack last tagName ~= token name ] whileTrue: [ entityStack removeLast ].					entityStack removeLast.				]. ] ]		ifFalse: [			"not a negated token.  it makes its own entity"			token isComment ifTrue: [				entity _ HtmlCommentEntity new initializeWithText: token source.			].			token isText ifTrue: [				entity _ HtmlTextEntity new text: token text.				(((entityStack last shouldContain: entity) not) and: 					[ token source isAllSeparators ]) ifTrue: [					"blank text may never cause the stack to back up"					entity _ HtmlCommentEntity new initializeWithText: token source ].			].			token isTag ifTrue: [				entity _ token entityFor.				entity = nil ifTrue: [ entity _ HtmlCommentEntity new initializeWithText: token source ] ].			entity = nil ifTrue: [ self error: 'could not deal with this token' ].			entity isComment ifTrue: [				"just stick it anywhere"				entityStack last addEntity: entity ]			ifFalse: [				"only put it in something that is valid"				[ entityStack last mayContain: entity ] 					whileFalse: [ entityStack removeLast ].				"if we have left the head, create a body"									entityStack size < 2 ifTrue: [ 					body _ HtmlBody new.					document addEntity: body.					entityStack add: body  ].				"add the entity"				entityStack last addEntity: entity.				entityStack addLast: entity.			].		]].	body == nil ifTrue: [		"add an empty body"		body _ HtmlBody new.		document addEntity: body ].	document parsingFinished.	^document! !!HtmlParser class methodsFor: 'example' stamp: 'ls 6/27/1998 15:32'!example1	"HtmlParser example1"	| input |	input _ ReadStream on: '<html><head><title>The Gate of Chaos</title></head><body><h1>Chaos</h1><h2>Into the Maelstrom</h2>Direction is useless in the ever-changing Maelstrom.  However,if you wander with purpose, you might be able to find....<ul><li><a href="/cgi-bin/w">see who''s logged in</a><li><a href="/Telnet/connect.html">log in, if you (oooh) have an account</a><li><a href="http://chaos.resnet.gatech.edu:9000/sw">The Chaos Swiki</a>--scribble on chaos<li>the original <a href="/cgi-bin/guestlog-print">Visitor Sands</a><li>my old <a href="rant.html">Rant Page</a><li>neverending <a href="/cgi-bin/bread">poll</a>: do you have an opinion on bread?<li>a <a href="http://www.cc.gatech.edu/~lex/linux.html">Linux page</a>-- free UNIX for PC''s!!<li><a href="english.au">Hear Linus Himself speak!!!!</a><li><a href="/doc/">some docs on all kinds of computer stuff</a></ul><hr><h2>Paths of Retreat</h2>Several commonly travelled ways have left paths leading <em>away</em> from the maelstrom, too:<p><ul><li><a href="friends.html">Friends of Chaos</a><li><a href="http://www.apache.org/">The <em>Apache</em> home page</a> --         <em>Chaos</em>''s WWW server!!<li><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html">Notscape</a>the <a href="http://www.eskimo.com/%7Eirving/anti-ns/">Anti-NetscapePage</a> -- fight the tyranny!!</ul><hr><a href="/analog/usage.html">usage stats</a> for this server<hr><a href="http://www.eff.org/blueribbon.html"><img src="blueribbon.gif" alt="[blue ribbon campaign]"></a><a href="http://www.ee.umanitoba.ca/~djc/personal/notscape.html"><img src="notscape.gif" alt="[NOTscape]"></a><a href="http://www.anybrowser.org/campaign/"><img src="anybrowser3.gif" alt="[Best Viewed With Any Browser]"></a></body></html>'.	^HtmlParser parse: input! !!HtmlPreformattedRegion methodsFor: 'lint' stamp: 'ls 7/29/1998 00:27'!shouldContain: anEntity	^anEntity isTextualEntity! !!HtmlPreformattedRegion methodsFor: 'testing' stamp: 'ls 7/4/1998 12:06'!mayContain: anEntity	^true! !!HtmlPreformattedRegion methodsFor: 'testing' stamp: 'ls 7/4/1998 12:06'!tagName	^'pre'! !!HtmlPreformattedRegion methodsFor: 'formatting' stamp: 'ls 7/13/1998 23:15'!addToFormatter: formatter	formatter ensureNewlines: 1.	formatter increasePreformatted.	super addToFormatter: formatter.	formatter decreasePreformatted.	formatter ensureNewlines: 1.! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!isTextualEntity	^true! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:32'!mayContain: anEntity	^true  "end tag required"! !!HtmlSelect methodsFor: 'testing' stamp: 'ls 7/21/1998 07:05'!tagName	^'select'! !!HtmlSelect methodsFor: 'formatting' stamp: 'ls 8/11/1998 03:12'!addToFormatter: formatter	| options defaultOption listMorph names |	names _ OrderedCollection new.	options _ OrderedCollection new.	defaultOption _ nil.	(self getAttribute: 'multiple') ifNotNil: [		self flag: #incomplete.		formatter addString: '[M option list]'.		^self ].	contents do: [ :c |  c isOption ifTrue: [		names add: c value.		options add: c label.		(c getAttribute: 'selected') ifNotNil: [ defaultOption _ c label ] ] ].	contents isEmpty ifTrue: [ ^self ].	defaultOption ifNil: [ defaultOption _ contents first ].	listMorph _ PluggableListMorph on: (ValueHolder new contents: (contents indexOf: defaultOption)) list: nil  selected: #contents  changeSelected: #contents:.	listMorph list: options.	formatter addMorph: listMorph.	formatter currentFormData addInput: (SelectionInput  name: self name  defaultValue: defaultOption  list: listMorph  values: names asArray)! !supposedly decreases the font size its constituents are displayed in!the contents should be displayed struck-through!!HtmlStrikeEntity methodsFor: 'formatting' stamp: 'ls 7/5/1998 02:05'!addToFormatter: formatter	formatter increaseStrike.	super addToFormatter: formatter.	formatter decreaseStrike.! !!HtmlStyle methodsFor: 'testing' stamp: 'ls 7/5/1998 00:15'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlStyle methodsFor: 'testing' stamp: 'ls 7/5/1998 00:15'!tagName	^'style'! !an entity to be displayed as a subscript!an entity whose contents are to be displayed as a superscript!!HtmlTable methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!mayContain: anEntity	^anEntity isTableRow! !!HtmlTable methodsFor: 'testing' stamp: 'ls 7/4/1998 19:07'!tagName	^'table'! !!HtmlTable methodsFor: 'formatting' stamp: 'ls 9/12/1998 00:52'!addToFormatter: formatter	formatter ensureNewlines: 1.	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlTableDataItem methodsFor: 'formatting' stamp: 'ls 9/5/1998 03:37'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureSpaces: 1.! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!isTableDataItem	^true! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 12:56'!mayContain: anEntity	^anEntity isTextualEntity or: [ anEntity isBlockEntity or: [ anEntity isHeader ] ]! !!HtmlTableDataItem methodsFor: 'testing' stamp: 'ls 7/4/1998 19:01'!tagName	^'td'! !a TH tag.  Currently treated the same as a TD!!HtmlTableHeader methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:51'!tagName	^'th'! !!HtmlTableRow methodsFor: 'formatting' stamp: 'ls 9/12/1998 00:52'!addToFormatter: formatter	super addToFormatter: formatter.	formatter ensureNewlines: 1.! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 12:53'!isTableRow	^true! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 12:54'!mayContain: anEntity	^anEntity isTableDataItem! !!HtmlTableRow methodsFor: 'testing' stamp: 'ls 7/4/1998 19:00'!tagName	^'tr'! !An HTML tag, eg <a href="foo.html">!!HtmlTag methodsFor: 'parser support' stamp: 'ls 6/27/1998 13:18'!entityFor	"return an empty entity corresponding to this tag"	| eClass |	eClass _ self class entityClasses at: name ifAbsent: [ ^nil ].	^eClass forTag: self ! !!HtmlTag methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isTag	^true! !!HtmlTag methodsFor: 'access' stamp: 'ls 1/25/98 04:50'!attribs	"return a dictionary mapping attribute names (in lowercase) to their values"	^attribs! !!HtmlTag methodsFor: 'access' stamp: 'ls 6/24/1998 18:53'!isNegated	^isNegated! !!HtmlTag methodsFor: 'access' stamp: 'ls 1/25/98 04:49'!name	"return the basic kind of tag, in lowercase"	^name! !!HtmlTag methodsFor: 'private-initialization' stamp: 'ls 7/14/1998 22:49'!name: name0  negated: isNegated0 attribs: attribs0	"initialize from the given attributes"	name _ name0.	isNegated _ isNegated0.	attribs _ attribs0 ifNil: (Dictionary new).! !!HtmlTag class methodsFor: 'parser support' stamp: 'ls 9/12/1998 00:52'!entityClasses	"a Dictionary mapping tag names into the correct entity class"	"EntityClasses _ nil"	EntityClasses isNil ifFalse: [ ^EntityClasses ].	EntityClasses _ Dictionary new.	#( 		frameset	HtmlFrame		frame	HtmlFrame		title		HtmlTitle		style	HtmlStyle		meta	HtmlMeta		p		HtmlParagraph		form	HtmlForm		blockquote	HtmlBlockQuote		input	HtmlInput		textarea	HtmlTextArea		select	HtmlSelect		optgroup	HtmlOptionGroup		option		HtmlOption		img		HtmlImage		a		HtmlAnchor		br		HtmlBreak		li		HtmlListItem		dd		HtmlDefinitionDefinition		dt		HtmlDefinitionTerm		ol		HtmlOrderedList		ul		HtmlUnorderedList		dl		HtmlDefinitionList		h1		HtmlHeader		h2		HtmlHeader		h3		HtmlHeader		h4		HtmlHeader		h5		HtmlHeader		h6		HtmlHeader		hr		HtmlHorizontalRule		strong	HtmlBoldEntity		b		HtmlBoldEntity		em		HtmlItalicsEntity		i		HtmlItalicsEntity		dfn 	HtmlItalicsEntity		u		HtmlUnderlineEntity 		tt		HtmlFixedWidthEntity		kbd		HtmlFixedWidthEntity				strike	HtmlStrikeEntity		big		HtmlBiggerFontEntity		small	HtmlSmallerFontEntity		sub		HtmlSubscript		sup		HtmlSuperscript		font	HtmlFontEntity		pre		HtmlPreformattedRegion 		table	HtmlTable		tr		HtmlTableRow		td		HtmlTableDataItem 		th		HtmlTableHeader		) pairsDo: [ 			:tagName :className |			EntityClasses at: tagName asString put: (Smalltalk at: className) ].	^EntityClasses ! !!HtmlTag class methodsFor: 'parser support' stamp: 'ls 7/14/1998 22:56'!initialize	EntityClasses _ nil.! !!HtmlTag class methodsFor: 'instance creation' stamp: 'ls 6/24/1998 18:54'!source: source0  name: name0  negated: negated0 attribs: attribs0	^(super forSource: source0) name: name0 negated: negated0 attribs: attribs0! !A sequence of text without any tags in it.  &sp; style characters have been replaced by their actual values. !!HtmlText methodsFor: 'formatter' stamp: 'ls 6/24/1998 17:29'!addToFormatter: aFormatter	"add ourself to a formatter"	aFormatter addText: source! !!HtmlText methodsFor: 'access' stamp: 'ls 1/25/98 04:57'!text	^text! !!HtmlText methodsFor: 'private-initialization' stamp: 'ls 8/25/1998 05:47'!initialize: source0	super initialize: source0.	self text: source0 replaceHtmlCharRefs.! !!HtmlText methodsFor: 'private-initialization' stamp: 'ls 7/21/1998 01:02'!text: text0	text _ text0.! !!HtmlText methodsFor: 'properties' stamp: 'ls 1/25/98 04:57'!isText	^true! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/5/1998 02:28'!isBlockEntity	"not sure...."	^true! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/29/1998 00:28'!mayContain: anEntity	^true   "really we shouldn't be interpretting tags in here at all, though...."! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/17/1998 19:05'!suppliesInput	^self name ~= nil! !!HtmlTextArea methodsFor: 'testing' stamp: 'ls 7/5/1998 02:40'!tagName	^'textarea'! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:17'!columns	| a |	a _ self getAttribute: 'cols' default: '70'.	^(Integer readFrom: (ReadStream on: a)) max: 5.! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:12'!defaultValue	^self textualContents  "it would be nice to through the tags in there, too....  Easiest way would probably be to modiy the tokenizer"! !!HtmlTextArea methodsFor: 'attributes' stamp: 'ls 7/17/1998 03:16'!rows	| a |	a _ self getAttribute: 'rows' default: '20'.	^(Integer readFrom: (ReadStream on: a)) max: 1.! !!HtmlTextArea methodsFor: 'formatting' stamp: 'ls 8/5/1998 08:50'!addToFormatter: formatter	| inputMorph |	formatter ensureNewlines: 1.	inputMorph _ PluggableTextMorph on: StringHolder new text: #contents accept: #acceptContents:.	inputMorph extent: (self columns * 5) @ (self rows * 8).	formatter addMorph: inputMorph.	formatter currentFormData addInput: (TextInput name: self name  defaultValue:  self textualContents  textMorph: inputMorph).	formatter ensureNewlines: 1.! !!HtmlTextEntity methodsFor: 'contents' stamp: 'ls 7/5/1998 00:38'!textualContents	^text! !!HtmlTextEntity methodsFor: 'testing' stamp: 'ls 7/28/1998 20:26'!mayContain: anEntity	^false! !!HtmlTextEntity methodsFor: 'testing' stamp: 'ls 7/4/1998 16:30'!tagName	"bogus"	^'x-text'  ! !!HtmlTextEntity methodsFor: 'formatting' stamp: 'ls 6/25/1998 17:24'!addToFormatter: aFormatter	aFormatter addString: text! !!HtmlTextEntity methodsFor: 'printing' stamp: 'ls 7/14/1998 22:28'!printOn: aStream indent: indent	indent timesRepeat: [ aStream space ].	aStream nextPutAll: '['.	aStream nextPutAll: text.	aStream nextPutAll: ']'.	aStream cr.! !!HtmlTextEntity methodsFor: 'access' stamp: 'ls 6/25/1998 02:58'!text	^text! !!HtmlTextEntity methodsFor: 'access' stamp: 'ls 7/14/1998 23:58'!text: text0	text _ text0! !includes raw text, font-changing entities like <b> and <em>, and special entities like <a> and <img>.  All of these are relatively low level regarding formatting; they are superceded by higher level things like <li> and <p>.  When formatted, they flow around like characters.!!HtmlTextualEntity methodsFor: 'testing' stamp: 'ls 6/25/1998 02:12'!isTextualEntity	^true! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:35'!isHeadElement	^true! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:35'!mayContain: anEntity	^anEntity isTextualEntity! !!HtmlTitle methodsFor: 'testing' stamp: 'ls 6/27/1998 15:36'!tagName	^'title'! !!HtmlToken methodsFor: 'parser support' stamp: 'ls 6/25/1998 02:37'!entityFor	^self subclassResponsibility! !!HtmlToken methodsFor: 'formatting' stamp: 'ls 6/24/1998 17:29'!addToFormatter: aFormatter	"add ourself to a formatter"! !!HtmlToken methodsFor: 'printing' stamp: 'ls 1/25/98 05:45'!printOn: aStream	aStream nextPutAll: '{';		nextPutAll: self class name;		nextPut: $:;		nextPutAll: self source;		nextPut: $}.! !!HtmlToken methodsFor: 'private-initialization' stamp: 'ls 1/25/98 05:34'!initialize: s	"default initialization doesn't do much.  subclasses are free to override"	source _ s! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:47'!isComment	"whether this token is an HTML comment"	^false! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:38'!isTag	"is this an HTML tag"	^false! !!HtmlToken methodsFor: 'properties' stamp: 'ls 1/25/98 04:39'!isText	"return whether it is a string of text"	^false! !!HtmlToken methodsFor: 'access' stamp: 'ls 1/25/98 04:48'!source	"the raw source text that composes this token"	^source! !!HtmlToken class methodsFor: 'instance creation' stamp: 'ls 1/25/98 06:01'!forSource: source  	^super new initialize: source! !This class takes a text stream and produces a sequence of HTML tokens.It requires its source stream to support #peek.!!HtmlTokenizer methodsFor: 'private-initialization' stamp: 'ls 9/18/1998 08:06'!initialize: s	text _ s withSqueakLineEndings.	pos _ 1.	textAreaLevel _ 0.! !!HtmlTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/18/1998 08:08'!next 	"return the next HtmlToken, or nil if there are no more"	|token|	"branch, depending on what the first character is"	self atEnd ifTrue: [ ^nil ].	self peekChar = $< 		ifTrue: [ token _ self nextTagOrComment ]		ifFalse: [ token _ self nextText ].	"return the token, modulo modifications inside of textarea's"	textAreaLevel > 0 ifTrue: [		(token isTag and: [ token name = 'textarea' ]) ifTrue: [			"textarea tag--change textAreaLevel accordingly"			token isNegated				ifTrue: [ textAreaLevel _ textAreaLevel - 1 ]				ifFalse: [ textAreaLevel _ textAreaLevel -2 ].			textAreaLevel > 0				ifTrue: [ 					"still inside a <textarea>, so convert this tag to text"					^HtmlText forSource: token source ]				ifFalse: [ "end of the textarea; return the tag"  ^token ] ].			"end of the textarea"		"inside the text area--return the token as text"		^HtmlText forSource: token source ].	(token isTag and: [ token isNegated not and: [ token name = 'textarea' ]]) ifTrue: [		"beginning of a textarea"		inTextArea _ true.		^token ].			^token! !!HtmlTokenizer methodsFor: 'stream protocol' stamp: 'ls 8/20/1998 05:15'!atEnd	"are there any more tokens?  This is equivalent to whether there is any more input"	^(pos > text size)! !!HtmlTokenizer methodsFor: 'private' stamp: 'ls 8/20/1998 05:14'!nextChar	| c |	self atEnd ifTrue: [ ^nil ].	c _ text at: pos.	pos _ pos + 1.	^c! !!HtmlTokenizer methodsFor: 'private' stamp: 'ls 8/20/1998 05:14'!peekChar	self atEnd ifTrue: [ ^nil ].	^text at: pos! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:33'!nextAttributeValue	"return the next sequence of alphanumeric characters; used to read in the value part of a tag's attribute, ie <tagname  attribname=attribvalue>"	"because of the plethora of sloppy web pages, this is EXTREMELY tolerant"	| c start end |	"make sure there are at least two characters left"	pos >= text size ifTrue: [ ^self nextChar asString ].	"okay, peek at the first character"	start _ pos.	c _ text at: start.	"check whether it's either kind of quote mark"	(c = $" or: [ c = $' ]) ifTrue: [		"yes--so find the matching quote mark"		end _ text indexOf: c startingAt: start+1 ifAbsent: [ text size + 1 ].		pos _ end+1.		^text copyFrom: start to: end ].	"no--go until a space or a $> is seen"	end _ text indexOfAnyOf: CSAttributeEnders startingAt: start ifAbsent: [ text size + 1 ].	end _ end - 1.	pos _ end + 1.	^text copyFrom: start to: end.! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:31'!nextComment	"we've seen < and the next is a !!.  read until the whole comment is done"	"this isn't perfectly correct--for instance <!!--> is considered a proper comment--but it should do for now.  It also picks up <!!DOCTYPE...> tags"	| source c hyphens |		self nextChar.   "swallow the $!!"	source _ WriteStream on: String new.	source nextPutAll: '<!!'.		self peekChar = $- ifFalse: [ 		"this case is wierd.  go until we find a > at all and pray it's the correct end-of-'comment'"		[	self atEnd or: [ self peekChar = $> ] 		] whileFalse: [			c _ self nextChar.			source nextPut: c 		].		self atEnd ifFalse: [ source nextPut: self nextChar ].		^HtmlComment forSource: source contents ].		hyphens _ 0.	[ 	c _ self nextChar.		c = nil or: [			source nextPut: c.			(hyphens >=2 and: [ c = $> ])]	] whileFalse: [		c = $- ifTrue: [ hyphens _ hyphens + 1 ] ifFalse: [ hyphens _ 0 ]	].			^HtmlComment forSource: source contents.! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:24'!nextName	"return the next sequence of alphanumeric characters"	"because of the plethora of sloppy web pages, this also accepts most non-space characters"	| start end |	start _ pos.	end _ text indexOfAnyOf: CSNameEnders startingAt: start ifAbsent: [ text size + 1].	end _ end - 1.	pos _ end+1.	^text copyFrom: start to: end! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:23'!nextSpaces	"read in as many consecutive space characters as possible"	| start end |	"short cut for a common case"	self peekChar isSeparator not ifTrue: [ ^'' ].	"find the start and end of the sequence of spaces"	start _ pos.	end _ text indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [ text size + 1 ].	end _ end - 1.	"update pos and return the sequence"	pos _ end + 1.	^text copyFrom: start to: end! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:43'!nextTag	"we've seen a < and peek-ed something other than a !!.  Parse and return a tag"	| source negated name attribs attribName attribValue sourceStart sourceEnd c |		sourceStart _ pos-1.	attribs _ Dictionary new.	"determine if its negated"	self peekChar = $/ 		ifTrue: [ negated _ true.  self nextChar. ]		ifFalse: [ negated _ false ].	"read in the name"	self skipSpaces.	name _ self nextName.	name _ name asLowercase.	"read in any attributes"	[ 	self skipSpaces.		c _ self peekChar.		c = nil or: [c isLetter not ]	] whileFalse: [		attribName _ self nextName.		attribName _ attribName asLowercase.		self skipSpaces.		self peekChar = $= 			ifTrue: [ 				self nextChar.				self skipSpaces.				attribValue _ self nextAttributeValue withoutQuoting  ]			ifFalse: [ attribValue _ '' ].		attribs at: attribName  put: attribValue ].	self peekChar = $> ifTrue: [ self nextChar ].	sourceEnd _ pos-1.	source _ text copyFrom: sourceStart to: sourceEnd.	^HtmlTag source: source name: name asLowercase negated: negated attribs: attribs! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:31'!nextTagOrComment	"next character is a $<.  So read either a tag or a token"	self nextChar.  "skip the $<"	^self peekChar = $!! 		ifTrue: [ self nextComment ]		ifFalse: [ self nextTag ]! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/20/1998 05:34'!nextText	"returns the next textual segment"	|start end|	start _ pos.	end _ (text indexOf: $< startingAt: start ifAbsent: [ text size + 1 ]) - 1.	pos _ end+1.	^HtmlText forSource: (text copyFrom: start to: end)! !!HtmlTokenizer methodsFor: 'private-tokenizing' stamp: 'ls 8/25/1998 05:26'!skipSpaces	"skip as many consecutive space characters as possible"	pos _ text indexOfAnyOf: CSNonSeparators startingAt: pos ifAbsent: [ text size + 1 ].! !!HtmlTokenizer class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 05:13'!on: aStream	^super basicNew initialize: aStream contents! !!HtmlTokenizer class methodsFor: 'initialization' stamp: 'ls 8/19/1998 09:09'!initialize	"HtmlTokenizer initialize"	CSAttributeEnders _ CharacterSet empty.	CSAttributeEnders addAll: Character separators.	CSAttributeEnders add: $>.		CSNameEnders _ CharacterSet empty.	CSNameEnders addAll: '=>'.	CSNameEnders addAll: Character separators.	CSNonSeparators _ CharacterSet separators complement.! !!HtmlUnderlineEntity methodsFor: 'formatting' stamp: 'ls 7/5/1998 01:41'!addToFormatter: formatter	formatter increaseUnderline.	super addToFormatter: formatter.		formatter decreaseUnderline.! !!HtmlUnorderedList methodsFor: 'formatting' stamp: 'ls 7/4/1998 19:50'!addToFormatter: formatter	formatter startUnorderedList.	super addToFormatter: formatter.	formatter endUnorderedList.! !!HtmlUnorderedList methodsFor: 'testing' stamp: 'ls 6/25/1998 02:07'!tagName	^'ul'! !A URL that can be accessed via the Hypertext Transfer Protocol (HTTP), ie, a standard Web URLrealm = the name of the security realm that has been discovered for this URL.   Look it up in Passwords.Passwords = a Dictionary of (realm -> encoded user&password)!!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 23:08'!askNamePassword	"Authorization is required by the host site.  Ask the user for a userName and password.  Encode them and store under this realm.  Return false if the user wants to give up."	| user password |	(self confirm: 'Host ', self toText, 'wants a different user and password.  Type them now?' orCancel: [false])		ifFalse: [^ false].	"Note: When Scamper is converted to run under MVC, we'll have to pass in topView in order to decide which FillInTheBlank to call."	user _ FillInTheBlank request: 'User account name?' initialAnswer: '' 				centerAt: Sensor cursorPoint - (50@0).	password _ FillInTheBlank request: 'Password?'.	Passwords at: realm put: (Authorizer new encode: user password: password).	^ true! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:25'!postFormArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpPostDocument: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self postFormArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self postFormArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:49'!privateInitializeFromText: aString relativeTo: aUrl	super privateInitializeFromText: aString relativeTo: aUrl.	realm _ aUrl realm.! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:47'!realm	^ realm! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:21'!retrieveContents	^ self retrieveContentsArgs: nil! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 20:21'!retrieveContentsArgs: args	| contents request std oldRealm encoded |	request _ realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request _ 'Authorization: Basic ', request, PWS crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents _ (HTTPSocket httpGetDocument: self toText args: args				accept: 'application/octet-stream' request: request).	(contents isKindOf: String) ifTrue: [		(contents beginsWith: 'HTTP/1.0 401 Unauthorized') ifTrue: [			std _ (PWS unauthorizedFor: '') findTokens: '"'.			(contents beginsWith: (std at: 1)) ifTrue: [				oldRealm _ realm.				realm _ (contents findTokens: '"') at: 2.				Passwords ifNil: [Passwords _ Dictionary new].				encoded _ Passwords at: realm ifAbsent: [nil].				(oldRealm ~= realm) & (encoded ~~ nil) 					ifTrue: [^ self retrieveContentsArgs: args]					ifFalse: ["ask the user"						self askNamePassword ifTrue: [^ self retrieveContentsArgs: args]]				]].		^MIMEDocument contentType: 'text/plain' content: 'error occured retrieving ', self toText, ': ', contents].	contents contentType = MIMEDocument defaultContentType ifTrue: [		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) 			content: contents content url: contents url ].	^contents! !!HttpUrl class methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 23:13'!shutDown	"Forget all cached passwords, so they won't stay in the image"	Passwords _ nil.! !holds various info on a channel that the user is a member of.!!IRCChannelInfo methodsFor: 'messages' stamp: 'ls 9/5/1998 00:40'!sendMessage: aString	"send a message on the channel"	connection privmsgFrom: nil  to: name  text: aString! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:17'!addMember: memberName	"note that memberName is on the channel.  memberName should be given in the user's preferred capitalization"	members add: memberName.	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:18'!addMembers: list	members addAll: list.	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 10:07'!changeTopic: aText	"attempt to change the topic"	connection sendMessage: (IRCProtocolMessage		command: 'TOPIC'		arguments: (Array with: self name with: aText asString)).	^true! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:44'!connection	"return the IRC connection I am watching"	^connection! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:18'!memberNames	"names of the clients subscribing to this channel"	^members! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/3/1998 21:28'!name	"name of the channel, in its preferred capitalization"	^name! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 09:39'!removeMember: memberName	"note that memberName has left (PART-ed or QUIT-ed) the channel"	members remove: memberName ifAbsent: [ ^self ].	self changed: #memberNames.! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/5/1998 00:41'!subscribe: anObject	"add anObject as a subscriber.  anObject must respond to ircMessageRecieved"	subscribers isEmpty ifTrue: [ connection join: name ].	subscribers add: anObject! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/3/1998 21:28'!subscribers	"collection of objects watching for messages on the channel"	^subscribers! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 08:52'!topic	^topic ifNil: ['']! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/17/1998 08:53'!topic: aString	topic _ aString.	self changed: #topic! !!IRCChannelInfo methodsFor: 'access' stamp: 'ls 9/5/1998 00:39'!unsubscribe: anObject	"unsubscribe anObject"	subscribers remove: anObject.	subscribers isEmpty ifTrue: [ connection leave: name ].! !!IRCChannelInfo methodsFor: 'private-initialization' stamp: 'ls 9/6/1998 20:23'!initializeName: aString  connection: aConnection	name _ aString.	members _ Set new.	subscribers _ IdentitySet new.	connection _ aConnection! !!IRCChannelInfo methodsFor: 'interface' stamp: 'ls 9/17/1998 09:21'!openUserList	"open a listing with all the users on this channel"	^IRCChannelUsersBrowser openOnChannel: self! !!IRCChannelInfo class methodsFor: 'instance creation' stamp: 'ls 9/6/1998 20:22'!forChannelNamed: aString  onConnection: connection	"create an instance for the channel with the given name"	^super new initializeName: aString connection: connection! !a browser of the list of channels a given connection offers.  Allows users to easily join and create channels.!!IRCChannelListBrowser methodsFor: 'private-initialization' stamp: 'ls 9/17/1998 11:23'!initialize: anIRCConnection	connection _ anIRCConnection.	channelList _ #().	channelIndex _ 0.	sortCriterion _ #name.	anIRCConnection addDependent: self.	self refreshChannelList.! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'ls 9/17/1998 10:45'!refreshChannelList	"update the list of channels"	| sortBlock |	channelList _ connection channelList.	"sort the channels"	sortCriterion = #name ifTrue: [		sortBlock _ [ :a :b | a name asIRCLowercase < b name asIRCLowercase ] ]	ifFalse: [		sortBlock _ [ :a :b |		a numUsers = b numUsers			ifTrue: [ a name asIRCLowercase < b name asIRCLowercase ]			ifFalse: [ a numUsers > b numUsers ] ] ].	channelList _ channelList asSortedCollection: sortBlock.	channelList _ channelList asArray.		channelIndex _ 0.	self changed: #channelDescriptions.	self changed: #channelIndex.! !!IRCChannelListBrowser methodsFor: 'private' stamp: 'ls 9/17/1998 07:00'!update: aSymbol	aSymbol == #channelList ifTrue: [		self refreshChannelList ].! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/17/1998 08:57'!createChannel	|  channelName |	channelName _ FillInTheBlank request: 'channel name'.	channelName isEmpty ifTrue: [ ^self ].	IRCChannelObserver openForChannelNamed: channelName  onConnection: connection! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/4/1998 22:07'!openMorphicView	| win descListView updateButton actionColumn openChannelButton createChannelButton |	win _ SystemWindow new.	win setLabel: 'Channel Listing'.	win model: self.	descListView _ PluggableListMorph on: self  list: #channelDescriptions selected: #channelIndex changeSelected: #channelIndex:.	win addMorph: descListView  frame: (0@0 extent: 0.8@0.9).	updateButton _ PluggableButtonMorph on: connection getState: nil action: #requestChannelList.	updateButton label: 'update'.	win addMorph: updateButton  frame: (0@0.9 extent: 1@0.1).	actionColumn _ AlignmentMorph newColumn.	openChannelButton _ PluggableButtonMorph on: self getState: nil action: #openSelectedChannel.	openChannelButton label: 'join channel'.	actionColumn addMorphBack: openChannelButton.	createChannelButton _ PluggableButtonMorph on: self getState: nil action: #createChannel.	createChannelButton label: 'create channel'.	actionColumn addMorphBack: createChannelButton.	win addMorph: actionColumn  frame: (0.8@0 extent: 0.2@0.9).	win openInWorld! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/17/1998 08:57'!openSelectedChannel	| channelInfo channelName |	channelInfo _ channelList at: channelIndex ifAbsent: [ ^self ].	channelName _ channelInfo name.	IRCChannelObserver openForChannelNamed: channelName  onConnection: connection! !!IRCChannelListBrowser methodsFor: 'interface' stamp: 'ls 9/4/1998 21:28'!openView	^self openMorphicView! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/17/1998 06:59'!channelDescriptions	^channelList collect: [ :channel |		channel name, '(', channel numUsers printString, ')    ', channel topic].! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/4/1998 21:34'!channelIndex	^channelIndex! !!IRCChannelListBrowser methodsFor: 'access' stamp: 'ls 9/4/1998 21:53'!channelIndex: anInteger	channelIndex _ anInteger.	self changed: #channelIndex! !!IRCChannelListBrowser class methodsFor: 'instance creation' stamp: 'ls 9/4/1998 21:35'!forConnection: connection	^super new initialize: connection! !!IRCChannelListBrowser class methodsFor: 'instance creation' stamp: 'ls 9/4/1998 21:36'!openForConnection: connection	(self forConnection: connection) openView! !converts IRC messages forwarded to it, into a textual format that may be displayed.  Messages may additionally sent *from* it, to a specified target.!!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 17:51'!chatAreaSelection	"where to put the cursor in the chat area.  We'll leave it at the very end so that the most recent mesages are always visible"	^chatText size to: chatText size-1! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/3/1998 19:59'!chatText	^chatText! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:12'!chatTextSelection	"where to put the cursor in the chat area.  We'll leave it at the very end so that the most recent mesages are always visible"	^chatText size to: chatText size-1! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:58'!connection: anIRCConnection channelName: aString	connection _ anIRCConnection.	channel _ connection channelInfo: aString.	channel subscribe: self.	chatText _ Text new.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 00:23'!ircMessageRecieved: aMessage	| sender newLine |	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	chatText _ chatText, newLine.	chatText size > 1000 ifTrue: [		chatText _ chatText copyFrom: (chatText size - 500) to: chatText size ].	self changed: #chatText.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 10:22'!openMorphicView	"open a view for interacting with this collector"	| win textArea inputArea topicArea usersButton |	win _ SystemWindow new.	win setLabel: channel name.	win model: self.	topicArea _ PluggableTextMorph on: channel  text: #topic  accept: #changeTopic:.	topicArea acceptOnCR: true.	win addMorph: topicArea frame: (0@0 extent: 0.9@0.1).	usersButton _ PluggableButtonMorph on: channel  getState: nil  action: #openUserList.	usersButton label: 'users'.	win addMorph: usersButton frame: (0.9@0 extent: 0.1@0.1).	textArea _ PluggableTextMorph on: self text: #chatText accept: nil readSelection: #chatTextSelection menu: nil.	win addMorph: textArea frame: (0@0.1 extent: 1@0.8).	inputArea _ PluggableTextMorph on: self text: nil accept: #sendMessage:.	inputArea acceptOnCR: true.	win addMorph: inputArea frame: (0@0.9 extent: 1@0.1) .	win openInWorld.! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/3/1998 20:59'!openView	"open a view for interacting with this collector"	^self openMorphicView! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:57'!release	super release.	channel unsubscribe: self! !!IRCChannelObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 08:57'!sendMessage: aText	channel sendMessage: aText asString.	^true! !!IRCChannelObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 08:56'!openForChannelNamed: channelName  onConnection: connection 	^(super new connection: connection  channelName: channelName) openView! !very basic info on an IRC channel; specifically, that returned by a LIST command!!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:39'!name	"the name of the channel"	^name! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:40'!numUsers	"number of users currently on the channel"	^numUsers! !!IRCChannelSummary methodsFor: 'access' stamp: 'ls 9/2/1998 22:40'!topic	"the current topic of discussion"	^topic! !!IRCChannelSummary methodsFor: 'printing' stamp: 'ls 9/2/1998 23:35'!printOn: aStream	aStream nextPutAll: 'IRCChannel '.	aStream nextPutAll: self name.	aStream nextPutAll: ' ('.	aStream nextPutAll: numUsers printString.	aStream nextPutAll: ')'.! !!IRCChannelSummary methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 22:38'!initializeName: aString  numUsers: anInteger  topic: anotherString	name _ aString.	numUsers _ anInteger.	topic _ anotherString.! !!IRCChannelSummary class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 22:39'!name: cname  numUsers: numUsers  topic: topic	^super new initializeName: cname  numUsers: numUsers  topic: topic! !Used for browsing the list of users on a particular channel.!!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:17'!onChannel: aChannel	channel _ aChannel.	userList _ #().	userIndex _ 0.	channel addDependent: self.	self refreshUserList.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:47'!openAsMorph	| win listView talkToButton |	win _ SystemWindow labelled: 'users in ', channel name.	win model: self.	listView _ PluggableListMorph on: self list: #userList selected: #userIndex  changeSelected: #userIndex:.	win addMorph: listView  frame: (0@0 extent: 1@0.9).	talkToButton _ PluggableButtonMorph on: self getState: nil action: #talkTo.	talkToButton label: 'talk to selected user'.	win addMorph: talkToButton  frame: (0@0.9 extent: 1@0.1).	win openInWorld! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:18'!openView	^self openAsMorph! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:22'!refreshUserList	"update the user list from the channel"	|oldName |	(userIndex > 0) ifTrue: [		oldName _ userList at: userIndex ].	userList _ channel memberNames asSortedCollection asArray.	userIndex _ 0.	oldName ifNotNil: [		"try to select the same user again"		userIndex _ userList indexOf: oldName ].	self changed: #userList.	self changed: #userIndex.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:42'!selectedUser	"return the name of the selected user, or nil if none"	^userList at: userIndex ifAbsent: [nil ].! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:43'!talkTo	"open a window for talking to the selected user"	| user |	user _ self selectedUser.	user ifNil: [ ^self ].	^IRCDirectMessagesObserver openForConnection: channel connection   talkingTo: user! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:17'!update: aSymbol	aSymbol == #memberNames ifTrue: [ self refreshUserList ].! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:16'!userIndex	"return the index in userList of the user currently selected"	^userIndex! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:25'!userIndex: anInteger	"change which user is selected"	userIndex _ anInteger.	self changed: #userIndex.! !!IRCChannelUsersBrowser methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:16'!userList	"return the current list of user names"	^userList! !!IRCChannelUsersBrowser class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:20'!onChannel: channel	^self new onChannel: channel! !!IRCChannelUsersBrowser class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:20'!openOnChannel: channel	^(self onChannel: channel) openView! !A connection to an IRC server.  This handles spooling messages in and out, and converts between network commands and more convenient data structures.Start up an instance along with an interface with:		IRCConnection new openView!!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!fullName	^fullName! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:26'!fullName: aString	fullName _ aString asString.	DefaultFullName _ fullName.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!nick	^nick ifNil: [ '(not set)' ]! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!nick: aString	nick _ aString asString.	DefaultNick _ nick.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:24'!portAsString	^port printString! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!portAsString: aString	port _ [ aString asString asNumber ] ifError: [ :a :b | ^false ].	DefaultPort _ port.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!server	^server ifNil: [ '(not set)' ]! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!server: aString	server _ aString asString.	DefaultServer _ server.	^true! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!userName	^userName! !!IRCConnection methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!userName: aText	userName _ aText asString.	DefaultUserName _ userName.	^true! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/6/1998 20:23'!channelInfo: channelName	"return cached info on a channel"	| lChannelName |	lChannelName _ channelName asIRCLowercase.	^subscribedChannels at: lChannelName ifAbsent: [ 		"no info available--create and return a skeleton"		subscribedChannels at: lChannelName put:			(IRCChannelInfo forChannelNamed: channelName  onConnection: self) ]! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:35'!channelList	"returns the list of channels, or nil if it hasn't been retrieved yet"	^channelList! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:53'!channelListReport	"list the channels in a textual format"	| list |	list _ self channelList.	list ifNil: [ ^'(info not available)' ].	^String streamContents: [ :stream |		stream nextPutAll: 'Channel List'; cr.		stream nextPutAll: '--------------'; cr.		list do: [ :channel |			stream nextPutAll: channel name.			stream nextPutAll: '('.			stream nextPutAll: channel numUsers printString.			stream nextPutAll: ')		['.			stream nextPutAll: channel topic.			stream nextPutAll: ']'.			stream cr ] ]! !!IRCConnection methodsFor: 'server info' stamp: 'ls 9/2/1998 23:18'!motd	"return the most recently seen Message of the Day, or nil if none has been seen yet"	^motd! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/17/1998 06:51'!initialize	self reset.	server _ DefaultServer.	port _ DefaultPort.	nick _ DefaultNick.	userName _ DefaultUserName.	fullName _ DefaultFullName.	directMessageSubscribers _ IdentitySet new.	protocolMessageSubscribers _ IdentitySet new.	consoleText _ Text new.! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/17/1998 08:44'!reset	"prepare for a new connection"	recieveBuffer _ String new.	protocolMessagesToSend _ OrderedCollection new.	sendBuffer _ nil.	socket _ nil.	channelList _ nil.	channelListBeingBuilt _ nil.	motd _ nil.	motdBeingBuilt _ nil.	messagesProcessed _ 0.	subscribedChannels _ Dictionary new.! !!IRCConnection methodsFor: 'private' stamp: 'ls 9/4/1998 23:22'!step	self processIO! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:38'!processChannelList: aMessage	"an item has arrived in the list of channels"	| chanName chanNumUsers chanTopic |	aMessage arguments size < 4 ifTrue: [ ^self ].	chanName _ aMessage arguments at: 2.	chanNumUsers _ (aMessage arguments at: 3) asNumber.	chanTopic _ (aMessage arguments at: 4).	chanName = '*' ifTrue: [ ^self ].	channelListBeingBuilt ifNil: [ channelListBeingBuilt _ OrderedCollection new ].	channelListBeingBuilt add: (IRCChannelSummary name: chanName numUsers: chanNumUsers topic: chanTopic). ! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:39'!processChannelListEnd: aMessage	"a complete channel listing has arrived"	"end of a channel listing"	channelList _ channelListBeingBuilt asArray.	channelListBeingBuilt _ nil.	self changed: #channelList. 	self changed: #channelListReport.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:37'!processChannelListStart: aMessage	"start of a channel listing"	channelListBeingBuilt _ OrderedCollection new.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 09:33'!processJoin: aMessage	"a user is joining a channel"	| channelName user |	channelName _ aMessage arguments first.	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	(self channelInfo: channelName) addMember: user! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 08:48'!processMessage: aMessage	| handler |	protocolMessageSubscribers do: [ :subscriber |		subscriber ircProtocolMessage: aMessage ].	handler _ MessageHandlers at: aMessage command ifAbsent: [ nil ].	handler ifNil: [	^self ].	^self perform: handler  with: aMessage! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:36'!processMotd: aMessage	"a new line has arrived for the MOTD"	motdBeingBuilt nextPutAll: aMessage arguments second.	motdBeingBuilt cr.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:36'!processMotdEnd: aMessage	"the whole MOTD has arrived"	motd _ motdBeingBuilt contents.	motdBeingBuilt _ nil.	self changed: #motd.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/4/1998 22:35'!processMotdStart: aMessage	"MOTD is being transmitted"	motdBeingBuilt _ WriteStream on: String new.! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:19'!processNamReply: aMessage	"list of names for a channel, probably a channel being joined"	| names lChannelName channelInfo |	names _ aMessage arguments last findTokens: ' '.	names _ names collect: [ :origName |		('+@' includes: origName first) 			ifTrue: [ origName copyFrom: 2 to: origName size ]			ifFalse: [ origName ] ].	lChannelName _ (aMessage arguments at: 3) asIRCLowercase.	channelInfo _ subscribedChannels at: lChannelName ifAbsent: [nil].	channelInfo ifNotNil: [ channelInfo addMembers: names ].! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:07'!processNoTopic: aMessage	"remove a channel's topic"	(self channelInfo: (aMessage arguments at: 2)) topic: ''! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 09:33'!processPach: aMessage	"a user is leaving a channel"	| channelName user |	channelName _ aMessage arguments first.	user _ aMessage prefix.	(user includes: $!!) ifTrue: [ user _ user copyFrom: 1 to: (user indexOf: $!!)-1 ].	(self channelInfo: channelName) removeMember: user! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPart: aMessage! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPing: aMessage	"ping request"	self sendMessage: (IRCProtocolMessage command: 'pong' arguments: aMessage arguments).! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/15/1998 06:35'!processPrivmsg: aMessage	"handle a PRIVMSG or NOTICE message"	| sender recipient text privMessage info |	"put together the message"	sender _ aMessage prefix.	recipient _ aMessage arguments at: 1.	text _ aMessage arguments at: 2.	privMessage _ IRCMessage sender: sender  recipient: recipient  text: text.	"broadcast the message to all subscribers"	info _ subscribedChannels at: recipient asIRCLowercase ifAbsent: [ nil ].	info ifNotNil: [ info subscribers do: [ :sub |		sub ircMessageRecieved: privMessage ] ].	recipient asIRCLowercase = nick asIRCLowercase ifTrue: [		directMessageSubscribers do: [ :sub |			sub ircMessageRecieved: privMessage ] ].! !!IRCConnection methodsFor: 'private-message handling' stamp: 'ls 9/17/1998 10:14'!processTopic: aMessage	"change a channel topic"	| args |	args _ aMessage arguments.	args size < 2 ifTrue: [ "malformed message" ^self ].	(self channelInfo: (args at: (args size-1))) topic: (args at: args size).! !!IRCConnection methodsFor: 'menu' stamp: 'ls 9/17/1998 11:18'!consoleMenu: menu	^menu		labels: 'connect\disconnect\message of the day\channel list\talk to individual\inspect me' withCRs		lines: #(2 4 5)		selections: #(openConnectionDialogue disconnect openMotd openChannelList talkTo inspect)! !!IRCConnection methodsFor: 'menu' stamp: 'ls 9/17/1998 11:17'!talkTo	"talk to some user using 1-to-1 chat messages"	| user |	user _ FillInTheBlank request: 'user to talk to'.	user _ user withBlanksTrimmed.	user isEmpty ifTrue: [ ^self ].	IRCDirectMessagesObserver openForConnection: self  talkingTo: user! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:42'!addToConsole: aText	"add aString to the text being displayed on console."	consoleText _ consoleText, aText.	consoleText size > 2000 ifTrue: [		consoleText _ consoleText copyFrom: (consoleText size - 1000) to: consoleText size ].	self changed: #consoleText.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:41'!consoleText	^consoleText! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:43'!consoleTextSelection	| size |	size _ self consoleText size.	^size+1 to: size! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:55'!openAsMorph	| win consolePane inputPane |	"build views"	win _ SystemWindow labelled: 'IRC'.	win model: self.	consolePane _ PluggableTextMorph on: self text: #consoleText accept: nil readSelection: #consoleTextSelection menu: #consoleMenu:.	win addMorph: consolePane frame: (0@0 extent: 1@0.9).	inputPane _ PluggableTextMorph on: self text: nil accept: #sendRawCommand:.	inputPane acceptOnCR: true.	win addMorph: inputPane  frame: (0@0.9 extent: 1@0.1).	"subscribe to protocol messages and direct messages, so we can display them on console"	self subscribeToDirectMessages: self.	self subscribeToProtocolMessages: self.	win openInWorld! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:32'!openChannelList	"open a view on the list of channels"	IRCChannelListBrowser openForConnection: self! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:58'!openConnectionDialogue	"open a dialogue for making new connections"	| dialogue textEntry connectButton y yDelta descMorph textEntryList |	dialogue _ SystemWindow new.	y _ 0.	yDelta _ 0.8 / 5.	textEntryList _ OrderedCollection new.	#(		'server'		server		'port'		portAsString		'nick'		nick		'username'	userName		'full name'	fullName	) pairsDo: [ :desc :meth |		descMorph _ PluggableButtonMorph on: self getState: nil action: nil.		descMorph label: desc.		dialogue addMorph: descMorph  frame: (0@y extent: 0.3@yDelta).		textEntry _ PluggableTextMorph on: self text: meth accept: (meth, ':') asSymbol.		textEntry extent: 200@20.		textEntry acceptOnCR: true.		dialogue addMorph: textEntry frame: (0.3@y extent: 0.7@yDelta).		textEntryList add: textEntry.		y _ y + yDelta.	].	connectButton _ PluggableButtonMorph on: [			textEntryList do: [ :m | m hasUnacceptedEdits ifTrue:[ m accept ] ].			self connect 		] getState: nil action: #value.	connectButton label: 'connect'.	dialogue addMorph: connectButton frame: (0@0.8 extent: 1@0.2).	dialogue setLabel: 'connect to an IRC server'.	dialogue openInWorld.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 01:12'!openDirectMessagesObserver	IRCDirectMessagesObserver openForConnection: self! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:37'!openMotd	"open a view on the MOTD"	| win textView updateButton |	win _ SystemWindow labelled: 'MOTD'.	textView _ PluggableTextMorph on: self text: #motd accept: nil.	win addMorph: textView  frame: (0@0 extent: 1@0.9).	updateButton _ PluggableButtonMorph on: self getState: nil action: #requestMotd.	updateButton label: 'update'.	win addMorph: updateButton  frame: (0@0.9 extent: 1@0.1).	win openInWorld.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:37'!openView	^self openAsMorph! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/17/1998 06:45'!perform: aSelector  orSendTo: editor	(self respondsTo: aSelector) ifTrue: [		^self perform: aSelector ].	^editor perform: aSelector! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:36'!release	super release.	self disconnect.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 23:46'!sendRawCommand: aString	"send a command directly"	| message |	message _ [ IRCProtocolMessage fromString: aString asString ] ifError: [ :a :b |		^false ].	self sendMessage: message.	^true! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/6/1998 20:21'!subscribe: anObject toChannel: channelName	"send all messages for channelName to anObject.  anObject must implemented #ircMessageReceieved:"	|  info |	info _ self channelInfo: channelName.	info subscribe: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/4/1998 18:06'!subscribeToDirectMessages: anObject	"send all messages directly to the user's nick to anObject.  anObject must implemented #ircMessageReceieved:"	directMessageSubscribers add: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/15/1998 06:30'!subscribeToProtocolMessages: anObject	"anObject should respond to #ircProtocolMessage:.  It will be sent all incoming messages"	protocolMessageSubscribers add: anObject! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 00:38'!unsubscribe: anObject fromChannel: channelName	"see subscribe:toChannel:"	|  lChannelName info |	lChannelName _ channelName asIRCLowercase.	info _ subscribedChannels at: lChannelName ifAbsent: [ ^self ].	info unsubscribe: anObject.! !!IRCConnection methodsFor: 'UI' stamp: 'ls 9/5/1998 00:10'!unsubscribeFromDirectMessages: anObject 	"see #subscribeFromDirectMessages:"	directMessageSubscribers remove: anObject ifAbsent: []! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!join: channelName	"join a channel"	self sendMessage: (IRCProtocolMessage		command: 'join'		arguments: (Array with: channelName))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!leave: channelName	"leave a channel"	self sendMessage: (IRCProtocolMessage		command: 'part'		arguments: (Array with: channelName))! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/12/1998 04:54'!privmsgFrom: from  to: to  text: text	"send a private message.  'to' can be a channel name...."	| msg |	msg _ (IRCProtocolMessage		prefix: from		command: 'privmsg'		arguments: (Array with: to  with: text)).	self processMessage: msg.	"because these aren't sent back by default"	self sendMessage: msg.! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:59'!quit	"tell the server we are leaving"	self sendMessage: (IRCProtocolMessage command: 'quit')! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 23:36'!requestChannelList	"request a list of all channels"	self sendMessage: (IRCProtocolMessage command: 'list')! !!IRCConnection methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 23:18'!requestMotd	self sendMessage: (IRCProtocolMessage command: 'motd')! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/4/1998 23:30'!connect	"connect to a server"	| addr |	Socket initializeNetwork.	socket ifNotNil: [ socket destroy ].	self reset.	Utilities informUser: 'looking up server address...' during: [		addr _ NetNameResolver addressForName: server ].	addr ifNil: [ ^PopUpMenu notify: 'could not find address for ', server ].	socket _ Socket new.	socket connectTo: addr  port: port.	self sendMessage: (IRCProtocolMessage fromString: 'NICK ', nick).	self sendMessage: (IRCProtocolMessage fromString: 'USER ', userName, ' * * :', fullName).! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/4/1998 21:27'!disconnect		"disconnect from the server"	socket ifNotNil: [ socket isValid ifTrue: [ 		Transcript show: 'disconnecting from IRC', String cr.		socket close ] ].		socket _ nil.! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/2/1998 17:45'!isConnected	"whether we are currently connected"	^socket ~~ nil  and: [ socket isConnected ]! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/3/1998 00:19'!processIO	"do as much network IO as is immediately possible"		| amount idx messageText message |	"do nothing if the socket isn't ready for work"	(socket isNil or: [socket isValid not or: [ socket isConnected not ]]) ifTrue: [ 		"Transcript show: 'socket not ready; no IO done'; cr."		^self ].	"first do sending"	[ socket sendDone and: [ sendBuffer isNil not or: [ protocolMessagesToSend size > 0 ] ] ]	whileTrue: [		sendBuffer ifNil: [			protocolMessagesToSend isEmpty ifFalse: [				sendBuffer _ protocolMessagesToSend removeFirst asString ] ].		sendBuffer ifNotNil: [			amount _ socket sendSomeData: sendBuffer.			sendBuffer _ sendBuffer copyFrom: amount+1 to: sendBuffer size.			sendBuffer isEmpty ifTrue: [ sendBuffer _ nil ] ].	].	"now do receiving"	[ socket dataAvailable ] whileTrue: [ 		recieveBuffer _ recieveBuffer, socket getData ].	"parse as many messages as possible"	[ idx _ recieveBuffer indexOf: Character lf.  	  idx > 0 ] whileTrue: [		messageText _ recieveBuffer copyFrom: 1 to: idx.		message _ IRCProtocolMessage fromString: messageText.				self processMessage: message.		recieveBuffer _ recieveBuffer copyFrom: idx+1 to: recieveBuffer size ].! !!IRCConnection methodsFor: 'network IO' stamp: 'ls 9/2/1998 21:53'!sendMessage: aMessage	"queue a message for sending"	protocolMessagesToSend addLast: aMessage.! !!IRCConnection methodsFor: 'naval mode' stamp: 'ls 9/17/1998 06:49'!ircMessageRecieved: aMessage	| sender newLine |	Smalltalk beep.	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	self addToConsole: newLine.! !!IRCConnection methodsFor: 'naval mode' stamp: 'ls 9/17/1998 06:47'!ircProtocolMessage: msg	"a new message.  log it on the console, unless it's a channel listing"	(msg command ~= IRCConnection RPLList printString	and: [ msg command ~= IRCConnection RPLMotd ]) ifTrue: [		self addToConsole: msg asString ].! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLAway	"someone has marked themselves as away"	^301! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLBanList	""	^367! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLChannelModeIs	""	^324! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLEndOfBanList	""	^368! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLEndOfLinks	""	^365! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:10'!RPLEndOfMotd	"the MOTD has been completely transmitted"	^376! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLEndOfNames	""	^366! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:07'!RPLEndOfWho	"end of responses to a WHO"	^315! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLEndOfWhoIs	""	^318! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:03'!RPLEndOfWhoWas	""	^369! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLInviting	"inform that you are inviting someone to a channel"	^341! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLLinks	""	^364! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLList	"one item in a list command"	^322! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLListEnd	"marks end of listing from a LIST command"	^323! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:04'!RPLListStart	"start of response to a LIST command"	^321! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:45'!RPLMotd	"a line from the MOTD"	^372! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/3/1998 18:17'!RPLMotd2	"secondd version of a line from the MOTD"	^377! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:09'!RPLMotdStart	"a MOTD listing is beginning"	^375! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:08'!RPLNamReply	""	^353! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLNoTopic	"no topic is set for the given channel"	^331! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLNowaway	"something to do with AWAY"	^306! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:06'!RPLSummoning	"inform that you are summoning a user"	^342! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:05'!RPLTopic	"topic for the given channel"	^332! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 22:59'!RPLUnaway	"someone has marked themselves as unaway"	^305! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:06'!RPLVersion	"version info for the server"	^351! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLWhoIsIdle	""	^317! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsOperator	""	^313! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsServer	""	^312! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:00'!RPLWhoIsUser	""	^311! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:07'!RPLWhoReply	"response to a WHO"	^352! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:03'!RPLWhoWasUser	""	^314! !!IRCConnection class methodsFor: 'reply codes' stamp: 'ls 9/2/1998 23:02'!RPLWhoisChannels	""	^319! !!IRCConnection class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 10:10'!initialize	"IRCConnection initialize"	self initializeMessageHandlers.	DefaultServer _ 'us.chatnet.org'.	DefaultPort _ 6667.	DefaultNick _ 'nick'.	DefaultUserName _ 'username'.	DefaultFullName _ 'J. Doe <jdoe@somewhere>'.! !!IRCConnection class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 10:11'!initializeMessageHandlers	"initilize the table mapping IRC commands to processing methods"	"IRCConnection initializeMessageHandlers"	MessageHandlers _ Dictionary new.	#(		372		processMotd:		377		processMotd:		375		processMotdStart:		376		processMotdEnd:		ping	processPing:		join		processJoin:		part	processPart:		privmsg		processPrivmsg:		notice		processPrivmsg:		321		processChannelListStart:		322		processChannelList:		323		processChannelListEnd:		331		processNoTopic:		332		processTopic:		topic	processTopic:		353		processNamReply:	) pairsDo: [ :command  :method |		MessageHandlers at: command asString put: method ].! !!IRCConnection class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:31'!new	^super new initialize! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!addToChatText: aString	chatText _ chatText, aString.	chatText size > 1000 ifTrue: [		chatText _ chatText copyFrom: (chatText size - 500) to: chatText size ].	self changed: #chatText.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:12'!chatAreaSelection 	^self chatTextSelection! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 23:52'!chatText	^chatText! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!chatTextSelection	^chatText size+1 to: chatText size! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/5/1998 00:01'!initialize: aConnection	connection _ aConnection.	chatText _ Text new.	connection subscribeToDirectMessages: self.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:11'!ircMessageRecieved: aMessage	| sender newLine |	sender _ aMessage sender ifNil: [ 'me' ].	(sender includes: $!!) ifTrue: [ sender _ sender copyFrom: 1 to: (sender indexOf: $!!)-1 ].	talkingTo ifNotNil: [		"only display messages to or from talkingTo"		sender asIRCLowercase = talkingTo asIRCLowercase ifFalse: [^self ] ].	newLine _ 		(Text string: sender emphasis: (Array with: TextEmphasis bold)), 		': ', aMessage text, String cr.	self addToChatText: newLine.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:15'!openMorphicView	"open a view for messages sent here"	| win textArea inputArea |	win _ SystemWindow new.	win setLabel: (talkingTo ifNotNil: [ talkingTo ] ifNil: [ 'private messages' ]).	win model: self.	textArea _ PluggableTextMorph on: self text: #chatText accept: nil readSelection: #chatTextSelection menu: nil.	talkingTo		ifNil: [ win addMorph: textArea frame: (0@0 extent: 1@1) ]		ifNotNil: [			win addMorph: textArea  frame: (0@0 extent: 1@0.9).			inputArea _ PluggableTextMorph on: self text: nil accept: #sendMessage:.			inputArea acceptOnCR: true.			win addMorph: inputArea  frame: (0@0.9 extent: 1@0.1) ].	win openInWorld.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/4/1998 23:53'!openView	^self openMorphicView! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/8/1998 04:55'!release	connection unsubscribeFromDirectMessages: self.	super release.! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 11:09'!sendMessage: aString	"send a message to the user we are talking to"	| newLine |	talkingTo ifNil: [ Smalltalk beep.  ^self ].	connection privmsgFrom: nil  to: talkingTo  text: aString.	newLine _ (Text string: 'me' attribute: TextEmphasis bold),		': ', aString, String cr.	self addToChatText: newLine.	^true! !!IRCDirectMessagesObserver methodsFor: 'as yet unclassified' stamp: 'ls 9/17/1998 09:38'!talkingTo: aName	"set who this window is for talking to"	talkingTo _ aName! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/5/1998 00:00'!forConnection: aConnection	^super new initialize: aConnection! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:38'!forConnection: aConnection  talkingTo: aName	^(super new initialize: aConnection) talkingTo: aName! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/5/1998 00:00'!openForConnection: aConnection	^(self forConnection: aConnection) openView! !!IRCDirectMessagesObserver class methodsFor: 'instance creation' stamp: 'ls 9/17/1998 09:38'!openForConnection: aConnection  talkingTo: aName	^(self forConnection: aConnection talkingTo: aName) openView! !A message on IRC.  It has a sender (usually a username), a recipient (usually a user or channel name), and some text.!!IRCMessage methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 17:14'!initializeSender: sender0  recipient: recipient0  text: text0	sender _ sender0.	recipient _ recipient0.	text _ text0.! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!recipient	"name the message is destined to"	^recipient! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!sender	"name of the message's sender"	^sender! !!IRCMessage methodsFor: 'access' stamp: 'ls 9/2/1998 17:15'!text	"message text"	^text! !!IRCMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 17:15'!sender: sender  recipient: recipient  text: text	"create a new message with the given sender, recipient, and text"	^super new initializeSender: sender  recipient: recipient text: text! !A pattern for matching IRC messages.  Currently one can only match on the sender or the reciever.!!IRCMessagePattern methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 17:41'!sender: sender0  recipient: recipient0	sender _ sender0.	recipient _ recipient0.! !!IRCMessagePattern methodsFor: 'filtering' stamp: 'ls 9/2/1998 17:42'!matches: aMessage	"decide whether the message matches this pattern"	sender ifNotNil: [ sender = aMessage sender ifFalse: [ ^false ] ].	recipient ifNotNil: [ recipient = aMessage recipient ifFalse: [ ^false ] ].	^true! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:11'!recipient: recipient	"create a pattern matching messages to the given recipient"	^self sender: nil  recipient: recipient! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:10'!sender: sender	"create a pattern for messages from the given sender"	^self sender: sender  recipient: nil! !!IRCMessagePattern class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 18:11'!sender: sender  recipient: recipient	"create a pattern matching messages from the given sender and to the given recipient"	^super new sender: sender  recipient: recipient! !holds some subset of the messages coming in from an IRC connection.  subclasses define specific criteria for filtering the messages.!!IRCMessageSet methodsFor: 'as yet unclassified' stamp: 'ls 8/21/1998 10:39'!acceptMessage: ircMessage	"whether the given message should be accepted by this set"	^self subclassResponsibility! !A Morph for interfacing with IRC.!!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:15'!addToConsole: aText	consoleText _ consoleText, aText.	consoleText size > 1000 ifTrue: [		consoleText _ consoleText copyFrom: (consoleText size - 500) to: consoleText size ].	self changed: #consoleText.! !!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:15'!consoleSelection	^consoleText size to: consoleText size - 1! !!IRCMorph methodsFor: 'console' stamp: 'ls 9/4/1998 21:17'!consoleTextSelection	^consoleText size to: consoleText size - 1! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:19'!step	connection processIO.! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:17'!stepTime	^0! !!IRCMorph methodsFor: 'stepping' stamp: 'ls 9/3/1998 00:19'!wantsSteps	^true! !!IRCMorph methodsFor: 'initialization' stamp: 'ls 9/4/1998 23:13'!initialize 	|  connectButton column channelListButton motdButton consoleView inputPane |	super initialize.	connection _ IRCConnection new.	server _ DefaultServer.	port _ DefaultPort.	nick _ DefaultNick.	userName _ DefaultUserName.	fullName _ DefaultFullName.	self setLabel: 'IRC'.	self extent: 200@100.	column _ AlignmentMorph newColumn.	connectButton _ PluggableButtonMorph		on: self		getState: nil		action: #openConnection.	connectButton label: 'connect to server'.	column addMorphBack: connectButton.	motdButton _ PluggableButtonMorph		on: self		getState: nil		action: #openMotd.	motdButton label: 'view MOTD'.	column addMorphBack: motdButton.	channelListButton _ PluggableButtonMorph		on: self		getState: nil		action: #openChannelList.	channelListButton label: 'channel list'.	column addMorphBack: channelListButton.	self addMorph: column frame: (0@0 extent: 0.4@0.8).	consoleText _ Text new.	consoleView _ PluggableTextMorph on: self  text: #consoleText accept: nil readSelection: #consoleTextSelection menu: nil.	self addMorph: consoleView frame: (0.4@0 extent: 0.6@0.8).	consoleView color: (Color r: 0.937 g: 0.937 b: 0.937).	inputPane _ PluggableTextMorph on: self text: nil accept: #sendCommand:.	self addMorph: inputPane frame: (0@0.8 corner: 1@1).! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/3/1998 17:29'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu  hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'connect to server' action: #makeConnection.	aCustomMenu addLine.	aCustomMenu add: 'view MOTD' action: #openMotd.	aCustomMenu add: 'view channel list' action: #openChannelList.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:12'!connect	connection ifNotNil: [ connection disconnect ].	connection ifNil: [ connection _ IRCConnection new ].	connection connectToServer: server  port: port nick: nick  user: userName  fullName: fullName.	connection subscribeToDirectMessages: self.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 18:10'!delete	super delete.	connection quit.	connection processIO.  "give the QUIT a brief chance to happen"	connection disconnect.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 22:11'!ircMessageRecieved: aMessage	| sender |	sender _ aMessage sender ifNil: [ nick ].	self addToConsole: (		sender asText,		': ',		aMessage text,		String cr).! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:57'!makeConnection	connection ifNotNil: [ connection disconnect ].	connection ifNil: [ connection _ IRCConnection new ].	connection connectToServer: server  port: port nick: nick  user: userName  fullName: fullName.	connection requestChannelList.    "this is usually necessary, so go ahead and ask for it"! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 23:11'!openChannel: name	"open a window for interacting with the given channel"	IRCChannelObserver openForChannel: name  onConnection: connection ! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 21:35'!openChannelList	"open a view on the list of channels"	IRCChannelListBrowser openForConnection: connection! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/4/1998 17:57'!openConnection	"open a dialogue for making new connections"	| dialogue textEntry connectButton y yDelta descMorph |	dialogue _ SystemWindow new.	y _ 0.	yDelta _ 0.8 / 5.	#(		'server'		server		'port'		portAsString		'nick'		nick		'username'	userName		'full name'	fullName	) pairsDo: [ :desc :meth |		descMorph _ PluggableButtonMorph on: self getState: nil action: nil.		descMorph label: desc.		dialogue addMorph: descMorph  frame: (0@y extent: 0.3@yDelta).		textEntry _ PluggableTextMorph on: self text: meth accept: (meth, ':') asSymbol.		textEntry extent: 200@20.		dialogue addMorph: textEntry frame: (0.3@y extent: 0.7@yDelta).		y _ y + yDelta.	].	connectButton _ PluggableButtonMorph on: self getState: nil action: #connect.	connectButton label: 'connect'.	dialogue addMorph: connectButton frame: (0@0.8 extent: 1@0.2).	dialogue setLabel: 'connect to an IRC server'.	dialogue openInWorld.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/3/1998 17:44'!openMotd	connection openMotd! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/8/1998 04:55'!release	connection quit.	connection processIO.  "give the QUIT a brief chance to happen"	connection disconnect.	super release.! !!IRCMorph methodsFor: 'interface' stamp: 'ls 9/3/1998 00:23'!sendCommand: aString	| message |	[ message _ IRCProtocolMessage fromString: aString asString ] ifError: [ ^false ].	connection sendMessage: message.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/4/1998 18:49'!consoleText	^consoleText! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!fullName	^fullName! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:26'!fullName: aString	fullName _ aString asString.	DefaultFullName _ fullName.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!nick	^nick ifNil: [ '(not set)' ]! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!nick: aString	nick _ aString asString.	DefaultNick _ nick.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:24'!portAsString	^port printString! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!portAsString: aString	port _ [ aString asString asNumber ] ifError: [ :a :b | ^false ].	DefaultPort _ port.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/2/1998 18:23'!server	^server ifNil: [ '(not set)' ]! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!server: aString	server _ aString asString.	DefaultServer _ server.	^true! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:04'!userName	^userName! !!IRCMorph methodsFor: 'access' stamp: 'ls 9/3/1998 18:27'!userName: aText	userName _ aText asString.	DefaultUserName _ userName.	^true! !!IRCMorph class methodsFor: 'misc' stamp: 'ls 9/4/1998 18:53'!hasPrototype	"it's not needed here...."	^false! !!IRCMorph class methodsFor: 'initialization' stamp: 'ls 9/3/1998 20:42'!initialize 	"set all the defaults to something reasonable"	DefaultServer _ 'us.chatnet.org'.	DefaultPort _ 6667.	DefaultNick _ 'nick'.	DefaultUserName _ 'username'.	DefaultFullName _ 'J. Doe <jdoe@somewhere>'.! !A low-level IRC message; this is an internal format for what actually goes over the wire.!!IRCProtocolMessage methodsFor: 'IRC commands' stamp: 'ls 9/2/1998 21:57'!quit	self sendMessage: (IRCProtocolMessage command: 'quit')! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:49'!arguments	"return the arguments to the command"	^arguments! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:48'!command	"return the main command, in lowercase"	^command! !!IRCProtocolMessage methodsFor: 'access' stamp: 'ls 9/2/1998 21:49'!prefix	"return the prefix of the message, or nil if none"	^prefix! !!IRCProtocolMessage methodsFor: 'private-initialization' stamp: 'ls 9/2/1998 21:49'!prefix: aString  command: anotherString  arguments: aCollection	prefix _ aString.	command _ anotherString asLowercase.	arguments _ aCollection.! !!IRCProtocolMessage methodsFor: 'encoding' stamp: 'ls 9/2/1998 21:49'!asString	"encode in the format used for transferral over the network"	^String streamContents: [ :stream |		prefix ifNotNil: [			stream nextPut: $:.			stream nextPutAll: prefix.			stream space ].		stream nextPutAll: command asUppercase.		stream space.		arguments isEmpty ifFalse: [			"print out all but the last argument"			(arguments copyFrom: 1 to: (arguments size - 1)) do: [ :arg |				stream nextPutAll: arg.				stream space ].						"print the last as a trailer, just to be safe"			stream nextPut: $:.			stream nextPutAll: arguments last. ].		stream nextPut: Character cr.		stream nextPut: Character lf. ]! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:52'!command: anotherString	^self command: anotherString  arguments: Array new! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 21:52'!command: anotherString  arguments: aCollection	^self prefix: nil  command: anotherString  arguments: aCollection! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 19:47'!fromString: aString	"parse an IRC message from its network format"	| remainder trailerStart trailer tokens command  arguments prefix idx |	remainder _ aString.	"strip the CRLF"	idx _ remainder indexOf: Character cr.	idx > 0 ifTrue: [ remainder _ remainder copyFrom: 1 to: idx-1 ].	idx _ remainder indexOf: Character lf.	idx > 0 ifTrue: [ remainder _ remainder copyFrom: 1 to: idx-1 ].	"check if there is a trailer"	trailerStart _ remainder indexOf: $: startingAt: 2 ifAbsent: [0].	trailerStart > 0 ifTrue: [		trailer _ remainder copyFrom: trailerStart+1 to: remainder size.		remainder _ remainder copyFrom: 1 to: trailerStart-1 ].	"divide the rest of the string up between spaces"	tokens _ remainder findTokens: ' '.	"the command is the first token..."	command _ tokens removeFirst.	command first = $: ifTrue: [		"...unless it starts with a $:, in which case there is a prefix and the command is the second token"		prefix _ command copyFrom: 2 to: command size.  "copy without the leading :"		command _ tokens removeFirst ].	"the arguments are the remaining tokens, plus the trailer if any"	arguments _ tokens.	trailer ifNotNil: [ arguments _ arguments copyWith: trailer ].	^self prefix: prefix  command: command  arguments: arguments.! !!IRCProtocolMessage class methodsFor: 'instance creation' stamp: 'ls 9/2/1998 19:34'!prefix: aString  command: anotherString  arguments: aCollection	^super new prefix: aString  command: anotherString  arguments: aCollection! !a filter for messages  sent to a particular user!!ImageMorph methodsFor: 'menu commands' stamp: 'di 9/15/1998 09:58'!readFromFile	| fileName |	fileName _ FillInTheBlank		request: 'Please enter the image file name'		initialAnswer: 'fileName'.	fileName isEmpty ifTrue: [^ self].	self image: (Form fromFileNamed: fileName).! !Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.I am an abstract class to provide for encoding and/or decoding an image ona stream.Instance Variables:	stream		<ReadStream | WriteStream>	stream for imagestoragesClass Variables:	ImageNotStoredSignal		<Signal>	image not storederror signal	MagicNumberErrorSignal		<Signal>	magic number errorsignalSubclasses must implement the following messages:	accessing		nextImage		nextPutImage:	testing		canUnderstand         (added tao 10/26/97)!!ImageReadWriter methodsFor: 'accessing'!nextImage	"Dencoding an image on stream and answer the image."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'accessing'!nextPutImage: anImage	"Encoding anImage on stream."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'stream access'!atEnd	^stream atEnd! !!ImageReadWriter methodsFor: 'stream access'!close	"close if you can"	(stream respondsTo: #close) ifTrue: [			stream closed ifFalse: [stream close]]! !!ImageReadWriter methodsFor: 'stream access'!contents	^stream contents! !!ImageReadWriter methodsFor: 'stream access'!cr	^stream nextPut: Character cr asInteger! !!ImageReadWriter methodsFor: 'stream access'!lf	"PPM and PBM are used LF as CR."	^stream nextPut: Character lf asInteger! !!ImageReadWriter methodsFor: 'stream access'!next	^stream next! !!ImageReadWriter methodsFor: 'stream access'!next: size	^stream next: size! !!ImageReadWriter methodsFor: 'stream access'!nextLong	"Read a 32-bit quantity from the input stream."	^(stream next bitShift: 24) + (stream next bitShift: 16) +		(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextLongPut: a32BitW	"Write out a 32-bit integer as 32 bits."	stream nextPut: ((a32BitW bitShift: -24) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -16) bitAnd: 16rFF).	stream nextPut: ((a32BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a32BitW bitAnd: 16rFF).	^a32BitW! !!ImageReadWriter methodsFor: 'stream access'!nextPut: aByte	^stream nextPut: aByte! !!ImageReadWriter methodsFor: 'stream access'!nextPutAll: aByteArray	^stream nextPutAll: aByteArray! !!ImageReadWriter methodsFor: 'stream access'!nextWord	"Read a 16-bit quantity from the input stream."	^(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextWordPut: a16BitW	"Write out a 16-bit integer as 16 bits."	stream nextPut: ((a16BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a16BitW bitAnd: 16rFF).	^a16BitW! !!ImageReadWriter methodsFor: 'stream access' stamp: 'tao 10/23/97 18:00'!peekFor: aValue	^stream peekFor: aValue! !!ImageReadWriter methodsFor: 'stream access'!position	^stream position! !!ImageReadWriter methodsFor: 'stream access'!position: anInteger	^stream position: anInteger! !!ImageReadWriter methodsFor: 'stream access'!size	^stream size! !!ImageReadWriter methodsFor: 'stream access'!skip: anInteger	^stream skip: anInteger! !!ImageReadWriter methodsFor: 'stream access'!space	^stream nextPut: Character space asInteger! !!ImageReadWriter methodsFor: 'stream access'!tab	^stream nextPut: Character tab asInteger! !!ImageReadWriter methodsFor: 'private'!changePadOfBits: bits width: width height: height depth: depth from: oldPadto: newPad	"Change padding size of bits."	| srcRowByteSize dstRowByteSize newBits srcRowBase rowEndOffset |	(#(8 16 32) includes: oldPad)		ifFalse: [^self error: 'Invalid pad: ', oldPad printString].	(#(8 16 32) includes: newPad)		ifFalse: [^self error: 'Invalid pad: ', newPad printString].	srcRowByteSize _ width * depth + oldPad - 1 // oldPad * (oldPad / 8).	srcRowByteSize * height = bits size		ifFalse: [^self error: 'Incorrect bitmap array size.'].	dstRowByteSize _ width * depth + newPad - 1 // newPad * (newPad / 8).	newBits _ ByteArray new: dstRowByteSize * height.	srcRowBase _ 1.	rowEndOffset _ dstRowByteSize - 1.	1 to: newBits size by: dstRowByteSize do:		[:dstRowBase |		newBits replaceFrom: dstRowBase			to: dstRowBase + rowEndOffset			with: bits			startingAt: srcRowBase.		srcRowBase _ srcRowBase + srcRowByteSize].	^newBits! !!ImageReadWriter methodsFor: 'private'!hasMagicNumber: aByteArray	| position |	position _ stream position.	((stream size - position) >= aByteArray size and:	[(stream next: aByteArray size)  = aByteArray])		ifTrue: [^true].	stream position: position.	^false! !!ImageReadWriter methodsFor: 'private' stamp: 'di 9/15/1998 11:42'!on: aStream	(stream _ aStream) reset.	(stream respondsTo: #binary) ifTrue: [stream binary].	"Note that 'reset' makes a file be text.  Must do this after."! !!ImageReadWriter methodsFor: 'private'!unpackBits: bits depthTo8From: depth with: width height: height pad: pad	"Unpack bits of depth 1, 2, or 4 image to it of depth 8 image."	| bitMask pixelInByte bitsWidth upBitsWidth stopWidth	 trailingSize upBits bitIndex upBitIndex val |	(#(1 2 4) includes: depth)		ifFalse: [^self error: 'depth must be 1, 2, or 4'].	(#(8 16 32) includes: pad)		ifFalse: [^self error: 'pad must be 8, 16, or 32'].	bitMask _ (1 bitShift: depth) - 1.	pixelInByte _ 8 / depth.	bitsWidth _ width * depth + pad - 1 // pad * (pad / 8).	upBitsWidth _ width * 8 + pad - 1 // pad * (pad / 8).	stopWidth _ width * depth + 7 // 8.	trailingSize _ width - (stopWidth - 1 * pixelInByte).	upBits _ ByteArray new: upBitsWidth * height.	1 to: height do: [:i |		bitIndex _ i - 1 * bitsWidth.		upBitIndex _ i - 1 * upBitsWidth.		1 to: stopWidth - 1 do: [:j |			val _ bits at: (bitIndex _ bitIndex + 1).			upBitIndex _ upBitIndex + pixelInByte.			1 to: pixelInByte do: [:k |				upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).				val _ val bitShift: depth negated]].		val _ (bits at: (bitIndex _ bitIndex + 1))				bitShift: depth negated * (pixelInByte - trailingSize).		upBitIndex _ upBitIndex + trailingSize.		1 to: trailingSize do: [:k |			upBits at: (upBitIndex - k + 1) put: (val bitAnd: bitMask).			val _ val bitShift: depth negated]].	^ upBits! !!ImageReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:26'!understandsImageFormat	"Test to see if the image stream format is understood by this decoder.	This should be implemented in each subclass of ImageReadWriter so that	a proper decoder can be selected without ImageReadWriter having to know	about all possible image file types."	^ false! !!ImageReadWriter class methodsFor: 'instance creation'!on: aStream	"Answer an instance of the receiver for encoding and/or decoding images on the given."	^ self new on: aStream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:08'!formFromFileNamed: fileName	"Answer a ColorForm stored on the file with the given name."	| stream |	stream _ FileStream readOnlyFileNamed: fileName.	^self formFromStream: stream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:10'!formFromStream: aBinaryStream	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form  |	readerClass _ self withAllSubclasses		detect: [:subclass | aBinaryStream reset. (subclass new on: aBinaryStream) understandsImageFormat]		ifNone: [			(aBinaryStream respondsTo: #close) ifTrue: [ aBinaryStream close ].			^self error: 'image format not recognized'].	reader _ readerClass new on: aBinaryStream reset.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!ImageReadWriter class methodsFor: 'image reading/writing'!putForm: aForm onFileNamed: fileName	"Store the given form on a file of the given name."	| writer |	writer _ self on: (FileStream newFileNamed: fileName) binary.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !I represent an index for the messages in a mail database. I acts like a dictionary that maps unique message ID's to IndexFileEntry objects.The index file is read into memory in its entirety and kept there for the duration of a mail reading session. It should be stored back to disk at the end of the session, or after a major change, such as fetching new mail. If necessary, it can be completely recreated by scanning the messages file.!!IndexFile methodsFor: 'file operations'!openOn: aFileName messageFile: messageFile	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: fileStream messageFile: messageFile.	fileStream setToEnd; close; release.		"close and release the file stream"	fileStream _ nil.! !!IndexFile methodsFor: 'dictionary access'!at: msgID	"Answer the IndexFileEntry for the message with the given ID."	^msgDictionary at: msgID ifAbsent: [self reportInconsistency]! !!IndexFile methodsFor: 'dictionary access'!at: msgID ifAbsent: aBlock	"Answer the IndexFileEntry for the message with the given ID. Evaluate the given block if there is no entry for the given ID."	^msgDictionary at: msgID ifAbsent: aBlock! !!IndexFile methodsFor: 'dictionary access'!at: msgID put: anIndexFileEntry	"Associate the given IndexFileEntry with the given message ID."	timeSortedEntries removeAllSuchThat:		[: assoc | assoc key = msgID].	"don't duplicate the entry!!"	msgDictionary at: msgID put: anIndexFileEntry.	timeSortedEntries add: (Association key: msgID value: anIndexFileEntry).! !!IndexFile methodsFor: 'dictionary access'!includesKey: msgID	"Answer true if my message dictionary contains an entry for the message with the given ID."	^msgDictionary includesKey: msgID! !!IndexFile methodsFor: 'dictionary access'!keys	"Answer a collection of message IDs for the messages in this IndexFile, sorted in ascending timestamp order. Because sorting is expensive, the sorted key list is cached."	| keys |	keys _ OrderedCollection new: timeSortedEntries size * 2.	timeSortedEntries do: [: assoc | keys addLast: assoc key].	^keys! !!IndexFile methodsFor: 'dictionary access'!remove: msgID	"Remove the entry with the given ID from my Dictionary."	timeSortedEntries removeAllSuchThat: [: assoc | assoc key = msgID].	msgDictionary removeKey: msgID ifAbsent: [].! !!IndexFile methodsFor: 'read-write'!readFrom: aStream messageFile: messageFile	"Initialize myself from the given text stream. It is assumed that the .index file was written in order of ascending message timestamps, although this method is only less efficient, not incorrect, if this is not the case."	| sorted lastTime msgID entry |	msgDictionary _ Dictionary new: 1000.	timeSortedEntries _ (SortedCollection new: 1000) sortBlock:		[: m1 : m2 | m1 value time <= m2 value time].	sorted _ true.	lastTime _ nil.	[aStream atEnd] whileFalse:		[msgID _ MailDB readIntegerLineFrom: aStream.		 entry _ IndexFileEntry readFrom: aStream messageFile: messageFile msgID: msgID.		 msgDictionary at: msgID put: entry.		 timeSortedEntries addLast: (Association key: msgID value: entry).		 ((sorted & lastTime notNil) and: [lastTime > entry time]) ifTrue:			[sorted _ false].		 lastTime _ entry time].	sorted ifFalse: [timeSortedEntries reSort]. 	"re-sort if necessary"! !!IndexFile methodsFor: 'read-write'!writeOn: aStream	"Write my index entries to the given text stream in human-readable form."	"Note: For efficiency, this is done in order of increasing message timestamps, to save the cost of sorting when we read it back in. It is assumed that timeSortedEntries should contains exactly the same message ID's as msgDictionary."	timeSortedEntries do:		[: assoc |		 (assoc key) printOn: aStream.		"message ID"		 aStream cr.		 (assoc value) writeOn: aStream].	"index entry"! !!IndexFile class methodsFor: 'instance creation'!openOn: fileName messageFile: messageFile	"Answer a new instance of me for the given message file, backed by the file with the given name."	^(super new) openOn: fileName messageFile: messageFile! !An IndexFileEntry contains enough information to present a table-of-contents entry for the message and to support simple filtering based on a subset of the mail header information. The IndexFile maps unique message ID's to IndexFileEntries.!!IndexFileEntry methodsFor: 'access'!cc	^cc! !!IndexFileEntry methodsFor: 'access'!cc: aString	cc _ aString.! !!IndexFileEntry methodsFor: 'access'!date	"Answer a date string for this index entry."	^Date fromDays: (time + (Date newDay: 1 year: 1980) asSeconds) // 86400! !!IndexFileEntry methodsFor: 'access'!from	^from! !!IndexFileEntry methodsFor: 'access'!from: aString	from _ aString.! !!IndexFileEntry methodsFor: 'access'!location	^location! !!IndexFileEntry methodsFor: 'access'!location: anInteger	location _ anInteger.! !!IndexFileEntry methodsFor: 'access'!messageFile	^messageFile! !!IndexFileEntry methodsFor: 'access'!messageFile: aMessageFile	messageFile _ aMessageFile.! !!IndexFileEntry methodsFor: 'access'!msgID	^msgID! !!IndexFileEntry methodsFor: 'access'!msgID: anID	msgID _ anID.! !!IndexFileEntry methodsFor: 'access'!subject	^subject! !!IndexFileEntry methodsFor: 'access'!subject: aString	subject _ aString.! !!IndexFileEntry methodsFor: 'access'!textLength	^textLength! !!IndexFileEntry methodsFor: 'access'!textLength: anInteger	textLength _ anInteger.! !!IndexFileEntry methodsFor: 'access'!time	^time! !!IndexFileEntry methodsFor: 'access'!time: anInteger	time _ anInteger.! !!IndexFileEntry methodsFor: 'access'!to	^to! !!IndexFileEntry methodsFor: 'access'!to: aString	to _ aString.! !!IndexFileEntry methodsFor: 'printing' stamp: 'jm 9/21/1998 10:55'!computeTOCString	"Answer a string for the table of contents."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	| fromFieldSize s |	fromFieldSize _ 18.	s _ WriteStream on: (String new: 200).	s nextPutAll: self dateString.	[s position < 9] whileTrue: [s space].	s nextPutAll: (self fromStringLimit: fromFieldSize).	[s position <= (9 + fromFieldSize + 2)] whileTrue: [s space].	s nextPutAll: subject.	^ s contents! !!IndexFileEntry methodsFor: 'printing'!dateString	"Answer a date string for this index entry."	^self date printFormat: #(2 1 3 47 1 2)! !!IndexFileEntry methodsFor: 'printing'!flushTOCCache	"Flush my cached table-of-contents entry string."	"IndexFileEntry allInstancesDo: [: e | e flushTOCCache]"	tocLineCache _ nil.! !!IndexFileEntry methodsFor: 'printing' stamp: 'ls 9/10/1998 21:15'!fromStringLimit: limit	"Answer a cleaned up 'from' field for the table of contents."	| editedFrom s ch i |	editedFrom _ WriteStream on: (String new: limit + 1).	s _ ReadStream on: from.	s skipSeparators.	('"<' includes: s peek) ifTrue: [s next].	((i _ from indexOf: $() > 0) ifTrue: [s position: i].	[s atEnd] whileFalse: [		ch _ s next.		(('@<>)$"' includes: ch) or: [editedFrom position >= limit])			ifTrue: [^editedFrom contents]			ifFalse: [editedFrom nextPut: ch]].	^editedFrom contents! !!IndexFileEntry methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self dateString; cr.	aStream nextPutAll: from; cr.	aStream nextPutAll: to; cr.	aStream nextPutAll: cc; cr.	aStream nextPutAll: subject; cr.	aStream nextPut: $(; nextPutAll: location printString; space.	aStream nextPutAll: textLength printString; nextPut: $).	aStream cr.! !!IndexFileEntry methodsFor: 'printing'!tocString	"Answer a string for the table of contents."	(tocLineCache isNil) ifTrue:		[tocLineCache _ self computeTOCString].	^tocLineCache! !!IndexFileEntry methodsFor: 'read-write'!readFrom: aStream	"Initialize myself from the given text stream."	location _ MailDB readIntegerLineFrom: aStream.	textLength _ MailDB readIntegerLineFrom: aStream.	time _ MailDB readIntegerLineFrom: aStream.	from _ MailDB readStringLineFrom: aStream.	to _ MailDB readStringLineFrom: aStream.	cc _ MailDB readStringLineFrom: aStream.	subject _ MailDB readStringLineFrom: aStream.! !!IndexFileEntry methodsFor: 'read-write'!writeOn: aStream	"Write a human-readable representation of myself on the given text stream."	aStream		print: location; cr;		print: textLength; cr;		print: time; cr;		nextPutAll: from; cr;		nextPutAll: to; cr;		nextPutAll: cc; cr;		nextPutAll: subject; cr.! !!IndexFileEntry methodsFor: 'filtering support'!ccHas: stringOrList	^ self field: cc has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support' stamp: 'jm 8/14/1998 13:39'!field: field has: stringOrList	"Return true if either the given field contains the argument string or, if the argument is a collection, return true if the given field contains any of the strings in that collection."	| s |	(stringOrList isKindOf: String) ifTrue: [		^ field includesSubstring: stringOrList caseSensitive: false	] ifFalse: [		1 to: stringOrList size do: [ :i |			s _ stringOrList at: i.			s isNumber ifTrue: [s _ s printString].			(field includesSubstring: s caseSensitive: false) ifTrue: [^ true].		].		^ false	].! !!IndexFileEntry methodsFor: 'filtering support'!fromHas: stringOrList	^ self field: from has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!getMessage	"Answer the MailMessage for this index file entry."	^MailMessage from:		(messageFile			getMessage: msgID			at: location			textLength: textLength).! !!IndexFileEntry methodsFor: 'filtering support'!participantHas: stringOrList	^ (self field: from has: stringOrList) or:	   [(self field: self to has: stringOrList) or:	   [self field: self cc has: stringOrList]]! !!IndexFileEntry methodsFor: 'filtering support'!subjectHas: stringOrList	^ self field: subject has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!textHas: stringOrList	^ self field: self getMessage has: stringOrList! !!IndexFileEntry methodsFor: 'filtering support'!toHas: stringOrList	^ self field: to has: stringOrList! !!IndexFileEntry class methodsFor: 'instance creation'!message: aMailMessage location: location messageFile: aMessageFile msgID: msgID	"Answer a new instance of me for the given message and message file location."	^self new		messageFile: aMessageFile;		msgID: msgID;		location: location;		textLength: aMailMessage text size;		time: aMailMessage time;		from: aMailMessage from;		to: aMailMessage to;		cc: aMailMessage cc;		subject: aMailMessage subject! !!IndexFileEntry class methodsFor: 'instance creation'!readFrom: aStream messageFile: aMessageFile msgID: msgID	"Answer a new instance of me initialized from the given text stream."	^(self new readFrom: aStream)		messageFile: aMessageFile;		msgID: msgID! !Used in conjunction wi[th a TabbedPalette -- each TabbedPalette has one.  Each submorph of an IndexTabs is a TabMorph.  When you click on one of the tabs, a corresponding action is taken -- sometimes, the existing palette gets replaced by the new one, other times, the tab results in some selector being invoked; in any case, tab highlighting takes place accordingly.!!IndexTabs methodsFor: 'initialization' stamp: 'sw 7/3/1998 16:10'!initialize	super initialize.	padding _ 10.	basicHeight _ 14.	color _ Color transparent.	fillColor2 _ color.	borderWidth _ 0! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/4/1998 14:53'!addActionTabWithTitle: aString	|  aTab |	aTab _ TabMorph new.	aTab contents: aString.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab color: self regularColor.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/3/1998 11:44'!addTab: aTab	self addMorphBack: aTab.	self laySubpartsOutInOneRow! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/4/1998 14:53'!addTabForBook: aBook	|  aTab |	aTab _ TabMorph new morphToInstall: aBook.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab color: self regularColor.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 7/3/1998 12:42'!tabMorphs	"Presently all the submorphs are tabMorphs, but this still supports an earlier design where spacers are interleaved."	^ submorphs select: [:m | m isKindOf: TabMorph]! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/3/1998 18:37'!basicHeight	^ basicHeight! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/3/1998 18:37'!laySubpartsOutInOneRow	| aPosition |	aPosition _ self topLeft.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			aPosition _ aMorph topRight].	self extent: (((aPosition x - self left) "max: owner pageSize x") @ self basicHeight)! !!IndexTabs methodsFor: 'layout' stamp: 'sw 7/21/1998 22:05'!openToDragNDrop	^ false! !!IndexTabs methodsFor: 'selection' stamp: 'sw 7/3/1998 18:43'!selectTab: aTab	| aWorld |	(aWorld _ self world) ifNotNil: [aWorld abandonAllHalos].  "nil can happen at init time"	self highlightTab: aTab.! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 14:56'!highlightColor	^ highlightColor ifNil: [Color yellow]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:29'!highlightColor: aColor	highlightColor _ aColor! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:43'!highlightColor: color1 regularColor: color2	"Apply these colors to all of the receiver's tabs"	highlightColor _ color1.	regularColor _ color2.	self tabMorphs do:		[:m | m highlightColor: color1.  m regularColor: color2]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 15:27'!highlightTab: aTab	self tabMorphs do: [:m |		m == aTab		ifTrue: [m color: m highlightColor]		ifFalse: [m color: m regularColor]]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/4/1998 14:58'!highlightTabFor: aBook	| theOne |	self tabMorphs do: [:m |		(m morphToInstall == aBook)				ifTrue: [m color: m highlightColor.  theOne _ m]				ifFalse: [m color: m regularColor]].	^ theOne! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 14:47'!regularColor	^ regularColor ifNil: [Color r: 0.4 g: 0.2 b: 0.6]! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:29'!regularColor: aColor	regularColor _ aColor! !!IndexTabs class methodsFor: 'all' stamp: 'sw 7/2/1998 15:16'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver"	^ 'tabs'! !!InputSensor methodsFor: 'modifier keys' stamp: 'jm 5/29/1998 14:17'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific."	^ self primMouseButtons anyMask: 32! !!InputSensor methodsFor: 'user interrupts' stamp: 'di 9/23/1998 16:12'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[true] whileTrue: [		InterruptSemaphore wait.		Display deferUpdates: false.		Smalltalk shutDownSound.		Smalltalk handleUserInterrupt]! !!Inspector methodsFor: 'accessing' stamp: 'di 9/22/1998 21:28'!step	"Continuously update the value of the selected item"	| newText |	contents ifNotNil: [ contents size > 1000 ifTrue: [ 		"too much text--forget the automatic updating"		^self  ] ].	newText _ self contentsIsString		ifTrue: [self selection]		ifFalse: [self selection printString].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'tk 6/11/1998 22:23'!trash: newText	"Don't save it"	^ true! !!Inspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:24'!contentsIsString	"Hacked so contents empty when deselected and = long printString when item 2"	^ (selectionIndex = 2) | (selectionIndex = 0)! !!Inspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:29'!toggleIndex: anInteger	"The receiver has a list of variables of its inspected object. One of these 	is selected. If anInteger is the index of this variable, then deselect it. 	Otherwise, make the variable whose index is anInteger be the selected 	item."	selectionIndex = anInteger		ifTrue: 			["same index, turn off selection"			selectionIndex _ 0.			contents _ '']		ifFalse:			["different index, new selection"			selectionIndex _ anInteger.			self contentsIsString				ifTrue: [contents _ self selection]				ifFalse: [contents _ self selection printString]].	self changed: #selection.	self changed: #contents.	self changed: #selectionIndex.! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:16'!openAsMorphOn: anObject	^ self openAsMorphOn: anObject withLabel: anObject defaultLabelForInspector! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:30'!openAsMorphOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	"Note: for now, this always adds an eval pane, and ignores the valueViewClass"	(self openAsMorphOn: anObject withLabel: label) openInWorld! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:16'!openAsMorphOn: anObject withLabel: aLabel	"(Inspector openAsMorphOn: SystemOrganization) openInMVC"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: aLabel)				model: inspector.	window addMorph: (PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex:				menu: ((inspector isMemberOf: DictionaryInspector)						ifTrue: [#dictionaryMenu:]						ifFalse: [#fieldListMenu:])				keystroke: #inspectorKey:from:)		frame: (0@0 corner: 0.3@0.7).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.3@0 corner: 1@0.7).	window addMorph: ((PluggableTextMorph on: inspector text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@0.7 corner: 1@1).	window position: 16@0.  "Room for scroll bar."	^ window! !!Inspector class methodsFor: 'instance creation' stamp: 'di 9/23/1998 12:38'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	World ifNotNil:		[^ self openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: valueViewClass].	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	topView borderWidth: 1.	listView _ PluggableListView on: inspector		list: #fieldList		selected: #selectionIndex		changeSelected: #toggleIndex:		menu: #fieldListMenu:		keystroke: #inspectorKey:from:.	(inspector isMemberOf: DictionaryInspector)		ifTrue: [listView menu: #dictionaryMenu:].	listView window: (0 @ 0 extent: 40 @ 40).	topView addSubView: listView.	valueView _ valueViewClass new.		"PluggableTextView or PluggableFormView"	(valueView respondsTo: #getText) ifTrue: [		valueView on: inspector 			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:].	(valueViewClass inheritsFrom: FormView) ifTrue: [		valueView model: inspector].	valueView window: (0 @ 0 extent: 75 @ 40).	topView addSubView: valueView toRightOf: listView.		withEval ifTrue:		[evalView _ PluggableTextView new on: inspector 			text: #trash accept: #trash:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		evalView window: (0 @ 0 extent: 115 @ 20).		evalView askBeforeDiscardingEdits: false.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView controller open! !!Integer methodsFor: 'arithmetic' stamp: 'LC 6/18/1998 09:33'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger		ifTrue: [quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"								neg: self negative ~~ aNumber negative.				(quoRem at: 2) = 0					ifTrue: [^(quoRem at: 1) normalize]					ifFalse: [^(Fraction numerator: self denominator: aNumber) reduced]]		ifFalse: [^ (aNumber adaptInteger: self) / aNumber adaptToInteger]! !!Integer methodsFor: 'arithmetic' stamp: 'LC 9/8/1998 18:44'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger		ifTrue: 			[ng _ self negative == aNumber negative == false.			quo _ (self digitDiv:				(aNumber class == SmallInteger					ifTrue: [aNumber abs]					ifFalse: [aNumber])				neg: ng) at: 1.			^ quo normalize]		ifFalse: [^ (aNumber adaptInteger: self) quo: aNumber adaptToInteger]! !!Integer methodsFor: 'truncation and round off' stamp: 'sw 6/26/1998 15:48'!atRandom	"Return a random integer from 1 to self.  Heavy users should use Interval atRandom or atRandom: directly."	self < 1 ifTrue: [^ self].	^ (1 to: self) atRandom! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher _ SmallInteger maxVal highBit.	u _ self abs max: (v _ anInteger abs).	v _ self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat _ u bitShift: (k _ higher - u highBit)) class == SmallInteger				ifFalse: 					[k _ k - 1.					uHat _ uHat bitShift: -1].			vHat _ v bitShift: k.			a _ 1.			b _ 0.			c _ 0.			d _ 1.			"Test quotient"			[(vPrime _ vHat + d) ~= 0				and: [(vPrimePrime _ vHat + c) ~= 0 and: [(q _ uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c _ a - (q * (a _ c)).					d _ b - (q * (b _ d)).					vHat _ uHat - (q * (uHat _ vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v _ u rem: (u _ v)]				ifFalse: 					[t _ u * a + (v * b).					v _ u * c + (v * d).					u _ t]].	^ v gcd: u! !!Integer methodsFor: 'converting' stamp: 'di 7/1/1998 21:37'!asFloat	"Answer a Float that represents the value of the receiver. Optimized to process only the significant digits of a LargeInteger."	| sum factor numBytes |	sum _ 0.0.	factor _ self sign asFloat.	numBytes _ self size.	numBytes > 8		ifFalse: [			1 to: self size do: [:i |				sum _ sum + ((self digitAt: i) * factor).				factor _ factor * 256.0]]		ifTrue: [			(numBytes - 7) to: numBytes do: [:i |				sum _ sum + ((self digitAt: i) * factor).				factor _ factor * 256.0].			sum _ sum timesTwoPower: 8 * (numBytes - 8)].	^ sum! !!Integer methodsFor: 'converting' stamp: 'ls 5/26/1998 20:53'!asHexDigit	^'0123456789ABCDEF' at: self+1! !!Integer methodsFor: 'private' stamp: 'LC 6/18/1998 10:07'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	arg = 0 ifTrue: [^ self error: 'division by 0'].	"*****We've added this line*****"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^Array with: 0 with: self].	d _ 8 - arg lastDigit highBit.	div _ arg digitLshift: d.  div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue:		[rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1			ifTrue: [0]			ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j) = dh			ifTrue: [qhi _ qlo _ 15"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13 bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j) bitShift: 4) + ((rem digitAt: j - 1) bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4) + ((rem digitAt: j - 1) bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15) bitShift: 4).				hi _ (hi bitShift: -4) + (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3 ifTrue: [0]						 ifFalse: [rem digitAt: j - 2].				[(t < hi or: [t = hi and: [r3 < lo]]) and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0 ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i) * qhi.			lo _ a + (rem digitAt: l) 					- ((hi bitAnd: 15) bitShift: 4) 					- ((div digitAt: i) * qlo).			rem digitAt: l				put: lo - (lo // 256 * 256) "sign-tolerant form of (lo bitAnd: 255)".			a _ (lo // 256) - (hi bitShift: -4).			l _ l + 1].		a < 0 ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8) + (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4) + qlo].	rem _ rem digitRshift: d bytes: 0 lookfirst: dl.	^Array with: quo with: rem! !!Interpreter methodsFor: 'contexts' stamp: 'jm 6/24/1998 17:59'!stackObjectValue: offset	"Ensures that the given object is a real object, not a SmallInteger."	| oop |	oop _ self longAt: stackPointer - (offset * 4).	(self isIntegerObject: oop) ifTrue: [self primitiveFail. ^ nil].	^ oop! !!Interpreter methodsFor: 'primitive support' stamp: 'jm 8/22/1998 09:41'!primitiveResponse	"Details: Since primitives can run for a long time, we must check to see if it is time to process a timer interrupt. However, on the Mac, the high-resolution millisecond clock is expensive to poll. Thus, we use a fast, low-resolution (1/60th second) clock to determine if the primitive took enough time to justify polling the high-resolution clock. Seems Byzantine, but Bob Arning showed that the performance of primitive-intensive code decreased substantially if there was another process waiting on a Delay.	One other detail: If the primitive fails, we want to postpone the timer interrupt until just after the primitive failure code has been entered. This is accomplished by setting the interrupt check counter to zero, thus triggering a check for interrupts when activating the method containing the primitive."	| startTime |	primitiveIndex > MaxPrimitiveIndex ifTrue: [^ false].	(nextWakeupTick ~= 0) ifTrue: [startTime _ self ioLowResMSecs].	successFlag _ true.	self dispatchOn: primitiveIndex in: PrimitiveTable.	((nextWakeupTick ~= 0) and: [self ioLowResMSecs ~= startTime]) ifTrue: [		"primitive ran for more than a tick; check for possible timer interrupts"		((self ioMSecs bitAnd: 16r1FFFFFFF) >= nextWakeupTick) ifTrue: [			successFlag				ifTrue: [  "process the interrupt now"					self checkForInterrupts]				ifFalse: [  "process the interrupt in primtive failure code"					interruptCheckCounter _ 0]]].	^ successFlag! !!Interpreter methodsFor: 'array and stream primitives' stamp: 'ls 8/18/1998 06:24'!primitiveStringReplace"<array> primReplaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>"	| array start stop repl replStart hdr arrayFmt totalLength arrayInstSize replFmt replInstSize srcIndex |	array _ self stackValue: 4.	start _ self stackIntegerValue: 3.	stop _ self stackIntegerValue: 2.	repl _ self stackValue: 1.	replStart _ self stackIntegerValue: 0.	successFlag ifFalse: [^ self primitiveFail].	(self isIntegerObject: repl)  "can happen in LgInt copy"		ifTrue: [^ self primitiveFail].	hdr _ self baseHeader: array.	arrayFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: array baseHeader: hdr format: arrayFmt.	arrayInstSize _ self fixedFieldsOf: array format: arrayFmt length: totalLength.	((start >= 1) and: [(start <= stop) and: [stop + arrayInstSize <= totalLength]])		ifFalse: [^ self primitiveFail].	hdr _ self baseHeader: repl.	replFmt _ (hdr >> 8) bitAnd: 16rF.	totalLength _ self lengthOf: repl baseHeader: hdr format: replFmt.	replInstSize _ self fixedFieldsOf: repl format: replFmt length: totalLength.	((replStart >= 1) and: [stop - start + replStart + replInstSize <= totalLength])		ifFalse: [^ self primitiveFail].	"Array formats (without byteSize bits, if bytes array) must be same"	arrayFmt < 8		ifTrue: [arrayFmt = replFmt ifFalse: [^ self primitiveFail]]		ifFalse: [(arrayFmt bitAnd: 16rC) = (replFmt bitAnd: 16rC) ifFalse: [^ self primitiveFail]].	srcIndex _ replStart + replInstSize - 1.   " - 1 for 0-based access"	arrayFmt < 4 ifTrue: [ "pointer type objects"		start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 			self storePointer: i ofObject: array withValue:				(self fetchPointer: srcIndex ofObject: repl).			srcIndex _ srcIndex + 1. ] ]	ifFalse: [		arrayFmt < 8  ifTrue: [ "long-word type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeWord: i ofObject: array withValue:					(self fetchWord: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1 ] ]		ifFalse: [  "byte-type objects"			start + arrayInstSize - 1 to: stop + arrayInstSize - 1 do: [:i | 				self storeByte: i ofObject: array withValue:					(self fetchByte: srcIndex ofObject: repl).				srcIndex _ srcIndex + 1. ] ].	].	self pop: 4.  "leave rcvr on stack"! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:32'!checkForInterrupts	"Check for possible interrupts and handle one if necessary."	| sema now index externalObjects semaClass |	self inline: false.	interruptCheckCounter _ 1000.  "reset the interrupt check counter"	"Mask so same wrap as primitiveMillisecondClock"	now _ self ioMSecs bitAnd: 16r1FFFFFFF. 	now < lastTick ifTrue: [		"millisecond clock wrapped"		nextPollTick _ now + (nextPollTick - lastTick).		nextWakeupTick ~= 0			ifTrue: [nextWakeupTick _ now + (nextWakeupTick - lastTick)]].	lastTick _ now.  "used to detect millisecond clock wrapping"	signalLowSpace ifTrue: [		signalLowSpace _ false.  "reset flag"		sema _ (self splObj: TheLowSpaceSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	now >= nextPollTick ifTrue: [		self ioProcessEvents.  "sets interruptPending if interrupt key pressed"		nextPollTick _ now + 500].  "msecs to wait before next call to ioProcessEvents"	interruptPending ifTrue: [		interruptPending _ false.  "reset interrupt flag"		sema _ (self splObj: TheInterruptSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	((nextWakeupTick ~= 0) and: [now >= nextWakeupTick]) ifTrue: [		nextWakeupTick _ 0.  "reset timer interrupt"		sema _ (self splObj: TheTimerSemaphore).		sema = nilObj ifFalse: [self synchronousSignal: sema]].	"signal all semaphores in semaphoresToSignal" 	semaphoresToSignalCount > 0 ifTrue: [		externalObjects _ self splObj: ExternalObjectsArray.		semaClass _ self splObj: ClassSemaphore.		1 to: semaphoresToSignalCount do: [:i |			index _ semaphoresToSignal at: i.			sema _ self fetchPointer: index - 1 ofObject: externalObjects.				"Note: semaphore indices are 1-based"			(self fetchClassOf: sema) = semaClass				ifTrue: [self synchronousSignal: sema]].		semaphoresToSignalCount _ 0].! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:34'!internalQuickCheckForInterrupts	"Internal version of quickCheckForInterrupts for use within jumps."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0) ifTrue: [		self externalizeIPandSP.		self checkForInterrupts.		self internalizeIPandSP].! !!Interpreter methodsFor: 'processes' stamp: 'jm 8/22/1998 09:37'!quickCheckForInterrupts	"Quick check for possible user or timer interrupts. Decrement a counter and only do a real check when counter reaches zero or when a low space or user interrupt is pending."	"Note: Clients that trigger interrupts should set interruptCheckCounter to zero to get immediate results."	"Note: Requires that instructionPointer and stackPointer be external."	((interruptCheckCounter _ interruptCheckCounter - 1) <= 0)		ifTrue: [self checkForInterrupts].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'jm 9/22/1998 23:09'!primitiveBeCursor	"Set the cursor to the given shape. The Mac only supports 16x16 pixel cursors. Cursor offsets are handled by Smalltalk."	| cursorObj maskBitsIndex maskObj bitsObj extentX extentY depth offsetObj offsetX offsetY cursorBitsIndex |	argumentCount = 0 ifTrue: [		cursorObj _ self stackTop.		maskBitsIndex _ nil].	argumentCount = 1 ifTrue: [		cursorObj _ self stackValue: 1.		maskObj _ self stackTop].	self success: (argumentCount < 2).	self success: ((self isPointers: cursorObj) and: [(self lengthOf: cursorObj) >= 5]).	successFlag ifTrue: [		bitsObj _ self fetchPointer: 0 ofObject: cursorObj.		extentX _ self fetchInteger: 1 ofObject: cursorObj.		extentY _ self fetchInteger: 2 ofObject: cursorObj.		depth _ self fetchInteger: 3 ofObject: cursorObj.		offsetObj _ self fetchPointer: 4 ofObject: cursorObj].	self success: ((self isPointers: offsetObj) and: [(self lengthOf: offsetObj) >= 2]).	successFlag ifTrue: [		offsetX _ self fetchInteger: 0 ofObject: offsetObj.		offsetY _ self fetchInteger: 1 ofObject: offsetObj.		self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).		self success: ((offsetX >= -16) and: [offsetX <= 0]).		self success: ((offsetY >= -16) and: [offsetY <= 0]).		self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).		cursorBitsIndex _ bitsObj + BaseHeaderSize].	argumentCount = 1 ifTrue: [		self success: ((self isPointers: maskObj) and: [(self lengthOf: maskObj) >= 5]).		successFlag ifTrue: [			bitsObj _ self fetchPointer: 0 ofObject: maskObj.			extentX _ self fetchInteger: 1 ofObject: maskObj.			extentY _ self fetchInteger: 2 ofObject: maskObj.			depth _ self fetchInteger: 3 ofObject: maskObj].		successFlag ifTrue: [			self success: ((extentX = 16) and: [extentY = 16 and: [depth = 1]]).			self success: ((self isWords: bitsObj) and: [(self lengthOf: bitsObj) = 16]).			maskBitsIndex _ bitsObj + BaseHeaderSize]].	successFlag ifTrue: [		argumentCount = 0			ifTrue: [self cCode: 'ioSetCursor(cursorBitsIndex, offsetX, offsetY)']			ifFalse: [self cCode: 'ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY)'].		self pop: argumentCount].! !!Interpreter methodsFor: 'I/O primitives' stamp: 'di 6/29/1998 22:58'!primitiveCopyBits	"Invoke the copyBits primitive. If the destination is the display, then copy it to the screen."	| rcvr |	rcvr _ self stackValue: argumentCount.	self success: (self loadBitBltFrom: rcvr).	successFlag ifTrue: [		self copyBits.		self showDisplayBits.	].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/25/1998 06:45'!asyncFileValueOf: oop	"Return a pointer to the first byte of the async file record within the given Smalltalk bytes object, or nil if oop is not an async file record."	self returnTypeC: 'AsyncFile *'.	self success:		((self isIntegerObject: oop) not and:		 [(self isBytes: oop) and:		 [(self lengthOf: oop) = (self cCode: 'sizeof(AsyncFile)')]]).	successFlag ifFalse: [^ nil].	^ self cCode: '(AsyncFile *) (oop + 4)'! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 09:37'!primitiveAsyncFileClose	| f |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [self asyncFileClose: f].	successFlag ifTrue: [self pop: 1].  "pop f; leave rcvr on stack"! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 17:59'!primitiveAsyncFileOpen	| semaIndex writeFlag fileName fmt fileNameSize fOop f |	self var: #f declareC: 'AsyncFile *f'.	semaIndex	_ self stackIntegerValue: 0.	writeFlag	_ self booleanValueOf: (self stackValue: 1).	fileName	_ self stackObjectValue: 2.	successFlag ifFalse: [^ nil].	fmt _ self formatOf: fileName.	self success: (fmt >= 8 and: [fmt <= 11]).  "fileName is bytes, but not a CompiledMethod"	fileNameSize _ self lengthOf: fileName.	successFlag ifTrue: [		fOop _ self instantiateClass: (self splObj: ClassByteArray)					indexableSize: (self cCode: 'sizeof(AsyncFile)').		f _ self asyncFileValueOf: fOop].	successFlag ifTrue: [		self cCode: 'asyncFileOpen(f, fileName + 4, fileNameSize, writeFlag, semaIndex)'].	successFlag ifTrue: [		self pop: 4.  "pop fileName, writeFlag, semaIndex, and rcvr"		self push: fOop].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 18:00'!primitiveAsyncFileReadResult	| f count startIndex buffer fmt bufferSize bufferPtr r |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	f			_ self asyncFileValueOf: (self stackValue: 3).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		r _ self cCode: 'asyncFileReadResult(f, bufferPtr, count)'].	successFlag ifTrue: [		self pop: 5.  "pop 4 args and rcvr"		self pushInteger: r].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 11:14'!primitiveAsyncFileReadStart	| f fPosition count |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	fPosition	_ self stackIntegerValue: 1.	f			_ self asyncFileValueOf: (self stackValue: 2).	successFlag ifTrue: [self cCode: 'asyncFileReadStart(f, fPosition, count)'].	successFlag ifTrue: [self pop: 3].  "pop f, fPosition, count; leave rcvr on stack"! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 14:08'!primitiveAsyncFileWriteResult	| f r |	self var: #f declareC: 'AsyncFile *f'.	f _ self asyncFileValueOf: self stackTop.	successFlag ifTrue: [r _ self asyncFileWriteResult: f].	successFlag ifTrue: [		self pop: 2.  "pop f, rcvr"		self pushInteger: r].! !!Interpreter methodsFor: 'async file primitives' stamp: 'jm 6/24/1998 18:00'!primitiveAsyncFileWriteStart	| f count startIndex buffer fPosition fmt bufferSize bufferPtr |	self var: #f declareC: 'AsyncFile *f'.	count		_ self stackIntegerValue: 0.	startIndex	_ self stackIntegerValue: 1.	buffer		_ self stackObjectValue: 2.	fPosition	_ self stackIntegerValue: 3.	f			_ self asyncFileValueOf: (self stackValue: 4).	successFlag ifFalse: [^ nil].	fmt _ self formatOf: buffer.	self success: ((fmt = 6) or: [fmt >= 8 and: [fmt <= 11]]).		"buffer is words or bytes, but not a CompiledMethod"	bufferSize _ self lengthOf: buffer.  "in bytes or words"	fmt = 6 ifTrue: [  "covert word counts to byte counts"		count _ count * 4.		startIndex _ ((startIndex - 1) * 4) + 1.		bufferSize _ bufferSize * 4].	self success: (		(startIndex >= 1) and:		[(startIndex + count - 1) <= bufferSize]).	bufferPtr _ buffer + BaseHeaderSize + startIndex - 1.  "adjust for zero-origin indexing"	successFlag ifTrue: [		self cCode: 'asyncFileWriteStart(f, fPosition, bufferPtr, count)'].	successFlag ifTrue: [self pop: 5].  "pop 5 args; leave rcvr on stack"! !!Interpreter class methodsFor: 'initialization' stamp: 'jm 9/22/1998 16:52'!initializePrimitiveTable	"This table generates a C switch statement for primitive dispatching."	"NOTE: The real limit here is 2047, but our C compiler currently barfs over 700"	MaxPrimitiveIndex _ 700.	PrimitiveTable _ Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		"32-bit logic is aliased to Integer prims above"		(20 39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveNext)		(66 primitiveNextPut)		(67 primitiveAtEnd)		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveFail)					"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveFail)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveFail)   					"Blue Book:  primitiveBlockCopy"		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveFail)					"Blue Book: primitiveCursorLocPut"		(92 primitiveFail)					"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveFail)					"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveCopyBits)		(97 primitiveSnapshot)		(98 primitiveFail)					"Blue Book: primitiveTimeWordsInto"		(99 primitiveFail)					"Blue Book: primitiveTickWordsInto"		(100 primitiveFail)					"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveDrawLoop)		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveFail)					"Blue Book: primitiveOopsLeft"		(116 primitiveFail)		(117 primitiveFail)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)		"Miscellaneous Primitives (120-127)"		(120 primitiveFail)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveFail)		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		(146 primitiveReadJoystick)		(147 primitiveWarpBits)		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169)"		(150 primitiveFileAtEnd)		(151 primitiveFileClose)		(152 primitiveFileGetPosition)		(153 primitiveFileOpen)		(154 primitiveFileRead)		(155 primitiveFileSetPosition)		(156 primitiveFileDelete)		(157 primitiveFileSize)		(158 primitiveFileWrite)		(159 primitiveFileRename)		(160 primitiveDirectoryCreate)		(161 primitiveDirectoryDelimitor)		(162 primitiveDirectoryLookup)		(163 168 primitiveFail)		(169 primitiveDirectorySetMacTypeAndCreator)		"Sound Primitives (170-199)"		(170 primitiveSoundStart)		(171 primitiveSoundStartWithSemaphore)		(172 primitiveSoundStop)		(173 primitiveSoundAvailableSpace)		(174 primitiveSoundPlaySamples)		(175 primitiveSoundPlaySilence)		"obsolete; will be removed in the future"		(176 primWaveTableSoundmixSampleCountintostartingAtpan)		(177 primFMSoundmixSampleCountintostartingAtpan)		(178 primPluckedSoundmixSampleCountintostartingAtpan)		(179 primSampledSoundmixSampleCountintostartingAtpan)		(180 primFMSoundmixSampleCountintostartingAtleftVolrightVol)		(181 primPluckedSoundmixSampleCountintostartingAtleftVolrightVol)		(182 primSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(183 primReverbSoundapplyReverbTostartingAtcount)		(184 primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol)		(185 188 primitiveFail)		(189 primitiveSoundInsertSamples)		(190 primitiveSoundStartRecording)		(191 primitiveSoundStopRecording)		(192 primitiveSoundGetRecordingSampleRate)		(193 primitiveSoundRecordSamples)		(194 primitiveSoundSetRecordLevel)		(195 199 primitiveFail)		"Networking Primitives (200-229)"		(200 primitiveInitializeNetwork)		(201 primitiveResolverStartNameLookup)		(202 primitiveResolverNameLookupResult)		(203 primitiveResolverStartAddressLookup)		(204 primitiveResolverAddressLookupResult)		(205 primitiveResolverAbortLookup)		(206 primitiveResolverLocalAddress)		(207 primitiveResolverStatus)		(208 primitiveResolverError)		(209 primitiveSocketCreate)		(210 primitiveSocketDestroy)		(211 primitiveSocketConnectionStatus)		(212 primitiveSocketError)		(213 primitiveSocketLocalAddress)		(214 primitiveSocketLocalPort)		(215 primitiveSocketRemoteAddress)		(216 primitiveSocketRemotePort)		(217 primitiveSocketConnectToPort)		(218 primitiveSocketListenOnPort)		(219 primitiveSocketCloseConnection)		(220 primitiveSocketAbortConnection)		(221 primitiveSocketReceiveDataBufCount)		(222 primitiveSocketReceiveDataAvailable)		(223 primitiveSocketSendDataBufCount)		(224 primitiveSocketSendDone)		(225 229 primitiveFail)		"Other Primitives (230-249)"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primBitmapdecompressfromByteArrayat)		(235 primStringcomparewithcollated)		(236 primSampledSoundconvert8bitSignedFromto16Bit)		(237 primBitmapcompresstoByteArray)		(238 primitiveSerialPortOpen)		(239 primitiveSerialPortClose)		(240 primitiveSerialPortWrite)		(241 primitiveSerialPortRead)		(242 primitiveFail)		(243 primStringtranslatefromtotable)		(244 primStringfindFirstInStringinSetstartingAt)		(245 primStringindexOfAsciiinStringstartingAt)		(246 249 primitiveFail)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveFail)		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"MIDI Primitives (520-539)"		(520 primitiveFail)		(521 primitiveMIDIClosePort)		(522 primitiveMIDIGetClock)		(523 primitiveMIDIGetPortCount)		(524 primitiveMIDIGetPortDirectionality)		(525 primitiveMIDIGetPortName)		(526 primitiveMIDIOpenPort)		(527 primitiveMIDIParameterGetOrSet)		(528 primitiveMIDIRead)		(529 primitiveMIDIWrite)		(530 539 primitiveFail)  "reserved for extended MIDI primitives"		"Experimental Asynchrous File Primitives"		(540 primitiveAsyncFileClose)		(541 primitiveAsyncFileOpen)		(542 primitiveAsyncFileReadResult)		(543 primitiveAsyncFileReadStart)		(544 primitiveAsyncFileWriteResult)		(545 primitiveAsyncFileWriteStart)		"Unassigned Primitives"		(546 700 primitiveFail)).! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:17'!primBitmapcompresstoByteArray	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:16'!primBitmapdecompressfromByteArrayat	^ self primitiveFail! !!InterpreterSimulator methodsFor: 'other primitives' stamp: 'di 6/29/1998 22:17'!primStringcomparewithcollated	^ self primitiveFail! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 9/22/1998 16:41'!cCodeForMiscPrimitives	"Return the contents of the miscellaneous primitives file, which is generated via automatic translation to C."	^ CCodeGenerator new codeStringForPrimitives: #(		(Bitmap compress:toByteArray:)		(Bitmap decompress:fromByteArray:at:)		(Bitmap encodeBytesOf:in:at:)		(Bitmap encodeInt:in:at:)		(String compare:with:collated:)		(String translate:from:to:table:)			(String findFirstInString:inSet:startingAt:)		(String indexOfAscii:inString:startingAt:)		(SampledSound convert8bitSignedFrom:to16Bit:))! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 9/22/1998 17:00'!compareWithFilesInFolder: folderName	"InterpreterSupportCode compareWithFilesInFolder: 'Tosh:Desktop Folder:CW Test Project'"	| dir |	dir _ FileDirectory on: folderName.	(dir readOnlyFileNamed: 'projectArchive.sit') binary contentsOfEntireFile =	InterpreterSupportCode archiveBinaryFileBytes		ifFalse: [self inform: 'File projectArchive.sit differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'readme') contentsOfEntireFile =	InterpreterSupportCode readmeFile		ifFalse: [self inform: 'File readme differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sq.h') contentsOfEntireFile =	InterpreterSupportCode squeakHeaderFile		ifFalse: [self inform: 'File sq.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqConfig.h') contentsOfEntireFile =	InterpreterSupportCode squeakConfigFile		ifFalse: [self inform: 'File sqConfig.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMachDep.h') contentsOfEntireFile =	InterpreterSupportCode squeakMachDepFile		ifFalse: [self inform: 'File sqMachDep.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqPlatformSpecific.h') contentsOfEntireFile =	InterpreterSupportCode squeakPlatSpecFile		ifFalse: [self inform: 'File sqPlatformSpecific.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakFilePrimsFile		ifFalse: [self inform: 'File sqFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacAsyncFilePrims.c') contentsOfEntireFile =	InterpreterSupportCode macAsyncFilePrimsFile		ifFalse: [self inform: 'File sqMacAsyncFilePrims.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacDirectory.c') contentsOfEntireFile =	InterpreterSupportCode macDirectoryFile		ifFalse: [self inform: 'File sqMacDirectory.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacJoystick.c') contentsOfEntireFile =	InterpreterSupportCode macJoystickFile		ifFalse: [self inform: 'File sqMacJoystick.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacMinimal.c') contentsOfEntireFile =	InterpreterSupportCode macMinimal		ifFalse: [self inform: 'File sqMacMinimal.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacNetwork.c') contentsOfEntireFile =	InterpreterSupportCode macNetworkFile		ifFalse: [self inform: 'File sqMacNetwork.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSerialAndMIDIPort.c') contentsOfEntireFile =	InterpreterSupportCode macSerialAndMIDIPortFile		ifFalse: [self inform: 'File sqMacSerialAndMIDIPort.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacSound.c') contentsOfEntireFile =	InterpreterSupportCode macSoundFile		ifFalse: [self inform: 'File sqMacSound.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqMacWindow.c') contentsOfEntireFile =	InterpreterSupportCode macWindowFile		ifFalse: [self inform: 'File sqMacWindow.c differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'sqOldSoundPrims.c') contentsOfEntireFile =	InterpreterSupportCode squeakOldSoundPrimsFile		ifFalse: [self inform: 'File sqOldSoundPrims.c differs from the version stored in this image.'].	dir _ dir directoryNamed: 'MacTCP'.	(dir readOnlyFileNamed: 'MacTCP.h') contentsOfEntireFile =	InterpreterSupportCode macTCPFile		ifFalse: [self inform: 'File MacTCP.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'AddressXlation.h') contentsOfEntireFile =	InterpreterSupportCode macAddressXlationFile		ifFalse: [self inform: 'File AddressXlation.h differs from the version stored in this image.'].	(dir readOnlyFileNamed: 'dnr.c') contentsOfEntireFile =	InterpreterSupportCode macDNRFile		ifFalse: [self inform: 'File dnr.c differs from the version stored in this image.'].! !!InterpreterSupportCode class methodsFor: 'source file exporting' stamp: 'jm 6/28/1998 11:56'!writeMacSourceFiles	"Store into this image's folder the C sources files required to support the interpreter on the Macintosh. It also generates the code for the sound synthesis primitives. However, because generating code for the interpreter itself takes several minutes, that is not done automatically by this method. To generate that code, use the method 'translate:doInlining:' in Interpreter class."	"InterpreterSupportCode writeMacSourceFiles"	self storeString: self readmeFile			onFileNamed: 'readme'.	self storeString: self squeakHeaderFile	onFileNamed: 'sq.h'.	self storeString: self squeakConfigFile	onFileNamed: 'sqConfig.h'.	self storeString: self squeakMachDepFile	onFileNamed: 'sqMachDep.h'.	self storeString: self squeakPlatSpecFile	onFileNamed: 'sqPlatformSpecific.h'.	self storeString: self squeakFilePrimsFile	onFileNamed: 'sqFilePrims.c'.	self storeString: self macAsyncFilePrimsFile	onFileNamed: 'sqMacAsyncFilePrims.c'.	self storeString: self macDirectoryFile	onFileNamed: 'sqMacDirectory.c'.	self storeString: self macJoystickFile		onFileNamed: 'sqMacJoystick.c'.	self storeString: self macMinimal		onFileNamed: 'sqMacMinimal.c'.	self storeString: self macNetworkFile		onFileNamed: 'sqMacNetwork.c'.	self storeString: self macSerialAndMIDIPortFile	onFileNamed: 'sqMacSerialAndMIDIPort.c'.	self storeString: self macSoundFile		onFileNamed: 'sqMacSound.c'.	self storeString: self macWindowFile		onFileNamed: 'sqMacWindow.c'.	self storeString: self macTCPFile			onFileNamed: 'MacTCP.h'.	self storeString: self macAddressXlationFile		onFileNamed: 'AddressXlation.h'.	self storeString: self macDNRFile					onFileNamed: 'dnr.c'.	Smalltalk at: #AbstractSound ifPresent: [:abstractSound |		self storeString: abstractSound cCodeForSoundPrimitives													onFileNamed: 'sqSoundPrims.c'].	self storeString: self cCodeForMiscPrimitives													onFileNamed: 'sqMiscPrims.c'.	self storeString: self squeakOldSoundPrimsFile	onFileNamed: 'sqOldSoundPrims.c'.	self storeProjectArchiveOnFileNamed: 'projectArchive.sit'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/30/1998 13:58'!macArchiveBinaryFile	"To create this method use:	  (FileStream oldFileNamed: 'projectArchive.sit') binary contentsOfEntireFile asArray"	^ # (83 73 84 33 0 2 0 0 34 226 114 76 97 117 2 162 0 0 0 22 1 221 13 13 14 83 113 117 101 97 107 54 56 75 46 112 114 111 106 46 99 67 32 118 52 46 53 46 48 0 0 0 0 0 0 0 189 166 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 16 140 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 90 110 177 190 158 132 0 0 37 198 0 0 29 242 0 0 7 229 0 0 8 33 202 166 25 188 0 0 0 0 0 0 74 218 13 192 248 235 186 60 187 86 182 50 249 202 82 126 132 219 225 217 121 124 162 181 178 35 44 114 140 80 66 9 187 40 158 158 156 30 167 157 39 161 114 250 92 159 19 110 134 239 165 173 199 52 252 197 241 79 249 209 6 121 107 17 38 127 194 201 113 9 229 71 24 121 110 132 229 25 57 22 225 71 158 69 249 25 225 79 158 63 225 132 19 254 132 19 202 7 132 19 70 248 153 157 132 19 26 97 228 248 17 78 152 132 191 132 37 225 3 35 199 8 91 129 187 26 176 232 243 35 199 143 54 136 242 149 175 17 78 56 161 71 88 228 248 73 88 100 198 9 127 138 39 28 24 127 2 1 232 117 118 1 48 0 144 199 3 204 192 63 123 39 167 221 46 115 126 81 240 169 92 139 40 72 156 230 23 52 78 149 91 68 89 18 57 49 168 90 107 111 109 21 133 230 121 133 149 142 144 34 47 175 100 49 187 203 229 174 113 214 47 44 99 96 81 254 0 250 37 222 254 46 118 220 124 163 4 48 237 48 192 165 175 138 156 39 40 120 155 57 185 85 11 6 144 32 161 172 234 156 53 127 64 229 240 167 249 69 206 39 54 9 173 65 13 207 106 179 38 135 184 144 18 144 52 81 113 44 172 163 151 251 47 113 94 65 146 100 141 243 32 27 249 54 209 199 201 77 77 81 18 122 30 143 232 21 90 85 145 11 104 132 30 10 194 66 26 86 129 153 22 130 17 76 228 143 214 65 58 176 152 200 132 72 39 158 140 0 106 135 69 22 22 3 1 21 23 17 69 108 46 193 203 85 215 114 243 10 155 57 231 108 103 65 129 227 233 129 44 216 241 0 204 209 67 244 124 3 211 201 100 178 171 250 243 56 32 35 138 140 233 156 61 152 201 14 12 227 98 183 178 33 211 187 80 14 48 65 4 152 120 132 50 75 99 32 18 137 165 137 68 24 18 4 186 88 63 146 216 180 9 160 56 66 190 168 178 153 233 46 89 18 188 242 176 2 102 184 2 44 204 75 108 56 126 30 12 66 239 188 249 144 70 170 132 22 73 37 87 21 144 154 69 229 123 38 209 12 110 183 243 68 134 220 18 183 187 106 188 100 111 193 127 73 40 20 52 6 224 225 114 85 149 166 242 88 171 2 30 110 97 75 72 86 52 34 237 143 57 92 238 42 172 86 67 0 30 245 206 107 141 1 116 173 169 173 25 34 248 39 143 186 178 134 58 214 225 77 182 48 87 189 222 53 79 169 170 243 48 59 188 5 5 134 0 60 76 14 239 207 130 252 206 35 100 24 160 107 104 152 200 25 30 98 219 207 130 252 26 122 189 250 255 169 87 91 156 71 82 141 137 200 195 45 168 94 33 120 90 88 93 215 144 160 26 5 240 240 14 43 155 210 149 24 27 194 35 157 240 248 169 19 141 241 96 29 223 251 155 254 48 213 136 43 83 245 218 224 172 30 241 13 54 146 164 60 233 28 124 178 183 245 191 214 65 251 189 162 42 201 102 63 202 67 245 7 61 169 60 86 119 217 47 170 34 15 173 213 32 128 7 9 179 3 171 228 111 93 221 164 22 83 30 216 0 196 225 162 180 63 230 56 235 112 79 241 48 12 112 184 213 165 139 200 76 46 169 135 203 93 159 210 195 168 193 41 159 84 227 172 83 78 242 56 227 148 71 120 140 58 229 17 93 71 157 114 138 135 241 130 83 30 210 227 47 167 124 74 216 63 157 114 138 199 168 83 30 162 113 206 41 39 121 24 3 56 101 227 15 135 123 178 96 207 58 220 211 157 209 48 192 225 214 7 164 171 231 114 109 133 243 78 56 92 203 31 78 7 137 156 200 241 135 211 73 242 56 227 80 70 244 24 117 40 41 30 99 29 120 136 199 185 14 156 228 97 114 36 187 94 6 242 192 194 31 177 194 227 29 38 193 35 24 24 110 123 223 78 18 78 87 26 225 33 123 150 15 243 168 246 44 79 241 200 116 157 92 87 136 23 135 203 89 97 8 32 250 111 51 130 12 84 131 86 244 47 60 176 83 5 135 189 226 100 194 35 40 168 42 231 148 91 66 129 224 119 234 198 58 3 86 180 216 100 8 160 235 120 103 72 120 233 164 39 31 227 145 234 192 169 58 75 116 78 109 184 204 70 195 156 75 215 134 24 48 49 22 220 240 41 130 70 196 151 28 219 2 141 51 15 232 24 192 139 0 141 124 248 131 99 248 63 200 135 249 112 239 251 151 46 193 141 159 73 176 27 51 175 195 51 44 38 20 170 248 246 135 222 132 198 171 42 96 201 87 183 64 120 223 46 8 119 180 241 225 7 45 244 78 120 61 182 67 194 68 231 199 217 248 118 146 143 111 223 188 15 110 218 123 247 0 23 68 194 119 61 122 92 112 253 252 145 46 25 229 119 60 248 246 39 46 230 219 31 199 219 81 126 144 115 51 236 198 127 63 159 142 143 160 177 120 63 158 159 161 92 122 40 231 195 176 137 42 157 131 89 145 49 110 20 177 23 22 233 163 212 218 214 16 233 206 4 173 192 109 66 81 81 139 236 214 30 152 188 253 138 56 113 102 150 174 8 102 101 124 143 205 1 251 13 251 241 191 219 31 249 154 71 252 74 188 23 1 251 148 89 136 29 193 191 13 114 218 235 48 255 139 249 96 54 35 206 29 207 15 136 187 117 124 150 198 20 188 209 165 122 149 0 76 197 129 36 230 167 91 85 190 110 172 3 212 135 230 207 192 252 59 118 129 61 55 177 19 149 127 255 147 252 198 167 52 68 176 8 8 159 238 110 176 95 178 131 185 38 205 134 216 30 228 215 73 235 124 242 246 213 122 126 212 131 228 183 79 143 217 202 92 152 78 182 225 72 13 92 48 88 3 104 122 20 65 9 136 106 17 24 90 212 0 179 224 250 47 12 3 106 32 3 216 169 131 53 16 107 2 0 93 121 208 87 249 10 244 213 180 241 29 119 188 94 77 166 234 38 200 196 15 224 67 198 183 130 112 140 144 219 112 224 145 46 56 248 230 3 192 204 94 207 248 86 162 30 43 58 123 163 65 239 247 169 107 144 201 91 252 70 212 148 230 239 202 195 28 135 74 97 70 41 100 189 211 0 231 21 178 180 135 229 100 233 134 225 192 182 231 83 253 28 121 206 137 65 58 190 42 23 114 122 55 227 191 19 49 15 189 159 211 119 20 172 207 245 68 48 16 231 175 197 90 224 183 101 230 195 17 6 235 117 109 4 152 189 116 18 206 90 112 175 52 171 54 208 18 10 138 92 169 40 142 79 54 13 59 130 1 198 8 166 8 48 236 96 198 133 89 186 212 73 55 60 17 164 97 133 9 223 22 11 198 43 184 91 11 19 245 61 107 110 177 139 140 6 201 190 245 200 248 160 63 202 75 106 235 244 157 149 203 109 54 218 207 255 141 98 140 56 248 195 142 44 76 216 53 152 114 46 234 120 110 47 216 130 155 192 137 122 216 67 55 140 7 27 138 17 80 44 93 170 106 130 66 172 158 129 67 216 169 83 196 98 30 172 103 236 126 70 0 237 170 216 0 66 95 198 78 94 21 48 164 137 103 201 132 41 181 153 79 220 134 238 94 24 50 179 192 63 217 213 111 48 4 240 49 169 178 61 238 115 126 112 57 186 55 177 128 57 209 181 6 222 207 96 39 126 178 113 26 25 129 95 196 72 192 134 22 211 249 236 133 33 5 135 177 83 225 178 218 186 154 60 204 216 191 113 151 215 75 135 155 232 249 112 139 229 83 152 134 247 173 4 171 121 13 112 110 195 208 225 246 117 247 66 33 98 244 189 130 10 55 224 56 159 33 19 63 8 189 13 213 200 122 6 193 90 214 194 82 196 234 8 86 56 27 240 113 0 214 71 176 54 55 172 65 108 53 193 46 216 10 29 136 117 19 108 230 11 112 15 98 71 9 198 47 128 251 0 206 159 79 48 233 101 216 130 146 53 16 204 255 57 60 140 82 210 65 114 254 6 216 137 24 114 1 152 146 14 56 75 185 136 204 106 224 166 101 208 131 239 121 208 124 75 43 224 61 196 54 80 222 235 224 99 196 54 19 236 74 39 124 6 112 201 109 4 155 244 25 124 131 24 205 145 187 19 223 221 0 142 14 25 203 50 152 108 128 233 248 54 8 6 78 87 176 162 230 18 200 116 136 98 88 11 152 219 141 111 142 136 94 141 195 186 82 3 178 148 141 27 70 241 65 184 149 110 58 196 225 44 178 235 226 148 125 226 117 162 100 73 236 189 208 107 81 26 147 162 91 87 177 148 49 188 94 80 164 128 180 76 181 198 232 150 181 105 138 160 166 151 249 2 154 172 152 203 101 73 75 175 19 148 101 162 150 93 226 245 138 56 140 119 11 154 31 239 211 52 89 212 172 71 137 39 86 74 233 181 40 33 171 190 220 17 87 78 135 99 180 211 157 229 46 76 150 69 30 92 136 241 72 60 190 48 129 64 184 57 68 175 71 249 252 15 0 12 0 235 49 185 14 204 107 214 217 121 201 105 215 132 222 54 182 50 249 211 46 202 7 166 178 181 79 217 105 231 118 141 167 71 56 57 238 225 217 122 50 15 79 40 158 106 225 159 230 19 222 17 38 217 79 54 97 251 201 109 178 201 126 242 155 12 54 217 100 31 57 30 225 100 31 149 71 37 191 143 12 232 38 155 220 150 112 178 201 38 147 77 56 225 40 32 19 126 132 31 57 78 56 225 228 54 217 228 182 100 63 217 20 184 183 117 211 107 227 143 93 79 205 111 128 39 252 141 222 102 100 176 9 26 182 148 108 0 130 7 62 60 80 14 186 152 166 169 132 16 23 124 27 9 217 243 77 248 254 12 122 17 248 22 193 247 71 100 27 105 35 110 210 82 28 213 198 245 152 108 16 215 243 207 146 71 72 247 240 252 95 59 73 49 32 208 87 130 53 125 110 142 231 13 75 177 230 62 229 172 46 233 10 160 30 99 120 219 17 67 224 242 199 240 124 129 254 104 232 95 128 23 10 120 116 198 22 66 218 103 73 217 195 149 196 245 202 15 9 185 48 239 122 168 234 109 114 144 68 160 126 236 18 20 157 129 225 225 163 252 177 250 192 119 220 62 82 228 138 213 158 180 166 35 238 195 238 35 23 230 201 59 192 61 41 175 36 213 160 2 66 60 76 35 11 175 68 73 152 178 158 244 199 108 120 251 245 97 93 154 42 171 121 24 166 240 64 125 26 234 114 172 189 80 159 129 218 135 253 50 168 37 168 75 210 191 121 180 14 234 163 233 137 83 47 67 221 159 158 120 168 8 234 96 122 242 193 31 64 253 93 242 61 152 170 204 230 197 107 140 245 40 170 28 209 149 81 99 149 156 214 45 3 120 17 124 252 137 60 5 211 84 219 124 212 25 99 224 5 1 99 42 17 91 227 229 4 214 53 51 123 167 159 128 41 26 176 222 157 250 219 139 111 66 45 120 218 133 255 213 98 93 143 245 50 127 135 241 127 193 99 245 140 242 151 63 127 194 231 31 200 31 129 141 42 155 207 74 198 103 151 162 203 49 83 211 167 242 18 19 174 37 248 220 186 129 199 199 201 44 176 224 179 121 172 96 60 30 215 166 12 83 137 141 20 156 226 58 139 199 42 168 127 191 192 163 224 207 241 143 77 190 178 62 226 99 124 245 203 230 132 166 175 208 69 190 136 245 126 228 165 14 235 138 148 235 209 159 64 93 153 242 236 122 122 129 63 255 6 127 205 136 35 248 107 250 229 220 123 109 80 55 254 234 245 95 140 231 249 116 249 93 109 192 70 147 205 103 61 227 51 42 235 138 164 6 18 241 112 168 43 20 209 116 243 10 179 61 88 247 162 238 132 14 239 196 58 132 255 9 190 239 178 252 83 240 191 236 63 29 89 31 218 129 245 78 172 143 225 156 142 63 221 157 245 169 67 150 126 150 245 210 239 162 233 115 159 173 151 114 174 23 109 60 17 95 203 92 95 192 250 118 156 119 15 214 109 88 219 250 17 122 185 227 127 186 57 104 233 167 29 107 225 47 182 158 14 204 124 57 176 19 234 219 214 117 245 185 158 178 254 3 57 17 244 244 160 146 136 107 19 171 130 186 213 210 147 237 51 66 31 247 97 127 47 214 199 215 125 215 214 145 208 205 17 172 239 157 249 199 219 95 91 208 77 231 127 243 209 61 168 171 27 240 191 13 189 20 114 117 88 49 98 31 231 234 174 45 7 114 117 150 143 42 99 108 64 141 51 63 92 227 36 176 85 2 31 144 207 62 33 3 94 247 150 3 124 252 147 17 81 111 243 113 93 60 161 127 188 156 129 39 182 76 34 39 216 251 7 59 7 220 130 253 125 150 223 181 96 125 51 214 203 249 222 206 1 215 99 125 19 214 55 98 45 124 75 228 78 225 251 118 238 236 33 189 219 222 130 218 157 97 148 41 161 20 220 125 32 234 87 149 179 235 252 11 220 43 115 240 156 26 150 204 97 88 204 29 234 56 209 220 35 181 180 43 7 58 226 173 126 248 193 158 35 156 155 131 241 177 35 169 107 231 96 1 164 31 234 24 105 137 142 74 170 218 186 68 14 108 221 46 205 33 250 56 135 55 26 26 120 224 164 31 232 248 144 132 133 39 252 32 59 199 14 182 113 68 62 155 131 249 129 232 30 52 131 220 9 83 148 252 216 225 32 229 105 188 232 154 14 71 250 122 104 135 184 25 234 183 28 69 166 60 173 79 10 212 214 39 201 54 134 250 13 71 55 144 146 230 56 42 237 144 34 134 250 136 195 110 202 235 125 9 103 133 14 236 120 64 173 222 247 157 157 208 227 207 61 245 117 215 244 96 247 201 65 218 1 231 4 84 95 189 227 180 179 95 117 3 175 20 149 118 96 47 198 102 117 246 104 179 95 249 123 26 81 161 3 59 102 80 173 247 253 34 99 204 63 92 16 61 205 8 28 149 165 133 210 78 80 111 241 183 183 143 130 135 21 112 89 18 97 168 172 83 198 81 139 167 206 75 170 145 135 101 185 68 160 74 196 131 168 134 25 87 180 85 212 211 25 212 211 164 156 163 150 0 42 168 58 7 107 161 122 51 168 186 146 24 90 65 61 147 65 61 67 124 168 6 83 25 149 215 212 176 56 107 69 39 232 181 228 167 229 160 214 94 89 138 203 250 146 36 88 202 231 168 180 83 201 81 233 29 0 162 130 5 125 232 121 176 19 152 14 135 131 189 172 83 197 24 122 190 180 75 54 70 142 142 231 180 199 146 61 155 149 117 170 57 106 241 224 84 82 46 232 149 229 39 142 74 59 53 28 181 38 168 37 226 138 169 104 9 73 5 178 116 205 154 128 165 47 49 235 19 164 150 163 122 194 202 164 28 15 107 241 172 144 44 212 58 142 90 210 125 94 78 152 121 138 44 212 29 56 235 151 198 193 141 227 186 52 113 117 214 157 28 181 34 131 58 40 79 154 87 144 45 212 122 84 222 64 244 1 83 201 187 158 133 186 11 121 13 203 163 212 195 55 120 221 141 122 165 247 0 43 254 74 243 54 119 20 218 105 16 26 210 117 45 235 65 31 204 218 200 51 74 9 72 123 48 24 201 161 210 44 205 115 3 75 213 123 80 121 129 100 82 149 7 37 117 228 170 242 154 248 172 149 129 120 92 151 13 227 100 159 68 109 229 50 52 205 239 124 86 150 228 175 199 89 239 151 13 126 99 115 117 214 102 225 121 186 148 92 241 188 127 163 238 69 149 31 147 13 83 82 63 112 133 143 80 247 33 106 143 166 230 236 255 10 234 13 200 235 32 156 24 21 60 197 66 189 81 160 130 105 93 67 189 9 189 33 26 211 149 100 142 86 27 245 102 116 202 80 194 84 11 234 179 80 111 17 106 80 38 233 106 100 67 13 45 168 215 80 76 75 92 211 107 43 207 202 206 77 207 108 241 169 62 204 202 208 129 13 56 67 117 54 230 105 255 247 127 141 89 25 58 176 231 21 179 174 238 133 211 115 175 13 33 42 116 224 218 130 161 58 215 25 233 253 167 222 69 84 232 144 253 153 156 119 94 201 57 222 101 53 248 209 27 34 186 6 160 198 134 83 30 64 229 113 33 228 149 71 183 241 28 149 118 218 56 106 121 80 27 77 106 137 92 106 179 102 189 13 81 217 172 161 68 114 124 201 139 172 252 122 59 71 245 178 180 145 143 136 214 172 119 112 212 237 221 145 72 176 144 230 45 212 118 100 8 64 169 49 159 213 38 63 229 245 32 71 245 245 107 166 114 78 137 45 229 154 203 168 135 80 229 220 76 54 85 126 39 71 45 131 92 110 234 90 46 138 90 168 29 168 242 176 156 200 239 13 46 163 222 37 124 8 142 112 180 161 77 134 238 70 134 104 70 233 134 221 193 103 12 221 35 18 27 108 95 244 85 134 22 189 225 94 134 250 76 153 216 2 46 207 74 111 37 56 42 237 28 70 94 163 108 63 180 201 235 125 34 151 131 242 174 105 232 8 162 70 180 137 117 94 23 81 59 133 43 199 32 192 254 7 53 192 211 134 115 251 48 251 194 27 63 199 60 4 29 114 148 239 14 203 140 49 240 148 115 202 242 190 140 222 21 96 70 129 14 9 114 212 90 99 44 162 74 230 57 77 31 141 38 229 24 181 191 75 248 244 10 1 81 161 3 215 31 153 20 181 114 45 146 174 169 11 32 42 116 224 38 66 164 168 213 27 138 116 69 181 216 110 66 7 54 219 12 213 185 36 75 207 189 154 18 137 237 213 20 57 38 178 50 3 92 201 202 139 62 212 139 89 25 242 208 232 90 86 94 68 13 113 212 234 224 253 97 62 238 82 224 179 80 143 35 67 125 218 4 44 150 54 211 252 9 174 6 231 222 52 253 219 221 143 161 26 160 3 215 185 12 213 185 230 77 255 238 226 20 162 66 135 132 217 150 125 218 185 141 72 121 26 218 197 70 191 161 157 244 115 71 241 48 134 134 187 228 172 239 209 59 95 225 67 112 241 203 158 11 174 179 137 59 18 149 135 230 231 51 64 240 143 139 208 127 232 92 110 239 59 73 232 55 209 155 229 72 159 97 82 0 248 7 106 175 31 174 86 205 72 143 106 208 127 254 15 0 13 13 14 83 113 117 101 97 107 80 80 67 46 112 114 111 106 77 114 67 32 118 52 46 53 46 48 0 0 0 0 0 0 0 215 154 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 255 255 255 255 77 77 80 82 67 87 73 69 1 0 172 94 103 33 177 190 158 123 0 0 42 109 0 0 31 62 0 0 9 113 0 0 8 117 16 125 111 57 0 0 0 0 0 0 27 241 13 192 213 101 47 91 187 188 110 221 29 229 18 150 183 198 233 53 72 187 149 29 97 73 24 97 155 146 205 162 120 122 246 155 230 166 118 54 232 76 126 126 20 79 13 207 60 59 243 247 250 17 78 219 94 172 181 174 129 145 219 100 179 219 18 70 246 179 178 167 91 194 201 38 180 35 172 211 45 97 219 235 216 126 178 25 217 39 217 71 201 182 35 199 200 38 140 48 194 175 99 114 194 54 57 30 219 30 97 69 185 132 17 254 81 242 180 91 129 175 26 212 121 117 190 155 125 180 149 173 237 35 91 26 97 155 220 214 205 54 153 109 178 201 102 120 178 129 241 30 16 128 94 103 135 7 96 0 48 103 9 192 108 60 53 159 116 5 223 89 254 32 131 224 123 30 88 32 6 7 240 28 172 219 186 208 28 124 75 185 149 167 86 127 182 93 150 90 109 54 139 217 227 117 183 88 4 204 110 181 218 170 44 181 43 138 24 148 102 15 163 239 4 240 249 72 236 94 215 148 9 48 243 110 128 121 109 89 121 230 224 209 157 79 150 22 173 215 173 220 186 115 79 238 76 68 166 149 184 130 93 11 205 144 134 167 1 207 164 242 125 39 117 21 111 67 90 189 97 229 86 122 235 209 237 170 170 169 88 148 80 214 63 125 32 232 41 95 87 222 190 8 32 129 115 75 224 159 54 74 150 196 29 14 109 2 6 148 175 2 40 249 3 203 152 141 47 4 158 92 139 119 254 30 52 198 23 241 222 18 194 241 125 162 71 178 183 74 77 242 7 90 42 49 41 244 222 236 219 208 118 254 125 74 245 6 159 95 110 179 56 37 159 79 246 93 160 144 125 78 169 243 161 3 1 19 105 16 217 134 183 143 114 142 133 128 44 244 42 0 44 194 81 74 138 164 89 37 187 169 162 218 132 45 194 100 89 104 201 201 49 127 119 56 139 168 148 153 114 9 221 87 178 109 44 89 120 224 76 30 61 48 164 131 39 151 153 208 40 108 230 213 41 68 106 116 60 152 86 21 160 90 212 65 2 27 106 184 36 38 50 26 70 50 25 177 8 93 194 98 225 215 26 108 162 0 137 216 23 83 6 56 179 4 52 14 193 112 154 96 16 11 150 74 22 96 134 114 165 216 177 3 32 47 72 95 168 95 36 235 172 110 151 100 119 143 41 160 133 185 160 103 63 17 2 145 251 217 234 38 89 214 64 2 245 158 80 235 41 115 184 90 101 239 251 76 198 51 76 203 183 217 202 110 21 89 61 158 249 30 143 83 29 128 135 213 90 86 16 207 147 90 230 104 48 173 104 243 184 189 126 146 246 66 14 171 173 172 88 37 128 71 173 165 80 29 64 215 170 234 170 81 130 31 243 168 41 90 93 163 49 55 52 219 251 250 250 128 253 108 59 127 120 236 9 63 93 197 199 90 94 71 187 84 104 40 144 156 78 183 219 101 42 145 157 30 122 56 117 153 0 199 182 246 64 215 156 101 176 51 247 0 61 33 30 130 217 30 107 133 214 90 197 211 92 170 14 133 135 214 108 207 201 81 5 224 161 49 219 175 8 242 119 30 92 118 85 0 93 61 99 68 174 243 144 59 174 8 242 215 80 234 181 249 63 245 154 22 225 17 83 35 5 121 216 36 159 93 114 94 22 86 209 213 35 141 26 252 127 242 176 143 41 27 215 149 12 18 241 208 17 143 15 59 209 53 30 130 249 125 159 116 38 52 85 242 231 62 170 87 223 149 62 173 67 25 242 125 109 188 79 243 247 231 250 244 106 75 197 184 143 73 163 36 197 49 39 211 232 182 183 255 183 5 113 255 225 245 121 99 166 97 130 135 175 217 217 16 207 147 106 43 186 170 42 242 240 183 171 4 240 160 208 154 177 74 254 173 171 141 106 81 113 220 75 151 125 70 189 196 113 163 180 23 114 220 112 220 151 120 168 6 56 238 138 130 82 211 184 30 86 91 109 92 15 181 15 231 126 81 213 27 206 61 198 227 186 115 31 231 49 225 220 199 117 157 112 238 113 30 234 11 206 125 84 143 127 57 247 75 194 126 236 220 227 60 38 156 251 40 141 155 206 61 198 67 61 192 185 107 205 62 185 233 195 62 13 208 117 231 41 156 198 207 133 130 108 236 207 251 135 251 116 49 239 211 234 31 142 251 98 225 223 112 220 151 59 172 106 128 227 174 117 184 238 90 108 234 88 182 244 207 142 91 255 15 199 132 68 174 116 134 107 142 41 198 227 186 211 25 215 99 194 233 196 121 92 235 228 163 60 110 118 242 24 15 141 57 214 245 146 144 7 22 254 184 53 191 213 97 162 60 156 142 177 182 119 122 178 113 185 210 136 135 187 161 101 140 71 69 67 75 156 71 178 245 226 58 71 164 56 172 150 18 85 0 209 255 54 107 72 66 53 120 69 95 229 129 157 202 57 230 57 211 137 7 45 141 153 44 238 54 143 195 121 86 221 112 103 192 138 150 215 171 2 232 122 171 51 68 61 121 204 219 95 227 17 239 192 241 58 139 118 78 255 88 153 77 132 206 196 151 213 4 208 50 218 69 203 133 58 196 215 158 250 6 212 205 123 67 193 0 246 3 212 137 129 223 158 194 179 95 12 136 129 190 87 102 173 197 141 168 201 112 16 51 111 194 59 208 202 20 43 19 59 191 254 75 168 91 80 2 107 223 171 135 192 107 7 32 240 72 135 24 120 82 207 223 4 30 198 118 72 76 20 126 166 52 177 147 242 137 157 79 189 6 107 94 221 50 204 5 145 192 99 221 67 130 43 119 244 228 24 152 31 249 13 133 216 217 51 67 236 220 131 175 67 252 96 202 58 56 136 231 25 62 143 188 14 117 121 71 240 254 2 231 210 203 57 159 128 29 92 233 41 152 21 25 51 220 62 20 114 115 55 139 155 95 90 29 34 199 64 51 163 144 185 106 30 197 19 153 38 158 54 97 11 120 2 229 237 83 32 188 253 10 225 38 173 136 249 77 70 113 243 46 101 110 155 188 184 135 53 125 77 209 142 242 85 126 191 67 220 220 93 12 250 162 189 48 248 157 67 172 242 231 189 152 107 35 36 182 126 1 30 127 119 144 85 190 184 13 71 18 60 48 199 17 150 240 165 39 224 228 189 221 226 163 39 202 185 250 240 116 61 205 36 128 189 90 200 42 191 7 66 83 198 29 48 248 171 233 10 187 251 127 196 53 27 139 193 147 212 138 120 241 71 52 230 186 252 120 31 192 198 93 236 48 8 217 185 202 120 187 186 221 67 14 37 183 68 150 26 101 175 47 55 191 188 122 5 206 44 21 16 167 36 63 56 69 39 91 254 242 17 214 216 227 199 115 46 91 78 229 53 245 16 103 212 248 172 173 0 146 12 96 200 50 70 216 27 243 15 199 123 18 251 212 134 55 56 208 24 226 65 56 42 78 124 216 221 83 255 50 13 63 10 62 24 128 94 204 181 157 234 133 53 62 183 133 52 193 252 61 252 189 225 142 45 144 254 149 238 108 72 210 114 61 158 102 233 252 84 34 3 50 177 32 132 105 35 53 128 104 88 121 99 106 47 164 63 51 55 42 216 252 112 117 11 172 229 143 139 192 184 242 8 158 7 155 131 127 18 17 191 19 223 5 193 248 137 249 136 13 224 153 6 83 58 107 48 255 254 108 208 106 17 55 13 229 7 196 109 10 62 223 207 114 94 238 242 217 189 14 248 127 28 68 97 126 190 125 216 210 143 253 16 245 225 249 147 48 255 91 7 192 152 17 221 29 204 58 177 73 220 190 151 166 88 216 12 137 79 255 115 96 156 185 155 21 26 108 136 29 66 126 219 120 197 167 63 243 160 146 31 245 160 252 198 204 112 103 67 253 105 23 151 106 224 182 145 26 64 243 235 149 188 14 25 139 95 245 161 6 196 237 151 107 128 181 254 238 135 106 2 53 48 121 164 6 104 23 84 68 78 196 89 29 165 15 160 152 250 208 34 186 218 75 132 86 182 85 96 194 136 179 130 72 73 12 69 42 36 98 137 240 35 244 242 37 114 152 227 155 243 87 35 15 67 217 165 98 129 213 231 254 188 112 35 136 79 4 60 191 161 143 60 71 82 46 70 29 111 214 190 30 93 0 70 200 93 31 82 122 233 112 67 81 3 138 251 238 243 249 37 47 95 218 80 111 8 35 104 132 208 79 29 162 127 4 192 224 221 79 13 68 95 102 84 137 113 127 31 196 62 154 45 165 40 127 142 49 173 178 146 193 161 63 200 224 255 99 134 146 20 231 87 215 40 238 101 14 78 221 18 105 99 168 11 61 17 247 228 106 7 101 59 228 115 206 187 28 229 31 35 250 179 191 149 137 254 51 71 72 121 243 240 204 47 227 147 233 236 5 16 60 171 248 156 126 154 199 139 67 249 219 97 118 117 77 85 22 102 252 226 105 74 201 249 124 200 205 187 222 61 63 5 154 119 164 18 86 249 0 228 226 245 255 8 43 125 28 104 43 246 97 194 218 111 131 123 241 186 155 176 148 26 104 194 43 13 15 33 115 22 32 87 86 74 88 245 124 216 136 216 87 9 91 234 133 173 136 125 155 176 252 231 169 142 216 94 194 214 164 195 179 136 29 37 44 241 56 214 37 8 253 132 125 190 15 126 129 74 242 237 208 197 107 224 55 136 225 63 117 0 214 217 224 77 196 248 230 68 150 27 142 35 198 183 197 54 62 15 239 34 214 75 88 173 22 6 113 4 194 103 59 121 243 88 50 254 238 131 116 131 230 37 12 53 54 221 67 88 253 239 25 78 93 77 124 127 33 199 201 230 32 198 117 93 255 45 118 23 170 200 243 77 57 198 112 235 54 115 19 97 183 239 97 149 136 209 220 5 30 90 206 112 194 156 197 91 69 85 55 107 68 140 231 120 232 155 12 127 26 146 205 181 47 90 194 238 7 152 165 172 163 244 210 220 105 54 253 217 7 52 199 57 198 117 157 108 195 126 35 219 253 38 172 79 159 195 237 202 176 74 77 14 187 201 34 121 70 150 44 208 134 135 31 42 59 37 233 209 7 33 14 169 124 209 38 146 113 18 173 90 89 220 141 242 167 101 151 62 186 118 197 159 133 50 166 209 254 115 161 195 135 68 229 182 6 98 73 46 255 244 3 131 178 251 142 91 134 46 217 105 192 181 188 8 189 201 161 197 195 179 120 173 228 117 57 92 77 190 212 176 178 69 29 126 175 228 211 21 53 58 252 110 175 182 216 237 242 235 106 36 111 147 236 55 228 219 237 50 74 108 147 252 205 248 158 167 153 68 138 132 69 139 110 103 243 103 97 153 149 189 164 48 239 16 28 166 173 179 20 91 49 217 36 62 174 8 241 136 254 87 37 145 32 92 122 227 207 67 124 254 7 0 12 0 235 117 249 249 94 179 188 38 114 202 39 70 249 123 114 202 39 102 3 183 84 182 246 41 211 235 240 155 173 199 125 201 38 252 60 60 245 164 143 223 212 180 240 31 243 247 128 108 74 182 145 231 29 217 132 19 70 246 145 219 39 249 125 100 27 121 182 201 38 91 42 139 186 201 237 35 155 28 219 132 147 227 145 77 54 225 228 55 217 132 147 125 100 191 100 19 222 17 78 126 31 217 94 146 253 146 77 54 121 74 182 71 184 192 189 173 156 30 63 252 177 139 108 182 118 246 50 60 97 101 244 146 12 54 65 195 62 74 54 158 224 129 47 160 28 116 81 77 139 19 66 92 240 223 69 72 243 207 225 255 23 232 73 240 47 134 255 11 80 181 19 55 188 53 70 91 24 198 179 59 95 129 154 144 115 115 199 88 125 233 163 120 173 155 32 224 17 82 228 142 238 152 37 174 55 35 174 32 57 232 10 183 252 128 52 2 145 225 221 79 147 166 121 52 15 252 41 222 182 226 23 88 31 240 178 111 31 35 143 187 31 221 51 242 238 116 165 0 119 208 253 240 103 46 144 215 73 17 33 149 111 144 122 242 20 188 171 96 26 153 255 202 212 132 169 232 201 182 104 142 166 236 215 135 245 141 233 242 186 199 96 138 155 161 62 9 245 30 172 111 129 250 20 212 173 216 191 9 106 25 234 27 50 223 63 219 0 245 3 153 137 129 223 64 45 101 38 62 86 12 245 67 153 201 227 95 134 250 73 114 6 166 42 183 121 241 24 227 221 106 92 145 116 117 204 88 37 39 184 105 0 47 130 143 159 145 23 97 154 90 155 143 6 99 60 36 71 125 198 84 34 90 224 37 132 245 214 153 235 167 127 4 83 212 96 93 157 254 199 75 127 128 90 240 84 133 239 202 177 246 98 189 200 223 253 248 94 240 88 54 163 254 253 111 31 240 249 19 112 63 66 106 108 62 171 25 159 157 170 174 68 77 77 159 202 75 236 58 139 207 205 27 120 60 71 102 129 5 175 205 99 21 227 241 136 54 101 152 106 116 116 217 41 186 44 30 187 161 126 126 158 71 193 159 227 31 235 124 229 124 196 203 248 234 83 204 9 77 95 161 139 92 143 245 237 200 75 5 214 183 166 93 103 191 1 245 109 233 138 237 175 206 243 183 119 141 191 109 136 35 248 171 127 230 252 95 219 161 174 125 246 119 223 73 229 249 116 181 185 218 129 141 102 155 207 38 198 103 88 209 85 57 238 75 196 66 129 206 128 164 233 230 37 102 15 99 29 64 221 9 29 222 139 245 17 124 39 248 190 207 242 79 193 255 162 255 236 207 249 80 37 214 30 172 123 112 78 199 159 14 228 124 234 30 75 63 139 122 233 115 209 244 121 131 173 151 74 174 23 45 149 136 21 50 23 205 145 44 39 226 188 117 88 183 97 109 235 71 232 229 206 255 234 230 110 75 63 119 97 45 252 197 214 211 190 153 99 190 70 168 239 184 162 171 255 233 41 231 63 144 19 65 79 199 213 68 76 155 88 21 212 195 150 158 108 159 17 250 232 192 126 35 214 189 87 124 215 214 145 208 141 15 235 206 153 183 94 253 236 188 110 14 253 39 31 249 81 87 219 241 221 154 94 150 115 117 72 53 162 87 115 245 71 54 29 200 213 57 62 106 140 241 254 120 140 249 97 129 147 7 55 75 224 3 242 217 7 100 192 119 112 211 1 62 222 102 68 52 217 124 108 137 37 244 171 203 25 248 96 227 195 62 145 19 236 253 131 157 3 118 99 191 201 242 187 102 172 119 97 189 152 239 237 28 208 128 245 78 172 119 96 45 124 75 228 78 225 251 118 238 236 38 61 69 127 132 218 157 101 148 41 193 235 235 11 7 90 252 109 146 228 111 11 170 131 121 254 133 110 114 115 120 194 129 254 71 78 92 29 131 108 177 230 128 237 217 194 28 149 1 186 47 27 146 163 74 97 140 236 252 185 57 170 146 186 54 4 139 36 157 50 18 95 30 165 164 48 71 105 72 54 71 174 80 193 62 129 155 155 195 27 58 238 63 154 74 152 234 152 82 16 8 221 167 210 239 43 228 41 54 135 232 139 124 17 30 79 41 242 104 203 177 80 203 254 3 189 203 124 244 103 199 255 147 219 251 100 171 219 243 218 79 221 222 35 103 70 97 37 9 143 36 119 241 119 223 96 50 242 246 61 77 200 133 183 97 178 185 236 174 18 220 231 157 65 96 199 41 36 247 241 71 171 249 72 29 192 74 217 39 29 239 72 123 122 63 225 154 14 73 193 110 218 33 110 134 250 121 71 225 51 253 103 59 92 211 198 72 124 144 118 72 17 67 157 118 116 248 204 215 6 40 170 153 26 164 29 82 204 80 191 232 168 46 93 19 172 69 134 160 67 182 48 212 175 59 94 150 174 216 245 85 68 133 14 41 97 168 159 115 28 103 230 173 215 246 114 84 218 129 60 1 14 230 109 114 242 199 236 167 221 63 118 77 71 186 78 68 104 135 148 117 128 127 150 254 170 52 50 149 84 140 182 247 118 210 11 179 210 12 192 80 89 103 43 71 173 243 107 137 152 106 170 90 66 142 67 168 215 53 107 2 150 32 56 42 237 148 115 212 138 144 58 169 196 66 90 76 185 60 175 133 90 193 81 203 186 78 43 9 51 79 145 133 90 137 179 126 52 5 91 198 152 46 79 124 56 171 135 163 86 101 81 35 202 164 121 9 217 66 245 114 212 173 253 225 71 76 53 190 68 145 133 90 133 188 134 148 49 186 207 93 227 181 26 245 74 119 218 203 122 101 153 145 161 178 78 141 208 144 174 107 250 53 13 213 114 71 41 3 105 71 252 210 18 42 205 131 220 81 88 50 172 67 229 249 146 201 184 18 145 227 163 31 42 175 158 207 90 237 139 197 116 197 48 78 4 101 106 43 23 161 105 6 229 179 178 52 218 128 179 30 85 12 45 165 71 23 21 97 205 186 77 120 158 46 39 87 60 239 61 212 70 84 249 97 197 48 229 248 251 174 240 79 212 38 68 237 214 226 49 37 47 61 11 117 59 242 26 129 51 153 101 79 177 80 119 8 84 48 173 13 212 157 232 13 225 168 174 38 151 104 181 81 119 161 83 66 246 138 47 171 207 66 221 45 212 160 78 210 248 181 166 134 102 212 107 32 170 37 54 244 122 29 117 20 207 156 115 55 49 251 169 55 51 152 135 160 3 91 92 134 234 108 125 51 109 95 250 30 71 165 29 216 253 51 84 231 86 32 179 111 224 207 136 10 29 216 53 51 212 98 99 60 79 42 69 133 253 19 162 66 135 220 216 1 168 165 95 40 25 91 22 16 77 0 116 203 197 19 0 237 220 196 81 75 167 78 203 249 132 194 80 229 44 170 76 110 70 84 195 140 169 218 42 234 201 44 234 73 178 135 163 150 1 42 196 214 37 88 11 245 150 44 170 174 38 134 87 80 79 101 81 79 145 86 84 3 75 228 171 106 88 152 245 214 14 216 166 148 125 179 18 212 218 163 200 75 198 204 54 200 28 149 118 110 227 168 158 119 80 33 153 191 143 74 247 205 211 161 144 191 135 117 110 71 207 235 84 78 171 75 9 229 162 123 237 69 47 151 116 13 64 141 181 100 179 15 157 146 27 87 222 41 233 5 0 71 165 157 54 142 90 233 215 198 146 90 98 41 101 91 179 222 129 168 108 214 64 34 153 186 156 29 216 54 92 160 62 79 218 57 170 135 165 195 124 164 183 102 189 147 163 150 116 209 85 72 94 229 22 234 93 200 16 128 210 32 53 168 77 254 139 215 187 57 170 183 79 51 213 33 53 122 57 135 94 68 189 7 85 206 15 27 214 85 126 47 71 45 135 61 138 169 107 75 198 108 161 238 71 149 135 148 68 106 35 15 221 39 124 8 14 127 180 225 117 134 14 32 67 52 83 118 193 174 231 223 12 221 143 179 134 153 151 175 207 250 0 207 67 229 198 56 232 97 72 93 204 0 116 15 143 121 8 58 112 103 192 80 157 187 132 217 95 255 254 91 152 243 160 67 30 226 168 245 198 184 20 151 205 33 77 31 11 39 149 40 21 252 187 83 211 93 63 206 10 29 184 33 16 57 111 245 230 32 83 85 43 18 27 116 224 50 131 161 58 151 28 153 186 6 31 162 66 7 238 95 178 168 43 247 50 153 243 191 29 70 84 232 144 14 177 31 2 71 217 240 6 31 162 74 218 132 162 95 67 61 36 210 70 20 22 41 215 80 253 136 26 129 196 86 152 117 33 55 116 50 212 95 148 139 157 232 162 15 209 219 29 142 74 59 93 92 67 206 205 225 185 95 190 248 56 215 16 237 144 238 108 98 51 70 15 229 29 214 98 232 48 159 213 185 175 203 156 127 57 45 244 250 114 154 244 136 237 11 3 92 217 190 44 204 26 224 168 85 144 216 198 10 219 151 5 212 35 28 181 214 127 52 196 199 189 28 73 45 212 94 100 40 168 77 192 170 114 125 63 20 204 186 215 234 245 237 108 233 64 16 93 25 58 112 139 203 80 157 219 221 204 15 119 124 27 53 4 29 184 116 102 168 206 101 116 230 185 39 166 16 21 58 112 207 192 25 186 114 255 144 121 238 12 36 0 159 36 5 105 7 46 212 225 250 194 51 87 193 24 26 233 84 114 190 71 111 166 69 70 129 235 105 246 185 224 210 157 184 165 176 50 124 33 123 1 65 175 223 225 196 26 222 208 185 220 158 215 159 128 126 51 189 255 150 130 134 73 1 224 205 75 176 25 245 194 5 240 43 82 119 220 160 111 254 15).! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:24'!macAsyncFilePrimsFile	^ '/*  Experimental support for asynchronous file reading and writing.  When a read or write operation is initiated, control is returned to Squeak  immediately. A semaphore is signaled when the operation completes, at which  time the client can find out how many bytes were actually read or written  and copy the results of the read operation from the file buffer into a Squeak  buffer. Only one operation may be in progress on a given file at a given time,  but operations on different files may be done in parallel.  The semaphore is signalled once for each transfer operation that is successfully  started, even if that operation later fails. Write operations always write  their entire buffer if they succeed, but read operations may transfer less than  their buffer size if they are started less than a buffer''s size from the end  of the file.    The state of a file is kept in the following structure, which is stored directly  in a Squeak ByteArray object:    typedef struct {	  int				sessionID;	  AsyncFileState	*state;    } AsyncFile;  The session ID is used to detect stale files--files that were open  when the image was saved. The state pointer of such files is meaningless.  Async file handles use the same session ID as ordinary file handles.  Note: These primitives are experimental!! They need not be implemented on  every platform, and they may be withdrawn or replaced in a future release.*/#include <Errors.h>#include <Files.h>#include <Strings.h>#include "sq.h"/* Async file handle (defined in header file):*/typedef struct {	ParamBlockRec pb;  /* must be first */	long	refNum;	int		writable;	int		semaIndex;	int		status;	int		bytesTransferred;	int		bufferSize;	char 	*bufferPtr;} AsyncFileState;/*** Status Values ***/#define IDLE			0#define LAST_OP_FAILED	1#define BUSY			2/*** Imported Variables ***/extern int successFlag;extern int thisSession;/*** Local Vaiables ***/IOCompletionUPP asyncFileCompletionProc = nil;/*** Exported Functions ***/int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);/*** Local Functions ***/int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount);int asyncFileCompletionRoutine(AsyncFileState *state);int asyncFileInitPB(AsyncFileState *state, int fPosition);int asyncFileValid(AsyncFile *f);int asyncFileAllocateBuffer(AsyncFileState *state, int byteCount) {  /* Allocate a new buffer of the given size if necessary. If the current buffer	 is already allocated and of the desired size, do nothing. */	if ((state->bufferPtr !!= nil) && (state->bufferSize == byteCount)) {		return;  /* buffer is already allocated and of the desired size */	}	/* free old buffer, if any */	if (state->bufferPtr !!= nil) {		DisposePtr(state->bufferPtr);		state->bufferSize = 0;		state->bufferPtr = nil;	}	/* allocate new buffer */	state->bufferPtr = NewPtr(byteCount);	if (state->bufferPtr == nil) {		state->bufferSize = 0;		return success(false);  /* could not allocate a buffer of size count */	}	state->bufferSize = byteCount;}int asyncFileCompletionRoutine(AsyncFileState *state) {  /* Called when an I/O request completes. Decides what to do based on the given state.	 Note that the first part of the state record is the I/O parameter block. */	OSErr err;	err = state->pb.ioParam.ioResult;	if ((err !!= noErr) && (err !!= eofErr)) {		/* Note: eofErr indicates that fewer than the count bytes were transfered when		   reading because the end-of-file was encountered first; it isn''t a real error. */		state->status = LAST_OP_FAILED;		state->bytesTransferred = 0;		signalSemaphoreWithIndex(state->semaIndex);		return;	}	state->bytesTransferred = state->pb.ioParam.ioActCount;	state->status = IDLE;	signalSemaphoreWithIndex(state->semaIndex);}int asyncFileInitPB(AsyncFileState *state, int fPosition) {	memset(&state->pb, 0, sizeof(ParamBlockRec));	state->pb.ioParam.ioCompletion = asyncFileCompletionProc;	state->pb.ioParam.ioRefNum = state->refNum;	state->pb.ioParam.ioBuffer = state->bufferPtr;	state->pb.ioParam.ioReqCount = state->bufferSize;	state->pb.ioParam.ioPosMode = fsFromStart;	state->pb.ioParam.ioPosOffset = (fPosition < 0) ? 0 : fPosition;	state->status = BUSY;	state->bytesTransferred = 0;}int asyncFileValid(AsyncFile *f) {	return (		(f !!= NULL) &&		(f->sessionID == thisSession) &&		(f->state !!= NULL) &&		(((AsyncFileState *) f->state)->refNum !!= 0));}/*** Exported Functions ***/int asyncFileClose(AsyncFile *f) {  /* Close the given asynchronous file. */	AsyncFileState *state;	short int volRefNum;	OSErr err;	if (!!asyncFileValid(f)) return;  /* already closed */	state = f->state;	err = GetVRefNum(state->refNum, &volRefNum);	success(err == noErr);	err = FSClose(state->refNum);	success(err == noErr);	if (successFlag) err = FlushVol(NULL, volRefNum);	success(err == noErr);	if (state->bufferPtr !!= nil) DisposePtr(state->bufferPtr);	DisposePtr((void *) f->state);	f->state = nil;	f->sessionID = 0;}int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex) {  /* Opens the given file using the supplied AsyncFile structure to record	 its state. Fails with no side effects if f is already open. Files are	 always opened in binary mode. */	int i;	char cFileName[256];	unsigned char *pFileName;	short int fileRefNum;	ParamBlockRec pb;	AsyncFileState *state;	OSErr err;	/* don''t open an already open file */	if (asyncFileValid(f)) return success(false);	/* build complete routine descriptor, if necessary */	if (asyncFileCompletionProc == nil) {		asyncFileCompletionProc = NewIOCompletionProc(asyncFileCompletionRoutine);	}	/* copy the file name into a null-terminated C string */	if (fileNameSize > 255) return success(false);	for (i = 0; i < fileNameSize; i++) {		cFileName[i] = *((char *) (fileNamePtr + i));	}	cFileName[fileNameSize] = 0;	pFileName = c2pstr(cFileName);	f->sessionID = 0;	if (writeFlag) {		/* first try to open an existing file read/write: */		err = FSOpen(pFileName, 0, &fileRefNum);		if (err !!= noErr) {			/* file does not exist; must create it. */			err = Create(pFileName, 0, ''TEXT'', ''R*ch'');			if (err !!= noErr) return success(false);			err = FSOpen(pFileName, 0, &fileRefNum);			if (err !!= noErr) return success(false);		}	} else {		/* open the file read-only (use parameter block call to specify read-only): */		memset(&pb, 0, sizeof(ParamBlockRec));		pb.ioParam.ioNamePtr = pFileName;		pb.ioParam.ioPermssn = fsRdPerm;		err = PBOpenSync(&pb);		if (err !!= noErr) return success(false);		fileRefNum = pb.ioParam.ioRefNum;	}	f->state = (AsyncFileState *) NewPtr(sizeof(AsyncFileState));	/* allocate state record */	if (f->state == nil) {		FSClose(fileRefNum);		return success(false);	}	f->sessionID = thisSession;	state = (AsyncFileState *) f->state;	state->refNum = fileRefNum;	state->writable = writeFlag;	state->semaIndex = semaIndex;	state->status = IDLE;	state->bytesTransferred = 0;	state->bufferSize = 0;	state->bufferPtr = nil;}int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize) {  /* Copy up to bufferSize bytes from the buffer of the last read operation	 into the given Squeak buffer, and return the number of bytes copied.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed	Note that a read operation may read fewer bytes than requested if, for	example, there are fewer than the requested number of bytes between the	starting file position of the read operation and the end-of-file. */	AsyncFileState *state;	int bytesRead;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	/* copy the file buffer into the squeak buffer */	bytesRead = (bufferSize < state->bytesTransferred) ? bufferSize : state->bytesTransferred;	memcpy((char *) bufferPtr, state->bufferPtr, bytesRead);	return bytesRead;}int asyncFileReadStart(AsyncFile *f, int fPosition, int count) {  /* Start an asynchronous operation to read count bytes from the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileReadResult() to	 find out if the operation succeeded and to get the data that was read. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, count);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	asyncFileInitPB(state, fPosition);	err = PBReadAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}int asyncFileRecordSize() {	return sizeof(AsyncFile);}int asyncFileWriteResult(AsyncFile *f) {  /* Return the number of bytes copied by the last write operation.	 Negative values indicate:		-1    -- busy; the last operation has not finished yet		-2    -- error; the last operation failed */	AsyncFileState *state;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return -1;	if (state->status == LAST_OP_FAILED) return -2;	return state->bytesTransferred;}int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize) {  /* Start an asynchronous operation to write bufferSize bytes to the given file	 starting at the given file position. The file''s semaphore will be signalled when	 the operation is complete. The client may then use asyncFileWriteResult() to	 find out if the operation succeeded and how many bytes were actually written. */	AsyncFileState *state;	OSErr err;	if (!!asyncFileValid(f)) return success(false);	state = f->state;	if (state->status == BUSY) return success(false);  /* operation in progress */	if (!!state->writable) return success(false);	/* allocate a new buffer if necessary */	asyncFileAllocateBuffer(state, bufferSize);	if (state->bufferPtr == nil) return success(false);  /* could not allocate buffer */	/* copy the squeak buffer into the file buffer */	memcpy(state->bufferPtr, (char *) bufferPtr, bufferSize);	asyncFileInitPB(state, fPosition);	err = PBWriteAsync(&state->pb);	if (err !!= noErr) {		state->status = IDLE;		return success(false);	}}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/23/1998 00:06'!macMinimal	^ '/* sqMacMinimal.c	This file includes the minimal support code to build a Macintosh virtual machine.	Many primitives are "stubbed-out", meaning that if they are invoked from the	image they will return a "primitive failed" error. Among the stubbed out primitives	are those that support sound input and output, serial and MIDI ports, networking,	joystick, and file directory operations. The basic file read/write operations are	NOT stubbed out, although they could be as long as the image loading mechanism	still works. In this case, you''ll need to modify the method "openSourceFiles"	in the image to skip opening the changes and sources files at startup time.	The purpose of this file is to provide an implementation roadmap when bootstrapping	Squeak on a new platform. Once all the non-stubbed-out functions in this file have	been implemented, you will have a working, usable Squeak virtual machine!!*** Implementation Notes ***  I/O Functions	The following are essential for display and user interaction:		ioScreenSize()		ioShowDisplay()		ioGetButtonState()		ioGetKeystroke()		ioMousePoint()		ioPeekKeystroke()	The following can be made no-ops:		ioProcessEvents() 	-- poll for input events on some platforms		ioSetCursor()		-- install a 16x16 black and white hardware cursor		ioSetCursorWithMask() -- install a masked cursor		ioBeep()			-- make a short beep through the speaker		ioExit()			-- exit the VM: quit the application, reboot, power down, or							-- some other behavior appropriate to this platform							-- (if this is a noop you won''t be able to quit from Squeak)		ioRelinquishProcessorForMicroseconds()							-- called when Squeak is idle to return time to the OS  File Naming	The virtual machine keeps track of the full path name of the Squeak image	file and the path to the directory containing the virtual machine. In this	minimal implementation, the VM path is the empty string and the image name is	hardwired to "squeak.image". It is assumed that the image file, the changes	file, the Squeak application, and the system sources file are all in the	the same directory, and that that directory is the default working directory	for file operations. The "shortImageName" is used to display the image file	name (but not its full path) in the title bar of the Macintosh window.  Time Functions		ioMSecs(), ioMicroMSecs()							-- both return a millisecond clock value, but historically							-- ioMicroMSecs() used a higher resolution timer; the							-- ideal implementation is an inexpensive clock with 1							-- millisecond accuracy, but both functions can use a							-- clock with much coarser accuracy (e.g., 50-100 mSecs)							-- if necessary		ioSeconds()			-- return the number of seconds since Jan 1, 1901	   						-- may return 0, but then the current date and time	   						-- will be wrong*** Linking ***	To build a Macintosh VM using this file, link together:		interp.c		-- automatically generated interpreter file		sqFilePrims.c	-- file primitives (can be stubbed out)		sqMacMinimal.c	-- this file		sqMiscPrims.c	-- automatically generated primitives (optional)	plus the appropriate support libraries. To build a PowerPC	virtual machine using CodeWarrior 8, these are:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		MathLib		MWCRuntime.Lib*/#include <MacHeaders.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include "sq.h"#define STUBBED_OUT { success(false); }/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;MenuHandle		editMenu = nil;MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	success(false);  /* stubbed out */}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* Process Macintosh events, checking for the interrupt key. Return	   true if the interrupt key was pressed. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top) - 20;		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 20, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support ***/int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	return 0;}int clipboardSize(void) {	return 0;}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	return 0;}/*** Directory ***/int dir_Delimitor(void) {	return '':'';}/*** System Attributes ***/char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return "";	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 680xx";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Directory Stubs ***/int dir_Create(char *pathString, int pathStringLength)						STUBBED_OUTint dir_Lookup(char *pathString, int pathStringLength, int index,  char *name, int *nameLength, int *creationDate, int *modificationDate,  int *isDirectory, int *sizeIfFile)										STUBBED_OUTdir_SetMacFileTypeAndCreator(char *filename, int filenameSize,  char *fType, char *fCreator)												{/* noop */}/*** Joystick Stubs ***/int joystickRead(int stickIndex)											STUBBED_OUT/*** MIDI Stubs ***/int sqMIDIClosePort(int portNum)											STUBBED_OUTint sqMIDIGetClock(void)													STUBBED_OUTint sqMIDIGetPortCount(void)												STUBBED_OUTint sqMIDIGetPortDirectionality(int portNum)								STUBBED_OUTint sqMIDIGetPortName(int portNum, int namePtr, int length)					STUBBED_OUTint sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate)	STUBBED_OUTint sqMIDIParameter(int whichParameter, int modify, int newValue)			STUBBED_OUTint sqMIDIPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time)	STUBBED_OUT/*** Networking Stubs ***/int sqNetworkInit(int resolverSemaIndex)									STUBBED_OUTvoid sqNetworkShutdown(void)												STUBBED_OUTvoid sqResolverAbort(void)													STUBBED_OUTvoid sqResolverAddrLookupResult(char *nameForAddress, int nameSize)			STUBBED_OUTint sqResolverAddrLookupResultSize(void)									STUBBED_OUTint sqResolverError(void)													STUBBED_OUTint sqResolverLocalAddress(void)											STUBBED_OUTint sqResolverNameLookupResult(void)										STUBBED_OUTvoid sqResolverStartAddrLookup(int address)									STUBBED_OUTvoid sqResolverStartNameLookup(char *hostName, int nameSize)				STUBBED_OUTint sqResolverStatus(void)													STUBBED_OUTvoid sqSocketAbortConnection(SocketPtr s)									STUBBED_OUTvoid sqSocketCloseConnection(SocketPtr s)									STUBBED_OUTint sqSocketConnectionStatus(SocketPtr s)									STUBBED_OUTvoid sqSocketConnectToPort(SocketPtr s, int addr, int port)					STUBBED_OUTvoid sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(  SocketPtr s, int netType, int socketType,  int recvBufSize, int sendBufSize, int semaIndex)							STUBBED_OUTvoid sqSocketDestroy(SocketPtr s)											STUBBED_OUTint sqSocketError(SocketPtr s)												STUBBED_OUTvoid sqSocketListenOnPort(SocketPtr s, int port)							STUBBED_OUTint sqSocketLocalAddress(SocketPtr s)										STUBBED_OUTint sqSocketLocalPort(SocketPtr s)											STUBBED_OUTint sqSocketReceiveDataAvailable(SocketPtr s)								STUBBED_OUTint sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize)			STUBBED_OUTint sqSocketRemoteAddress(SocketPtr s)										STUBBED_OUTint sqSocketRemotePort(SocketPtr s)											STUBBED_OUTint sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize)				STUBBED_OUTint sqSocketSendDone(SocketPtr s)											STUBBED_OUT/*** Profiling Stubs ***/int clearProfile(void)														STUBBED_OUTint dumpProfile(void)														STUBBED_OUTint startProfiling(void)													STUBBED_OUTint stopProfiling(void)														STUBBED_OUT/*** Serial Port Functions Stubs ***/int serialPortClose(int portNum)											STUBBED_OUTint serialPortOpen(  int portNum, int baudRate, int stopBitsType,  int parityType, int dataBits, int inFlowCtrl, int outFlowCtrl,  int xOnChar, int xOffChar)												STUBBED_OUTint serialPortReadInto(int portNum, int count, int bufferPtr)				STUBBED_OUTint serialPortWriteFrom(int portNum, int count, int bufferPtr)				STUBBED_OUT/*** Sound Output Stubs ***/int snd_AvailableSpace(void)												STUBBED_OUTint snd_PlaySamplesFromAtLength(  int frameCount, int arrayIndex, int startIndex)							STUBBED_OUTint snd_InsertSamplesFromLeadTime(  int frameCount, int srcBufPtr, int samplesOfLeadTime)						STUBBED_OUTint snd_PlaySilence(void)													STUBBED_OUTint snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_Stop(void)															STUBBED_OUT/*** Sound Input Stubs ***/int snd_SetRecordLevel(int level)											STUBBED_OUTint snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex)	STUBBED_OUTint snd_StopRecording(void)													STUBBED_OUTdouble snd_GetRecordingSampleRate(void)										STUBBED_OUTint snd_RecordSamplesIntoAtLength(  int buf, int startSliceIndex, int bufferSizeInBytes)						STUBBED_OUT/*** Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void)			STUBBED_OUTint primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)	STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUTint primReverbSoundapplyReverbTostartingAtcount(void)						STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void)		STUBBED_OUT/*** Old Sound Synthesis Primitives Stubs ***/int primFMSoundmixSampleCountintostartingAtpan(void)						STUBBED_OUTint primPluckedSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primSampledSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUTint primWaveTableSoundmixSampleCountintostartingAtpan(void)					STUBBED_OUT/*** Experimental Asynchronous File I/O ***/int asyncFileClose(AsyncFile *f)											STUBBED_OUTint asyncFileOpen(  AsyncFile *f, int fileNamePtr, int fileNameSize,  int writeFlag, int semaIndex)												STUBBED_OUTint asyncFileRecordSize()													STUBBED_OUTint asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize)		STUBBED_OUTint asyncFileReadStart(AsyncFile *f, int fPosition, int count)				STUBBED_OUTint asyncFileWriteResult(AsyncFile *f)										STUBBED_OUTint asyncFileWriteStart(  AsyncFile *f, int fPosition, int bufferPtr, int bufferSize)				STUBBED_OUT/*** Main ***/void main(void) {	sqImageFile f;	int reservedMemory, availableMemory;	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	InitMacintosh();	SetUpMenus();	SetUpWindow();	SetUpPixmap();	sqFileInit();	imageName[0] = shortImageName[0] = vmPath[0] = 0;	strcpy(imageName, "squeak.image");	strcpy(shortImageName, "squeak.image");	/* compute the desired memory allocation */	reservedMemory = 150000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following to open the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("In this minimal VM, the image file must be named ''squeak.image''\n");		printf("and must be in the same directory as the Squeak application.\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:12'!macSerialAndMIDIPortFile	^ '#include <CommResources.h>#include <CRMSerialDevices.h>#include <Devices.h>#include <Serial.h>#include <Strings.h>#include "sq.h"/*** Constants ***/#define INPUT_BUF_SIZE 1000/*** Imported Variables ***/extern int successFlag;/*** Local Variables ***/short inRefNum[4] = {0, 0, 0, 0};short outRefNum[4] = {0, 0, 0, 0};char inputBuffer[4][INPUT_BUF_SIZE];/*** Private Functions ***/int portCount(void);int portIsOpen(int portNum);int portNames(int portNum, char *portName, char *inName, char *outName);int setHandshakeOptions(int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int setMidiClockRate(int portNum, int interfaceClockRate);int portCount(void) {  /* Return the number of serial ports available on this machine */ 	CRMRec		commRec; 	CRMRecPtr	thisRecPtr; 	int			count = 0; 	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } 	return count; }int portIsOpen(int portNum) {	if ((portNum < 0) || (portNum > 1)) return false;	return outRefNum[portNum] !!= 0;}int portNames(int portNum, char *portName, char *inName, char *outName) {/* Fill in the user name and input and output port names for the given   port number. Note that ports are numbered starting with zero. */ 	CRMRec			commRec; 	CRMRecPtr		thisRecPtr; 	CRMSerialPtr	serialPtr; 	int				count = 0;  	portName[0] = inName[0] = outName[0] = 0;	InitCRM(); 	commRec.crmDeviceType = crmSerialDevice; 	commRec.crmDeviceID = 0;	thisRecPtr = (CRMRecPtr) CRMSearch(&commRec); 	while (thisRecPtr !!= nil) { 		if (count == portNum) {			serialPtr = (CRMSerialPtr) thisRecPtr->crmAttributes;			strcpy(portName, p2cstr(*(serialPtr->name)));			strcpy(inName, p2cstr(*(serialPtr->inputDriverName)));			strcpy(outName, p2cstr(*(serialPtr->outputDriverName)));			c2pstr((void *) *(serialPtr->name));			c2pstr((void *) *(serialPtr->inputDriverName));			c2pstr((void *) *(serialPtr->outputDriverName)); 		} 		count++;		commRec.crmDeviceID = thisRecPtr->crmDeviceID;		thisRecPtr = (CRMRecPtr) CRMSearch(&commRec);    } }int setHandshakeOptions(  int portNum, int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Set the given port''s handshaking parameters. */	SerShk handshakeOptions;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	handshakeOptions.fInX = false;	handshakeOptions.fDTR = false;	if (inFlowCtrl == 1) handshakeOptions.fInX = true;  /* XOn/XOff handshaking */	if (inFlowCtrl == 2) handshakeOptions.fDTR = true;  /* hardware handshaking */	handshakeOptions.fXOn = false;	handshakeOptions.fCTS = false;	if (outFlowCtrl == 1) handshakeOptions.fXOn = true;  /* XOn/XOff handshaking */	if (outFlowCtrl == 2) handshakeOptions.fCTS = true;  /* hardware handshaking */	handshakeOptions.xOn  = xOnChar;	/* XOn character */	handshakeOptions.xOff = xOffChar;	/* XOff character */	handshakeOptions.errs = 0;			/* clear errors mask bits */	handshakeOptions.evts = 0;			/* clear event enable mask bits */	osErr = Control(outRefNum[portNum], 14, &handshakeOptions);	if (osErr !!= noErr) {		success(false);	}}int setMidiClockRate(int portNum, int interfaceClockRate) {/* Put the given port into MIDI mode, which uses a clock supplied   by an external MIDI interface adaptor to determine the baud rate.   Possible external clock rates: 31.25 KHz, 0.5 MHz, 1 MHz, or 2 MHz. */	char midiParam = 15;  /* dummy value */	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	if (interfaceClockRate ==   31250) midiParam = 0x00;	if (interfaceClockRate ==  500000) midiParam = 0x40;	if (interfaceClockRate == 1000000) midiParam = 0x80;	if (interfaceClockRate == 2000000) midiParam = 0xC0;	if (midiParam == 15) {		return success(false);  /* bad interfaceClockRate */	}	osErr = Control(outRefNum[portNum], 15, &midiParam);	if (osErr !!= noErr) {		return success(false);	}}/*** Serial Port Functions ***/int serialPortClose(int portNum) {	int osErr;	if ((portNum < 0) || (portNum > 1)) {		return success(false); /* bad port number */	}	if (!!portIsOpen(portNum)) {		return;  /* already closed */	}	osErr = KillIO(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(inRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	osErr = CloseDriver(outRefNum[portNum]);	if (osErr !!= noErr) {		success(false);	}	inRefNum[portNum] = 0;	outRefNum[portNum] = 0;}int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar) {/* Open the given serial port using the given settings. The baud rate can be   any number between about 224 and 57600; the driver will pick a clock   divisor that will generate the closest available baud rate. */	short int options, baudRateParam;	char userName[256], inName[256], outName[256];	int osErr;	if ((portNum < 0) || (portNum > 1) || portIsOpen(portNum)) {		return success(false); /* bad port number or port already open */	}	options = baud9600;	switch (stopBitsType) {	case 0:		options += stop15;		break;	case 1:		options += stop10;		break;	case 2:		options += stop20;		break;	default:		return success(false);	}	switch (parityType) {	case 0:		options += noParity;		break;	case 1:		options += oddParity;		break;	case 2:		options += evenParity;		break;	default:		return success(false);	}	switch (dataBits) {	case 5:		options += data5;		break;	case 6:		options += data6;		break;	case 7:		options += data7;		break;	case 8:		options += data8;		break;	default:		return success(false);	}	portNames(portNum, userName, inName, outName);	osErr = OpenDriver(c2pstr(outName), &outRefNum[portNum]);	if (osErr !!= noErr) {		return success(false);	}	osErr = OpenDriver(c2pstr(inName), &inRefNum[portNum]);	if (osErr !!= noErr) {		CloseDriver(outRefNum[portNum]);		return success(false);	}	/* set the handshaking options */	setHandshakeOptions(portNum, inFlowCtrl, outFlowCtrl, xOnChar, xOffChar);	/* install a larger input buffer */	osErr = SerSetBuf(inRefNum[portNum], &inputBuffer[portNum][0], INPUT_BUF_SIZE);	if (osErr !!= noErr) {		success(false);	}	/* set data bits, parity type, and stop bits */	osErr = SerReset(outRefNum[portNum], options);	if (osErr !!= noErr) {		success(false);	}	/* set the baud rate (e.g., the value 9600 gives 9600 baud) */	baudRateParam = baudRate;	osErr = Control(outRefNum[portNum], 13, &baudRateParam);	if (osErr !!= noErr) {		success(false);	}	if (!!successFlag) {		CloseDriver(inRefNum[portNum]);		CloseDriver(outRefNum[portNum]);		inRefNum[portNum] = 0;		outRefNum[portNum] = 0;	}}int serialPortReadInto(int portNum, int count, int bufferPtr) {/* Read up to count bytes from the given serial port into the given byte array.   Read only up to the number of bytes in the port''s input buffer; if fewer bytes   than count have been received, do not wait for additional data to arrive.   Return zero if no data is available. */	long int byteCount;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = SerGetBuf(inRefNum[portNum], &byteCount);  /* bytes available */	if (osErr !!= noErr) {		return success(false);	}	if (byteCount > count) byteCount = count;  /* read at most count bytes */	osErr = FSRead(inRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}int serialPortWriteFrom(int portNum, int count, int bufferPtr) {/* Write count bytes from the given byte array to the given serial port''s   output buffer. Return the number of bytes written. This implementation is   synchronous: it doesn''t return until the data has been sent. However, other   implementations may return before transmission is complete. */	long int byteCount = count;	int osErr;	if (!!portIsOpen(portNum)) {		return success(false);	}	osErr = FSWrite(outRefNum[portNum], &byteCount, (char *) bufferPtr);	if (osErr !!= noErr) {		return success(false);	}	return byteCount;}/*** MIDI Parameters (used with sqMIDIParameter function) ***/#define sqMIDIInstalled				1/* Read-only. Return 1 if a MIDI driver is installed, 0 if not.   On OMS-based MIDI drivers, this returns 1 only if the OMS   system is properly installed and configured. */#define sqMIDIVersion				2/* Read-only. Return the integer version number of this MIDI driver.   The version numbering sequence is relative to a particular driver.   That is, version 3 of the Macintosh MIDI driver is not necessarily   related to version 3 of the Win95 MIDI driver. */#define sqMIDIHasBuffer				3/* Read-only. Return 1 if this MIDI driver has a time-stamped output   buffer, 0 otherwise. Such a buffer allows the client to schedule   MIDI output packets to be sent later. This can allow more precise   timing, since the driver uses timer interrupts to send the data   at the right time even if the processor is in the midst of a   long-running Squeak primitive or is running some other application   or system task. */#define sqMIDIHasDurs				4/* Read-only. Return 1 if this MIDI driver supports an extended   primitive for note-playing that includes the note duration and   schedules both the note-on and the note-off messages in the   driver. Otherwise, return 0. */#define sqMIDICanSetClock			5/* Read-only. Return 1 if this MIDI drivers clock can be set   via an extended primitive, 0 if not. */#define sqMIDICanUseSemaphore		6/* Read-only. Return 1 if this MIDI driver can signal a semaphore   when MIDI input arrives. Otherwise, return 0. If this driver   supports controller caching and it is enabled, then incoming   controller messages will not signal the semaphore. */#define sqMIDIEchoOn				7/* Read-write. If this flag is set to a non-zero value, and if   the driver supports echoing, then incoming MIDI events will   be echoed immediately. If this driver does not support echoing,   then queries of this parameter will always return 0 and   attempts to change its value will do nothing. */#define sqMIDIUseControllerCache	8/* Read-write. If this flag is set to a non-zero value, and if   the driver supports a controller cache, then the driver will   maintain a cache of the latest value seen for each MIDI controller,   and control update messages will be filtered out of the incoming   MIDI stream. An extended MIDI primitive allows the client to   poll the driver for the current value of each controller. If   this driver does not support a controller cache, then queries   of this parameter will always return 0 and attempts to change   its value will do nothing. */#define sqMIDIEventsAvailable		9/* Read-only. Return the number of MIDI packets in the input queue. */#define sqMIDIFlushDriver			10/* Write-only. Setting this parameter to any value forces the driver   to flush its I/0 buffer, discarding all unprocessed data. Reading   this parameter returns 0. Setting this parameter will do nothing   if the driver does not support buffer flushing. */#define sqMIDIClockTicksPerSec		11/* Read-only. Return the MIDI clock rate in ticks per second. */#define sqMIDIHasInputClock			12/* Read-only. Return 1 if this MIDI driver timestamps incoming   MIDI data with the current value of the MIDI clock, 0 otherwise.   If the driver does not support such timestamping, then the   client must read input data frequently and provide its own   timestamping. *//*** MIDI Functions ***/int sqMIDIClosePort(int portNum) {/* Close the given MIDI port. Do nothing if the port is not open.   Fail if there is no port of the given number.*/	return serialPortClose(portNum);}int sqMIDIGetClock(void) {/* Return the current value of the clock used to schedule MIDI events.   The MIDI clock is assumed to wrap at or before half the maximum   positive SmallInteger value. This allows events to be scheduled   into the future without overflowing into LargePositiveIntegers.    This implementation does not support event scheduling, so it   just returns the value of the Squeak millisecond clock. */	return ioMicroMSecs();}int sqMIDIGetPortCount(void) {/* Return the number of available MIDI interfaces, including both   hardware ports and software entities that act like ports. Ports   are numbered from 0 to N-1, where N is the number returned by this   primitive. */	return portCount();}int sqMIDIGetPortDirectionality(int portNum) {/* Return an integer indicating the directionality of the given   port where: 1 = input, 2 = output, 3 = bidirectional. Fail if   there is no port of the given number. */	success((portNum == 0) || (portNum == 1));	return 3;}int sqMIDIGetPortName(int portNum, int namePtr, int length) {/* Copy the name of the given MIDI port into the string at the given   address. Copy at most length characters, and return the number of   characters copied. Fail if there is no port of the given number.*/	char userName[256], inName[256], outName[256];	int count;	if ((portNum > 4) || (portNum >= portCount())) {		return success(false);	}	portNames(portNum, userName, inName, outName);	count = strlen(userName);	success(count > 0);	if (count > length) count = length;	memcpy((void *) namePtr, userName, count);	return count;}int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate) {/* Open the given port, if possible. If non-zero, readSemaphoreIndex   specifies the index in the external objects array of a semaphore   to be signalled when incoming MIDI data is available. Note that   not all implementations support read semaphores (this one does   not); see sqMIDICanUseSemaphore. The interfaceClockRate parameter   specifies the clock speed for an external MIDI interface   adaptor on platforms that use such adaptors (e.g., Macintosh).   Fail if there is no port of the given number.*/	serialPortOpen(portNum, 9600, 1, 0, 8, 0, 0, 0, 0);	if (successFlag) {		setMidiClockRate(portNum, interfaceClockRate);		if (!!successFlag) {			serialPortClose(portNum);		}	}}int sqMIDIParameter(int whichParameter, int modify, int newValue) {/* Read or write the given MIDI driver parameter. If modify is 0,   then newValue is ignored and the current value of the specified   parameter is returned. If modify is non-zero, then the specified   parameter is set to newValue. Note that many MIDI driver parameters   are read-only; attempting to set one of these parameters fails.   For boolean parameters, true = 1, false = 0. */	if (modify == 0) {		switch(whichParameter) {		case sqMIDIInstalled:			return 1;			break;		case sqMIDIVersion:			return 100;			break;		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:		case sqMIDIEchoOn:		case sqMIDIUseControllerCache:			return 0;			break;		case sqMIDIEventsAvailable:			return 1;  /* pretend that events are always available */			break;		case sqMIDIFlushDriver:			return 0;			break;		case sqMIDIClockTicksPerSec:			return 1000;			break;		case sqMIDIHasInputClock:			return 0;			break;		default:			return success(false);		}	} else {		switch(whichParameter) {		case sqMIDIInstalled:		case sqMIDIVersion:		case sqMIDIHasBuffer:		case sqMIDIHasDurs:		case sqMIDICanSetClock:		case sqMIDICanUseSemaphore:			return success(false);			break;		case sqMIDIEchoOn:			/* noop; echoing not supported */			break;		case sqMIDIUseControllerCache:			/* noop; controller cache not supported */			break;		case sqMIDIEventsAvailable:			return success(false);			break;		case sqMIDIFlushDriver:			/* noop; buffer flushing not supported */			break;		case sqMIDIClockTicksPerSec:			return success(false);			break;		default:			return success(false);		}	}}int sqMIDIPortReadInto(int portNum, int count, int bufferPtr) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Copy up to (length - 4) bytes   of incoming MIDI data into that buffer, preceded by a 4-byte   timestamp in the units of the MIDI clock, most significant byte   first. Implementations that do not support timestamping of   incoming data as it arrives (see sqMIDIHasInputClock) simply   set the timestamp to the value of the MIDI clock when this   function is called. Return the total number of bytes read,   including the timestamp bytes. Return zero if no data is   available. Fail if the buffer is shorter than five bytes,   since there must be enough room for the timestamp plus at   least one data byte. */	int bytesRead;	if (count < 5) return success(false);	bytesRead = serialPortReadInto(portNum, count - 4, bufferPtr + 4);	if (bytesRead == 0) return 0;	*((int *) bufferPtr) = sqMIDIGetClock();  /* set timestamp */	return bytesRead + 4;}int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time) {/* bufferPtr is the address of the first byte of a Smalltalk   ByteArray of the given length. Send its contents to the given   port when the MIDI clock reaches the given time. If time equals   zero, then send the data immediately. Implementations that do   not support a timestamped output queue, such as this one, always   send the data immediately; see sqMIDIHasBuffer. */	return serialPortWriteFrom(portNum, count, bufferPtr);}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:31'!macSoundFile	^ '#include <Sound.h>#include <SoundInput.h>#include "sq.h"/******  Mac Sound Output Notes:	The Squeak sound code produces 16-bit, stereo sound buffers. The was	arrived at after experimentation on a PPC 601 at 110 MHz on which I	found that:	  a. using 16-bit sound only slightly increased the background CPU burden and	  b. 16-bit sound yielded vastly superior sound quality.	My understanding is that SoundManager 3.0 or later supports the 16-bit	sound interface an all Macs, even if the hardware only supports 8-bits.	If this is not true, however, change BYTES_PER_SAMPLE to 1. Then, either	the Squeak code will need to be changed to use 8-bit sound buffers,	or (preferrably) snd_PlaySamplesFromAtLength will need to do the conversion	from 16 to 8 bits. I plan to cross that bridge if and when we need to.	The code as currently written was to support Squeak code that generated	8-bit sound buffers.	In earlier versions, I experimented with other sound buffer formats. Here	are all the sound buffer formats that were used at one point or another:		1. mono,    8-bits -- packed array of bytes (not currently used)		2. stereo,  8-bits -- as above, with L and R channels in alternate bytes (not currently used)		3. stereo, 16-bits -- array of 32-bit words; with L and R channels in high and low half-words	Note:  8-bit samples are encoded with 0x80 as the center (zero) value	Note: 16-bit samples are encoded as standard, signed integers (i.e., 2''s-complement)	Note: When the sound drive is operating in "mono", the two stereo channels are mixed	      together. This feature was added in January, 1998.	-- John Maloney, July 28, 1996	-- edited: John Maloney, January 5, 1998  Mac Sound Input Notes:	Squeak sound input is currently defined to provide a single (mono) stream	of signed 16-bit samples for all platforms. Platforms that only support	8-bit sound input should convert samples to signed 16 bit values, leaving	the low order bits zero. Since the available sampling rates differ from	platform to platform, the client may not get the requested sampling rate;	however, the call snd_GetRecordingSampleRate returns the sampling rate.	On many platforms, simultaneous record and playback is permitted only if	the input and output sampling rates are the same.	-- John Maloney, Aug 22, 1997******/#define BYTES_PER_SAMPLE 2/*** double-buffer state record ***/typedef struct {	int open;	int stereo;	int frameCount;	int sampleRate;	int lastFlipTime;	int playSemaIndex;	int bufSizeInBytes;	int bufState0;	int bufState1;	int done;} PlayStateRec;/*** possible buffer states ***/#define BUF_EMPTY	0#define BUF_FULL	1#define BUF_PLAYING	2/*** record buffer state record ***//* Note: RECORD_BUFFER_SIZE should be a multiple of 4096 bytes to avoid clicking.   (The clicking was observed on a Mac 8100; the behavior of other Macs could differ.)   Note: G3 Series Powerbook requires minimum of 4 * 4096 buffer size for stereo.*/#define RECORD_BUFFER_SIZE (4096 * 4)typedef struct {	SPB paramBlock;	int stereo;	int bytesPerSample;	int recordSemaIndex;	int readIndex;  /* index of the next sample to read */	char samples[RECORD_BUFFER_SIZE];} RecordBufferRec, *RecordBuffer;/*** sound output variables ***/SndChannelPtr chan;PlayStateRec bufState = {false, false, 0, 0, NULL, NULL, true, 0};SndDoubleBufferHeader dblBufHeader;/*** sound input variables ***/RecordBufferRec recordBuffer1, recordBuffer2;int recordingInProgress;long soundInputRefNum;/*** local functions ***/pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf);int FillBufferWithSilence(SndDoubleBufferPtr buf);pascal void FlipRecordBuffers(SPBPtr pb);int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex);pascal void DoubleBack(SndChannelPtr chan, SndDoubleBufferPtr buf) {	PlayStateRec *state;	chan;  /* reference argument to avoid compiler warnings */	/* insert a click to help user detect failure to fill buffer in time */	*(unsigned int *) &buf->dbSoundData[0] = 0;	*(unsigned int *) &buf->dbSoundData[4] = 0xFFFFFFFF;	state = (PlayStateRec *) buf->dbUserInfo[0];	if (buf->dbUserInfo[1] == 0) {		state->bufState0 = BUF_EMPTY;		state->bufState1 = BUF_PLAYING;	} else {		state->bufState0 = BUF_PLAYING;		state->bufState1 = BUF_EMPTY;	}	buf->dbNumFrames = state->frameCount;	buf->dbFlags = buf->dbFlags | dbBufferReady;	if (state->done) {		FillBufferWithSilence(buf);		buf->dbFlags = buf->dbFlags | dbLastBuffer;	} else {		signalSemaphoreWithIndex(state->playSemaIndex);	}	state->lastFlipTime = ioMicroMSecs();}int FillBufferWithSilence(SndDoubleBufferPtr buf) {	unsigned int *sample, *lastSample;	sample		= (unsigned int *) &buf->dbSoundData[0];	lastSample	= (unsigned int *) &buf->dbSoundData[bufState.bufSizeInBytes];	/* word-fill buffer with silence */	if (BYTES_PER_SAMPLE == 1) {		while (sample < lastSample) {			*sample++ = 0x80808080;  /* Note: 0x80 is zero value for 8-bit samples */		}	} else {		while (sample < lastSample) {			*sample++ = 0;		}	}}pascal void FlipRecordBuffers(SPBPtr pb) {	/* called at interrupt time to exchange the active and inactive record buffers */	RecordBuffer thisBuffer = (RecordBuffer) pb;	RecordBuffer nextBuffer = (RecordBuffer) pb->userLong;	if (pb->error == 0) {		/* restart recording using the other buffer */		SPBRecord(&nextBuffer->paramBlock, true);		/* reset the read pointer for the buffer that has just been filled */		thisBuffer->readIndex = 0;		signalSemaphoreWithIndex(nextBuffer->recordSemaIndex);	}}/*** exported sound output functions ***/int snd_AvailableSpace(void) {	if (!!bufState.open) return -1;	if ((bufState.bufState0 == BUF_EMPTY) ||		(bufState.bufState1 == BUF_EMPTY)) {			return bufState.bufSizeInBytes;	}	return 0;}int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex) {	SndDoubleBufferPtr buf;	int framesWritten;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		buf = dblBufHeader.dbhBufferPtr[0];		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			buf = dblBufHeader.dbhBufferPtr[1];			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	if (bufState.frameCount < frameCount) {		framesWritten = bufState.frameCount;	} else {		framesWritten = frameCount;	}	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) (arrayIndex + startIndex);		end = (unsigned char *) src + (framesWritten * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) &buf->dbSoundData[0];		while (src < end) {			*dst++ = *src++;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (arrayIndex + (startIndex * 4));		end = (short int *) (arrayIndex + ((startIndex + framesWritten) * 4));		dst = (short int *) &buf->dbSoundData[0];		if (bufState.stereo) {  /* stereo */			while (src < end) {				*dst++ = *src++;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			while (src < end) {				*dst++ = (*src++ + *src++) / 2;			}		}	}	return framesWritten;}int MixInSamples(int count, char *srcBufPtr, int srcStartIndex, char *dstBufPtr, int dstStartIndex) {	int sample;	if (BYTES_PER_SAMPLE == 1) {  /* 8-bit samples */		unsigned char *src, *dst, *end;		src = (unsigned char *) srcBufPtr + srcStartIndex;		end = (unsigned char *) srcBufPtr + (count * (bufState.stereo ? 2 : 1));		dst = (unsigned char *) dstBufPtr + dstStartIndex;		while (src < end) {			sample = *dst + (*src++ - 128);			if (sample > 255) sample = 255;			if (sample < 0) sample = 0;			*dst++ = sample;		}	} else {  /* 16-bit samples */		short int *src, *dst, *end;		src = (short int *) (srcBufPtr + (srcStartIndex * 4));		end = (short int *) (srcBufPtr + ((srcStartIndex + count) * 4));		if (bufState.stereo) {  /* stereo */			dst = (short int *) (dstBufPtr + (dstStartIndex * 4));			while (src < end) {				sample = *dst + *src++;				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		} else {  /* mono */			/* if mono, average the left and right channels of the source */			dst = (short int *) (dstBufPtr + (dstStartIndex * 2));			while (src < end) {				sample = *dst + ((*src++ + *src++) / 2);				if (sample > 32767) sample = 32767;				if (sample < -32767) sample = -32767;				*dst++ = sample;			}		}	}}int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime) {	SndDoubleBufferPtr bufPlaying, otherBuf;	int samplesInserted, startSample, count;	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_PLAYING) {		bufPlaying = dblBufHeader.dbhBufferPtr[0];		otherBuf = dblBufHeader.dbhBufferPtr[1];	} else {		bufPlaying = dblBufHeader.dbhBufferPtr[1];		otherBuf = dblBufHeader.dbhBufferPtr[0];	}	samplesInserted = 0;	/* mix as many samples as can fit into the remainder of the currently playing buffer */	startSample =		((bufState.sampleRate * (ioMicroMSecs() - bufState.lastFlipTime)) / 1000) + samplesOfLeadTime;	if (startSample < bufState.frameCount) {		count = bufState.frameCount - startSample;		if (count > frameCount) count = frameCount;		MixInSamples(count, (char *) srcBufPtr, 0, (char *) &bufPlaying->dbSoundData[0], startSample);		samplesInserted = count;	}	/* mix remaining samples into the inactive buffer */	count = bufState.frameCount;	if (count > (frameCount - samplesInserted)) {		count = frameCount - samplesInserted;	}	MixInSamples(count, (char *) srcBufPtr, samplesInserted, (char *) &otherBuf->dbSoundData[0], 0);	return samplesInserted + count;}int snd_PlaySilence(void) {	if (!!bufState.open) return -1;	if (bufState.bufState0 == BUF_EMPTY) {		FillBufferWithSilence(dblBufHeader.dbhBufferPtr[0]);		bufState.bufState0 = BUF_FULL;	} else {		if (bufState.bufState1 == BUF_EMPTY) {			FillBufferWithSilence(dblBufHeader.dbhBufferPtr[1]);			bufState.bufState1 = BUF_FULL;		} else {			return 0;  /* neither buffer is available */		}	}	return bufState.bufSizeInBytes;}int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex) {	OSErr				err;	SndDoubleBufferPtr	buffer;	int					bytesPerFrame, bufferBytes, i;	bytesPerFrame			= stereo ? 2 * BYTES_PER_SAMPLE : BYTES_PER_SAMPLE;	bufferBytes				= ((frameCount * bytesPerFrame) / 8) * 8;		/* Note: Must round bufferBytes down to an 8-byte boundary to avoid clicking!!!!!! */	if (bufState.open) {		/* still open from last time; clean up before continuing */		snd_Stop();	}	bufState.open			= false;  /* set to true if successful */	bufState.stereo			= stereo;	bufState.frameCount		= bufferBytes / bytesPerFrame;	bufState.sampleRate		= samplesPerSec;	bufState.lastFlipTime	= ioMicroMSecs();	bufState.playSemaIndex	= semaIndex;	bufState.bufSizeInBytes	= bufferBytes;	bufState.bufState0		= BUF_EMPTY;	bufState.bufState1		= BUF_EMPTY;	bufState.done			= false;	dblBufHeader.dbhNumChannels		= stereo ? 2 : 1;	dblBufHeader.dbhSampleSize		= BYTES_PER_SAMPLE * 8;	dblBufHeader.dbhCompressionID	= 0;	dblBufHeader.dbhPacketSize		= 0;	dblBufHeader.dbhSampleRate		= samplesPerSec << 16; /* convert to fixed point */	dblBufHeader.dbhDoubleBack		= NewSndDoubleBackProc(DoubleBack);	chan = NULL;	err = SndNewChannel(&chan, sampledSynth, 0, NULL);	if (err !!= noErr) return false; /* could not open sound channel */	for (i = 0; i < 2; i++) {		buffer = (SndDoubleBufferPtr) NewPtrClear(sizeof(SndDoubleBuffer) + bufState.bufSizeInBytes);		if (buffer == NULL) return false; /* could not allocate memory for a buffer */		buffer->dbNumFrames		= bufState.frameCount;		buffer->dbFlags			= dbBufferReady;		buffer->dbUserInfo[0]	= (long) &bufState;		buffer->dbUserInfo[1]	= i;		FillBufferWithSilence(buffer);		dblBufHeader.dbhBufferPtr[i] = buffer;	}	err = SndPlayDoubleBuffer(chan, &dblBufHeader);	if (err !!= noErr) return false; /* could not play double buffer */	bufState.open = true;	return true;}int snd_Stop(void) {	OSErr				err;	SndDoubleBufferPtr	buffer;	SCStatus			status;	long				i, junk;	if (!!bufState.open) return;	bufState.open = false;	bufState.done = true;	while (true) {		err = SndChannelStatus(chan, sizeof(status), &status);		if (err !!= noErr) break; /* could not get channel status */		if (!!status.scChannelBusy) break;		Delay(1, &junk);	}	SndDisposeChannel(chan, true);	DisposeRoutineDescriptor(dblBufHeader.dbhDoubleBack);	for (i = 0; i < 2; i++) {		buffer = dblBufHeader.dbhBufferPtr[i];		if (buffer !!= NULL) {			DisposePtr((char *) buffer);		}		dblBufHeader.dbhBufferPtr[i] = NULL;	}	bufState.open = false;}/*** exported sound input functions ***/int snd_SetRecordLevel(int level) {	/* set the recording level to a value between 0 (minimum gain) and 1000. */	Fixed inputGainArg;	int err;	if (!!recordingInProgress || (level < 0) || (level > 1000)) {		success(false);		return;  /* noop if not recording */	}	inputGainArg = ((500 + level) << 16) / 1000;  /* gain is Fixed between 0.5 and 1.5 */	err = SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	/* don''t fail on error; hardware may not support setting the gain */}int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex) {	/* turn on sound recording, trying to use a sampling rate close to	   the one specified. semaIndex is the index in the exportedObject	   array of a semaphore to be signalled when input data is available. */	Str255 deviceName = "";	short automaticGainControlArg;	Fixed inputGainArg;	long  compressionTypeArg;	short continuousArg;	short sampleSizeArg;	short channelCountArg;	UnsignedFixed sampleRateArg;	int err;	err = SPBOpenDevice(deviceName, siWritePermission, &soundInputRefNum);	if (err !!= noErr) {		success(false);		return;	}	/* try to initialize some optional parameters, but don''t fail if we can''t */	automaticGainControlArg = false;	SPBSetDeviceInfo(soundInputRefNum, siAGCOnOff, &automaticGainControlArg);	inputGainArg = 1 << 16;  /* 1.0 in Fixed */	SPBSetDeviceInfo(soundInputRefNum, siInputGain, &inputGainArg);	compressionTypeArg = ''NONE'';	SPBSetDeviceInfo(soundInputRefNum, siCompressionType, &compressionTypeArg);	continuousArg = true;	err = SPBSetDeviceInfo(soundInputRefNum, siContinuous, &continuousArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	sampleSizeArg = 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);	if (err !!= noErr) {		/* use 8-bit samples */		sampleSizeArg = 8;		err = SPBSetDeviceInfo(soundInputRefNum, siSampleSize, &sampleSizeArg);		if (err !!= noErr) {			success(false);			SPBCloseDevice(soundInputRefNum);			return;		}	}	channelCountArg = stereo ? 2 : 1;	err = SPBSetDeviceInfo(soundInputRefNum, siNumberChannels, &channelCountArg);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	/* try to set the client''s desired sample rate */	sampleRateArg = desiredSamplesPerSec << 16;	err = SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		/* if client''s rate fails, try the nearest common sampling rates in {11025, 22050, 44100} */		if (desiredSamplesPerSec <= 16538) {			sampleRateArg = 11025 << 16;		} else {			if (desiredSamplesPerSec <= 33075) {				sampleRateArg = 22050 << 16;			} else {				sampleRateArg = 44100 << 16;			}		}		/* even if following fails, recording can go on at the default sample rate */		SPBSetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	}	recordBuffer1.paramBlock.inRefNum = soundInputRefNum;	recordBuffer1.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.milliseconds = 0;	recordBuffer1.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer1.paramBlock.bufferPtr = recordBuffer1.samples;	recordBuffer1.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer1.paramBlock.interruptRoutine = nil;	recordBuffer1.paramBlock.userLong = (long) &recordBuffer2;  /* pointer to other buffer */	recordBuffer1.paramBlock.error = noErr;	recordBuffer1.paramBlock.unused1 = 0;	recordBuffer1.stereo = stereo;	recordBuffer1.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer1.recordSemaIndex = semaIndex;	recordBuffer1.readIndex = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.inRefNum = soundInputRefNum;	recordBuffer2.paramBlock.count = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.milliseconds = 0;	recordBuffer2.paramBlock.bufferLength = RECORD_BUFFER_SIZE;	recordBuffer2.paramBlock.bufferPtr = recordBuffer2.samples;	recordBuffer2.paramBlock.completionRoutine = NewSICompletionProc(FlipRecordBuffers);	recordBuffer2.paramBlock.interruptRoutine = nil;	recordBuffer2.paramBlock.userLong = (long) &recordBuffer1;  /* pointer to other buffer */	recordBuffer2.paramBlock.error = noErr;	recordBuffer2.paramBlock.unused1 = 0;	recordBuffer2.stereo = stereo;	recordBuffer2.bytesPerSample = sampleSizeArg == 8 ? 1 : 2;	recordBuffer2.recordSemaIndex = semaIndex;	recordBuffer2.readIndex = RECORD_BUFFER_SIZE;	err = SPBRecord(&recordBuffer1.paramBlock, true);	if (err !!= noErr) {		success(false);		SPBCloseDevice(soundInputRefNum);		return;	}	recordingInProgress = true;}int snd_StopRecording(void) {	/* turn off sound recording */	int err;	if (!!recordingInProgress) return;  /* noop if not recording */	err = SPBStopRecording(soundInputRefNum);	if (err !!= noErr) success(false);	SPBCloseDevice(soundInputRefNum);	DisposeRoutineDescriptor(recordBuffer1.paramBlock.completionRoutine);	recordBuffer1.paramBlock.completionRoutine = nil;	DisposeRoutineDescriptor(recordBuffer2.paramBlock.completionRoutine);	recordBuffer2.paramBlock.completionRoutine = nil;	recordBuffer1.recordSemaIndex = 0;	recordBuffer2.recordSemaIndex = 0;	recordingInProgress = false;}double snd_GetRecordingSampleRate(void) {	/* return the actual recording rate; fail if not currently recording */	UnsignedFixed sampleRateArg;	int err;	if (!!recordingInProgress) {		success(false);		return 0.0;	}	err = SPBGetDeviceInfo(soundInputRefNum, siSampleRate, &sampleRateArg);	if (err !!= noErr) {		success(false);		return 0.0;	}	return  (double) ((sampleRateArg >> 16) & 0xFFFF) +			((double) (sampleRateArg & 0xFFFF) / 65536.0);}int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes) {	/* if data is available, copy as many sample slices as possible into the	   given buffer starting at the given slice index. do not write past the	   end of the buffer, which is buf + bufferSizeInBytes. return the number	   of slices (not bytes) copied. a slice is one 16-bit sample in mono	   or two 16-bit samples in stereo. */	int bytesPerSlice = (recordBuffer1.stereo ? 4 : 2);	char *nextBuf = (char *) buf + (startSliceIndex * bytesPerSlice);	char *bufEnd = (char *) buf + bufferSizeInBytes;	char *src, *srcEnd;	RecordBuffer recBuf = nil;	int bytesCopied;	if (!!recordingInProgress) {		success(false);		return 0;	}	/* select the buffer with unread samples, if any */	recBuf = nil;	if (recordBuffer1.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer1;	if (recordBuffer2.readIndex < RECORD_BUFFER_SIZE) recBuf = &recordBuffer2;	if (recBuf == nil) return 0;  /* no samples available */	/* copy samples into the client''s buffer */	src = &recBuf->samples[0] + recBuf->readIndex;	srcEnd = &recBuf->samples[RECORD_BUFFER_SIZE];	if (recBuf->bytesPerSample == 1) {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			/* convert 8-bit sample to 16-bit sample */			*nextBuf++ = (*src++) - 128;  /* convert from [0-255] to [-128-127] */			*nextBuf++ = 0;  /* low-order byte is zero */		}	} else {		while ((src < srcEnd) && (nextBuf < bufEnd)) {			*nextBuf++ = *src++;		}	}	recBuf->readIndex = src - &recBuf->samples[0];  /* update read index */	/* return the number of slices copied */	bytesCopied = (int) nextBuf - (buf + (startSliceIndex * bytesPerSlice));	return bytesCopied / bytesPerSlice;}'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 23:28'!macWindowFile	^ '#include <MacHeaders.h>#include <AppleEvents.h>#include <Dialogs.h>#include <Devices.h>#include <Files.h>#include <Fonts.h>#include <Gestalt.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <Power.h>#include <QuickDraw.h>#include <Scrap.h>#include <Strings.h>#include <Timer.h>#include <ToolUtils.h>#include <Windows.h>#include <profiler.h>#include "sq.h"/*** Compilation Options:**	define PLUGIN		to compile code for Netscape Plug-in*	define MAKE_PROFILE	to compile code for profiling****///#define PLUGIN//#define MAKE_PROFILE/*** Enumerations ***/enum { appleID = 1, fileID, editID };enum { quitItem = 1 };/*** Variables -- Imported from Virtual Machine ***/extern int fullScreenFlag;extern int interruptCheckCounter;extern int interruptKeycode;extern int interruptPending;  /* set to true by recordKeystroke if interrupt key is pressed */extern unsigned char *memory;extern int savedWindowSize;   /* set from header when image file is loaded *//*** Variables -- image and path names ***/#define IMAGE_NAME_SIZE 300char imageName[IMAGE_NAME_SIZE + 1];  /* full path to image */#define SHORTIMAGE_NAME_SIZE 100char shortImageName[SHORTIMAGE_NAME_SIZE + 1];  /* just the image file name */#define DOCUMENT_NAME_SIZE 300char documentName[DOCUMENT_NAME_SIZE + 1];  /* full path to document or image file */#define SHORTDOCUMENT_NAME_SIZE 100char shortDocumentName[SHORTDOCUMENT_NAME_SIZE + 1];  /* just the document file name */#define VMPATH_SIZE 300char vmPath[VMPATH_SIZE + 1];  /* full path to interpreter''s directory *//*** Variables -- Mac Related ***/MenuHandle		appleMenu = nil;Handle			clipboardBuffer = nil;MenuHandle		editMenu = nil;int				menuBarHeight = 20;RgnHandle		menuBarRegion = nil;  /* if non-nil, then menu bar has been hidden */MenuHandle		fileMenu = nil;CTabHandle		stColorTable = nil;PixMapHandle	stPixMap = nil;WindowPtr		stWindow = nil;/*** Variables -- Event Recording ***/#define KEYBUF_SIZE 64int keyBuf[KEYBUF_SIZE];	/* circular buffer */int keyBufGet = 0;			/* index of next item of keyBuf to read */int keyBufPut = 0;			/* index of next item of keyBuf to write */int keyBufOverflows = 0;	/* number of characters dropped */int buttonState = 0;		/* mouse button and modifier state when mouse							   button went down or 0 if not pressed */Point savedMousePosition;	/* mouse position when window is inactive */int windowActive = true;	/* true if the Squeak window is the active window *//* This table maps the 5 Macintosh modifier key bits to 4 Squeak modifier   bits. (The Mac shift and caps lock keys are both mapped to the single   Squeak shift bit).		Mac bits: <control><option><caps lock><shift><command>		ST bits:  <command><option><control><shift>*/char modifierMap[32] = {	0,  8, 1,  9, 1,  9, 1,  9, 4, 12, 5, 13, 5, 13, 5, 13,	2, 10, 3, 11, 3, 11, 3, 11, 6, 14, 7, 15, 7, 15, 7, 15};/*** Functions ***/void AdjustMenus(void);void FreeClipboard(void);void FreePixmap(void);char * GetAttributeString(int id);int  HandleEvents(void);void HandleMenu(int mSelect);void HandleMouseDown(EventRecord *theEvent);void InitMacintosh(void);void InstallAppleEventHandlers(void);int  IsImageName(char *name);void MenuBarHide(void);void MenuBarRestore(void);void SetColorEntry(int index, int red, int green, int blue);void SetUpClipboard(void);void SetUpMenus(void);void SetUpPixmap(void);void SetUpWindow(void);void SetWindowTitle(char *title);void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length);/* event capture */int recordKeystroke(EventRecord *theEvent);int recordModifierButtons(EventRecord *theEvent);int recordMouseDown(EventRecord *theEvent);/*** Apple Event Handlers ***/static pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon);static pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon);/*** Apple Event Handling ***/void InstallAppleEventHandlers() {	OSErr	err;	long	result;	shortImageName[0] = 0;	err = Gestalt(gestaltAppleEventsAttr, &result);	if (err == noErr) {		AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(HandleOpenAppEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,   NewAEEventHandlerProc(HandleOpenDocEvent),  0, false);		AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,  NewAEEventHandlerProc(HandlePrintDocEvent), 0, false);		AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(HandleQuitAppEvent),  0, false);	}}pascal OSErr HandleOpenAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked application; look for "squeak.image" in same directory */	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* use default image name in same directory as the VM */	strcpy(shortImageName, "squeak.image");	return noErr;}pascal OSErr HandleOpenDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	/* User double-clicked an image file. Record the path to the VM''s directory,	   then set the default directory to the folder containing the image and	   record the image name. Fail if mullitple image files were selected. */	OSErr		err;	AEDesc		fileList = {''NULL'', NULL};	long		numFiles, size;	DescType	type;	AEKeyword	keyword;	FSSpec		fileSpec;	WDPBRec		pb;	reply; refCon;  /* reference args to avoid compiler warnings */	/* record path to VM''s home folder */	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	/* copy document list */	err = AEGetKeyDesc(aevt, keyDirectObject, typeAEList, &fileList);	if (err) goto done;	/* count list elements */	err = AECountItems( &fileList, &numFiles);	if (err) goto done;	if (numFiles !!= 1) {		error("You may only open one Squeak image or document file at a time.");	}	/* get image name */	err = AEGetNthPtr(&fileList, 1, typeFSS,					  &keyword, &type, (Ptr) &fileSpec, sizeof(fileSpec), &size);	if (err) goto done;	strcpy(shortImageName, p2cstr(fileSpec.name));	if (!!IsImageName(shortImageName)) {		/* record the document name, but run the default image in VM directory */		strcpy(shortDocumentName, shortImageName);		strcpy(shortImageName, "squeak.image");		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* make the image or document directory the working directory */	pb.ioNamePtr = NULL;	pb.ioVRefNum = fileSpec.vRefNum;	pb.ioWDDirID = fileSpec.parID;	PBHSetVolSync(&pb);	if (shortDocumentName[0] !!= 0) {		/* record the document''s full name */		StoreFullPathForLocalNameInto(shortDocumentName, documentName, DOCUMENT_NAME_SIZE);	}done:	AEDisposeDesc(&fileList);	return err;}pascal OSErr HandlePrintDocEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}pascal OSErr HandleQuitAppEvent(AEDescList *aevt, AEDescList *reply, int refCon) {	aevt; reply; refCon;  /* reference args to avoid compiler warnings */	return errAEEventNotHandled;}/*** VM Home Directory Path ***/int vmPathSize(void) {	return strlen(vmPath);}int vmPathGetLength(int sqVMPathIndex, int length) {	char *stVMPath = (char *) sqVMPathIndex;	int count, i;	count = strlen(vmPath);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		stVMPath[i] = vmPath[i];	}	return count;}/*** Mac-related Functions ***/void AdjustMenus(void) {	WindowPeek		wp;	int				isDeskAccessory;	wp = (WindowPeek) FrontWindow();	if (wp !!= NULL) {		isDeskAccessory = (wp->windowKind < 0);	} else {		isDeskAccessory = false;	}	if (isDeskAccessory) {		/* Enable items in the Edit menu */		EnableItem(editMenu, 1);		EnableItem(editMenu, 3);		EnableItem(editMenu, 4);		EnableItem(editMenu, 5);		EnableItem(editMenu, 6);	} else {		/* Disable items in the Edit menu */		DisableItem(editMenu, 1);		DisableItem(editMenu, 3);		DisableItem(editMenu, 4);		DisableItem(editMenu, 5);		DisableItem(editMenu, 6);	}}int HandleEvents(void) {	EventRecord		theEvent;	int				ok;	SystemTask();	ok = GetNextEvent(everyEvent, &theEvent);	if (ok) {		switch (theEvent.what) {			case mouseDown:				HandleMouseDown(&theEvent);				return false;			break;			case mouseUp:				recordModifierButtons(&theEvent);				return false;			break;			case keyDown:			case autoKey:				if ((theEvent.modifiers & cmdKey) !!= 0) {					AdjustMenus();					HandleMenu(MenuKey(theEvent.message & charCodeMask));				}				recordModifierButtons(&theEvent);				recordKeystroke(&theEvent);			break;			case updateEvt:				BeginUpdate(stWindow);				fullDisplayUpdate();  /* this makes VM call ioShowDisplay */				EndUpdate(stWindow);			break;			case activateEvt:				if (theEvent.modifiers & activeFlag) {					windowActive = true;				} else {					GetMouse(&savedMousePosition);					windowActive = false;				}				InvalRect(&stWindow->portRect);			break;			case kHighLevelEvent:				AEProcessAppleEvent(&theEvent);			break;		}	}	return ok;}void HandleMenu(int mSelect) {	int			menuID, menuItem;	Str255		name;	GrafPtr		savePort;	menuID = HiWord(mSelect);	menuItem = LoWord(mSelect);	switch (menuID) {		case appleID:			GetPort(&savePort);			GetMenuItemText(appleMenu, menuItem, name);			OpenDeskAcc(name);			SetPort(savePort);		break;		case fileID:			if (menuItem == quitItem) {				ioExit();			}		break;		case editID:			if (!!SystemEdit(menuItem - 1)) {				SysBeep(5);			}		break;	}}void HandleMouseDown(EventRecord *theEvent) {	WindowPtr	theWindow;	Rect		growLimits = { 20, 20, 4000, 4000 };	Rect		dragBounds;	int			windowCode, newSize;	windowCode = FindWindow(theEvent->where, &theWindow);	switch (windowCode) {		case inSysWindow:			SystemClick(theEvent, theWindow);		break;		case inMenuBar:			AdjustMenus();			HandleMenu(MenuSelect(theEvent->where));		break;		case inDrag:			dragBounds = qd.screenBits.bounds;			if (theWindow == stWindow) {				DragWindow(stWindow, theEvent->where, &dragBounds);			}		break;		case inGrow:			if (theWindow == stWindow) {				newSize = GrowWindow(stWindow, theEvent->where, &growLimits);				if (newSize !!= 0) {					SizeWindow(stWindow, LoWord(newSize), HiWord(newSize), true);				}			}		break;		case inContent:			if (theWindow == stWindow) {				if (theWindow !!= FrontWindow()) {					SelectWindow(stWindow);				}				recordMouseDown(theEvent);			}		break;		case inGoAway:			if ((theWindow == stWindow) &&				(TrackGoAway(stWindow, theEvent->where))) {					/* HideWindow(stWindow); noop for now */			}		break;	}}void InitMacintosh(void) {	MaxApplZone();	InitGraf(&qd.thePort);	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();}void MenuBarHide(void) {  /* Remove the menu bar, saving its old state. */  /* Many thanks to John McIntosh for this code!! */	Rect screenRect, mBarRect;	if (menuBarRegion !!= nil) return;  /* saved state, so menu bar is already hidden */	screenRect = (**GetMainDevice()).gdRect;	menuBarHeight = GetMBarHeight();	SetRect(&mBarRect, screenRect.left, screenRect.top, screenRect.right, screenRect.top + menuBarHeight);	menuBarRegion = NewRgn();	if (menuBarRegion !!= nil) {		LMSetMBarHeight(0);		RectRgn(menuBarRegion, &mBarRect);		UnionRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	}}void MenuBarRestore(void) {  /* Restore the menu bar from its saved state. Do nothing if it isn''t hidden. */  /* Many thanks to John McIntosh for this code!! */ 	if (menuBarRegion == nil) return;  /* no saved state, so menu bar is not hidden */	DiffRgn(LMGetGrayRgn(), menuBarRegion, LMGetGrayRgn());	LMSetMBarHeight(menuBarHeight);	DisposeRgn(menuBarRegion);	menuBarRegion = nil;	DrawMenuBar();}void SetUpMenus(void) {	InsertMenu(appleMenu = NewMenu(appleID, "\p\024"), 0);	InsertMenu(fileMenu  = NewMenu(fileID,  "\pFile"), 0);	InsertMenu(editMenu  = NewMenu(editID,  "\pEdit"), 0);	DrawMenuBar();	AppendResMenu(appleMenu, ''DRVR'');	AppendMenu(fileMenu, "\pQuit");	AppendMenu(editMenu, "\pUndo/Z;(-;Cut/X;Copy/C;Paste/V;Clear");}void SetColorEntry(int index, int red, int green, int blue) {	(*stColorTable)->ctTable[index].value = index;	(*stColorTable)->ctTable[index].rgb.red = red;	(*stColorTable)->ctTable[index].rgb.green = green;	(*stColorTable)->ctTable[index].rgb.blue = blue;}void FreePixmap(void) {	if (stPixMap !!= nil) {		DisposePixMap(stPixMap);		stPixMap = nil;	}	if (stColorTable !!= nil) {		DisposeHandle((void *) stColorTable);		stColorTable = nil;	}}void SetUpPixmap(void) {	int i, r, g, b;	stColorTable = (CTabHandle) NewHandle(sizeof(ColorTable) + (256 * sizeof(ColorSpec)));	(*stColorTable)->ctSeed = GetCTSeed();	(*stColorTable)->ctFlags = 0;	(*stColorTable)->ctSize = 255;	/* 1-bit colors (monochrome) */	SetColorEntry(0, 65535, 65535, 65535);	/* white or transparent */	SetColorEntry(1,     0,     0,     0);	/* black */	/* additional colors for 2-bit color */	SetColorEntry(2, 65535, 65535, 65535);	/* opaque white */	SetColorEntry(3, 32768, 32768, 32768);	/* 1/2 gray */	/* additional colors for 4-bit color */	SetColorEntry( 4, 65535,     0,     0);	/* red */	SetColorEntry( 5,     0, 65535,     0);	/* green */	SetColorEntry( 6,     0,     0, 65535);	/* blue */	SetColorEntry( 7,     0, 65535, 65535);	/* cyan */	SetColorEntry( 8, 65535, 65535,     0);	/* yellow */	SetColorEntry( 9, 65535,     0, 65535);	/* magenta */	SetColorEntry(10,  8192,  8192,  8192);	/* 1/8 gray */	SetColorEntry(11, 16384, 16384, 16384);	/* 2/8 gray */	SetColorEntry(12, 24576, 24576, 24576);	/* 3/8 gray */	SetColorEntry(13, 40959, 40959, 40959);	/* 5/8 gray */	SetColorEntry(14, 49151, 49151, 49151);	/* 6/8 gray */	SetColorEntry(15, 57343, 57343, 57343);	/* 7/8 gray */	/* additional colors for 8-bit color */	/* 24 more shades of gray (does not repeat 1/8th increments) */	SetColorEntry(16,  2048,  2048,  2048);	/*  1/32 gray */	SetColorEntry(17,  4096,  4096,  4096);	/*  2/32 gray */	SetColorEntry(18,  6144,  6144,  6144);	/*  3/32 gray */	SetColorEntry(19, 10240, 10240, 10240);	/*  5/32 gray */	SetColorEntry(20, 12288, 12288, 12288);	/*  6/32 gray */	SetColorEntry(21, 14336, 14336, 14336);	/*  7/32 gray */	SetColorEntry(22, 18432, 18432, 18432);	/*  9/32 gray */	SetColorEntry(23, 20480, 20480, 20480);	/* 10/32 gray */	SetColorEntry(24, 22528, 22528, 22528);	/* 11/32 gray */	SetColorEntry(25, 26624, 26624, 26624);	/* 13/32 gray */	SetColorEntry(26, 28672, 28672, 28672);	/* 14/32 gray */	SetColorEntry(27, 30720, 30720, 30720);	/* 15/32 gray */	SetColorEntry(28, 34815, 34815, 34815);	/* 17/32 gray */	SetColorEntry(29, 36863, 36863, 36863);	/* 18/32 gray */	SetColorEntry(30, 38911, 38911, 38911);	/* 19/32 gray */	SetColorEntry(31, 43007, 43007, 43007);	/* 21/32 gray */	SetColorEntry(32, 45055, 45055, 45055);	/* 22/32 gray */	SetColorEntry(33, 47103, 47103, 47103);	/* 23/32 gray */	SetColorEntry(34, 51199, 51199, 51199);	/* 25/32 gray */	SetColorEntry(35, 53247, 53247, 53247);	/* 26/32 gray */	SetColorEntry(36, 55295, 55295, 55295);	/* 27/32 gray */	SetColorEntry(37, 59391, 59391, 59391);	/* 29/32 gray */	SetColorEntry(38, 61439, 61439, 61439);	/* 30/32 gray */	SetColorEntry(39, 63487, 63487, 63487);	/* 31/32 gray */	/* The remainder of color table defines a color cube with six steps	   for each primary color. Note that the corners of this cube repeat	   previous colors, but simplifies the mapping between RGB colors and	   color map indices. This color cube spans indices 40 through 255.	*/	for (r = 0; r < 6; r++) {		for (g = 0; g < 6; g++) {			for (b = 0; b < 6; b++) {				i = 40 + ((36 * r) + (6 * b) + g);				if (i > 255) error("index out of range in color table compuation");				SetColorEntry(i, (r * 65535) / 5, (g * 65535) / 5, (b * 65535) / 5);			}		}	}	stPixMap = NewPixMap();	(*stPixMap)->pixelType = 0; /* chunky */	(*stPixMap)->cmpCount = 1;	(*stPixMap)->pmTable = stColorTable;}void SetUpWindow(void) {	Rect windowBounds = {44, 8, 300, 500};	stWindow = NewCWindow(		0L, &windowBounds,		"\p Welcome to Squeak!!  Reading Squeak image file... ",		true, documentProc, (WindowPtr) -1L, true, 0);}void SetWindowTitle(char *title) {	SetWTitle(stWindow, c2pstr(title));	p2cstr((unsigned char *) title);}/*** Event Recording Functions ***/int recordKeystroke(EventRecord *theEvent) {	int keystate;	/* keystate: low byte is the ascii character; next 4 bits are modifier bits */	keystate =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 8) |		(theEvent->message & 0xFF);	if (keystate == interruptKeycode) {		/* Note: interrupt key is "meta"; it not reported as a keystroke */		interruptPending = true;		interruptCheckCounter = 0;	} else {		keyBuf[keyBufPut] = keystate;		keyBufPut = (keyBufPut + 1) % KEYBUF_SIZE;		if (keyBufGet == keyBufPut) {			/* buffer overflow; drop the last character */			keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;			keyBufOverflows++;		}	}}int recordMouseDown(EventRecord *theEvent) {	int stButtons;	stButtons = 4;		/* red button by default */	if ((theEvent->modifiers & optionKey) !!= 0) {		stButtons = 2;	/* yellow button if option down */	}	if ((theEvent->modifiers & cmdKey) !!= 0) {		stButtons = 1;	/* blue button if command down */	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}int recordModifierButtons(EventRecord *theEvent) {	int stButtons = 0;	if (Button()) {		stButtons = buttonState & 0x7;	} else {		stButtons = 0;	}	/* button state: low three bits are mouse buttons; next 4 bits are modifier bits */	buttonState =		(modifierMap[(theEvent->modifiers >> 8) & 0x1F] << 3) |		(stButtons & 0x7);}/*** I/O Primitives ***/int ioBeep(void) {	SysBeep(1000);}int ioExit(void) {	sqNetworkShutdown();	MenuBarRestore();	ExitToShell();}int ioForceDisplayUpdate(void) {	/* do nothing on a Mac */}int ioFormPrint(int bitsAddr, int width, int height, int depth, double hScale, double vScale, int landscapeFlag) {	/* experimental: print a form with the given bitmap, width, height, and depth at	   the given horizontal and vertical scales in the given orientation */	printf("ioFormPrint width %d height %d depth %d hScale %f vScale %f landscapeFlag %d\n",		width, height, depth, hScale, vScale, landscapeFlag);	bitsAddr;	return true;}int ioGetButtonState(void) {	ioProcessEvents();  /* process all pending events */	return buttonState;}int ioGetKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		keyBufGet = (keyBufGet + 1) % KEYBUF_SIZE;		/* set modifer bits in buttonState to reflect the last keystroke fetched */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioMicroMSecs(void) {	/* millisecond clock based on microsecond timer (about 60 times slower than clock()!!!!) */	/* Note: This function and ioMSecs() both return a time in milliseconds. The difference	   is that ioMicroMSecs() is called only when precise millisecond resolution is essential,	   and thus it can use a more expensive timer than ioMSecs, which is called frequently.	   However, later VM optimizations reduced the frequency of calls to ioMSecs to the point	   where clock performance became less critical, and we also started to want millisecond-	   resolution timers for real time applications such as music. Thus, on the Mac, we''ve	   opted to use the microsecond clock for both ioMSecs() and ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMSecs(void) {	/* return a time in milliseconds for use in Delays and Time millisecondClockValue */	/* Note: This was once a macro based on clock(); it now uses the microsecond clock for	   greater resolution. See the comment in ioMicroMSecs(). */	UnsignedWide microTicks;	Microseconds(&microTicks);	return (microTicks.lo / 1000) + (microTicks.hi * 4294967);}int ioMousePoint(void) {	Point p;	ioProcessEvents();  /* process all pending events */	if (windowActive) {		GetMouse(&p);	} else {		/* don''t report mouse motion if window is not active */		p = savedMousePosition;	}	return (p.h << 16) | (p.v & 0xFFFF);  /* x is high 16 bits; y is low 16 bits */}int ioPeekKeystroke(void) {	int keystate;	ioProcessEvents();  /* process all pending events */	if (keyBufGet == keyBufPut) {		return -1;  /* keystroke buffer is empty */	} else {		keystate = keyBuf[keyBufGet];		/* set modifer bits in buttonState to reflect the last keystroke peeked at */		buttonState = ((keystate >> 5) & 0xF8) | (buttonState & 0x7);	}	return keystate;}int ioProcessEvents(void) {	/* This is a noop when running as a plugin; the browser handles events. */	int maxPollsPerSec = 30;	static clock_t nextPollTick = 0;#ifndef PLUGIN	if (clock() > nextPollTick) {		/* time to process events!! */		while (HandleEvents()) {			/* process all pending events */		}		/* wait a while before trying again */		nextPollTick = clock() + (CLOCKS_PER_SEC / maxPollsPerSec);	}#endif	return interruptPending;}int ioRelinquishProcessorForMicroseconds(int microSeconds) {	/* This operation is platform dependent. On the Mac, it simply calls	 * HandleEvents(), which gives other applications a chance to run.	 */	while (HandleEvents()) {		/* process all pending events */	}	return microSeconds;}int ioScreenSize(void) {	int w = 10, h = 10;	if (stWindow !!= nil) {		w = stWindow->portRect.right - stWindow->portRect.left;		h = stWindow->portRect.bottom - stWindow->portRect.top;	}	return (w << 16) | (h & 0xFFFF);  /* w is high 16 bits; h is low 16 bits */}int ioSeconds(void) {	struct tm timeRec;	time_t time1904, timeNow;	/* start of ANSI epoch is midnight of Jan 1, 1904 */	timeRec.tm_sec   = 0;	timeRec.tm_min   = 0;	timeRec.tm_hour  = 0;	timeRec.tm_mday  = 1;	timeRec.tm_mon   = 0;	timeRec.tm_year  = 4;	timeRec.tm_wday  = 0;	timeRec.tm_yday  = 0;	timeRec.tm_isdst = 0;	time1904 = mktime(&timeRec);	timeNow = time(NULL);	/* Squeak epoch is Jan 1, 1901, 3 non-leap years earlier than ANSI one */	return (timeNow - time1904) + (3 * 365 * 24 * 60 * 60);}int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY) {	/* Old version; forward to new version. */	ioSetCursorWithMask(cursorBitsIndex, nil, offsetX, offsetY);}int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY) {	/* Set the 16x16 cursor bitmap. If cursorMaskIndex is nil, then make the mask the same as	   the cursor bitmap. If not, then mask and cursor bits combined determine how cursor is	   displayed:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel	*/	Cursor macCursor;	int i;	if (cursorMaskIndex == nil) {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;		}	} else {		for (i = 0; i < 16; i++) {			macCursor.data[i] = (checkedLongAt(cursorBitsIndex + (4 * i)) >> 16) & 0xFFFF;			macCursor.mask[i] = (checkedLongAt(cursorMaskIndex + (4 * i)) >> 16) & 0xFFFF;		}	}	/* Squeak hotspot offsets are negative; Mac''s are positive */	macCursor.hotSpot.h = -offsetX;	macCursor.hotSpot.v = -offsetY;	SetCursor(&macCursor);}int ioSetFullScreen(int fullScreen) {	Rect screen = qd.screenBits.bounds;	int width, height, maxWidth, maxHeight;	int oldWidth, oldHeight;	if (fullScreen) {		MenuBarHide();		oldWidth = stWindow->portRect.right - stWindow->portRect.left;		oldHeight = stWindow->portRect.bottom - stWindow->portRect.top;		width  = screen.right - screen.left;		height = (screen.bottom - screen.top);		if ((oldWidth < width) || (oldHeight < height)) {			/* save old size if it wasn''t already full-screen */ 			savedWindowSize = (oldWidth << 16) + (oldHeight & 0xFFFF);		}		MoveWindow(stWindow, 0, 0, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = true;	} else {		MenuBarRestore();		/* get old window size */		width  = (unsigned) savedWindowSize >> 16;		height = savedWindowSize & 0xFFFF;		/* minimum size is 64 x 64 */		width  = (width  > 64) ?  width : 64;		height = (height > 64) ? height : 64;		/* maximum size is screen size inset slightly */		maxWidth  = (screen.right  - screen.left) - 16;		maxHeight = (screen.bottom - screen.top)  - 52;		width  = (width  <= maxWidth)  ?  width : maxWidth;		height = (height <= maxHeight) ? height : maxHeight;		MoveWindow(stWindow, 8, 44, true);		SizeWindow(stWindow, width, height, true);		fullScreenFlag = false;	}}int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB) {	Rect		dstRect = { 0, 0, 0, 0 };	Rect		srcRect = { 0, 0, 0, 0 };	RgnHandle	maskRect = nil;	if (stWindow == nil) {		return;	}	dstRect.left	= 0;	dstRect.top		= 0;	dstRect.right	= width;	dstRect.bottom	= height;	srcRect.left	= 0;	srcRect.top		= 0;	srcRect.right	= width;	srcRect.bottom	= height;	(*stPixMap)->baseAddr = (void *) dispBitsIndex;	/* Note: top three bits of rowBytes indicate this is a PixMap, not a BitMap */	(*stPixMap)->rowBytes = (((((width * depth) + 31) / 32) * 4) & 0x1FFF) | 0x8000;	(*stPixMap)->bounds = srcRect;	(*stPixMap)->pixelSize = depth;	(*stPixMap)->cmpSize = depth;	/* create a mask region so that only the affected rectangle is copied */	maskRect = NewRgn();	SetRectRgn(maskRect, affectedL, affectedT, affectedR, affectedB);	SetPort(stWindow);	CopyBits((BitMap *) *stPixMap, &stWindow->portBits, &srcRect, &dstRect, srcCopy, maskRect);	DisposeRgn(maskRect);}/*** Image File Naming ***/void StoreFullPathForLocalNameInto(char *shortName, char *fullName, int length) {	int offset, sz, i;	offset = dir_PathToWorkingDir(fullName, length);	/* copy the file name into a null-terminated C string */	sz = strlen(shortName);	for (i = 0; i <= sz; i++) {		/* append shortName to fullName, including terminator */		fullName[i + offset] = shortName[i];	}}int imageNameSize(void) {	return strlen(imageName);}int imageNameGetLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i;	count = strlen(imageName);	count = (length < count) ? length : count;	/* copy the file name into the Squeak string */	for (i = 0; i < count; i++) {		sqImageName[i] = imageName[i];	}	return count;}int imageNamePutLength(int sqImageNameIndex, int length) {	char *sqImageName = (char *) sqImageNameIndex;	int count, i, ch, j;	int lastColonIndex = -1;	count = (IMAGE_NAME_SIZE < length) ? IMAGE_NAME_SIZE : length;	/* copy the file name into a null-terminated C string */	for (i = 0; i < count; i++) {		ch = imageName[i] = sqImageName[i];		if (ch == '':'') {			lastColonIndex = i;		}	}	imageName[count] = 0;	/* copy short image name into a null-terminated C string */	for (i = lastColonIndex + 1, j = 0; i < count; i++, j++) {		shortImageName[j] = imageName[i];	}	shortImageName[j] = 0;	SetWindowTitle(shortImageName);	return count;}/*** Clipboard Support (text only for now) ***/void SetUpClipboard(void) {	/* allocate clipboard in the system heap to support really big copy/paste */	THz oldZone;	oldZone = GetZone();	SetZone(SystemZone());	clipboardBuffer = NewHandle(0);	SetZone(oldZone);}void FreeClipboard(void) {	if (clipboardBuffer !!= nil) {		DisposeHandle(clipboardBuffer);		clipboardBuffer = nil;	}}int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex) {	long clipSize, charsToMove;	char *srcPtr, *dstPtr, *end;	clipSize = clipboardSize();	charsToMove = (count < clipSize) ? count : clipSize;	srcPtr = (char *) *clipboardBuffer;	dstPtr = (char *) byteArrayIndex + startIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}int clipboardSize(void) {	long count, offset;	count = GetScrap(clipboardBuffer, ''TEXT'', &offset);	if (count < 0) {		return 0;	} else {		return count;	}}int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex) {	ZeroScrap();	PutScrap(count, ''TEXT'', (char *) (byteArrayIndex + startIndex));}/*** Profiling ***/int clearProfile(void) {#ifdef MAKE_PROFILE	ProfilerClear();#endif}int dumpProfile(void) {#ifdef MAKE_PROFILE	ProfilerDump("\pProfile.out");#endif}int startProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(true);#endif}int stopProfiling(void) {#ifdef MAKE_PROFILE	ProfilerSetStatus(false);#endif}/*** Plugin Support ***/int plugInInit(char *fullImagePath) {	if (memory == nil) {		return;	/* failed to read image */	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}	strcpy(imageName, fullImagePath);	dir_PathToWorkingDir(vmPath, VMPATH_SIZE);	SetUpClipboard();	SetUpPixmap();	sqFileInit();	joystickInit();}int plugInShutdown(void) {	snd_Stop();	FreeClipboard();	FreePixmap();	if (memory !!= nil) {		DisposePtr((void *) memory);		memory = nil;	}}/*** System Attributes ***/int IsImageName(char *name) {	char *suffix;	suffix = strrchr(name, ''.'');  /* pointer to last period in name */	if (suffix == NULL) return false;	if (strcmp(suffix, ".ima") == 0) return true;	if (strcmp(suffix, ".image") == 0) return true;	if (strcmp(suffix, ".IMA") == 0) return true;	if (strcmp(suffix, ".IMAGE") == 0) return true;	return false;}char * GetAttributeString(int id) {	/* This is a hook for getting various status strings back from	   the OS. In particular, it allows Squeak to be passed arguments	   such as the name of a file to be processed. Command line options	   are reported this way as well, on platforms that support them.	*/	// id #0 should return the full name of VM; for now it just returns its path	if (id == 0) return vmPath;	// id #1 should return imageName, but returns empty string in this release to	// ease the transition (1.3x images otherwise try to read image as a document)	if (id == 1) return "";  /* will be imageName */	if (id == 2) return documentName;	if (id == 1001) return "Mac OS";	if (id == 1002) return "System 7 or Later";	if (id == 1003) return "PowerPC or 68K";	/* attribute undefined by this platform */	success(false);	return "";}int attributeSize(int id) {	return strlen(GetAttributeString(id));}int getAttributeIntoLength(int id, int byteArrayIndex, int length) {	char *srcPtr, *dstPtr, *end;	int charsToMove;	srcPtr = GetAttributeString(id);	charsToMove = strlen(srcPtr);	if (charsToMove > length) {		charsToMove = length;	}	dstPtr = (char *) byteArrayIndex;	end = srcPtr + charsToMove;	while (srcPtr < end) {		*dstPtr++ = *srcPtr++;	}	return charsToMove;}/*** Image File Operations ***/void sqImageFileClose(sqImageFile f) {	FSClose(f);}sqImageFile sqImageFileOpen(char *fileName, char *mode) {	short int err, err2, fRefNum;	unsigned char *pascalFileName;	pascalFileName = c2pstr(fileName);	err = FSOpen(pascalFileName, 0, &fRefNum);	if ((err !!= 0) && (strchr(mode, ''w'') !!= null)) {		/* creating a new file for "save as" */		err2 = Create(pascalFileName, 0, ''FAST'', ''STim'');		if (err2 == 0) {			err = FSOpen(pascalFileName, 0, &fRefNum);		}	}	p2cstr(pascalFileName);	if (err !!= 0) return null;	if (strchr(mode, ''w'') !!= null) {		/* truncate file if opening in write mode */		err = SetEOF(fRefNum, 0);		if (err !!= 0) {			FSClose(fRefNum);			return null;		}	}	return (sqImageFile) fRefNum;}int sqImageFilePosition(sqImageFile f) {	long int currentPosition = 0;	GetFPos(f, &currentPosition);	return currentPosition;}int sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSRead(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}void sqImageFileSeek(sqImageFile f, int pos) {	SetFPos(f, fsFromStart, pos);}int sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f) {	long int byteCount = elementSize * count;	short int err;	err = FSWrite(f, &byteCount, ptr);	if (err !!= 0) return 0;	return byteCount / elementSize;}/*** Main ***/#ifndef PLUGINvoid main(void) {	EventRecord theEvent;	sqImageFile f;	int reservedMemory, availableMemory;	InitMacintosh();	SetUpMenus();	SetUpClipboard();	SetUpWindow();	SetUpPixmap();	sqFileInit();	joystickInit();	/* install apple event handlers and wait for open event */	imageName[0] = shortImageName[0] = documentName[0] = vmPath[0] = 0;	InstallAppleEventHandlers();	while (shortImageName[0] == 0) {		GetNextEvent(everyEvent, &theEvent);		if (theEvent.what == kHighLevelEvent) {			AEProcessAppleEvent(&theEvent);		}	}	if (imageName[0] == 0) {		StoreFullPathForLocalNameInto(shortImageName, imageName, IMAGE_NAME_SIZE);	}	/* check the interpreter''s size assumptions for basic data types */	if (sizeof(int) !!= 4) {		error("This C compiler''s integers are not 32 bits.");	}	if (sizeof(double) !!= 8) {		error("This C compiler''s floats are not 64 bits.");	}	if (sizeof(time_t) !!= 4) {		error("This C compiler''s time_t''s are not 32 bits.");	}#ifdef MAKE_PROFILE	ProfilerInit(collectDetailed, bestTimeBase, 1000, 50);	ProfilerSetStatus(false);	ProfilerClear();#endif	/* compute the desired memory allocation */	reservedMemory = 750000;	availableMemory = MaxBlock() - reservedMemory;	/******	  Note: This is platform-specific. On the Mac, the user specifies the desired	    memory partition for each application using the Finder''s Get Info command.	    MaxBlock() returns the amount of memory in the partition minus space for	    the code segment and other resources. On other platforms, the desired heap	    size would be specified in other ways (e.g, via a command line argument).	    The maximum size of the object heap is fixed at at startup. If you run low	    on space, you must save the image and restart with more memory.	  Note: Some memory must be reserved for Mac toolbox calls, sound buffers, etc.	    A 30K reserve is too little. 40K allows Squeal to run but crashes if the	    console is opened. 50K allows the console to be opened (with and w/o the	    profiler). I added another 30K to provide for sound buffers and reliability.	    (Note: Later discovered that sound output failed if SoundManager was not	    preloaded unless there is about 100K reserved. Added 30K to that.)	******/	/* uncomment the following when using the C transcript window for debugging: */	//printf("Move this window, then hit CR\n"); getchar();	/* read the image file and allocate memory for Squeak heap */	f = sqImageFileOpen(imageName, "rb");	if (f == NULL) {		/* give a Mac-specific error message if image file is not found */		printf("Could not open the Squeak image file ''%s''\n\n", imageName);		printf("There are several ways to open a Squeak image file. You can:\n");		printf("  1. Double-click on the desired image file.\n");		printf("  2. Drop the image file icon onto the Squeak application or an alias to it.\n");		printf("  3. Name your image ''squeak.image'' and put it in the same folder as the\n");		printf("     Squeak application, then double-click on the Squeak application.\n\n");		printf("Press the return key to exit.\n");		getchar();		printf("Aborting...\n");		ioExit();	}	readImageFromFileHeapSize(f, availableMemory);	sqImageFileClose(f);	SetWindowTitle(shortImageName);	ioSetFullScreen(fullScreenFlag);	/* run Squeak */	interpret();}#endif'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 6/28/1998 12:38'!readmeFile	^ 'Building the Squeak Virtual MachineThe Macintosh virtual machine is built from four header and twelve source files:	sq.h				-- shared definitions included in all .c files	sqConfig.h			-- platform configuration settings	sqMachDep.h		-- machine dependent macros to support threaded code	sqPlatformSpecific.h -- platform specific macros and definitions	sqFilePrims.c		-- file primitives	sqMacAsyncFilePrims.c -- Mac asynchronous file I/O	sqMacDirectory.c	-- Mac directory enumerations	sqMacJoystick.c		-- Mac primitives to support Gravis MouseStickII joystick	sqMacNetwork.c		-- Mac networking primitives	sqMacSerialAndMIDIPort.c -- Mac serial and MIDI port primitives	sqMacSound.c		-- Mac audio output primitives	sqMacWindow.c		-- Mac window and event handling; main program	sqMiscPrims.c		-- miscellaneous automatically generated primitives	sqSoundPrims.c		-- automatically generated sound synthesis primitives	sqOldSoundPrims.c	-- old versions of sound primitives for backward compatibility	interp.c				-- automatically generated code for the virtual machineThe platform specific files are sqMacXXX.c, totaling about 2000 lines of code when this document was written. All other code is written to standard ANSI libraries and should port easily to other C environments.The file sqMacMinimal.c can be used a porting guide. This ~1100 line file stubs out all non-essential support functions and, together with sqFilePrims.c, allows one to build a functioning virtual machine that only lacks non-essential I/O functions (including support for file directory enumeration, which is not really essential!!). The small size of this file demonstrates how little code is really needed to get Squeak running on a new platform.Thanks to Ian Piumarta, the C header files are identical across all the major Squeak platforms.The code assumes that C ints and pointers are 4 bytes and double floats are 8 bytes; these assumptions are checked at start up time. Float objects in the image are stored in the IEEE standard byte ordering for double-precision floats on all platforms; macros in sq.h can be defined to swap bytes into and out of the platform native float format if necessary. (To ensure proper word alignment, one typically has to copy a Squeak Float object into a C "double" variable before operating on it; byte swapping can be done while doing this copy for little or no additional cost.)The files interp.c, sqSoundPrims.c, and sqMiscPrims.c are generated automatically, so changes to these files will be lost when they are next generated. It is fine to make ephemeral changes to these file for the purpose of debugging or statistics gathering. To generate the interpreter, see the "translation" category in Interpreter class. To generate sqSoundPrims.c, see the class method "cCodeForSoundPrimitives" in AbstractSound.The current VM was compiled with Metrowerks CodeWarrier 8. Earlier, I used Semantec Think C 6.0, but discovered a few bugs in their libraries having to do with 8-byte versus 4-byte integers. These bugs have probably been fixed by now.This code has also been compiled under the MPW "Mr. C" Macintosh compiler by Hans-Martin Mosner (hmm@heeg.de) with only one minor change: you will need to create an empty "MacHeaders.h" file. You may get some harmless compiler warnings and, for peak performance, the method that patches the dispatch loop must also be changed. Hans-Martin says: "The whole VM seems to be marginally slower than the delivered VM, but it is significantly smaller."The virtual machine uses the following libraries:	Libraries for 68K Project:		MathLib68K (4i/8d).Lib		MacOS.lib		profiler68k(Small).lib		SIOUX.68K.Lib		ANSI (4i/8d) C.68K.lib	Libraries for PowerPC Project:		ANSI C.PPC.Lib		SIOUX.PPC.Lib		InterfaceLib		profilerPPC.lib		MathLib		MWCRuntime.LibThe Mac networking code also requires three files from Apple''s MacTCP developer''s kit:	MacTCP.h	AddressXlation.h	dnr.cFor convenience, these files are included.To build a fat binary, build the 68K version first, and make sure that the file "Squeak VM 68K" is included in the PowerPC project. Then build the PowerPC version. CodeWarrier will include the 68K interpreter in the resource fork of the output file, resulting in an interpreter that runs on either 68K or PowerPC Macs. To get an additional speedup, the object code for the bytecode dispatch loop of the PPC version can be patched using the method "patchInterp:" in Interpreter class.	-- John Maloney, May 8, 1998'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:34'!squeakConfigFile	^ '/* sqConfig.h -- platform identification and configuration */#if defined(__MWERKS__) && !!defined(macintosh)  /* CodeWarrior 8 neglects to define "macintosh" */# define macintosh#endif#if defined(WIN32) || defined(_WIN32) || defined(Win32)  /* Some compilers use different win32 definitions.     Define WIN32 so we have only to check for one symbol. */# if !!defined(WIN32)#  define WIN32# endif#endif#if defined(macintosh)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define SQ_CONFIG_DONE#endif#if defined(ACORN)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define USE_CLOCK_MSECS# define LITTLE_ENDIAN_BITBLT# define SQ_CONFIG_DONE#endif#if defined(WIN32)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# if defined(_M_IX86) || defined(X86)  /* x86 systems */#  define DOUBLE_WORD_ALIGNMENT#  define DOUBLE_WORD_ORDER  /* Note: We include a generic sqWin32.h to override some settings */#  include "sqWin32.h"#  define SQ_CONFIG_DONE# else#  error unsupported win32 processor type (alpha?!!)# endif#endif/* for Unix variants, this file must define the following symbols as appropriate:   HAS_D_NAMLEN      defined if struct dirent has d_namlen field and hence directory names      are not null terminated.  if underfined then directory names are null      terminated.   HAS_TIMEZONE      defined if the external variable timezone is available, containing the      local offset from GMT in seconds.  if  undefined then the tm structure      must contain the same information in the tm_gmtoff field.  (Consider      defining NEED_TZSET too!!)   HAS_ON_EXIT      defined if cleanup functions are declared with on_exit().  If      undefined then cleanup functions are declared with atexit().   HAS_MSB_FIRST      defined if the most significant byte is first in an int.   HAS_LSB_FIRST      defined if the least significant byte is first in an int.      (Complains if neither of the last two are defined.)   HAS_SUN_AUDIO      defined if the platform supports the Sun /dev/audio device.   DOUBLE_WORD_ALIGNMENT      defined if the platform CANNOT support double-word accesses at an      arbitrary word address.         DOUBLE_WORD_ORDER      defined if the platform stores floats in the opposite order      to the Squeak image (the image is always PowerPC order).   SUN_FUN_KEYS      defined for Sun type 3 or 4 keyboards to enable the editing keys      (Again, Undo, Copy, Paste, Cut, Find, Stop on the "left keypad",      and PgUp, PgDn, Home, End keys on the right keypad).   NEED_FILIO      defined if the platform requires <sys/filio.h> to be included      to get a definition for FIONBIO.   NEED_SELECT      defined if the platform requires <sys/select.h> to be included      to get definitions for select().   NEED_TZSET      defined if the platform required tzset() to be called explicitly      before reading the local wall clock.   JUMP_ALIGN_BYTE      defined if the platform has no instruction alignment restrictions      (e.g. Pentium).   JUMP_ALIGN_STRICT      defined if the platform has word-aligned instructions, and cannot      tolerate the low two bits of an address being non-zero (e.g.      Sparc).*/#if defined(sun) && (defined(sparc) || defined(__sparc))# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# include <errno.h># ifdef ECHRNG					/* Sparc/Solaris */#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_FILIO#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# else						/* Sparc/SunOS */#   include <unistd.h>#   define HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   define HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   define DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define SUN_FUN_KEYS#   define NEED_TZSET#   define JUMP_ALIGN_STRICT#   define SQ_CONFIG_DONE# endif#endif#if defined(sun) && defined(i386)		/* iX86/Solaris */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_FILIO# define NEED_TZSET# define JUMP_ALIGN_BYTE# define SQ_CONFIG_DONE#endif#if defined(mips) || defined(__mips)# if defined(_SYSTYPE_SVR4)			/* (SGI)/IRIX */#  if defined(SQ_CONFIG_DONE)#    error configuration conflict#  endif#  undef  HAS_D_NAMLEN#  define HAS_TIMEZONE#  undef  HAS_ON_EXIT#  define HAS_MSB_FIRST#  undef  HAS_SUN_AUDIO#  undef  DOUBLE_WORD_ALIGNMENT#  undef  DOUBLE_WORD_ORDER#  define JUMP_ALIGN_STRICT#  define SQ_CONFIG_DONE# endif#endif#if defined(linux)# if defined(i386)				/* iX86/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define NEED_TZSET#   define JUMP_ALIGN_BYTE#  define SQ_CONFIG_DONE# endif# if defined(powerpc)				/* PPC/Linux */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_MSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif# if defined(arm)				/* SA110/Linux, maybe Itsy */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   if defined(ITSY)#     define LITTLE_ENDIAN_BITBLT#   endif#   undef  HAS_D_NAMLEN#   define HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   undef  DOUBLE_WORD_ORDER#   define NEED_TZSET#   define SQ_CONFIG_DONE# endif#endif#if defined(__FreeBSD__)# if defined(i386)				/* iX86/FreeBSD */#   if defined(SQ_CONFIG_DONE)#     error configuration conflict#   endif#   undef  HAS_D_NAMLEN#   undef  HAS_TIMEZONE#   undef  HAS_ON_EXIT#   define HAS_LSB_FIRST#   undef  HAS_SUN_AUDIO#   undef  DOUBLE_WORD_ALIGNMENT#   define DOUBLE_WORD_ORDER#   define JUMP_ALIGN_BYTE#   define SQ_CONFIG_DONE# endif#endif#if defined(__alpha)				/* Alpha/OSF1 */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# undef  HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_LSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# define DOUBLE_WORD_ORDER# define NEED_TZSET# define SQ_CONFIG_DONE#endif#if defined(hpux) || defined (__hpux)		/* HPPA/HP-UX */# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# define HAS_D_NAMLEN# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# define DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_TZSET  extern int h_errno;	/* loser!! */# define SQ_CONFIG_DONE#endif#if defined(_AIX) || defined(_M_UNIX)# if defined(SQ_CONFIG_DONE)#   error configuration conflict# endif# undef  HAS_D_NAMLEN				/* IBM RS6000/AIX */# define HAS_TIMEZONE# undef  HAS_ON_EXIT# define HAS_MSB_FIRST# undef  HAS_SUN_AUDIO# undef  DOUBLE_WORD_ALIGNMENT# undef  DOUBLE_WORD_ORDER# define NEED_SELECT# define SQ_CONFIG_DONE#endif#if !!defined(SQ_CONFIG_DONE)# error test for, and describe, your architecture here.#endif'! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 23:26'!squeakHeaderFile	^ '#include <math.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#include "sqConfig.h"#define true 1#define false 0#define null 0  /* using ''null'' because nil is predefined in Think C *//* image save/restore macros *//* Note: The image file save and restore code uses these macros; they   can be redefined in sqPlatformSpecific.h if desired. These default   versions are defined in terms of the ANSI Standard C libraries.*/#define sqImageFile FILE *#define sqImageFileClose(f)                  fclose(f)#define sqImageFileOpen(fileName, mode)      fopen(fileName, mode)#define sqImageFilePosition(f)               ftell(f)#define sqImageFileRead(ptr, sz, count, f)   fread(ptr, sz, count, f)#define sqImageFileSeek(f, pos)              fseek(f, pos, SEEK_SET)#define sqImageFileWrite(ptr, sz, count, f)  fwrite(ptr, sz, count, f)#define sqAllocateMemory(minHeapSize, desiredHeapSize)   malloc(desiredHeapSize)/* platform-dependent float conversion macros *//* Note: Second argument must be a variable name, not an expression!! *//* Note: Floats in image are always in PowerPC word order; change   these macros to swap words if necessary. This costs no extra and   obviates sometimes having to word-swap floats when reading an image.*/#if defined(DOUBLE_WORD_ALIGNMENT) || defined(DOUBLE_WORD_ORDER)# ifdef DOUBLE_WORD_ORDER/* word-based copy with swapping for non-PowerPC order */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 1); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 0);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 1); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 0);# else /*!!DOUBLE_WORD_ORDER*//* word-based copy for machines with alignment restrictions */#   define storeFloatAtfrom(i, floatVarName) \	*((int *) (i) + 0) = *((int *) &(floatVarName) + 0); \	*((int *) (i) + 1) = *((int *) &(floatVarName) + 1);#   define fetchFloatAtinto(i, floatVarName) \	*((int *) &(floatVarName) + 0) = *((int *) (i) + 0); \	*((int *) &(floatVarName) + 1) = *((int *) (i) + 1);# endif /*!!DOUBLE_WORD_ORDER*/#else /*!!(DOUBLE_WORD_ORDER||DOUBLE_WORD_ALIGNMENT)*//* for machines that allow doubles to be on any word boundary */# define storeFloatAtfrom(i, floatVarName) \	*((double *) (i)) = (floatVarName);# define fetchFloatAtinto(i, floatVarName) \	(floatVarName) = *((double *) (i));#endif/* this include file may redefine earlier definitions and macros: */#include "sqPlatformSpecific.h"/*** increment this version number when the image file format changes ***/#define CURRENT_VERSION 6502/* squeak file record; see sqFilePrims.c for details */typedef struct {	FILE	*file;	int		sessionID;	int		writable;	int		fileSize;	int		lastOp;  /* 0 = uncommitted, 1 = read, 2 = write */} SQFile;/* file i/o */int sqFileAtEnd(SQFile *f);int sqFileClose(SQFile *f);int sqFileDeleteNameSize(int sqFileNameIndex, int sqFileNameSize);int sqFileGetPosition(SQFile *f);int sqFileInit(void);int sqFileOpen(SQFile *f, int sqFileNameIndex, int sqFileNameSize, int writeFlag);int sqFileReadIntoAt(SQFile *f, int count, int byteArrayIndex, int startIndex);int sqFileRenameOldSizeNewSize(int oldNameIndex, int oldNameSize, int newNameIndex, int newNameSize);int sqFileSetPosition(SQFile *f, int position);int sqFileSize(SQFile *f);int sqFileValid(SQFile *f);int sqFileWriteFromAt(SQFile *f, int count, int byteArrayIndex, int startIndex);/* directories */int dir_Create(char *pathString, int pathStringLength);int dir_Delimitor(void);int dir_Lookup(char *pathString, int pathStringLength, int index,	/* outputs: */	char *name, int *nameLength, int *creationDate, int *modificationDate,	int *isDirectory, int *sizeIfFile);int dir_PathToWorkingDir(char *pathName, int pathNameMax);int dir_SetMacFileTypeAndCreator(char *filename, int filenameSize, char *fType, char *fCreator);/* interpreter entry points */void error(char *s);int checkedByteAt(int byteAddress);int checkedByteAtput(int byteAddress, int byte);int checkedLongAt(int byteAddress);int checkedLongAtput(int byteAddress, int a32BitInteger);int fullDisplayUpdate(void);int initializeInterpreter(int bytesToShift);int interpret(void);int primitiveFail(void);int signalSemaphoreWithIndex(int index);int success(int);/* display, mouse, keyboard, time i/o */int ioBeep(void);int ioExit(void);int ioForceDisplayUpdate(void);int ioFormPrint(	int bitsAddr, int width, int height, int depth,	double hScale, double vScale, int landscapeFlag);int ioSetFullScreen(int fullScreen);int ioGetButtonState(void);int ioGetKeystroke(void);int ioMicroMSecs(void);int ioMSecs(void);int ioMousePoint(void);int ioPeekKeystroke(void);int ioProcessEvents(void);int ioRelinquishProcessorForMicroseconds(int microSeconds);int ioScreenSize(void);int ioSeconds(void);int ioSetCursor(int cursorBitsIndex, int offsetX, int offsetY);int ioSetCursorWithMask(int cursorBitsIndex, int cursorMaskIndex, int offsetX, int offsetY);int ioShowDisplay(	int dispBitsIndex, int width, int height, int depth,	int affectedL, int affectedR, int affectedT, int affectedB);/* cheap clock with coarse resolution (about 17 msecs on Mac) */# define ioLowResMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)/* optional millisecond clock macro */#ifdef USE_CLOCK_MSECS# define ioMSecs() ((1000 * clock()) / CLOCKS_PER_SEC)#endif/* image file and VM path names */extern char imageName[];int imageNameGetLength(int sqImageNameIndex, int length);int imageNamePutLength(int sqImageNameIndex, int length);int imageNameSize(void);int vmPathSize(void);int vmPathGetLength(int sqVMPathIndex, int length);/* save/restore */int readImageFromFileHeapSize(sqImageFile f, int desiredHeapSize);/* clipboard (cut/copy/paste) */int clipboardSize(void);int clipboardReadIntoAt(int count, int byteArrayIndex, int startIndex);int clipboardWriteFromAt(int count, int byteArrayIndex, int startIndex);/* sound output */int snd_AvailableSpace(void);int snd_InsertSamplesFromLeadTime(int frameCount, int srcBufPtr, int samplesOfLeadTime);int snd_PlaySamplesFromAtLength(int frameCount, int arrayIndex, int startIndex);int snd_PlaySilence(void);int snd_Start(int frameCount, int samplesPerSec, int stereo, int semaIndex);int snd_Stop(void);/* sound input */int snd_SetRecordLevel(int level);int snd_StartRecording(int desiredSamplesPerSec, int stereo, int semaIndex);int snd_StopRecording(void);double snd_GetRecordingSampleRate(void);int snd_RecordSamplesIntoAtLength(int buf, int startSliceIndex, int bufferSizeInBytes);/* joystick support */int joystickInit(void);int joystickRead(int stickIndex);/* netscape plug-in support */int plugInInit(char *imageName);int plugInShutdown(void);int plugInInterpretCycles(int cycleCount);/* interpreter entry points needed by compiled primitives */void * arrayValueOf(int arrayOop);int checkedIntegerValueOf(int intOop);void * fetchArrayofObject(int fieldIndex, int objectPointer);double fetchFloatofObject(int fieldIndex, int objectPointer);int fetchIntegerofObject(int fieldIndex, int objectPointer);double floatValueOf(int floatOop);int pop(int nItems);int pushInteger(int integerValue);int sizeOfSTArrayFromCPrimitive(void *cPtr);int storeIntegerofObjectwithValue(int fieldIndex, int objectPointer, int integerValue);/* sound generation primitives (old, for backward compatibility) */int primWaveTableSoundmixSampleCountintostartingAtpan(void);int primFMSoundmixSampleCountintostartingAtpan(void);int primPluckedSoundmixSampleCountintostartingAtpan(void);int primSampledSoundmixSampleCountintostartingAtpan(void);/* sound generation primitives */int primFMSoundmixSampleCountintostartingAtleftVolrightVol(void);int primLoopedSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);int primPluckedSoundmixSampleCountintostartingAtleftVolrightVol(void);int primReverbSoundapplyReverbTostartingAtcount(void);int primSampledSoundmixSampleCountintostartingAtleftVolrightVol(void);/* squeak socket record; see sqMacNetwork.c for details */typedef struct {	int		sessionID;	int		socketType;  /* 0 = TCP, 1 = UDP */	void	*privateSocketPtr;}  SQSocket, *SocketPtr;/* networking primitives */int		sqNetworkInit(int resolverSemaIndex);void	sqNetworkShutdown(void);void	sqResolverAbort(void);void	sqResolverAddrLookupResult(char *nameForAddress, int nameSize);int		sqResolverAddrLookupResultSize(void);int		sqResolverError(void);int		sqResolverLocalAddress(void);int		sqResolverNameLookupResult(void);void	sqResolverStartAddrLookup(int address);void	sqResolverStartNameLookup(char *hostName, int nameSize);int		sqResolverStatus(void);void	sqSocketAbortConnection(SocketPtr s);void	sqSocketCloseConnection(SocketPtr s);int		sqSocketConnectionStatus(SocketPtr s);void	sqSocketConnectToPort(SocketPtr s, int addr, int port);void	sqSocketCreateNetTypeSocketTypeRecvBytesSendBytesSemaID(			SocketPtr s, int netType, int socketType,			int recvBufSize, int sendBufSize, int semaIndex);void	sqSocketDestroy(SocketPtr s);int		sqSocketError(SocketPtr s);void	sqSocketListenOnPort(SocketPtr s, int port);int		sqSocketLocalAddress(SocketPtr s);int		sqSocketLocalPort(SocketPtr s);int		sqSocketReceiveDataAvailable(SocketPtr s);int		sqSocketReceiveDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketRemoteAddress(SocketPtr s);int		sqSocketRemotePort(SocketPtr s);int		sqSocketSendDataBufCount(SocketPtr s, int buf, int bufSize);int		sqSocketSendDone(SocketPtr s);/* profiling */int clearProfile(void);int dumpProfile(void);int startProfiling(void);int stopProfiling(void);/* system attributes */int attributeSize(int id);int getAttributeIntoLength(int id, int byteArrayIndex, int length);/* miscellaneous primitives */int primBitmapcompresstoByteArray(void);int primBitmapdecompressfromByteArrayat(void);int primSampledSoundconvert8bitSignedFromto16Bit(void);int primStringcomparewithcollated(void);int primStringfindFirstInStringinSetstartingAt(void);int primStringindexOfAsciiinStringstartingAt(void);int primStringtranslatefromtotable(void);/* serial port primitives */int serialPortClose(int portNum);int serialPortOpen(  int portNum, int baudRate, int stopBitsType, int parityType, int dataBits,  int inFlowCtrl, int outFlowCtrl, int xOnChar, int xOffChar);int serialPortReadInto(int portNum, int count, int bufferPtr);int serialPortWriteFrom(int portNum, int count, int bufferPtr);/* MIDI primitives */int sqMIDIGetClock(void);int sqMIDIGetPortCount(void);int sqMIDIGetPortDirectionality(int portNum);int sqMIDIGetPortName(int portNum, int namePtr, int length);int sqMIDIClosePort(int portNum);int sqMIDIOpenPort(int portNum, int readSemaIndex, int interfaceClockRate);int sqMIDIParameter(int whichParameter, int modify, int newValue);int sqMIDIPortReadInto(int portNum, int count, int bufferPtr);int sqMIDIPortWriteFromAt(int portNum, int count, int bufferPtr, int time);/*** Experimental Asynchronous File I/O ***/typedef struct {	int			sessionID;	void		*state;} AsyncFile;int asyncFileClose(AsyncFile *f);int asyncFileOpen(AsyncFile *f, int fileNamePtr, int fileNameSize, int writeFlag, int semaIndex);int asyncFileRecordSize();int asyncFileReadResult(AsyncFile *f, int bufferPtr, int bufferSize);int asyncFileReadStart(AsyncFile *f, int fPosition, int count);int asyncFileWriteResult(AsyncFile *f);int asyncFileWriteStart(AsyncFile *f, int fPosition, int bufferPtr, int bufferSize);'.! !!InterpreterSupportCode class methodsFor: 'source files' stamp: 'jm 9/22/1998 22:35'!squeakPlatSpecFile	^ '/* sqPlatformSpecific.h -- Platform-specific prototypes and definitions *//* How to use this file:   This file is for general platform-specific macros and declarations.   Function prototypes that are unlikely to introduce name conflicts on   other platforms can be added directly. Macro re-definitions or conflicting   function prototypes can be wrapped in a #ifdefs. Alternatively, a customized   version of this file can be used on that platform. The goal is to keep all   the other header files generic across platforms. To override a definition or   macro from sq.h, you must first #undef it, then provide the new definition.*//* unix-specific prototypes and definitions */void aioPollForIO(int microSeconds, int extraFd);#define SQ_FORM_FILENAME	"squeak-form.ppm"#ifdef macintosh/* macintosh memory allocation */#include <Memory.h>#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) NewPtr(desiredHeapSize)/* replace the image file manipulation macros with functions */#undef sqImageFile#undef sqImageFileClose#undef sqImageFileOpen#undef sqImageFilePosition#undef sqImageFileRead#undef sqImageFileSeek#undef sqImageFileWritetypedef int sqImageFile;void        sqImageFileClose(sqImageFile f);sqImageFile sqImageFileOpen(char *fileName, char *mode);int         sqImageFilePosition(sqImageFile f);int         sqImageFileRead(void *ptr, int elementSize, int count, sqImageFile f);void        sqImageFileSeek(sqImageFile f, int pos);int         sqImageFileWrite(void *ptr, int elementSize, int count, sqImageFile f);#endif /* macintosh */#ifdef ACORN/* acorn memory allocation */#undef sqAllocateMemory#define sqAllocateMemory(minHeapSize, desiredHeapSize) platAllocateMemory(desiredHeapSize)#undef sqFilenameFromString#define sqFilenameFromString(dst, src, num) sqFilenameFromString(dst, src, num) #endif /* ACORN */#ifdef LITTLE_ENDIAN_BITBLT#define ifLittleEndianDoelseDo(a, b) a#else#define ifLittleEndianDoelseDo(a, b) b#endif'! !I represent a single component of color in JPEG YCbCr color space.  I can accept a list of blocks in my component from the current MCU, then stream the samples from this block for use in color conversion.  I also store the running DC sample value for my component, used by the Huffman decoder. !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!acTableIndex	^acTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!acTableIndex: anInteger	acTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:21'!dcTableIndex	^dcTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:20'!dcTableIndex: anInteger	dcTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!heightInBlocks	^heightInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!heightInBlocks: anInteger	heightInBlocks _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id	^id! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:09'!id: anObject	id _ anObject! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:29'!mcuWidth: mw mcuHeight: mh dctSize: ds	mcuWidth _ mw.	mcuHeight _ mh.	dctSize _ ds.	hSampleFactor _ mcuWidth // widthInBlocks.	vSampleFactor _ mcuHeight // heightInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:15'!priorDCValue: aNumber	priorDCValue _ aNumber! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:43'!qTableIndex	^qTableIndex! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!qTableIndex: anInteger	qTableIndex _ anInteger! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:18'!totalMcuBlocks	^ heightInBlocks * widthInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:16'!updateDCValue: aNumber	priorDCValue _ priorDCValue + aNumber.	^priorDCValue! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:11'!widthInBlocks	^widthInBlocks! !!JPEGColorComponent methodsFor: 'accessing' stamp: 'tao 10/23/97 12:10'!widthInBlocks: anInteger	widthInBlocks _ anInteger! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!initializeSampleStreamBlocks: aCollection	mcuBlocks _ aCollection.	self resetSampleStream! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 14:23'!nextSample	| dx dy blockIndex sampleIndex sample |	dx _ currentX // hSampleFactor.	dy _ currentY // vSampleFactor.	blockIndex _ dy // dctSize * widthInBlocks + (dx // dctSize) + 1.	sampleIndex _ dy \\ dctSize * dctSize + (dx \\ dctSize) + 1.	sample _ (mcuBlocks at: blockIndex) at: sampleIndex.	currentX _ currentX + 1.	currentX < (mcuWidth * dctSize)		ifFalse:			[currentX _ 0.			currentY _ currentY + 1].	^ sample! !!JPEGColorComponent methodsFor: 'sample streaming' stamp: 'tao 10/23/97 12:24'!resetSampleStream	currentX _ 0.	currentY _ 0! !I represent the table of values used to decode Huffman entropy-encoded bitstreams.  From the JFIF file header entropy values, I build a derived table of codes and values for faster decoding.!!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!bits: anObject	bits _ anObject! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:31'!lookaheadBits	^lookaheadBits! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:38'!lookaheadSymbol	^lookaheadSymbol! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/21/97 23:59'!maxcode	^maxcode! !!JPEGHuffmanTable methodsFor: 'accessing' stamp: 'tao 10/20/97 14:27'!values: anObject	values _ anObject! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/24/97 12:28'!makeDerivedTables	| huffSize huffCode code si index lookbits |	mincode _ Array new: 16.	maxcode _ Array new: 17.	valptr _ Array new: 17.	huffSize _ OrderedCollection new.	1 to: 16 do: [:l | 1 to: (bits at: l) do: [:i | huffSize add: l]].	huffSize add: 0.	code _ 0.	huffCode _ Array new: huffSize size.	si _ huffSize at: 1.	index _ 1.	[(huffSize at: index) ~= 0] whileTrue:		[[(huffSize at: index) = si] whileTrue:			[huffCode at: index put: code.			index _ index + 1.			code _ code + 1].		code _ code << 1.		si _ si + 1].	index _ 1.	1 to: 16 do:		[:l |		(bits at: l) ~= 0			ifTrue:				[valptr at: l put: index.				mincode at: l put: (huffCode at: index).				index _ index + (bits at: l).				maxcode at: l put: (huffCode at: index-1)]			ifFalse:				[maxcode at: l put: -1]].	maxcode at: 17 put: 16rFFFFF.	lookaheadBits _ (Array new: 1 << Lookahead) atAllPut: 0.	lookaheadSymbol _ Array new: 1 << Lookahead.	index _ 1.	1 to: Lookahead do:		[:l |		1 to: (bits at: l) do:			[:i |			lookbits _ (huffCode at: index) << (Lookahead - l) + 1.			(1 << (Lookahead - l) to: 1 by: -1) do:				[:ctr |				lookaheadBits at: lookbits put: l.				lookaheadSymbol at: lookbits put: (values at: index).				lookbits _ lookbits + 1].			index _ index + 1]]! !!JPEGHuffmanTable methodsFor: 'computation' stamp: 'tao 10/21/97 22:44'!valueForCode: code length: length	^ values at: ((valptr at: length) + code - (mincode at: length))! !!JPEGHuffmanTable class methodsFor: 'initialization' stamp: 'tao 10/21/97 11:06'!initialize	Lookahead _ 8.	BitBufferSize _ 16! !!JPEGHuffmanTable class methodsFor: 'constants' stamp: 'tao 10/21/97 22:15'!lookahead	^ Lookahead! !I am a subclass of ImageReadWriter that understands JFIF file streams, and can decode JPEG images.This code is based upon the Independent Joint Photographic Experts Group (IJPEG) software, originally written in C by Tom Lane, Philip Gladstone, Luis Ortiz, Jim Boucher, Lee Crocker, Julian Minguillon, George Phillips, Davide Rossi, Ge' Weijers, and other members of the Independent JPEG Group.!!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 9/18/1998 08:53'!nextImage	^ self nextImageDitheredToDepth: Display depth! !!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 9/18/1998 08:54'!nextImageDitheredToDepth: depth	| form xStep yStep x y |	ditherMask _ DitherMasks		at: depth		ifAbsent: [self error: 'can only dither to display depths'].	redResidual _ greenResidual _ blueResidual _ 0.	sosSeen _ false.	self parseFirstMarker.	[sosSeen] whileFalse: [self parseNextMarker].	form _ Form extent: (width @ height) depth: 32.	xStep _ mcuWidth * DCTSize.	yStep _ mcuHeight * DCTSize.	y _ 0.	1 to: mcuRowsInScan do:		[:row |		x _ 0.		1 to: mcusPerRow do:			[:col |			self decodeMCU.			self idctMCU.			self colorConvertMCU.			mcuImageBuffer displayOn: form at: (x @ y).			x _ x + xStep].		y _ y + yStep].	^ form! !!JPEGReadWriter methodsFor: 'public access' stamp: 'tao 10/26/97 21:41'!setStream: aStream	"Feed it in from an existing source"	stream _ aStream! !!JPEGReadWriter methodsFor: 'preferences' stamp: 'tao 10/26/97 22:09'!useFloatingPoint	^ false! !!JPEGReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:27'!understandsImageFormat	"test to see if the image stream format is understood by this decoder"	[self parseFirstMarker] ifError: [:err :rcvr | ^ false].	^ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:47'!initialSOSSetup	mcuWidth _ (components detectMax: [:c | c widthInBlocks]) widthInBlocks.	mcuHeight _ (components detectMax: [:c | c heightInBlocks]) heightInBlocks.	components do:		[:c |		c mcuWidth: mcuWidth mcuHeight: mcuHeight dctSize: DCTSize].	hACTable , hDCTable do: [:t | t ifNotNil: [t makeDerivedTables]].	bitBuffer _ 0.	bitsInBuffer _ 0.	lookahead _ JPEGHuffmanTable lookahead.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:31'!okToIgnoreMarker: aMarker	^ ((16rE0 to: 16rEF) includes: aMarker) "unhandled APPn markers"		or: [aMarker = 16rDC or: [aMarker = 16rFE]] "DNL or COM markers"! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:47'!parseAPPn	| length buffer thumbnailLength markerStart |	markerStart _ self position.	length _ self nextWord.	buffer _ self next: 4.	(buffer asString = 'JFIF') ifFalse: [self error: 'APP header is incorrect'].	self next.	majorVersion _ self next.	minorVersion _ self next.	densityUnit _ self next.	xDensity _ self nextWord.	yDensity _ self nextWord.	thumbnailLength _ self next * self next * 3.	length _ length - (self position - markerStart).	length = thumbnailLength ifFalse: [self error: 'APP0 thumbnail length is incorrect.'].	self next: length! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 13:36'!parseDecoderRestartInterval	| length |	length _ self nextWord.	length = 4 ifFalse: [self error: 'DRI length incorrect'].	restartInterval _ self nextWord.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/20/97 22:31'!parseFirstMarker	self next = 16rFF ifFalse: [self error: 'JFIF marker expected'].	self next = 16rD8 ifFalse: [self error: 'SOI marker expected'].	self parseStartOfInput.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/23/97 11:49'!parseHuffmanTable	| length markerStart index bits count huffVal isACTable hTable |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[index _ self next.		isACTable _ (index bitAnd: 16r10) ~= 0.		index _ (index bitAnd: 16r0F) + 1.		index > HuffmanTableSize			ifTrue: [self error: 'image has more than ', HuffmanTableSize printString,				' quantization tables'].		bits _ self next: 16.		count _ bits sum.		(count > 256 or: [(count > (length - (self position - markerStart)))])			ifTrue: [self error: 'Huffman Table count is incorrect'].		huffVal _ self next: count.		(hTable _ JPEGHuffmanTable new)			bits: bits;			values: huffVal.		isACTable			ifTrue:				[self hACTable at: index put: hTable]			ifFalse:				[self hDCTable at: index put: hTable]].! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:32'!parseNOP	"don't need to do anything, here"! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:40'!parseNextMarker	| byte discardedBytes |	discardedBytes _ 0.	[(byte _ self next) = 16rFF] whileFalse: [ self debug. discardedBytes _ discardedBytes + 1].		[[(byte _ self next) = 16rFF] whileTrue. byte = 16r00] whileTrue:		[discardedBytes _ discardedBytes + 2].	discardedBytes > 0 ifTrue: [self notify: 'warning: extraneous data discarded'].	self perform:		(JFIFMarkerParser			at: byte			ifAbsent:				[(self okToIgnoreMarker: byte)					ifTrue: [#skipMarker]					ifFalse: [self error: 'marker ', byte hex , ' cannot be handled']])! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:31'!parseQuantizationTable	| length markerStart n prec value table |	markerStart _ self position.	length _ self nextWord.	[self position - markerStart >= length] whileFalse:		[value _ self next.		n _ (value bitAnd: 16r0F) + 1.		prec _ (value >> 4) > 0.		n > QuantizationTableSize			 ifTrue: [self error: 'image has more than ',				QuantizationTableSize printString,				' quantization tables'].		table _ Array new: DCTSize2.		1 to: DCTSize2 do:			[:i |			value _ (prec				ifTrue: [self nextWord]				ifFalse: [self next]).			table at: (JPEGNaturalOrder at: i) put: value].		self useFloatingPoint ifTrue: [self scaleQuantizationTable: table].		self qTable at: n put: table]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/24/97 17:07'!parseStartOfFile	| length markerStart value n |	markerStart _ self position.	length _ self nextWord.	dataPrecision _ self next.	dataPrecision = 8		ifFalse: [self error: 'cannot handle ', dataPrecision printString, '-bit components'].	height _ self nextWord.	width _ self nextWord.	n _ self next.	(height = 0) | (width = 0) | (n = 0) ifTrue: [self error: 'empty image'].	(length - (self position - markerStart)) ~= (n * 3)		ifTrue: [self error: 'component length is incorrect'].	components _ Array new: n.	1 to: components size do:		[:i |		components			at: i			put:				(JPEGColorComponent new					id: self next;					"heightInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);					widthInBlocks: (value bitAnd: 16r0F);"					widthInBlocks: (((value _ self next) >> 4) bitAnd: 16r0F);					heightInBlocks: (value bitAnd: 16r0F);					qTableIndex: self next + 1)]! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 17:38'!parseStartOfInput	restartInterval _ 0.	densityUnit _ 0.	xDensity _ 1.	yDensity _ 1! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/26/97 21:53'!parseStartOfScan	| length n id value dcNum acNum comp |	length _ self nextWord.	n _ self next.	(length ~= (n*2 + 6)) | (n < 1) ifTrue: [self error: 'SOS length is incorrect'].	currentComponents _ Array new: n.	1 to: n do: [:i |		id _ self next.		value _ self next.		dcNum _ (value >> 4) bitAnd: 16r0F.		acNum _ value bitAnd: 16r0F.		comp _ components detect: [:c | c id = id].		comp			dcTableIndex: dcNum+1;			acTableIndex: acNum+1.		currentComponents at: i put: comp].	ss _ self next.	se _ self next.	value _ self next.	ah _ (value >> 4) bitAnd: 16r0F.	al _ value bitAnd: 16r0F.	self initialSOSSetup.	self perScanSetup.	sosSeen _ true! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 9/17/1998 01:02'!perScanSetup	mcusPerRow _ (width / (mcuWidth * DCTSize)) ceiling.	mcuRowsInScan _ (height / (mcuHeight * DCTSize)) ceiling.	(currentComponents size = 3 or: [currentComponents size = 1])		ifFalse: [self error: 'JPEG color space not recognized'].	mcuMembership _ OrderedCollection new.	currentComponents withIndexDo:		[:c :i |		c priorDCValue: 0.		mcuMembership addAll: ((1 to: c totalMcuBlocks) collect: [:b | i])].	mcuSampleBuffer _ (1 to: mcuMembership size) collect: [:i | Array new: DCTSize2].	currentComponents withIndexDo:		[:c :i |			c initializeSampleStreamBlocks:				((1 to: mcuMembership size)					select: [:j | i = (mcuMembership at: j)]					thenCollect: [:j | mcuSampleBuffer at: j])].	mcuImageBuffer _ Form		extent: (mcuWidth @ mcuHeight) * DCTSize		depth: 32.	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'marker parsing' stamp: 'tao 10/22/97 16:27'!skipMarker	| length markerStart |	markerStart _ self position.	length _ self nextWord.	self next: length - (self position - markerStart)! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/22/97 17:10'!decodeBlockInto: anArray component: aColorComponent dcTable: huffmanDC acTable: huffmanAC	| byte i zeroCount |	byte _ self decodeByteWithTable: huffmanDC.	byte ~= 0 ifTrue: [byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte].	byte _ aColorComponent updateDCValue: byte.	anArray atAllPut: 0.	anArray at: 1 put: byte.	i _ 2.	[i <= DCTSize2] whileTrue:		[byte _ self decodeByteWithTable: huffmanAC.		zeroCount _ byte >> 4.		byte _ byte bitAnd: 16r0F.		byte ~= 0			ifTrue:				[i _ i + zeroCount.				byte _ self scaleAndSignExtend: ( self getBits: byte) inFieldWidth: byte.				anArray at:	 (JPEGNaturalOrder at: i) put: byte]			ifFalse:				[zeroCount = 15 ifTrue: [i _ i + zeroCount] ifFalse: [^ self]].		i _ i + 1]		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:24'!decodeByteWithTable: aHuffmanTable	| look nb length code |	look _ self peekBits: lookahead.	(look >= 0 and: [(nb _ aHuffmanTable lookaheadBits at: look+1) ~= 0])		ifTrue:			[self getBits: nb.			^ aHuffmanTable lookaheadSymbol at: look+1].	length _ 1.	code _ self getBits: length.	[code > (aHuffmanTable maxcode at: length)] whileTrue:		[code _ code << 1 + (self getBits: 1).		length _ length + 1].	length > 16 ifTrue: [self error: 'bad encoding value in bit stream'].	^ aHuffmanTable valueForCode: code length: length.				! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/23/97 13:50'!decodeMCU	| comp |	(restartInterval ~= 0 and: [restartsToGo = 0]) ifTrue: [self processRestart].	mcuMembership withIndexDo:		[:ci :i |		comp _ currentComponents at: ci.		self			decodeBlockInto: (mcuSampleBuffer at: i)			component: comp			dcTable: (hDCTable at: comp dcTableIndex)			acTable: (hACTable at: comp acTableIndex)].	restartsToGo _ restartsToGo - 1.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:56'!fillBuffer	| byte |	[bitsInBuffer <= 16]		whileTrue:			[byte _ self next.			(byte = 16rFF and: [(stream peekFor: 16r00) not])					ifTrue:						[stream position: stream position - 1.						^0].			bitBuffer _ bitBuffer << 8 bitOr: byte.			bitsInBuffer _ bitsInBuffer + 8].	^ bitsInBuffer! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 20:54'!getBits: requestedBits	| value |	requestedBits > bitsInBuffer		ifTrue:			[self fillBuffer.			requestedBits > bitsInBuffer				ifTrue:					[self error: 'not enough bits available to decode']].	value _ bitBuffer >> (bitsInBuffer - requestedBits).	bitBuffer _ bitBuffer bitAnd: (1 << (bitsInBuffer - requestedBits) -1).	bitsInBuffer _ bitsInBuffer - requestedBits.	^ value		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 12:46'!peekBits: requestedBits	requestedBits > bitsInBuffer		ifTrue:			[self fillBuffer.			requestedBits > bitsInBuffer ifTrue: [^ -1]].	^ bitBuffer >> (bitsInBuffer - requestedBits)		! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/24/97 19:40'!processRestart	bitBuffer _ 0.	bitsInBuffer _ 0.	self parseNextMarker.	currentComponents do: [:c | c priorDCValue: 0].	restartsToGo _ restartInterval.! !!JPEGReadWriter methodsFor: 'huffman encoding' stamp: 'tao 10/22/97 09:43'!scaleAndSignExtend: aNumber inFieldWidth: w	^ aNumber < (1 << (w - 1))		ifTrue: [aNumber + (1 << w) negated + 1]		ifFalse: [aNumber]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 15:16'!dctFloatRangeLimit: value	^ (value / 8.0) + FloatSampleOffset.! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:34'!idctBlockFloat: anArray component: aColorComponent	| t0 t1 t2 t3 t4 t5 t6 t7 t10 t11 t12 t13 z5 z10 z11 z12 z13 qt ws |	qt _ self qTable at: (aColorComponent qTableIndex).	ws _ Array new: DCTSize2.	"Pass 1: process columns from input, store into work array"	1 to: DCTSize do: [:i |		t0 _ (anArray at: i) * (qt at: i).		t1 _ (anArray at: (DCTSize*2 + i)) * (qt at: (DCTSize*2 + i)).		t2 _ (anArray at: (DCTSize*4 + i)) * (qt at: (DCTSize*4 + i)).		t3 _ (anArray at: (DCTSize*6 + i)) * (qt at: (DCTSize*6 + i)).		t10 _ t0 + t2.		t11 _ t0 - t2.		t13 _ t1 + t3.		t12 _ (t1 - t3) * DCTK1 - t13.		t0 _ t10 + t13.		t3 _ t10 - t13.		t1 _ t11 + t12.		t2 _ t11 - t12.		t4 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).		t5 _ (anArray at: (DCTSize*3 + i)) * (qt at: (DCTSize*3 + i)).		t6 _ (anArray at: (DCTSize*5 + i)) * (qt at: (DCTSize*5 + i)).		t7 _ (anArray at: (DCTSize*7 + i)) * (qt at: (DCTSize*7 + i)).		z13 _ t6 + t5.		z10 _ t6 - t5.		z11 _ t4 + t7.		z12 _ t4 - t7.		t7 _ z11 + z13.		t11 _ (z11 - z13) * DCTK1.		z5 _ (z10 + z12) * DCTK2.		t10 _ DCTK3 * z12 - z5.		t12 _ DCTK4 * z10 + z5.		t6 _ t12 - t7.		t5 _ t11 - t6.		t4 _ t10 + t5.		ws at: i put: t0 + t7.		ws at: (DCTSize*7 + i) put: t0 - t7.		ws at: (DCTSize + i) put: t1 + t6.		ws at: (DCTSize*6 + i) put: t1 - t6.		ws at: (DCTSize*2 + i) put: t2 + t5.		ws at: (DCTSize*5 + i) put: t2 - t5.		ws at: (DCTSize*4 + i) put: t3 + t4.		ws at: (DCTSize*3 + i) put: t3 - t4].		"Pass 2: process rows from the workspace"	(0 to: DCTSize2-DCTSize by: DCTSize) do: [:i |		t10 _ (ws at: (i+1)) + (ws at: (i+5)).		t11 _ (ws at: (i+1)) - (ws at: (i+5)).		t13 _ (ws at: (i+3)) + (ws at: (i+7)).		t12 _ ((ws at: (i+3)) - (ws at: (i+7))) * DCTK1 - t13.		t0 _ t10 + t13.		t3 _ t10 - t13.		t1 _ t11 + t12.		t2 _ t11 - t12.		z13 _ (ws at: (i+6)) + (ws at: (i+4)).		z10 _ (ws at: (i+6)) - (ws at: (i+4)).		z11 _ (ws at: (i+2)) + (ws at: (i+8)).		z12 _ (ws at: (i+2)) - (ws at: (i+8)).		t7 _ z11 + z13.		t11 _ (z11 - z13) * DCTK1.		z5 _ (z10 + z12) * DCTK2.		t10 _ DCTK3 * z12 - z5.		t12 _ DCTK4 * z10 + z5.		t6 _ t12 - t7.		t5 _ t11 - t6.		t4 _ t10 + t5.		"final output stage: scale down by a factor of 8 and range-limit"		anArray at: (i+1) put: (self dctFloatRangeLimit: (t0 + t7)).		anArray at: (i+8) put: (self dctFloatRangeLimit: (t0 - t7)).		anArray at: (i+2) put: (self dctFloatRangeLimit: (t1 + t6)).		anArray at: (i+7) put: (self dctFloatRangeLimit: (t1 - t6)).		anArray at: (i+3) put: (self dctFloatRangeLimit: (t2 + t5)).		anArray at: (i+6) put: (self dctFloatRangeLimit: (t2 - t5)).		anArray at: (i+5) put: (self dctFloatRangeLimit: (t3 + t4)).		anArray at: (i+4) put: (self dctFloatRangeLimit: (t3 - t4))]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'di 9/15/1998 14:29'!idctBlockInt: anArray component: aColorComponent	|  qt ws anACTerm dcval z1 z2 z3 z4 z5 t0 t1 t2 t3 t10 t11 t12 t13 shift |	qt _ self qTable at: (aColorComponent qTableIndex).	ws _ Array new: DCTSize2.	"Pass 1: process columns from anArray, store into work array"	shift _ 1 bitShift: ConstBits - Pass1Bits.	1 to: DCTSize do:		[:i |		anACTerm _ (1 to: DCTSize-1)			detect: [:row | (anArray at: (row * DCTSize + i)) ~= 0]			ifNone: [nil].		anACTerm isNil			ifTrue:				[dcval _ (anArray at: i) * (qt at: 1) bitShift: Pass1Bits.				(0 to: DCTSize-1) do: [:j | ws at: (j * DCTSize + i) put: dcval]]			ifFalse:				[z2 _ (anArray at: (DCTSize * 2 + i)) * (qt at: (DCTSize * 2 + i)).				z3 _ (anArray at: (DCTSize * 6 + i)) * (qt at: (DCTSize * 6 + i)).				z1 _ (z2 + z3) * FIXn0n541196100.				t2 _ z1 + (z3 * FIXn1n847759065 negated).				t3 _ z1 + (z2 * FIXn0n765366865).				z2 _ (anArray at: i) * (qt at: i).				z3 _ (anArray at: (DCTSize * 4 + i)) * (qt at: (DCTSize * 4 + i)).				t0 _ (z2 + z3) bitShift: ConstBits.				t1 _ (z2 - z3) bitShift: ConstBits.				t10 _ t0 + t3.				t13 _ t0 - t3.				t11 _ t1 + t2.				t12 _ t1 - t2.				t0 _ (anArray at: (DCTSize * 7 + i)) * (qt at: (DCTSize * 7 + i)).				t1 _ (anArray at: (DCTSize * 5 + i)) * (qt at: (DCTSize * 5 + i)).				t2 _ (anArray at: (DCTSize * 3 + i)) * (qt at: (DCTSize * 3 + i)).				t3 _ (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).				z1 _ t0 + t3.				z2 _ t1 + t2.				z3 _ t0 + t2.				z4 _ t1 + t3.				z5 _ (z3 + z4) * FIXn1n175875602.				t0 _ t0 * FIXn0n298631336.				t1 _ t1 * FIXn2n053119869.				t2 _ t2 * FIXn3n072711026.				t3 _ t3 * FIXn1n501321110.				z1 _ z1 * FIXn0n899976223 negated.				z2 _ z2 * FIXn2n562915447 negated.				z3 _ z3 * FIXn1n961570560 negated.				z4 _ z4 * FIXn0n390180644 negated.				z3 _ z3 + z5.				z4 _ z4 + z5.				t0 _ t0 + z1 + z3.				t1 _ t1 +z2 +z4.				t2 _ t2 + z2 + z3.				t3 _ t3 + z1 + z4.				ws at: i put: (t10 + t3) >> (ConstBits - Pass1Bits).				ws at: (DCTSize * 7 + i) put: (t10 - t3) // shift.				ws at: (DCTSize * 1 + i) put: (t11 + t2) // shift.				ws at: (DCTSize * 6 + i) put: (t11 - t2) // shift.				ws at: (DCTSize * 2 + i) put: (t12 + t1) // shift.				ws at: (DCTSize * 5 + i) put: (t12 - t1) // shift.				ws at: (DCTSize * 3 + i) put: (t13 + t0) // shift.				ws at: (DCTSize * 4 + i) put: (t13 - t0) // shift]].	"Pass 2: process rows from work array, store back into anArray"	shift _ 1 bitShift: ConstBits + Pass1Bits + 3.	(0 to: DCTSize2-DCTSize by: DCTSize) do:		[:i |		z2 _ ws at: i + 3.		z3 _ ws at: i + 7.		z1 _ (z2 + z3) * FIXn0n541196100.		t2 _ z1 + (z3 * FIXn1n847759065 negated).		t3 _ z1 + (z2 * FIXn0n765366865).		t0 _ (ws at: (i + 1)) + (ws at: (i + 5)) bitShift: ConstBits.		t1 _ (ws at: (i + 1)) - (ws at: (i + 5)) bitShift: ConstBits.		t10 _ t0 + t3.		t13 _ t0 - t3.		t11 _ t1 + t2.		t12 _ t1 -t2.		t0 _ ws at: (i + 8).		t1 _ ws at: (i + 6).		t2 _ ws at: (i + 4).		t3 _ ws at: (i + 2).		z1 _ t0 + t3.		z2 _ t1 + t2.		z3 _ t0 + t2.		z4 _ t1 + t3.		z5 _ (z3 + z4) * FIXn1n175875602.		t0 _ t0 * FIXn0n298631336.		t1 _ t1 * FIXn2n053119869.		t2 _ t2 * FIXn3n072711026.		t3 _ t3 * FIXn1n501321110.		z1 _ z1 * FIXn0n899976223 negated.		z2 _ z2 * FIXn2n562915447 negated.		z3 _ z3 * FIXn1n961570560 negated.		z4 _ z4 * FIXn0n390180644 negated.		z3 _ z3 + z5.		z4 _ z4 + z5.		t0 _ t0 + z1 + z3.		t1 _ t1 + z2 + z4.		t2 _ t2 + z2 + z3.		t3 _ t3 + z1 + z4.		anArray at: (i + 1) put: (self sampleRangeLimit: (t10 + t3) // shift + SampleOffset).		anArray at: (i + 8) put: (self sampleRangeLimit: (t10 - t3) // shift + SampleOffset).		anArray at: (i + 2) put: (self sampleRangeLimit: (t11 + t2) // shift + SampleOffset).		anArray at: (i + 7) put: (self sampleRangeLimit: (t11 - t2) // shift + SampleOffset).		anArray at: (i + 3) put: (self sampleRangeLimit: (t12 + t1) // shift + SampleOffset).		anArray at: (i + 6) put: (self sampleRangeLimit: (t12 - t1) // shift + SampleOffset).		anArray at: (i + 4) put: (self sampleRangeLimit: (t13 + t0) // shift + SampleOffset).		anArray at: (i + 5) put: (self sampleRangeLimit: (t13 - t0) // shift + SampleOffset)].! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 21:25'!idctMCU	| comp |	self useFloatingPoint		ifTrue:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockFloat: (mcuSampleBuffer at: i) component: comp]]		ifFalse:			[mcuMembership withIndexDo:				[:ci :i |				comp _ currentComponents at: ci.				self idctBlockInt: (mcuSampleBuffer at: i) component: comp]]! !!JPEGReadWriter methodsFor: 'dct' stamp: 'tao 10/26/97 16:16'!scaleQuantizationTable: table	| index |	index _ 1.	1 to: DCTSize do:		[:row |		1 to: DCTSize do:			[:col |			table at: index				put: ((table at: index) * (QTableScaleFactor at: row) *					(QTableScaleFactor at: col)) rounded.			index _ index + 1]].	^ table! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 18:53'!colorConvertFloatYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - FloatSampleOffset.		cr _ crSampleStream nextSample - FloatSampleOffset.		red _ self sampleFloatRangeLimit: (y + (1.40200 * cr)).		green _ self sampleFloatRangeLimit: (y - (0.34414 * cb) - (0.71414 * cr)).		blue _ self sampleFloatRangeLimit: (y + (1.77200 * cb)).		bits at: i put: (red << 16) + (green << 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 9/17/1998 00:55'!colorConvertGrayscaleMCU	| ySampleStream y bits |	ySampleStream _ currentComponents at: 1.	ySampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ (ySampleStream nextSample) + greenResidual.		y > MaxSample ifTrue: [y _ MaxSample].		greenResidual _ y bitAnd: ditherMask.		y _ y bitAnd: MaxSample - ditherMask.		y < 1 ifTrue: [y _ 1].		bits at: i put: (y<<16) + (y<<8) + y].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 9/17/1998 00:58'!colorConvertIntYCbCrMCU	| ySampleStream crSampleStream cbSampleStream y cb cr red green blue bits |	ySampleStream _ currentComponents at: 1.	cbSampleStream _ currentComponents at: 2.	crSampleStream _ currentComponents at: 3.	ySampleStream resetSampleStream.	cbSampleStream resetSampleStream.	crSampleStream resetSampleStream.	bits _ mcuImageBuffer bits.	1 to: bits size do:		[:i |		y _ ySampleStream nextSample.		cb _ cbSampleStream nextSample - SampleOffset.		cr _ crSampleStream nextSample - SampleOffset.		red _ y + ((FIXn1n40200 * cr) // 65536) + redResidual.		red > MaxSample			ifTrue: [red _ MaxSample]			ifFalse: [red < 0 ifTrue: [red _ 0]].		redResidual _ red bitAnd: ditherMask.		red _ red bitAnd: MaxSample - ditherMask.		red < 1 ifTrue: [red _ 1].		green _ y - ((FIXn0n34414 * cb) // 65536) -			((FIXn0n71414 * cr) // 65536) + greenResidual.		green > MaxSample			ifTrue: [green _ MaxSample]			ifFalse: [green < 0 ifTrue: [green _ 0]].		greenResidual _ green bitAnd: ditherMask.		green _ green bitAnd: MaxSample - ditherMask.		green < 1 ifTrue: [green _ 1].		blue _ y + ((FIXn1n77200 * cb) // 65536) + blueResidual.		blue > MaxSample			ifTrue: [blue _ MaxSample]			ifFalse: [blue < 0 ifTrue: [blue _ 0]].		blueResidual _ blue bitAnd: ditherMask.		blue _ blue bitAnd: MaxSample - ditherMask.		blue < 1 ifTrue: [blue _ 1].		bits at: i put: (red bitShift: 16) + (green bitShift: 8) + blue].	! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 21:27'!colorConvertMCU	^ currentComponents size = 3		ifTrue:			[self useFloatingPoint				ifTrue: [self colorConvertFloatYCbCrMCU]				ifFalse: [self colorConvertIntYCbCrMCU]]		ifFalse: [self colorConvertGrayscaleMCU]! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'tao 10/26/97 15:43'!sampleFloatRangeLimit: aNumber	^ (aNumber rounded max: 0) min: MaxSample! !!JPEGReadWriter methodsFor: 'colorspace conversion' stamp: 'di 9/15/1998 14:30'!sampleRangeLimit: aNumber	aNumber < 0 ifTrue: [^ 0].	aNumber > MaxSample ifTrue: [^ MaxSample].	^ aNumber! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hACTable	hACTable ifNil: [hACTable _ Array new: HuffmanTableSize].	^ hACTable! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 13:46'!hDCTable	hDCTable ifNil: [hDCTable _ Array new: HuffmanTableSize].	^ hDCTable! !!JPEGReadWriter methodsFor: 'accessing' stamp: 'tao 10/19/97 08:46'!qTable	qTable ifNil: [qTable _ Array new: QuantizationTableSize].	^ qTable! !!JPEGReadWriter methodsFor: 'error handling' stamp: 'tao 10/19/97 12:25'!notSupported: aString	self error: aString , ' is not currently supported'! !!JPEGReadWriter class methodsFor: 'initialization' stamp: 'tao 9/18/1998 09:06'!initialize	"general constants"	DCTSize _ 8.	MaxSample _ (2 raisedToInteger: DCTSize) - 1.	SampleOffset _ MaxSample // 2.	FloatSampleOffset _ SampleOffset asFloat.	DCTSize2 _ DCTSize squared.	QuantizationTableSize _ 4.	HuffmanTableSize _ 4.	"floating-point Inverse Discrete Cosine Transform (IDCT) constants"	ConstBits _ 13.	Pass1Bits _ 2.	DCTK1 _ 2 sqrt.	DCTK2 _ 1.847759065.	DCTK3 _ 1.082392200.	DCTK4 _ -2.613125930.	"fixed-point Inverse Discrete Cosine Transform (IDCT) constants"	FIXn0n298631336 _ 2446.	FIXn0n390180644 _ 3196.	FIXn0n541196100 _ 4433.	FIXn0n765366865 _ 6270.	FIXn0n899976223 _ 7373.	FIXn1n175875602 _ 9633.	FIXn1n501321110 _ 12299.	FIXn1n847759065 _ 15137.	FIXn1n961570560 _ 16069.	FIXn2n053119869 _ 16819.	FIXn2n562915447 _ 20995.	FIXn3n072711026 _ 25172.	"fixed-point color conversion constants"	FIXn0n34414 _ 22554.	FIXn0n71414 _ 46802.	FIXn1n40200 _ 91881.	FIXn1n77200 _  116130.	"reordering table from JPEG zig-zag order"	JPEGNaturalOrder _ #(		1 2 9 17 10 3 4 11		18 25 33 26 19 12 5 6		13 20 27 34 41 49 42 35		28 21 14 7 8 15 22 29		36 43 50 57 58 51 44 37		30 23 16 24 31 38 45 52		59 60 53 46 39 32 40 47		54 61 62 55 48 56 63 64).	"scale factors for the values in the Quantization Tables"	QTableScaleFactor _ (0 to: DCTSize-1) collect:		[:k | k = 0			ifTrue: [1.0]			ifFalse: [(k * Float pi / 16) cos * 2 sqrt]].	"dithering masks"	(DitherMasks _ Dictionary new)		add: 0 -> 0;		add: 1 -> 127;		add: 2 -> 63;		add: 4 -> 63;		add: 8 -> 31;		add: 16 -> 7;		add: 32 -> 0.	"dictionary of marker parsers"	(JFIFMarkerParser _ Dictionary new)		add: (16r01 -> #parseNOP);		add: (16rC0 -> #parseStartOfFile);		add: (16rC4 -> #parseHuffmanTable);		addAll: ((16rD0 to: 16rD7) collect: [:m | Association key: m value: #parseNOP]);		add: (16rD8 -> #parseStartOfInput);		add: (16rD9 -> #parseEndOfInput);		add: (16rDA -> #parseStartOfScan);		add: (16rDB -> #parseQuantizationTable);		add: (16rDD -> #parseDecoderRestartInterval);		add: (16rE0 -> #parseAPPn);		add: (16rE1 -> #parseAPPn)! !!JoystickMorph methodsFor: 'stepping' stamp: 'jm 6/22/1998 18:05'!step	"Track the real joystick whose index is realJoystickIndex."	"Details:	  a. stop stepping if realJoystickIndex is nil; that means we're not tracking a joystick	  b. [-joyMax..joyMax] is nominal range of joystick in both X and Y	  c. [-threshold..threshold] is considered 0 to compensate for poor joystick centering"	| threshold joyMax joyPt m mCenter r scaledPt |	realJoystickIndex ifNil: [^ self stopStepping].	threshold _ 30.	joyMax _ 350.	joyPt _ Sensor joystickXY: realJoystickIndex.	joyPt x abs < threshold ifTrue: [joyPt _ 0@joyPt y].	joyPt y abs < threshold ifTrue: [joyPt _ joyPt x@0].	lastRealJoystickValue = joyPt ifTrue: [^ self].	lastRealJoystickValue _ joyPt.	m _ handleMorph.	mCenter _ m center.	r _ m owner innerBounds insetBy:		((mCenter - m fullBounds origin) corner: (m fullBounds corner - mCenter)).	scaledPt _ r center + ((r extent * joyPt) / (joyMax * 2)) truncated.	m position: (scaledPt adhereTo: r) - (m extent // 2).! !!JoystickMorph methodsFor: 'stepping' stamp: 'jm 6/22/1998 18:00'!stepTime	^ 0! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set X range' action: #setXRange.	aCustomMenu add: 'set Y range' action: #setYRange.	autoCenter		ifTrue: [aCustomMenu add: 'turn auto-center off' action: #toggleAutoCenter]		ifFalse: [aCustomMenu add: 'turn auto-center on' action: #toggleAutoCenter].	realJoystickIndex		ifNil: [aCustomMenu add: 'track real joystick' action: #trackRealJoystick]		ifNotNil: [aCustomMenu add: 'stop tracking joystick' action: #stopTrackingJoystick].! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:24'!stopTrackingJoystick	realJoystickIndex _ nil.	self stopStepping.! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:59'!trackRealJoystick	| s |	s _ FillInTheBlank		request: 'Number of joystick to track?'		initialAnswer: '1'.	s isEmpty ifTrue: [^ self].	realJoystickIndex _ Number readFromString: s.	self startStepping.! !I represent positive integers of more than 30 bits (ie, >= 1073741824).  These values are beyond the range of SmallInteger, and are encoded here as an array of 8-bit digits.  Care must be taken, when new values are computed, that any result that COULD BE a SmallInteger IS a SmallInteger (see normalize).Note that the bit manipulation primitives, bitAnd:, bitShift:, etc., = and ~= run without failure (and therefore fast) if the value fits in 32 bits.  This is a great help to the simulator.!I am a 7-segment LED that can display a decimal digit!!LedDigitMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:01'!initialize	super initialize.	color _ Color green.	highlighted _ false.	digit _ 0.! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit	^ digit! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit: anInteger	digit _ anInteger \\ 10	"make sure it stays between 0 and 9"! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 17:00'!highlighted	^ highlighted! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:43'!highlighted: aBoolean	highlighted _ aBoolean.	self changed.! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 17:03'!drawOn: aCanvas	| foregroundColor backgroundColor thickness hThickness vThickness hOffset vOffset |	foregroundColor _ highlighted ifTrue: [Color white] ifFalse: [color].	backgroundColor _ color darker darker.	hThickness _ self height * 0.1.	vThickness _ self width * 0.1.	thickness _ hThickness min: vThickness.	vOffset _ ((hThickness - thickness) // 2) max: 0.	hOffset _ ((vThickness - thickness) // 2) max: 0.	aCanvas fillRectangle: self bounds color: backgroundColor.	HSegmentOrigins with: (HSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (0@vOffset) + (o * self extent)) rounded				extent: ((self width * 0.6) @ thickness) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].	VSegmentOrigins with: (VSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (hOffset@0) + (o * self extent)) rounded				extent: (thickness @ (self height * 0.25)) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 13:58'!drawOnFills: aRectangle	^ true! !!LedDigitMorph class methodsFor: 'initialization' stamp: 'tao 5/18/1998 12:29'!initialize	HSegmentOrigins _ {0.2@0.1. 0.2@0.45. 0.2@0.8}.	VSegmentOrigins _ {0.1@0.2. 0.1@0.55. 0.8@0.2. 0.8@0.55}.	HSegments _ {		{true. false. true}.		{false. false. false}.		{true. true. true}.		{true. true. true}.		{false. true. false}.		{true. true. true}.		{true. true. true}.		{true. false. false}.		{true. true. true}.		{true. true. true}}.	VSegments _ {		{true. true. true. true}.		{false. false. true. true}.		{false. true. true. false}.		{false. false. true. true}.		{true. false. true. true}.		{true. false. false. true}.		{true. true. false. true}.		{false. false. true. true}.		{true. true. true. true}.		{true. false. true. true}}.! !I am a collection of LED digits that can display a decimal value.  The display can be set to flash by sending flash: true.!!LedMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:38'!initialize	super initialize.	flashing _ false.	flash _ false.	self digits: 2.	self value: 0.	self color: Color green.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:51'!color: aColor	color _ aColor.	self submorphsDo: [:m | m color: aColor]! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!digits	^ digits! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:46'!digits: aNumber	digits _ aNumber.	self removeAllMorphs.	1 to: digits do: [:i | self addMorph: (LedDigitMorph new color: color)].	self layoutChanged.	self changed.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash	^ flash! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash: aBoolean	flash _ aBoolean.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!value	^ value! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:47'!value: aNumber	| val |	value _ aNumber.	val _ value.	submorphs reverseDo:		[:m |		m digit: val \\ 10.		val _ val // 10].	self changed.! !!LedMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 14:00'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color darker darker.! !!LedMorph methodsFor: 'change reporting' stamp: 'tao 5/18/1998 13:53'!layoutChanged	super layoutChanged.	submorphs withIndexDo:		[:m :i |		m			position: self position + (((i-1) * self width / digits) rounded @ 0);			extent: (self width / digits) rounded @ self height]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:42'!step	(flash or: [flashing])		ifTrue:			[flashing _ flashing not.			self submorphsDo: [:m | m highlighted: flashing]]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:44'!stepTime	^ 500! !The LessHTMLformatter provides a few more plaintext notations to swikify,to avoid typing HTML a bit more.  Used in rendering -- see FileListrenderFile!]style[(133 19)f1,f1LFileList renderFile;!!LessHTMLformatter methodsFor: 'translating' stamp: 'mjg 9/3/1998 17:31'!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacterasString) startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to:start+1 with: specialCharacter.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection:(specialCharacter asString)  startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom:start to: end						with: (aBlock value: (aLinecopyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll:'<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll:'<h4>',(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll:'<h3>',(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll:'<h2>',(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll:'<h1>',aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll:'<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [targetStream nextPutAll:aLine].]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in aseparator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue:[ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStreamnextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>';cr.]]].	^targetStream contents.! !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'di 9/21/1998 23:03'!selectedMessage	"Answer the source method for the currently selected message.  Allow class comment, definition, and hierarchy."	| source |	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse: [			source _ class sourceMethodAt: selector.			^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass].		selector = #Comment ifTrue: [^ class comment].		selector = #Definition ifTrue: [^ class definition].		selector = #Hierarchy ifTrue: [^ class printHierarchy].		source _ class sourceMethodAt: selector.		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass]! !!ListParagraph class methodsFor: 'instance creation' stamp: 'jm 9/20/1998 17:10'!withArray: anArray style: aTextStyleOrNil	"Convert an array of strings into a ListParagraph using the given TextStyle."	aTextStyleOrNil		ifNil: [^ (super withText: Text new style: ListStyle) withArray: anArray]		ifNotNil: [^ (super withText: Text new style: aTextStyleOrNil) withArray: anArray].! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 18:59'!font	| style |	textStyle		ifNil: [style _ TextStyle default]		ifNotNil: [style _ textStyle].	^ style fontNamed: style fontNames first! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 19:44'!font: aFontOrNil	aFontOrNil		ifNil: [textStyle _ nil]		ifNotNil: [			textStyle _ TextStyle fontArray: (Array with: aFontOrNil).			textStyle gridForFont: 1 withLead: 1].	self changed: #list.  "update display"! !!ListView methodsFor: 'list access' stamp: 'jm 9/20/1998 17:10'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty _ anArray isEmpty.	arrayCopy _ Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i _ 2.	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].	arrayCopy _ arrayCopy copyWithout: nil.	list _ ListParagraph withArray: arrayCopy style: textStyle.	selection _ 0.	self positionList.! !I respresent a sequence of sound samples, often used to record a single note played by a real instrument. I can be pitch-shifted up or down, and can include a looped portion to allow a sound to be sustained indefinitely.!!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/17/1998 17:45'!addReleaseEnvelope	"Add a simple release envelope to this sound."	| p env |	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 130@0.0.	env _ (VolumeEnvelope points: p loopStart: 2 loopEnd: 2) target: self.	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"		envelopes copy do: [:e |			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].	self addEnvelope: env.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:48'!computeSampleCountForRelease	"Calculate the number of samples before the end of the note after which looping back will be be disabled. The units of this value, sampleCountForRelease, are samples at the original sampling rate. When playing a specific note, this value is converted to releaseCount, which is number of samples to be computed at the current pitch and sampling rate."	"Details: For short loops, set the sampleCountForRelease to the loop length plus the number of samples between loopEnd and lastSample. Otherwise, set it to 1/10th of a second worth of samples plus the number of samples between loopEnd and lastSample. In this case, the trailing samples will be played only if the last loop-back occurs within 1/10th of a second of the total note duration, and the note may be shortened by up to 1/10th second. For long loops, this is the best we can do."	(scaledLoopLength > 0 and: [lastSample > loopEnd])		ifTrue: [			sampleCountForRelease _ (lastSample - loopEnd) +				(self loopLength min: (originalSamplingRate / 10.0)) asInteger]		ifFalse: [sampleCountForRelease _ 0].	releaseCount _ sampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/2/1998 19:54'!fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: mergeFlag		skipDataChunk: false.	aiffFileReader isLooped		ifTrue: [			self samples: aiffFileReader leftSamples				loopEnd: aiffFileReader loopEnd				loopLength: aiffFileReader loopLength				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate]		ifFalse: [			self unloopedSamples: aiffFileReader leftSamples				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate].	"the following must be done second, since the initialization above sets	 leftSamples and rightSamples to the same sample data"	aiffFileReader isStereo		ifTrue: [rightSamples _ aiffFileReader rightSamples].	self addReleaseEnvelope.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 07:43'!initialize	"This default initialization creates a loop consisting of a single cycle of a sine wave."	"(LoopedSampledSound pitch: 440.0 dur: 1.0 loudness: 0.4) play"	| samples |	super initialize.	samples _ FMSound sineTable.	self samples: samples		loopEnd: samples size		loopLength: samples size		pitch: 1.0		samplingRate: samples size.	self addReleaseEnvelope.	self setPitch: 440.0 dur: 1.0 loudness: 0.5.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:38'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	| loopStartIndex |	loopStartIndex _ (loopEndIndex - loopSampleCount) truncated + 1.	((1 <= loopStartIndex) and:	 [loopStartIndex < loopEndIndex and:	 [loopEndIndex <= aSoundBuffer size]])		ifFalse: [self error: 'bad loop parameters'].	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitch _ perceivedPitchInHz asFloat.	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ loopEndIndex.	scaledLoopLength _ (loopSampleCount * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(LoopedSampledSound pitch: 440.0 dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:38'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitchInHz		ifNil: [perceivedPitch _ 100.0]		ifNotNil: [perceivedPitch _ perceivedPitchInHz asFloat].	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	loopEnd _ leftSamples size.	scaledLoopLength _ 0.  "zero length means unlooped"	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate asFloat! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:36'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample	^ firstSample! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample: aNumber	firstSample _ (aNumber asInteger max: 1) min: lastSample.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain	^ gain! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain: aNumber	gain _ aNumber asFloat.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!isLooped	^ scaledLoopLength ~= 0.  "zero loop length means unlooped"! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:14'!isStereo	^ leftSamples ~~ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples	^ leftSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples: aSampleBuffer	leftSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:35'!loopEnd	^ loopEnd! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:12'!loopLength	^ scaledLoopLength / FloatLoopIndexScaleFactor! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:08'!pitch	^ (scaledIndexIncr asFloat * perceivedPitch * self samplingRate asFloat) /	  (originalSamplingRate * FloatLoopIndexScaleFactor)! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 11:38'!pitch: p	scaledIndexIncr _		((p asFloat * originalSamplingRate * FloatLoopIndexScaleFactor) /		 (perceivedPitch * self samplingRate asFloat)) asInteger.	sampleCountForRelease > 0		ifTrue: [releaseCount _ (sampleCountForRelease * LoopIndexScaleFactor) // scaledIndexIncr]		ifFalse: [releaseCount _ 0].! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples	^ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples: aSampleBuffer	rightSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/19/1998 10:43'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive: 184>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #leftSamples declareC: 'short int *leftSamples'.	self var: #rightSamples declareC: 'short int *rightSamples'.	isInStereo _ leftSamples ~~ rightSamples.	compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.	compositeRightVol _  (rightVol * scaledVol) // ScaleFactor.	i _ (2 * startIndex) - 1.	lastIndex _ (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex _ (scaledIndex _ scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex _ (scaledIndex _ scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex _ sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count _ 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex _ sampleIndex]				ifFalse: [nextSampleIndex _ ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m _ scaledIndex bitAnd: LoopIndexFractionMask.		rightVal _ leftVal _			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal _				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		rightVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0].			compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.			compositeRightVol _  (rightVol * scaledVol) // ScaleFactor]].	count _ count - n.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 09:38'!reset	super reset.	count _ initialCount.	scaledIndex _ firstSample * LoopIndexScaleFactor.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/18/1998 09:31'!samplesRemaining	"Answer the number of samples remaining until the end of this sound."	^ count! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:57'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 08:19'!copyDownSampledLowPassFiltering: doFiltering	"Answer a copy of the receiver at half its sampling rate. The result consumes half the memory space, but has only half the frequency range of the original. If doFiltering is true, the original sound buffers are low-pass filtered before down-sampling. This is slower, but prevents aliasing of any high-frequency components of the original signal. (While it may be possible to avoid low-pass filtering when down-sampling from 44.1 kHz to 22.05 kHz, it is probably essential when going to lower sampling rates.)"	^ self copy downSampleLowPassFiltering: doFiltering! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:30'!edit	"Open a WaveEditor on this sound."	| loopLen ed |	loopLen _ scaledLoopLength asFloat / LoopIndexScaleFactor.	ed _ WaveEditor new		data: leftSamples;		samplingRate: originalSamplingRate;		loopEnd: loopEnd;		loopLength: loopLen;		loopCycles: (loopLen / (originalSamplingRate asFloat / perceivedPitch)) rounded.	ed openInWorld.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 07:49'!fftAt: startIndex	"Answer the Fast Fourier Transform (FFT) of my samples (only the left channel, if stereo) starting at the given index."	| availableSamples fftWinSize |	availableSamples _ (leftSamples size - startIndex) + 1.	fftWinSize _ 2 raisedTo: (((availableSamples - 1) log: 2) truncated + 1).	fftWinSize _ fftWinSize min: 4096.	fftWinSize > availableSamples ifTrue: [fftWinSize _ fftWinSize / 2].	^ self fftWindowSize: fftWinSize startingAt: startIndex! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:29'!findStartPointForThreshold: threshold	"Answer the index of the last zero crossing sample before the first sample whose absolute value (in either the right or left channel) exceeds the given threshold."	| i |	i _ self indexOfFirstPointOverThreshold: threshold.	i >= lastSample ifTrue: [^ self error: 'no sample exceeds the given threshold'].	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].	^ i! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:26'!highestSignificantFrequencyAt: startIndex	"Answer the highest significant frequency in the sample window starting at the given index. The a frequency is considered significant if it's power is at least 1/50th that of the maximum frequency component in the frequency spectrum."	| fft powerArray threshold indices |	fft _ self fftAt: startIndex.	powerArray _ self normalizedResultsFromFFT: fft.	threshold _ powerArray max / 50.0.	indices _ (1 to: powerArray size) select: [:i | (powerArray at: i) > threshold].	^ originalSamplingRate / (fft samplesPerCycleForIndex: indices last)! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/17/1998 09:22'!indexOfFirstPointOverThreshold: threshold	"Answer the index of the first sample whose absolute value exceeds the given threshold."	| s |	leftSamples == rightSamples		ifTrue: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]]		ifFalse: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i].				s _ rightSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]].	^ lastSample + 1! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'jm 8/18/1998 07:47'!comeFullyUpOnReload	"Convert my sample buffers from ByteArrays into SampleBuffers after raw loading from a DataStream. Answer myself."	leftSamples == rightSamples		ifTrue: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ leftSamples]		ifFalse: [			leftSamples _ SoundBuffer fromByteArray: self leftSamples.			rightSamples _ SoundBuffer fromByteArray: self rightSamples].! !!LoopedSampledSound methodsFor: 'disk i/o' stamp: 'jm 8/18/1998 07:48'!objectToStoreOnDataStream    "Answer an object to store on a data stream, a copy of myself whose SampleBuffers have been converted into ByteArrays."	| objToStore |	objToStore _ self clone.	objToStore leftSamples: leftSamples asByteArray.	self isStereo		ifTrue: [objToStore rightSamples: rightSamples asByteArray]		ifFalse: [objToStore rightSamples: objToStore leftSamples].	^ objToStore! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 08:11'!downSampleLowPassFiltering: doFiltering	"Cut my sampling rate in half. Use low-pass filtering (slower) if doFiltering is true."	"Note: This operation loses information, and modifies the receiver in place."	| stereo newLoopLength |	stereo _ self isStereo.	leftSamples _ leftSamples downSampledLowPassFiltering: doFiltering.	stereo		ifTrue: [rightSamples _ rightSamples downSampledLowPassFiltering: doFiltering]		ifFalse: [rightSamples _ leftSamples].	originalSamplingRate _ originalSamplingRate / 2.0.	loopEnd odd		ifTrue: [newLoopLength _ (self loopLength / 2.0) + 0.5]		ifFalse: [newLoopLength _ self loopLength / 2.0].	firstSample _ (firstSample + 1) // 2.	lastSample _ (lastSample + 1) // 2.	loopEnd _ (loopEnd + 1) // 2.	scaledLoopLength _ (newLoopLength * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ scaledIndexIncr // 2.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 07:48'!fftWindowSize: windowSize startingAt: startIndex	"Answer a Fast Fourier Transform (FFT) of the given number of samples starting at the given index (the left channel only, if stereo). The window size will be rounded up to the nearest power of two greater than the requested size. There must be enough samples past the given starting index to accomodate this window size."	| nu n fft |	nu _ ((windowSize - 1) log: 2) truncated + 1.	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((startIndex to: startIndex + n - 1) collect: [:i | leftSamples at: i]).	^ fft transformForward: true.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/16/1998 17:48'!normalizedResultsFromFFT: fft	"Answer an array whose size is half of the FFT window size containing power in each frequency band, normalized to the average power over the entire FFT. A value of 10.0 in this array thus means that the power at the corresponding frequences is ten times the average power across the entire FFT."	| r avg |	r _ (1 to: fft realData size // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	avg _ r sum / r size.	^ r collect: [:v | v / avg].! !!LoopedSampledSound class methodsFor: 'class initialization' stamp: 'jm 8/13/1998 12:54'!initialize	"LoopedSampledSound initialize"	LoopIndexScaleFactor _ 512.	FloatLoopIndexScaleFactor _ LoopIndexScaleFactor asFloat.	LoopIndexFractionMask _ LoopIndexScaleFactor - 1.! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:40'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		samples: aSoundBuffer		loopEnd: loopEndIndex		loopLength: loopSampleCount		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:41'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		unloopedSamples: aSoundBuffer		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !I am a parser for mail files in the format output by the Unix 'mh' program.!!MHMailInboxFile methodsFor: 'scanning'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream textStart textSize msgText |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue:			["if possible, buffer the entire file in memory for speed"			 stream _ ReadStream on: (fileStream contentsOfEntireFile).			 fileStream _ nil]		ifFalse:			["otherwise, use the actual file stream, reading from disk"			 stream _ fileStream].	[self scanToNextMessageIn: stream] whileTrue:		["skip the three-line message delimiter"		 3 timesRepeat: [MailDB skipRestOfLine: stream].		 textStart _ stream position.		 self scanToNextMessageIn: stream.		 textSize _ stream position - textStart.		 stream position: textStart.		 msgText _ stream next: textSize.		 aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MHMailInboxFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message in the given stream. Answer true if we find a message delimiter, false if we hit the end of the stream first. The stream is left positioned at the start of the next message delimiter (if there is one) or at the end of the stream."	| msgStart |	[true] whileTrue:		[(aStream skipTo: $:) ifFalse: [^false].	"end of stream"		 msgStart _ aStream position - 1.		 ((MailDB readStringLineFrom: aStream) = ':::::::::::::') ifTrue:			["looking good..."			 MailDB skipRestOfLine: aStream.	"skip message number"			 ((MailDB readStringLineFrom: aStream) = '::::::::::::::') ifTrue:				["found a message!!"				 aStream position: msgStart. ^true]].		 "false alarm, keep scanning"		 aStream position: msgStart + 1].! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 18:29'!readHeaderChunk	| chunkType chunkSize division |	chunkType _ self readChunkType.	chunkType = 'RIFF' ifTrue:[chunkType _ self riffSkipToMidiChunk].	chunkType = 'MThd' ifFalse: [self scanForMIDIHeader].	chunkSize _ self readChunkSize.	fileType _ self next16BitWord.	trackCount _ self next16BitWord.	division _ self next16BitWord.	(division anyMask: 16r8000)		ifTrue: [self error: 'SMPTE time formats are not yet supported']		ifFalse: [ticksPerQuarter _ division].	maxNoteTicks _ 12 * 4 * ticksPerQuarter.		"longest acceptable note; used to detect stuck notes"	"sanity checks"	chunkSize = 6		ifFalse: [self error: 'unexpected MIDI header size ', chunkSize printString].	(#(0 1 2) includes: fileType)		ifFalse: [self error: 'unknown MIDI file type ', fileType printString].	Transcript		show: 'Reading Type ', fileType printString, ' MIDI File (';		show: trackCount printString, ' tracks, ';		show: ticksPerQuarter printString, ' ticks per quarter note)';		cr.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 19:08'!readMIDIFrom: aBinaryStream	"Read one or more MIDI tracks from the given binary stream."	stream _ aBinaryStream.	tracks _ OrderedCollection new.	trackInfo _ OrderedCollection new.	self readHeaderChunk.	trackCount timesRepeat: [self readTrackChunk].	stream atEnd ifFalse: [self report: 'data beyond final track'].	fileType = 0 ifTrue: [self splitIntoTracks].	self guessMissingInstrumentNames.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:10'!readTrackContents: byteCount	| info |	strings _ OrderedCollection new.	track _ OrderedCollection new.	trackStream _ ReadStream on: (stream next: byteCount).	activeEvents _ OrderedCollection new.	self readTrackEvents.	(tracks isEmpty and: [self isTempoTrack: track])		ifTrue: [tempoMap _ track asArray]		ifFalse: [			"Note: Tracks without note events are currently not saved to			 eliminate clutter in the score player. In control applications,			 this can be easily changed by modifying the following test."			(self trackContainsNotes: track) ifTrue: [				tracks add: track asArray.				info _ WriteStream on: (String new: 100).				strings do: [:s | info nextPutAll: s; cr].				trackInfo add: info contents]].	strings _ track _ trackStream _ activeEvents _ nil.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/10/1998 09:57'!readTrackEvents	"Read the events of the current track."	| cmd chan key vel ticks byte length evt |	cmd _ #unknown.	chan _ key _ vel _ 0.	ticks _ 0.	[trackStream atEnd] whileFalse: [		ticks _ ticks + (self readVarLengthIntFrom: trackStream).		byte _ trackStream next.		byte >= 16rF0			ifTrue: [  "meta or system exclusive event"				byte = 16rFF ifTrue: [self metaEventAt: ticks].				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"					length _ self readVarLengthIntFrom: trackStream.					trackStream skip: length].				cmd _ #unknown]			ifFalse: [  "channel message event"				byte >= 16r80					ifTrue: [  "new command"						cmd _ byte bitAnd: 16rF0.						chan _ byte bitAnd: 16r0F.						key _ trackStream next]					ifFalse: [  "use running status"						cmd == #unknown							ifTrue: [self error: 'undefined running status; bad MIDI file?'].						key _ byte].				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [					"all but program change and channel pressure have two data bytes"					vel _ trackStream next].				cmd = 16r80 ifTrue: [  "note off"					self endNote: key chan: chan at: ticks].				cmd = 16r90 ifTrue: [  "note on"					vel = 0						ifTrue: [self endNote: key chan: chan at: ticks]						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].				"cmd = 16A0 -- polyphonic key pressure; skip"				cmd = 16rB0 ifTrue: [					evt _ ControlChangeEvent new control: key value: vel channel: chan.					evt time: ticks.					track add: evt].				cmd = 16rC0 ifTrue: [					evt _ ProgramChangeEvent new program: key channel: chan.					evt time: ticks.					track add: evt].				"cmd = 16D0 -- channel aftertouch pressure; skip"				cmd = 16rE0 ifTrue: [					evt _ PitchBendEvent new bend: key + (vel bitShift: 7) channel: chan.					evt time: ticks.					track add: evt]	]].! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:15'!trackContainsNotes: eventList	"Answer true if the given track contains at least one note event."	eventList do: [:e | e isNoteEvent ifTrue: [^ true]].	^ false! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:00'!guessMissingInstrumentNames	"Attempt to guess missing instrument names from the first program change in that track."	| progChange instrIndex instrName |	1 to: tracks size do: [:i |		(trackInfo at: i) isEmpty ifTrue: [			progChange _ (tracks at: i) detect: [:e | e isProgramChange] ifNone: [nil].			progChange ifNotNil: [				instrIndex _ progChange program + 1.				instrName _ self class standardMIDIInstrumentNames at: instrIndex.				trackInfo at: i put: instrName]]].! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 17:32'!readChunkType	"Read a chunk ID string from the next 4 bytes."	"Assume: Stream has at least four bytes left."	| s |	s _ String new: 4.	1 to: 4 do: [:i | s at: i put: (stream next) asCharacter].	^ s! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 19:19'!scanForMIDIHeader	"Scan the first part of this file in search of the MIDI header string 'MThd'. Report an error if it is not found. Otherwise, leave the input stream positioned to the first byte after this string."	| asciiM p lastSearchPosition byte restOfHeader |	asciiM _ $M asciiValue.	stream skip: -3.	p _ stream position.	lastSearchPosition _ p + 10000.  "search only the first 10000 bytes of the file"	[p < lastSearchPosition and: [stream atEnd not]] whileTrue: [		[(byte _ stream next) ~= asciiM and: [byte ~~ nil]] whileTrue.  "find the next 'M' or file end"		restOfHeader _ (stream next: 3) asString.		restOfHeader = 'Thd'			ifTrue: [^ self]			ifFalse: [restOfHeader size = 3 ifTrue: [stream skip: -3]].		p _ stream position].	self error: 'MIDI header chunk not found'.! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:10'!splitIntoTracks	"Split a type zero MIDI file into separate tracks by channel number."	| newTempoMap newTracks |	tracks size = 1 ifFalse: [self error: 'expected exactly one track in type 0 file'].	tempoMap ifNotNil: [self error: 'did not expect a tempo map in type 0 file'].	newTempoMap _ OrderedCollection new.	newTracks _ (1 to: 16) collect: [:i | OrderedCollection new].	tracks first do: [:e |		e isTempoEvent			ifTrue: [newTempoMap addLast: e]			ifFalse: [(newTracks at: e channel + 1) addLast: e]].	newTempoMap size > 0 ifTrue: [tempoMap _ newTempoMap asArray].	newTracks _ newTracks select: [:t | self trackContainsNotes: t].	tracks _ newTracks collect: [:t | t asArray].	trackInfo _ trackInfo, ((2 to: tracks size) collect: [:i | '']).! !!MIDIFileReader class methodsFor: 'all' stamp: 'ls 8/8/1998 03:14'!playStream: binaryStream	ScorePlayerMorph		openOn: (self scoreFromStream: binaryStream)		title: 'a MIDI stream'! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 5/29/1998 17:12'!playURLNamed: urlString	| titleString |	titleString _ urlString		copyFrom: (urlString findLast: [:c | c=$/]) + 1		to: urlString size.	ScorePlayerMorph		openOn: (self scoreFromURL: urlString)		title: titleString.! !!MIDIFileReader class methodsFor: 'all' stamp: 'ls 8/8/1998 03:14'!scoreFromStream: binaryStream	|  score |	score _ (self new readMIDIFrom: binaryStream) asScore.	^ score! !!MIDIFileReader class methodsFor: 'all' stamp: 'jm 9/12/1998 19:57'!standardMIDIInstrumentNames	"Answer an array of Standard MIDI instrument names."	^ #(		'Grand Piano'		'Bright Piano'		'Electric Grand Piano'		'Honky-tonk Piano'		'Electric Piano 1'		'Electric Piano 2'		'Harpsichord'		'Clavichord'		'Celesta'		'Glockenspiel'		'Music Box'		'Vibraphone'		'Marimba'		'Xylophone'		'Tubular Bells'		'Duclimer'		'Drawbar Organ'		'Percussive Organ'		'Rock Organ'		'Church Organ'		'Reed Organ'		'Accordion'		'Harmonica'		'Tango Accordion'		'Nylon Guitar'		'Steel Guitar'		'Electric Guitar 1'		'Electric Guitar 2'		'Electric Guitar 3'		'Overdrive Guitar'		'Distorted Guitar'		'Guitar Harmonics'		'Acoustic Bass'		'Electric Bass 1'		'Electric Bass 2'		'Fretless Bass'		'Slap Bass 1'		'Slap Bass 2'		'Synth Bass 1'		'Synth Bass 2'		'Violin'		'Viola'		'Cello'		'Contrabass'		'Tremolo Strings'		'Pizzicato Strings'		'Orchestral Harp'		'Timpani'		'String Ensemble 1'		'String Ensemble 2'		'Synth Strings 1'		'Synth Strings 2'		'Choir Ahhs'		'Choir Oohs'		'Synth Voice'		'Orchestra Hit'		'Trumpet'		'Trombone'		'Tuba'		'Muted Trumpet'		'French Horn'		'Brass Section'		'Synth Brass 1'		'Synth Brass 2'		'Soprano Sax'		'Alto Sax'		'Tenor Sax'		'Baritone Sax'		'Oboe'		'English Horn'		'Bassoon'		'Clarinet'		'Piccolo'		'Flute'		'Recorder'		'Pan Flute'		'Blown Bottle'		'Shakuhachi'		'Whistle'		'Ocarina'		'Lead 1 (square)'		'Lead 2 (sawtooth)'		'Lead 3 (calliope)'		'Lead 4 (chiff)'		'Lead 5 (charang)'		'Lead 6 (voice)'		'Lead 7 (fifths)'		'Lead 8 (bass+lead)'		'Pad 1 (new age)'		'Pad 2 (warm)'		'Pad 3 (polysynth)'		'Pad 4 (choir)'		'Pad 5 (bowed)'		'Pad 6 (metallic)'		'Pad 7 (halo)'		'Pad 8 (sweep)'		'FX 1 (rain)'		'FX 2 (soundtrack)'		'FX 3 (crystals)'		'FX 4 (atmosphere)'		'FX 5 (brightness)'		'FX 6 (goblins)'		'FX 7 (echoes)'		'FX 8 (sci-fi)'		'Sitar'		'Banjo'		'Shamisen'		'Koto'		'Kalimba'		'Bagpipe'		'Fiddle'		'Shanai'		'Tinkle Bell'		'Agogo'		'Steel Drum'		'Woodblock'		'Taiko Drum'		'Melodic Tom'		'Synth Drum'		'Reverse Cymbal'		'Guitar Fret Noise'		'Breath Noise'		'Seashore'		'Bird Tweet'		'Telephone Ring'		'Helicopter'		'Applause'		'Gunshot')! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 14:55'!addAmbientEvent: evt	| i |	ambientTrack == nil ifTrue: [^ ambientTrack _ Array with: evt].	i _ ambientTrack findFirst: [:e | e time >= evt time].	i = 0 ifTrue: [^ ambientTrack _ ambientTrack , (Array with: evt)].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i-1 with: (Array with: evt)! !!MIDIScore methodsFor: 'all' stamp: 'di 8/1/1998 15:31'!ambientEventAfter: eventIndex ticks: scoreTicks	| evt |	(ambientTrack == nil or: [eventIndex > ambientTrack size]) ifTrue: [^ nil].	evt _ ambientTrack at: eventIndex.	evt time <= scoreTicks ifTrue: [^ evt].	^ nil! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 20:34'!ambientTrack	^ ambientTrack! !!MIDIScore methodsFor: 'all' stamp: 'jm 9/10/1998 17:22'!eventForTrack: trackIndex after: eventIndex ticks: scoreTick	| track evt |	track _ tracks at: trackIndex.	eventIndex > track size ifTrue: [^ nil].	evt _ track at: eventIndex.	evt time > scoreTick ifTrue: [^ nil].	^ evt! !!MIDIScore methodsFor: 'all' stamp: 'jm 8/6/1998 21:16'!jitterStartAndEndTimesBy: mSecs	| r range halfRange oldEnd newEnd newStart |	r _ Random new.	range _ 2.0 * mSecs.	halfRange _ mSecs.	tracks do: [:t |		t do: [:e |			e isNoteEvent ifTrue: [				oldEnd _ e time + e duration.				newEnd _ oldEnd + ((r next * range) asInteger - halfRange).				newStart _ e time + ((r next * range) asInteger - halfRange).				e time: newStart.				e duration: (newEnd - newStart)]]].				! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 08:04'!otherPlayersDo: playerBlock	"Not elegant -- scan for any players registered in the ambientTrack,	and evaluate the block for them."	| players p |	ambientTrack == nil ifTrue: [^ self].	players _ Set new.	ambientTrack do:		[:evt | p _ evt relatedPlayer.		p ifNotNil: [players add: p]].	players do: playerBlock! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!pauseFrom: scorePlayer	self otherPlayersDo: [:p | p pauseFrom: scorePlayer]! !!MIDIScore methodsFor: 'all' stamp: 'di 8/3/1998 21:52'!removeAmbientEventWithMorph: aMorph	| i |	ambientTrack == nil ifTrue: [^ self].	i _ ambientTrack findFirst: [:e | e morph == aMorph].	i = 0 ifTrue: [^ self].	ambientTrack _ ambientTrack copyReplaceFrom: i to: i with: Array new! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!resetFrom: scorePlayer	self otherPlayersDo: [:p | p resetFrom: scorePlayer]! !!MIDIScore methodsFor: 'all' stamp: 'di 8/6/1998 07:58'!resumeFrom: scorePlayer	self otherPlayersDo: [:p | p resumeFrom: scorePlayer]! !a MIME object, along with its type and the URL it was found at (if any)!!MIMEDocument methodsFor: 'printing' stamp: 'ls 7/23/1998 20:12'!printOn: aStream	aStream nextPutAll: self class name;		nextPutAll: ' (';		nextPutAll: self contentType;		nextPutAll: ', ';		nextPutAll: self content size printString;		nextPutAll: ' bytes)'.! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:11'!privateContent: aString	content _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:06'!privateMainType: aString	mainType _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 7/23/1998 20:06'!privateSubType: aString	subType _ aString! !!MIMEDocument methodsFor: 'private-initialization' stamp: 'ls 8/12/1998 00:25'!privateUrl: aUrl	url _ aUrl! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:26'!content	"return the raw data in this object"	^content! !!MIMEDocument methodsFor: 'access' stamp: 'ls 9/18/1998 05:41'!contentStream	"return a RWBinaryOrTextStream on the contents"	^(RWBinaryOrTextStream with: self content) reset! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:26'!contentType	^self mainType, '/', self subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!mainType	#XXX.  "is there a better name?"	^mainType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!subType	^subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 7/23/1998 19:25'!type	^mainType, '/', subType! !!MIMEDocument methodsFor: 'access' stamp: 'ls 8/12/1998 00:25'!url	"returns the URL this object was downloaded from.  It may legitimately be nil"	^url! !!MIMEDocument class methodsFor: 'content-types' stamp: 'ls 8/8/1998 03:15'!guessTypeFromName: url	"guesses a content type from the url"	| extension |	extension _ url asString.	(extension includes: $.) ifFalse: [ ^self defaultContentType].	extension _ (extension findTokens: '.') last asLowercase.	extension = 'html' ifTrue: [ ^'text/html' ].	extension = 'htm' ifTrue:[ ^'text/html' ].	extension = 'txt' ifTrue: [ ^'text/plain' ].	extension = 'gif' ifTrue: [ ^'image/gif' ].	extension = 'jpg' ifTrue: [ ^'image/jpeg' ].	extension = 'jpeg' ifTrue: [ ^'image/jpeg' ].	extension = 'mid' ifTrue: [ ^'audio/midi' ].	^self defaultContentType! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 22:59'!content: aString	^self contentType: self defaultContentType  content: aString! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 08:00'!contentType: aString  content: content	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	^ans! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/12/1998 00:26'!contentType: aString  content: content  url: aUrl	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	ans privateUrl: aUrl asUrl.	^ans! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 7/23/1998 22:59'!defaultContentType	^'application/octet-stream'! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 6/22/1998 14:26'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| h |	h _ aWorld activeHand.	h ifNil: [h _ aWorld hands first].	self popUpAt: aPoint forHand: h.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneCycle].	self delete.	^ selectedItem! !Parse mail addresses.  The basic syntax is:	addressList := MailAddressParser addressesIn: aStringThis currently only returns the bare addresses, but it could also return a list of the address "source codes".  For example, if you give it "Joe <joe@foo>, <jane>", it will currently return a list ('joe@foo' 'jane').  It would be nice to also get a list ('Joe <joe@foo>'  '<jane>').!!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:31'!addToAddress	"add the last token to the address.  removes the token from the collection"	curAddrTokens addFirst: (tokens removeLast)! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!finishAddress	"we've finished one address.  Bundle it up and add it to the list of addresses"	| address |	address _ String streamContents: [ :str |		curAddrTokens do: [ :tok | str nextPutAll: tok text ] ].	addresses addFirst: address.	curAddrTokens _ nil.! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!startNewAddress	"set up data structures to begin a new address"	(curAddrTokens ~~ nil) ifTrue: [		self error: 'starting new address before finishing the last one!!' ].	curAddrTokens _ OrderedCollection new.	! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:08'!grabAddressWithRoute	"grad an address of the form 'Descriptive Text <real.address@c.d.e>"		self startNewAddress.	tokens removeLast.	"remove the >"	"grab until we see a $<"	[ 		tokens isEmpty ifTrue: [			self error: '<> are not matched' ].		tokens last type = $<	] whileFalse: [ self addToAddress ].	tokens removeLast.  "remove the <"	self removePhrase.	self finishAddress! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:25'!grabAddresses	"grab all the addresses in the string"	| token |	"grab one address or address group each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		"check whether any tokens are left"		tokens isEmpty 	] whileFalse: [		token _ tokens last.		"delegate, depending on what form the address is in"		"the from can be determined from the last token"		token type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: token type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			token type = $; ifTrue: [				self grabGroupAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ] ]	].	^addresses! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:32'!grabBasicAddress	"grad an address of the form a.b@c.d.e"		self startNewAddress.	"grab either the domain if specified, or the domain if not"	self addToAddress.		[ tokens last type = $. ] whileTrue: [		"add name-dot pairs of tokens"		self addToAddress.		(#(Atom QuotedString) includes: tokens last type) ifFalse: [			self error: 'bad token in address: ', tokens last text ].		self addToAddress ].	(tokens isEmpty or: [ tokens last type ~= $@]) ifTrue: [		"no domain specified"		self finishAddress ]	ifFalse: [		"that was the domain.  check that no QuotedString's slipped in"		curAddrTokens do: [ :tok |			tok type = #QuotedString ifTrue: [				self error: 'quote marks are not allowed within a domain name (',					tok text, ')'. ] ].		"add the @ sign"		self addToAddress.		"add the local part"		(#(Atom QuotedString) includes: tokens last type) ifFalse: [			self error: 'invalid local part for address: ', tokens last text ].		self addToAddress.		"add word-dot pairs if there are any"		[ tokens isEmpty not and: [ tokens last type = $. ] ] whileTrue: [			self addToAddress.			(tokens isEmpty not 			  and: [ #(Atom QuotedString) includes: tokens last type ]) 			  ifTrue: [ self addToAddress ] ].		self finishAddress ].! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:07'!grabGroupAddress	"grab an address of the form 'phrase : address, address, ..., address;'"	"I'm not 100% sure what this format means, so I'm just returningthe list of addresses between the : and ;   -ls  (if this sounds right to someone, feel free to remove this comment :)"	"remove the $; "	tokens removeLast.	"grab one address each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		tokens isEmpty ifTrue: [			"no matching :"			^self error: 'stray ; in address list'. ].		tokens last type = $:	] whileFalse: [		"delegate to either grabAddressWithRoute, or grabBasicAddress.  nested groups are not allowed"		tokens last type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: tokens last type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ]	].	tokens removeLast.   "remove the :"	self removePhrase.! !!MailAddressParser methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:08'!removePhrase	"skip most characters to the left of this"	[		tokens isEmpty not and: [			#(Atom QuotedString $. $@) includes: (tokens last type) ]	] whileTrue: [ tokens removeLast ].! !!MailAddressParser methodsFor: 'private-initialization' stamp: 'ls 9/13/1998 01:25'!initialize: tokenList	tokens _ tokenList asOrderedCollection copy.	addresses _ OrderedCollection new.! !!MailAddressParser class methodsFor: 'examples' stamp: 'ls 9/13/1998 02:08'!example	"test out several correct formats"	"MailAddressParser example"	^self addressesIn: 'joe@lama.com, joe2@lama.com joe3@lama.com joe4 , Not an Address <joe5@address>, joe.(annoying (nested) comment)literal@[1.2.3.4], "an annoying" group : joe1@groupie, joe2@groupie, "Joey" joe3@groupy, "joe6"."joe8"@group.com;,  Lex''s email account <lex>'! !!MailAddressParser class methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:34'!addressesIn: aString	"return a collection of the bare addresses listed in aString"	| tokens |	tokens _ MailAddressTokenizer tokensIn: aString.	^(self new initialize: tokens) grabAddresses! !a single token from an RFC822 mail address.  Used internally in MailAddressParser!!MailAddressToken methodsFor: 'access' stamp: 'ls 9/12/1998 20:42'!text	^text! !!MailAddressToken methodsFor: 'access' stamp: 'ls 9/12/1998 20:42'!type	^type! !!MailAddressToken methodsFor: 'private' stamp: 'ls 9/12/1998 20:24'!type: type0  text: text0	type _ type0.	text _ text0.! !!MailAddressToken methodsFor: 'printing' stamp: 'ls 9/12/1998 20:40'!printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self type asString.	aStream nextPut: $|.	aStream nextPutAll: self text.	aStream nextPut: $].! !!MailAddressToken class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 20:31'!type: type  text: text	^self new type: type text: text! !Divides an address into tokens, as specified in RFC 822.  Used by MailAddressParser.!!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!atEndOfChars	^pos > text size! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextAtom	| start end |	start _ pos.	pos _ text indexOfAnyOf: CSNonAtom startingAt: start ifAbsent: [ text size + 1].	end _ pos - 1.	^MailAddressToken		type: #Atom		text: (text copyFrom: start to: end)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:52'!nextChar	self atEndOfChars ifTrue: [ ^nil ].	pos _ pos + 1.	^text at: (pos-1)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:39'!nextDomainLiteral	| start end |	start _ pos.	end _ text indexOf: $] startingAt: start ifAbsent: [ 0 ].	end = 0 ifTrue: [		"not specified"		self error: 'saw [ without a matching ]' ].	pos _ end+1.	^MailAddressToken		type: #DomainLiteral		text: (text copyFrom: start to: end)! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!nextQuotedString	| res c |	res _ WriteStream on: String new.	res nextPut: self nextChar.   "record the starting quote"	[ self atEndOfChars ] whileFalse: [		c _ self nextChar.		c = $\ ifTrue: [			res nextPut: c.			res nextPut: self nextChar ]		ifFalse: [			c = $" ifTrue: [				res nextPut: c.				^MailAddressToken type: #QuotedString  text: res contents ]			ifFalse: [				res nextPut: c ] ] ].	"hmm, never saw the final quote mark"	^MailAddressToken type: #QuotedString  text: (res contents, '"')! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextSpecial	| c |	c _ self nextChar.	^MailAddressToken type: c  text: c asString.! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:49'!nextToken	| c |	self skipSeparatorsAndComments.	c _ self peekChar.	c ifNil: [ ^nil ].	c = $" ifTrue: [ ^self nextQuotedString ].	c = $[ ifTrue: [ ^self nextDomainLiteral ].	(CSSpecials includes: c) ifTrue: [ ^self nextSpecial ].	^self nextAtom! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:15'!peekChar	^text at: pos ifAbsent: [ nil ]! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 02:02'!skipComment	| nestLevel paren |	pos _ pos + 1.	nestLevel _ 1.	[ nestLevel > 0 ] whileTrue: [		pos _ text indexOfAnyOf: CSParens startingAt: pos  ifAbsent: [ 0 ].		pos = 0 ifTrue: [ 			self error: 'unterminated comment.  ie, more (''s than )''s' ].		paren _ self nextChar.		paren = $( ifTrue: [ nestLevel _ nestLevel + 1 ] ifFalse: [ nestLevel _ nestLevel - 1 ]. ]! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:14'!skipSeparators	pos _ text indexOfAnyOf: CSNonSeparators  startingAt: pos  ifAbsent: [ text size + 1 ].! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:49'!skipSeparatorsAndComments	[	self skipSeparators.		self peekChar = $(	] whileTrue: [ self skipComment ]! !!MailAddressTokenizer methodsFor: 'initialization' stamp: 'ls 9/12/1998 20:13'!initialize: aString	text _ aString.	pos _ 1.! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!atEnd	^self peek == nil! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:51'!next	| ans |	cachedToken ifNil: [ ^self nextToken ].	ans _ cachedToken.	cachedToken _ nil.	^ans! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!peek	cachedToken ifNil: [ cachedToken _ self nextToken. ].		^cachedToken	! !!MailAddressTokenizer class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 20:54'!forString: aString	^super basicNew initialize: aString! !!MailAddressTokenizer class methodsFor: 'instance creation' stamp: 'ls 9/13/1998 01:34'!tokensIn: aString	"return a collection of the tokens in aString"	^(self forString: aString) upToEnd! !!MailAddressTokenizer class methodsFor: 'class initialization' stamp: 'ls 9/13/1998 02:02'!initialize	"MailAddressTokenizer initialize"	CSNonSeparators _ CharacterSet separators complement.	CSSpecials _ CharacterSet empty.	CSSpecials addAll: '()<>@,;:\".[]'.	CSNonAtom _ CharacterSet separators.	CSNonAtom addAll: CSSpecials.	0 to: 31 do: [ :c |		CSNonAtom add: (Character value: c) ].	CSNonAtom add: (Character value: 127).	CSParens _ CharacterSet empty.	CSParens addAll: '()'.! !I am the in-memory representation of a Celeste mail database. A mail database named "current" consists of three files:	current.messages	-- an append-only file containing the full content of all messages	current.index		-- an index of all messages in the messages file that maps unique						   message ID's to index entries containing some header information						   and the offset of the full message in the .messages file	current.categories	-- maps category names to collections of message ID'sEach open mail database has a MailDB object that manages these three files. Operations such as fetching a message given its unique ID and finding out which messages are in which category are supported by the MailDB object. It also supports incorporating new messages (reading mail), message editing and deletions, and message file compaction and recovery.!!MailDB methodsFor: 'initialize-release'!close	"Save and close the messageFile."	self saveDB.	(messageFile notNil) ifTrue: [messageFile close].	rootFilename _ nil.	messageFile _ indexFile _ categoriesFile _ nil.! !!MailDB methodsFor: 'initialize-release'!openOn: rootNameString	"Open a mail database with the given root file name."	| status |	rootFilename _ rootNameString.	status _ self dbStatus.	messageFile _ indexFile _ categoriesFile _ nil.	(status = #exists) ifTrue: [^self openDB].	(status = #partialDatabase) ifTrue: [^self recoverDB].	(status = #doesNotExist) ifTrue: [^self createDB].! !!MailDB methodsFor: 'initialize-release'!release	"Close this database."	self close.	super release.! !!MailDB methodsFor: 'open-create-save'!createDB	"Create a new mail database."	(self confirm:'Shall I create a new mail databasenamed: ', rootFilename, '?')		ifFalse:	"abort create operation"			[rootFilename _ nil.			 self release.			^nil].	self openDB.							"creates new DB files"	self saveDB.							"save the new mail database to disk"! !!MailDB methodsFor: 'open-create-save' stamp: 'jm 8/14/1998 13:43'!dbStatus	"See if my database exists. Since the database has several components, the answer is one of:	#exists				all files exist	#partialDatabase	only some of the files exist	#doesNotExist		none of the files exist"	messageFile _ FileDirectory default includesKey: rootFilename, '.messages'.	indexFile _ FileDirectory default includesKey: rootFilename, '.index'.	categoriesFile _ FileDirectory default includesKey: rootFilename, '.categories'.	(messageFile & indexFile & categoriesFile) ifTrue: [^ #exists].	(messageFile | indexFile | categoriesFile) ifFalse: [^ #doesNotExist].	^ #partialDatabase! !!MailDB methodsFor: 'open-create-save'!openDB	"Open an existing mail database."	Transcript show: 'Opening mail database ''', rootFilename, '''...'.	messageFile _ MessageFile openOn: rootFilename, '.messages'.	indexFile _ IndexFile openOn: rootFilename, '.index' messageFile: messageFile.	categoriesFile _ CategoriesFile openOn: rootFilename, '.categories'.	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'open-create-save'!recoverDB	"Open a mail database with the given root file name."	(self confirm:'The mail database named:    ', rootFilename, 'appears to be damaged. Shall I fix it?')		ifFalse: [^self release].	self openDB.	self compact.! !!MailDB methodsFor: 'open-create-save'!rootFilename	"Answer my root filename."	^rootFilename! !!MailDB methodsFor: 'open-create-save'!saveDB	"Write all database files to disk."	(rootFilename notNil)		ifTrue: [Transcript show: 'Saving mail database ''', rootFilename, '''...']		ifFalse: [Transcript show: 'Saving mail database...'].	(messageFile notNil) ifTrue: [messageFile save].	(indexFile notNil) ifTrue: [indexFile save].	(categoriesFile notNil) ifTrue: [categoriesFile save].	Transcript show: 'Done.'; cr.! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'ls 9/14/1998 06:38'!POPMailFrom: server  userName: userName password: passworddoFormatting: doFormatting deleteInbox: deleteInbox informingUser: informUser	"Download mail via POP and append to this mail database. Answer the number of messages fetched."	| nextID msg location connection numMessages msgText displayMessage  |	"is there any mail?"		"connect to the POP server"	connection _ POPSocket createIfFail: [ ^0 ].	self do: [		connection serverName: server.			connection userName: userName.		connection password: password.		connection addProgressObserver: Transcript.		connection connectToPOP. ] 	andInform: (informUser ifTrue: ['connecting to ', server] ifFalse: [nil]).	connection isConnected ifFalse: [ ^ 0 ].	"download each message"	numMessages _ connection numMessages.	displayMessage _ 'downloading ', numMessages printString, ' messages'.	self showProgress: informUser from: 0 to: numMessages message: displayMessage during: [ :bar |		nextID _ self nextUnusedID.		1 to: numMessages do: [ :messageNum |			bar value: messageNum.			msgText _ connection retrieveMessage: messageNum.			"save the message"			msg _ MailMessage from: msgText.			doFormatting ifTrue: [msg format].			location _ messageFile basicAppend: msg text id: nextID.			indexFile				at: nextID				put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).			categoriesFile file: nextID inCategory: 'new'.			nextID _ nextID + 1.				"delete the message from the server, if desired"			deleteInbox ifTrue: [ connection deleteMessage: messageNum ].		].		messageFile endAppend.		LastID _ nextID.		connection disconnectFromPOP.		"snapshot the database and remove the inbox file"		self saveDB.	].	^numMessages! !!MailDB methodsFor: 'fetch-merge-compact'!appendMessages: msgBuffer messageFile: msgFile indexFile: idxFile	"Append the given collection of messages to the message file. msgBuffer is a collection of (message ID, message text) pairs."	| id msgText location entry |	msgBuffer do:		[: idAndText |		 id _ idAndText at: 1.		 msgText _ idAndText at: 2.		 location _ msgFile basicAppend: msgText id: id.		 entry _ indexFile			at: id			ifAbsent:				[IndexFileEntry					message: (MailMessage from: msgText)					location: location					messageFile: msgFile					msgID: id].		 entry _ (entry copy) location: location; textLength: msgText size.		 idxFile at: id put: entry].! !!MailDB methodsFor: 'fetch-merge-compact'!cleanUpCategories	"Prune the dead wood out of all categories."	categoriesFile categories do:		[: category |		 categoriesFile removeMessagesInCategory: category butNotIn: indexFile].! !!MailDB methodsFor: 'fetch-merge-compact'!compact	"Compact the message file and rebuild the index file. Answer an array containing with the number of messages and the number of bytes recovered."	| newMessageFile newIndexFile stats |	newMessageFile _ MessageFile openOn: rootFilename, '.messages.tmp'.	newIndexFile _ IndexFile openOn: rootFilename, '.index.tmp' messageFile: newMessageFile.	stats _ self copyUndeletedTo: newMessageFile indexFile: newIndexFile.	newMessageFile save.	newIndexFile save.	messageFile rename: rootFilename, '.messages.bak'.	indexFile rename: rootFilename, '.index.bak'.	newMessageFile rename: rootFilename, '.messages'.	newIndexFile rename: rootFilename, '.index'.	indexFile delete.	messageFile delete.	indexFile _ newIndexFile.	messageFile _ newMessageFile.	self cleanUpCategories.	categoriesFile save.	^stats! !!MailDB methodsFor: 'fetch-merge-compact'!copyUndeletedTo: newMsgFile indexFile: newIndexFile	"Copy all the undeleted messages in my current message file into the new message file, recording their locations in the new index file. Answer an array containing with the number of messages and the number of bytes recovered."	"Note: To minimize disk seeks, messages are buffered and written in large batches. You may wish to tune the amount of buffering if you have a particular shortage or abundance of physical memory. bufferLimit is the approximate number of bytes of messages that will be accumulated before writing the buffered messages to disk."	| bufferLimit msgBuffer bufferSize deletedCount deletedBytes |	Smalltalk garbageCollect.	bufferLimit _ Smalltalk bytesLeft // 2.	"use half of the available memory"	msgBuffer _ OrderedCollection new: 1000.	bufferSize _ 0.	deletedCount _ deletedBytes _ 0.	newMsgFile beginAppend.	messageFile messagesDo:		[: deleted : msgID : msgText |		 (deleted)			ifTrue:				[deletedCount _ deletedCount + 1.				 deletedBytes _ deletedBytes + msgText size]			ifFalse:				[msgBuffer addLast: (Array with: msgID with: msgText).				 bufferSize _ bufferSize + msgText size.				 (bufferSize >= bufferLimit) ifTrue:					[self						appendMessages: msgBuffer						messageFile: newMsgFile						indexFile: newIndexFile.					 msgBuffer _ OrderedCollection new: 1000.					 bufferSize _ 0]]].	"flush remaining buffered messages"	self		appendMessages: msgBuffer		messageFile: newMsgFile		indexFile: newIndexFile.	newMsgFile endAppend.	"return statistics"	^Array with: deletedCount with: deletedBytes! !!MailDB methodsFor: 'fetch-merge-compact'!fetchMailFrom: inboxFileName doFormatting: doFormatting deleteInbox: deleteInbox	"Append the messages from the given mail inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any mail?"	(StandardFileStream isAFileNamed: inboxFileName) ifFalse: [^0].	inbox _ MailInboxFile openOn: inboxFileName.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox mailMessagesDo:		[: msgText |		 msg _ MailMessage from: msgText.		 doFormatting ifTrue: [msg format].		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: 'new'.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	deleteInbox ifTrue: [inbox delete].	^count! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'jm 8/14/1998 16:47'!fetchNewsFrom: inboxPathName doFormatting: doFormatting deleteInbox: deleteInbox	"Append the messages from the given news inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any news?"	((FileDirectory on: inboxPathName) includesKey: 'news') ifFalse: [^ 0].	inbox _ RNInboxFile openOn: inboxPathName, ':news'.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox newsMessagesDo:		[: newsgroup : msgText |		 msg _ MailMessage from: msgText.		 doFormatting ifTrue: [msg format].		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: newsgroup.		 categoriesFile file: nextID inCategory: 'new'.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	deleteInbox ifTrue: [inbox delete].	^ count! !!MailDB methodsFor: 'fetch-merge-compact'!fileDuplicatesIn: categoryName	"MailDB someInstance fileDuplicatesIn: '.duplicates.'"	self fileAll: self findDuplicates inCategory: categoryName.! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'ls 9/15/1998 22:30'!findDuplicates	"MailDB someInstance findDuplicates"	| msgsAtTime m duplicates list text1 msg1 msg2 id1 id2 |	msgsAtTime _ Dictionary new.	(self messagesIn: '.all.') do: [ :msgID |		m _ indexFile at: msgID.		(msgsAtTime includesKey: m time) ifFalse: [			msgsAtTime at: m time put: OrderedCollection new.		].		(msgsAtTime at: m time) add: (Array with: msgID with: m).	].	duplicates _ Set new.	msgsAtTime associationsDo: [ :assoc |		list _ assoc value asOrderedCollection.		list do: [ :arr1 |  			id1 _ arr1 at: 1.			msg1 _ arr1 at: 2.			text1 _ self getText: id1.			list do: [ :arr2 |				id2 _ arr2 at: 1.				msg2 _ arr2 at: 2.				(id1 < id2 and: 				 [ (duplicates includes: id2) not and:				 [ msg2 _ self getMessage: id2.  msg1 to = msg2 to and:				 [ msg1 subject = msg2 subject and: 				 [ msg1 from = msg2 from and:				 [ text1 = (self getText: id2) ] ] ] ] ]) ifTrue: [ duplicates add: id2 ]. ] ] ].	^duplicates asArray! !!MailDB methodsFor: 'fetch-merge-compact' stamp: 'ls 9/17/1998 05:06'!importMailFrom: inboxFileName intoCategory: category	"Append the messages from the given mail inbox file to this mail database. Answer the number of messages fetched."	| inbox nextID count msg location |	"is there any mail?"	(StandardFileStream isAFileNamed: inboxFileName) ifFalse: [^0].	inbox _ MailInboxFile openOn: inboxFileName.	nextID _ self nextUnusedID.	count _ 0.	messageFile beginAppend.	inbox mailMessagesDo:		[: msgText |		 msg _ MailMessage from: msgText.		 location _ messageFile basicAppend: msg text id: nextID.		 indexFile			at: nextID			put: (IndexFileEntry					message: msg					location: location					messageFile: messageFile					msgID: nextID).		 categoriesFile file: nextID inCategory: category.		 nextID _ nextID + 1.		 count _ count + 1].	messageFile endAppend.	LastID _ nextID.	"snapshot the database and remove the inbox file"	self saveDB.	^count! !!MailDB methodsFor: 'fetch-merge-compact'!mergeMessages: msgIDList from: sourceDB	"Merge the given collection of messages from the source database into the receiver. When a message being added has the same message ID as an existing message, check to see if the two message texts are identical. If so, do not store the duplicate message. If the texts are different, make a new ID for the message being added. This operation will also copy the category information from the sourceDB, creating new catetories if necessary."	| msgText newMsgID saveIt msg location entry |	messageFile beginAppend.	msgIDList do:		[: oldMsgID |		 msgText _ sourceDB getText: oldMsgID.		 "resolve ID conflicts"		 (indexFile includesKey: oldMsgID)			ifFalse:	"no ID conflict"				[newMsgID _ oldMsgID.				 saveIt _ true]			ifTrue:	"resolve an ID conflict"				[(msgText = (self getText: oldMsgID))					ifTrue:	"identical text; don't save again"						[newMsgID _ oldMsgID.						 saveIt _ false]					ifFalse:	"different text; save with new ID"						[newMsgID _ self nextUnusedID.						 saveIt _ true]].		 "save the message in the destination DB"		 saveIt ifTrue:			[msg _ MailMessage from: msgText.			 location _ messageFile basicAppend: msg text id: newMsgID.			 entry _ IndexFileEntry						message: msg						location: location 						messageFile: messageFile						msgID: newMsgID.			 indexFile at: newMsgID put: entry].		 "update the categories for the message in the destination DB"		 (sourceDB categoriesThatInclude: oldMsgID) do:			[: categoryName |			 self file: newMsgID inCategory: categoryName]].	messageFile endAppend.! !!MailDB methodsFor: 'fetch-merge-compact'!nextUnusedID	"Answer the next unused message identifier. Message ID's are a monotonically increasing series roughly related to the time that they were requested. We use a block of message ID's based on the starting ID computed here. The last ID used is kept in LastID, to be sure that we don't reuse an already allocated ID."	| id |	"initialize LastID the first time it is used"	(LastID isNil) ifTrue: [LastID _ 0]. 	"message ID's are roughly the number of seconds since the beginning of 1980"	id _ Date today asSeconds + Time now asSeconds -		(Date newDay: 1 year: 1980) asSeconds.	id _ id max: (LastID + 1).	"never go backwards!!"	^id! !!MailDB methodsFor: 'categories'!addCategory: categoryName	"Create a category with the given name if one doesn't already exist."	categoriesFile addCategory: categoryName.! !!MailDB methodsFor: 'categories' stamp: 'ls 9/12/1998 02:17'!addNewMessage: message inCategory: category	"add the given message to the database, putting it in the given category.	Returns the message id"	|id location |	id _ self nextUnusedID.	location _ messageFile append: message text  id: id.	indexFile		at: id		put: (IndexFileEntry				message: message				location: location				messageFile: messageFile				msgID: id).	categoriesFile file: id inCategory: category.	^id! !!MailDB methodsFor: 'categories'!allCategories	"Answer a list of categories sorted in alphabetical order, including the special categories."	^categoriesFile categories asSortedCollection asOrderedCollection! !!MailDB methodsFor: 'categories'!categoriesThatInclude: msgID	"Answer a collection of names for real categories that include the message with the given ID. Pseudo-categories (such as '.unclassified.') are not considered real categories."	^categoriesFile categories select:		[: catName |		 (categoriesFile messagesIn: catName) includes: msgID]! !!MailDB methodsFor: 'categories'!file: msgID inCategory: categoryName	"File the message with the given ID in the given category."	categoriesFile file: msgID inCategory: categoryName.! !!MailDB methodsFor: 'categories'!fileAll: msgIDList inCategory: categoryName	"File all the messages with ID's in the given list in the given category."	msgIDList do:		[: msgID |		 categoriesFile file: msgID inCategory: categoryName].! !!MailDB methodsFor: 'categories'!messagesIn: categoryName	"Answer a collection of message ID's for the messages in the given category, sorted in ascending time order.  If the category does not exist, answer an empty collection. The pseudo-categories '.all.' and '.unclassified.' are computed dynamically, which may take a little time."	| msgList category |	(categoryName = '.unclassified.') ifTrue:		[Cursor execute showWhile:			[msgList _ categoriesFile unclassifiedFrom: indexFile keys].		 ^msgList].	(categoryName = '.all.') ifTrue:		[^indexFile keys].	"otherwise, it is a real category"	category _ categoriesFile messagesIn: categoryName.	^indexFile keys select:		"indexFile keys is sorted"		[: msgID | category includes: msgID]! !!MailDB methodsFor: 'categories'!remove: msgID fromCategory: categoryName	"Remove the message with the given ID from the given category."	categoriesFile remove: msgID fromCategory: categoryName.! !!MailDB methodsFor: 'categories'!removeAll: msgIDList fromCategory: categoryName	"Remove all the messages with ID's in the given list from the given category."	msgIDList do:		[: msgID |		 categoriesFile remove: msgID fromCategory: categoryName].! !!MailDB methodsFor: 'categories'!removeCategory: categoryName	"Remove the category with the given name. This does nothing if the category does not exist or if it is a pseudo-category."	categoriesFile removeCategory: categoryName.! !!MailDB methodsFor: 'categories'!removeFromAllCategories: msgID	"Remove the message with the given ID from all categories. The message will appear in 'unclassified'."	categoriesFile categories do:		[: categoryName |		 categoriesFile remove: msgID fromCategory: categoryName].! !!MailDB methodsFor: 'categories'!renameCategory: oldName to: newName	"Rename the given category. This does nothing if the category does not exist or if it is a special category ('new', '.all.', or '.unclassified.')."	categoriesFile renameCategory: oldName to: newName.! !!MailDB methodsFor: 'messages'!delete: msgID	"Delete the messages with the given ID from the message file. In contrast to simply removing a message from a category, this is permanent!!"	messageFile		deleteMessageAt: (indexFile at: msgID) location		id: msgID.	indexFile remove: msgID.	self cleanUpCategories.! !!MailDB methodsFor: 'messages'!deleteAll: msgIDList	"Delete all the messages with ID's in the given list from the message file. This is permanent!!"	msgIDList do:		[: msgID |		 messageFile			deleteMessageAt: (indexFile at: msgID) location			id: msgID.		 indexFile remove: msgID].	self cleanUpCategories.! !!MailDB methodsFor: 'messages'!getMessage: msgID	"Answer the MailMessage with the given ID."	^MailMessage from: (self getText: msgID)! !!MailDB methodsFor: 'messages'!getTOCentry: msgID	"Answer the table-of-contents entry for the message with the given ID."	^indexFile at: msgID! !!MailDB methodsFor: 'messages'!getTOCstring: msgID	"Answer the table-of-contents string for the message with the given ID."	^(indexFile at: msgID) tocString! !!MailDB methodsFor: 'messages'!getText: msgID	"Answer the text for the message with the given ID."	| entry |	entry _ indexFile at: msgID.	^messageFile		getMessage: msgID		at: entry location		textLength: entry textLength! !!MailDB methodsFor: 'messages'!newText: newText for: msgID	"Replace the text for the message with the given ID."	| oldLocation newLocation newEntry |	oldLocation _ (indexFile at: msgID) location.	newLocation _ messageFile update: newText at: oldLocation id: msgID.	newEntry _ IndexFileEntry		message: (MailMessage from: newText)		location: newLocation		messageFile: messageFile		msgID: msgID.	indexFile at: msgID put: newEntry.! !!MailDB methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: 'a MailDB on ''', rootFilename, ''''.! !!MailDB methodsFor: 'private' stamp: 'ls 9/12/1998 00:26'!do: aBlock  andInform: aString	"evaluate aBlock.  If aString is non-nil, display it to the user while doing the evaluation"	^aString		ifNil: [ aBlock value ]		ifNotNil: [ Utilities informUser: aString during: aBlock ]! !!MailDB methodsFor: 'private' stamp: 'ls 9/12/1998 01:12'!showProgress: showProgress  from: start  to:  end message: message during: aBlock	"evaluate aBlock.  If showProgress is true, then displaya progress meter while evaluating"	showProgress ifFalse: [ ^aBlock value: [ :ignored | ] ].	^message displayProgressAt: Sensor mousePoint from: start to: end during: aBlock! !!MailDB class methodsFor: 'instance creation'!openOn: rootFilename	"Open or create a mail database with the given root filename. If an instance of me exists with the given root filename, return a reference to that instance rather than creating a new one. This allows multiple MailReaders to be open on the same database without synchronization problems."	| alreadyOpenDB |	alreadyOpenDB _ self allInstances		detect:			[: db |			 (db rootFilename notNil) and:			 [db rootFilename = rootFilename]]		ifNone: [nil].	(alreadyOpenDB notNil)		ifTrue: [^alreadyOpenDB]		ifFalse: [^(self new) openOn: rootFilename].! !!MailDB class methodsFor: 'utilities'!readIntegerLineFrom: aStream	"Read a positive integer from the given stream. Answer zero if there are no digits. Consume the stream through the next carriage return."	| digit value |	value _ 0.	[aStream atEnd] whileFalse: 		[digit _ aStream next digitValue.		 ((digit >= 0) & (digit <= 9))			ifTrue: 				[value _ (value * 10) + digit]			ifFalse:				[(digit == Character cr digitValue) ifFalse:					[self skipRestOfLine: aStream].				 ^value]].	^value! !!MailDB class methodsFor: 'utilities' stamp: 'ls 9/8/1998 05:19'!readStringLineFrom: aStream 	"Read and answer the next line from the given stream. Consume the carriage return but do not append it to the string."	| |	^aStream upTo: Character cr! !!MailDB class methodsFor: 'utilities'!skipRestOfLine: aStream	"Consume characters from the given stream through the next carriage return."	| crValue |	crValue _ Character cr asciiValue.	[aStream atEnd or:	 [aStream next asciiValue == crValue]] whileFalse:		["consume until end of stream or a carriage return"].! !I am an abstract class that collects some of the operations common to all mail database files.!!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:40'!delete	"Delete this file."	FileDirectory splitName: filename to: [:dirPath :name |		(FileDirectory forFileName: filename) 			deleteFileNamed: name ifAbsent: []].! !!MailDBFile methodsFor: 'file operations'!openOn: aFileName	"Initialize myself from the file with the given name."	| fileStream |	filename _ aFileName.	fileStream _ FileStream fileNamed: aFileName.	self readFrom: fileStream.	fileStream setToEnd; close; release.		"close and release the file stream"	fileStream _ nil.! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:35'!rename: newFileName	"Rename this file."	FileDirectory splitName: filename to: [:dirPath :oldFileName |		(FileDirectory forFileName: filename) 			rename: oldFileName toBe: newFileName].	filename _ newFileName.! !!MailDBFile methodsFor: 'file operations' stamp: 'ls 9/10/1998 01:00'!save	"Atomically save a representation of this object to its file. The old file is renamed to '<oldname>.bak' before the new file is written. If the write operation fails, the old file may be restored by renaming it. If it succeeds, the .bak file is deleted."	| f dir shortName |	"create the file if it doesn't already exist"	(StandardFileStream isAFileNamed: filename) ifFalse: [		f _ StandardFileStream new open: filename forWrite: true.		f close].	shortName _ FileDirectory localNameFor: filename.	dir _ FileDirectory forFileName: filename.	dir rename: shortName toBe: shortName, '.bak'.	f _ FileStream fileNamed: filename.	self writeOn: f.	f setToEnd; close.	dir deleteFileNamed: (shortName, '.bak') ifAbsent: [].! !!MailDBFile methodsFor: 'read-write'!readFrom: aStream	"Subclasses must override this method to provide a means of reading themselves into memory."	self subclassResponsibility! !!MailDBFile methodsFor: 'read-write'!writeOn: aStream	"Subclasses must override this method to provide a means of writing themseves out on their files."	self subclassResponsibility! !!MailDBFile methodsFor: 'error reporting'!reportInconsistency	"Report that the index file is not consistent with the messages file."	self error:'The .index file is not consistent with the .messages file. Thismay be fixed by compacting the mail database, whichwill rebuild the index file from scratch.'! !!MailDBFile class methodsFor: 'instance creation'!openOn: fileName	"Answer a new instance of me, backed by the file with the given name."	^(super new) openOn: fileName! !I am a parser for mail inboxes in a form found in the Unix '/var/spool' inboxes. This is also the format used by Eudora 3.0 on the Macintosh (and perhaps by other versions of Eudora as well).!!MailInboxFile methodsFor: 'read-write'!readFrom: aStream	"This operation is a noop for mail inboxes. Use 'messagesDo:' to enumerate the messages in the inbox."! !!MailInboxFile methodsFor: 'read-write'!writeOn: aStream	"This operation is illegal for mail inboxes."	self error: 'Mail inboxes are read only!!'! !!MailInboxFile methodsFor: 'scanning'!delimitersDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText delim |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	[self scanToNextMessageIn: stream] whileTrue: [		aBlock value: (MailDB readStringLineFrom: stream)].	fileStream = nil ifFalse: [fileStream close].! !!MailInboxFile methodsFor: 'scanning'!findPossibleMessageStart: aStream	"Find the next line starting with the string 'From' followed by a space. Leave the input stream positioned at the character following the space."	(self nextStringIs: 'From ' in: aStream) ifTrue: [^true].	[true] whileTrue: [		aStream skipTo: Character cr.		[aStream peek = Character cr] whileTrue: [aStream next].		(self nextStringIs: 'From ' in: aStream) ifTrue: [^true].		aStream atEnd ifTrue: [^false].	].! !!MailInboxFile methodsFor: 'scanning'!mailMessagesDo: aBlock	"Invoke the given block for each message in the mail inbox. The block argument is the text of a new message."	| fileStream stream msgStart msgSize msgText |	fileStream _ FileStream fileNamed: filename.	Smalltalk garbageCollect.	(fileStream size < (Smalltalk bytesLeft - 200000))		ifTrue: [			"if possible, buffer the entire file in memory for speed"			stream _ ReadStream on: (fileStream contentsOfEntireFile).			fileStream _ nil]		ifFalse: [			"otherwise, use the actual file stream, reading from disk"			stream _ fileStream].	self scanToNextMessageIn: stream.	MailDB skipRestOfLine: stream.  "skip message delimiter"	msgStart _ stream position.	[self scanToNextMessageIn: stream] whileTrue: [		msgSize _ stream position - msgStart.		stream position: msgStart.		msgText _ stream next: msgSize.		MailDB skipRestOfLine: stream.  "skip message delimiter"		msgStart _ stream position.		aBlock value: msgText].	"process final message"	msgSize _ stream position - msgStart.	msgSize > 0 ifTrue: [		stream position: msgStart.		msgText _ stream next: msgSize.		aBlock value: msgText].	fileStream = nil ifFalse: [fileStream close].! !!MailInboxFile methodsFor: 'scanning'!nextStringIs: aString in: aStream	"If the next characters of the given stream form the given string, then advance the stream position by the size of the string and return true. Otherwise, leave the stream untouched and return false."	| oldPosition |	oldPosition _ aStream position.	1 to: aString size do: [ :i |		aStream next = (aString at: i) ifFalse: [			aStream position: oldPosition.			^false		].	].	aStream position: oldPosition.	^true! !!MailInboxFile methodsFor: 'scanning' stamp: 'ls 8/21/1998 10:21'!scanToNextMessageIn: aStream	"Scan to the start of the next message in the given stream. Answer true if we find a message delimiter, false if we hit the end of the stream first. The stream is left positioned at the start of the next message or at the end of the stream."	| msgStart line dayOfWeek year |	[aStream atEnd] whileFalse: [		(self findPossibleMessageStart: aStream) ifFalse: [^false].		msgStart _ aStream position.		aStream next: 5.  "skip 'From '"		"skip address"		[aStream peek isSeparator] whileFalse: [aStream next].		[aStream peek = Character space] whileTrue: [aStream next].		line _ MailDB readStringLineFrom: aStream.		line size >= 7 ifTrue: [			dayOfWeek _ (line copyFrom: 1 to: 3) asLowercase.			year _ (line copyFrom: line size - 3 to: line size) asNumber.			((#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: dayOfWeek) and:			[(year > 1900) and: [year < 2100]]) ifTrue: [				aStream position: msgStart.				^true  "found a message!!"			].		].	].	^false! !I represent a mail or news message. I parse the message header and keep certain header fields in instance variables for rapid access.!!MailMessage methodsFor: 'initialize-release'!from: aString	"Parse the given string to initialize myself. The given string will become my text."	time _ 0.	from _ to _ cc _ subject _ ''.	text _ self removeTrailingSeparators: aString.	self fieldsFrom: (ReadStream on: text) do:		[: fName : fValue |		 (fName = 'date') ifTrue: [time _ self timeFrom: fValue].		 (fName = 'from') ifTrue: [from _ fValue].		 (fName = 'to') ifTrue: [to isEmpty ifTrue: [to _ fValue] ifFalse: [to _ to, ', ', fValue]].		 (fName = 'cc') ifTrue: [cc isEmpty ifTrue: [cc _ fValue] ifFalse: [cc _ cc, ', ', fValue]].		 (fName = 'subject') ifTrue: [subject _ fValue]].! !!MailMessage methodsFor: 'initialize-release'!removeTrailingSeparators: aString	"Answer a new string that is aString with all trailing white space characters removed."	| i |	i _ aString size.	[(i > 0) and: [(aString at: i) isSeparator]] whileTrue: [i _ i - 1].	(i > 1)		ifTrue: [^aString copyFrom: 1 to: i]		ifFalse: [^''].! !!MailMessage methodsFor: 'access' stamp: 'ls 9/13/1998 06:15'!body	"return just the body of the message"	| s |	s _ ReadStream on: self text.	"scan until a blank line is seen"	[ s atEnd not and: [ (s peek = Character cr) not ] ] whileTrue: [		s upTo: Character cr ].	s next. 	"skip the blank line"	"the body is the rest of the text"	^s upToEnd! !!MailMessage methodsFor: 'access'!cc	^cc! !!MailMessage methodsFor: 'access'!date	"Answer a date string for this message."	^(Time aTime: (time + (Date newDay: 1 year: 1980) asSeconds)) first		printFormat: #(2 1 3 47 1 2)! !!MailMessage methodsFor: 'access'!from	^from! !!MailMessage methodsFor: 'access'!subject	^subject! !!MailMessage methodsFor: 'access'!text	^text! !!MailMessage methodsFor: 'access'!time	^time! !!MailMessage methodsFor: 'access'!to	^to! !!MailMessage methodsFor: 'parsing' stamp: 'ls 9/13/1998 02:27'!fieldsFrom: aStream do: aBlock	"Invoke the given block with each of the header fields from the given stream. The block arguments are the field name and value."	| savedLine line s |	savedLine _ MailDB readStringLineFrom: aStream.	[aStream atEnd] whileFalse: [		line _ savedLine.		(line isEmpty) ifTrue: [^self].  "quit when we hit a blank line"		[savedLine _ MailDB readStringLineFrom: aStream.		 (savedLine size > 0) and: [savedLine first isSeparator]] whileTrue: [			"lines starting with white space are continuation lines"			s _ ReadStream on: savedLine.			s skipSeparators; skip: -1.			line _ line, s upToEnd].		self reportField: line withBlanksTrimmed to: aBlock].	"process final header line of a body-less message"	(savedLine isEmpty) ifFalse: [self reportField: savedLine withBlanksTrimmed to: aBlock].! !!MailMessage methodsFor: 'parsing'!readDateFrom: aStream	"Parse a date from the given stream and answer nil if the date can't be parsed. The date may be in any of the following forms:		<day> <monthName> <year>		(5 April 1982; 5-APR-82)		<monthName> <day> <year>		(April 5, 1982)		<monthNumber> <day> <year>		(4/5/82)	In addition, the date may be preceded by the day of the week and an optional comma, such as:		Tue, November 14, 1989"	| day month year |	self skipWeekdayName: aStream.	aStream peek isDigit ifTrue: [day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue:		"month name or weekday name"			[month _ WriteStream on: (String new: 10).			 [aStream peek isLetter] whileTrue: [month nextPut: aStream next].			 month _ month contents.			 day isNil ifTrue:		"name/number..."				[[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].				 (aStream peek isDigit) ifFalse: [^nil].				 day _ Integer readFrom: aStream]]		ifFalse:		"number/number..."			[month _ Date nameOfMonth: day.			 day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	(aStream peek isDigit) ifFalse: [^nil].	year _ Integer readFrom: aStream.	^Date newDay: day month: month year: year! !!MailMessage methodsFor: 'parsing'!reportField: aString to: aBlock	"Evaluate the given block with the field name a value in the given field. Do nothing if the field has an empty value part."	| s fieldName fieldValue |	s _ ReadStream on: aString.	fieldName _ (s upTo: $:) asLowercase.	s skipSeparators.	(s atEnd) ifFalse: [		"field is not empty"		fieldValue _ s upToEnd.		aBlock value: fieldName value: fieldValue].! !!MailMessage methodsFor: 'parsing'!skipWeekdayName: aStream	"If the given stream starts with a weekday name or its abbreviation, advance the stream to the first alphaNumeric character following the weekday name."	| position name abbrev |	aStream skipSeparators.	(aStream peek isDigit) ifTrue: [^self].	(aStream peek isLetter) ifTrue:		[position _ aStream position.		 name _ WriteStream on: (String new: 10).		 [aStream peek isLetter] whileTrue: [name nextPut: aStream next].		 abbrev _ (name contents copyFrom: 1 to: (3 min: name position)).		 abbrev _ abbrev asLowercase.		 (#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: abbrev asLowercase)			ifTrue:				["found a weekday; skip to the next alphanumeric character"				 [aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]			ifFalse:				["didn't find a weekday so restore stream position"				 aStream position: position]].! !!MailMessage methodsFor: 'parsing'!timeFrom: aString	"Parse the date and time and answer the result as the number of seconds since the start of 1980. The time is interpreted in the sender's time-zone; it should really be converted to GMT, depending on the timezone of the sender..."	| s t |	s _ ReadStream on: aString.	t _ (self readDateFrom: s) asSeconds.  "date part"	[s atEnd or: [s peek isAlphaNumeric]] whileFalse: [s next].	(s atEnd) ifFalse:		["read time part (interpreted as local, regardless of sender's timezone)"		 t _ t + (Time readFrom: s) asSeconds].	^t - (Date newDay: 1 year: 1980) asSeconds		"time started with 1980..."! !!MailMessage methodsFor: 'printing/formatting'!eudoraOutboxText	"Return this message formatted for inclusion in a Eudora outbox."	| old new |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	MailMessage new fieldsFrom: old do: [ :fName :fValue | "skip header fields" ].	new nextPutAll: 'To: ';		nextPutAll: to; cr.	new nextPutAll: 'From: ';	nextPutAll: from; cr.	new nextPutAll: 'Subject: ';	nextPutAll: subject; cr.	new nextPutAll: 'Cc: ';		nextPutAll: cc; cr.	new nextPutAll: 'Bcc: '; cr.	new nextPutAll: 'X-attachments: '; cr.	new cr.	new nextPutAll: old upToEnd.	^new contents! !!MailMessage methodsFor: 'printing/formatting'!format	"Replace the text of this message with a formatted version."	"NOTE: This operation discards extra header fields."	text _ self formattedText.! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 9/8/1998 05:17'!formattedText	"Answer a version of my text with a cleaned up header."	| old new header body |	old _ ReadStream on: text.	new _ WriteStream on: (String new: text size).	self fieldsFrom: old do:		[: fName : fValue |		 (#('received'			'return-path'			'newsgroups'			'message-id'			'path'			'reply-to'			'in-reply-to'			'sender'			'x-sender'			'fonts'			'x-mailer'			'mime-version'			'x-uidl'			'status'			'content-type'			'content-transfer-encoding'			'errors-to'			'keywords'			'references'			'x-vms-to'			'x-delivery-notice'			'x-reply-of'			'x-newsreader'			'x-icon'			'x-mailing-list'			'x-loop'			'x-priority'			'x-msmail-priority'			'x-mimeole'			'x-organization'			'x-originating-ip'			'x-sun-charset'			'x-url'			'x-nextstep-mailer'			'x-authentication-warning'			'x-lotus-fromdomain'			'x-blackmail'			'x-authenticated-timestamp'			'nntp-posting-host'			'lines'			'return-receipt-to'			'precedence'			'originator'			'distribution'			'content-disposition'			'importance'			'resent-to'			'resent-cc'			'resent-message-id'			'resent-date'			'resent-sender'			'resent-from') includes: fName) ifFalse:				[new nextPutAll: fName capitalized.				 new nextPutAll: ': '.				 new nextPutAll: fValue; cr]].	new cr.	header _ new contents.	body _ old upToEnd.	^header, body! !!MailMessage methodsFor: 'printing/formatting'!replace: oldString with: newString in: aString	"Replace all occurances of oldString in the given string with newString."	| target where |	target _ aString.	where _ 1.	[(where _ target findString: oldString startingAt: where) = 0] whileFalse:		[target _ target					copyReplaceFrom: where					to: where + oldString size - 1					with: newString].	^target! !!MailMessage class methodsFor: 'instance creation'!from: aString	"Initialize a new instance from the given string."	^(self new) from: aString! !a URL specifying a mailing address; activating it triggers a mail-sender to start up, if one is present.!!MailtoUrl methodsFor: 'downloading' stamp: 'ls 8/12/1998 21:05'!activate	(Smalltalk includesKey: #EmailWindow) ifTrue: [		(Smalltalk at: #EmailWindow) beginNewMessageTo: self locator	].	self notify: 'no mail reader present'! !!MenuItemMorph methodsFor: 'events' stamp: 'jm 6/15/1998 12:18'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	| mouseInMe |	mouseInMe _ self boundsInWorld containsPoint: evt cursorPoint.	self deselectItem.	self isInMenu ifTrue: [		(mouseInMe and: [self selector = #toggleStayUp:])			ifFalse: [owner deleteIfPopUp].		subMenu ifNil: [			mouseInMe ifTrue: [				evt hand world displayWorld.				owner invokeItem: self]]].! !!MenuItemMorph methodsFor: 'private' stamp: 'di 8/8/1998 09:22'!selectFromHand: aHand	self isSelected: true.	aHand newMouseFocus: self.	subMenu ifNotNil: [		subMenu delete.		subMenu			popUpAdjacentTo: (Array with: self bounds topRight + (10@0)									with: self bounds topLeft)			forHand: aHand			from: self].! !!MenuMorph methodsFor: 'construction' stamp: 'di 9/22/1998 20:29'!addStayUpItem	"Append a menu item that can be used to toggle this menu's persistent."	self add: 'keep this menu up'		target: self		selector: #toggleStayUp:		argumentList: EmptyArray.	self addLine! !!MenuMorph methodsFor: 'construction' stamp: 'di 8/20/1998 09:30'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!MenuMorph methodsFor: 'control' stamp: 'di 8/8/1998 09:48'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta tryToPlace selectedOffset |	popUpOwner _ sourceItem.	originalEvent _ MorphicEvent new setHand: hand.	selectedItem _ self items detect: [:each | each == lastSelection]							ifNone: [self items first].	self fullBounds.  "ensure layout is current"	selectedOffset := selectedItem position - self position.	tryToPlace :=		[ :where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'di 6/22/1998 15:15'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	popUpOwner _ hand.	selectedItem _ self items detect: [:each | each == lastSelection] ifNone: [self items first].	"Note: items may not be laid out yet (I found them all to be at 0@0),		so have to add up heights of items above the selected item."	i _ 0.  yOffset _ 0.	[(sub _ self submorphs at: (i _ i+1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2@(yOffset + 8)).	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self.	hand newMouseFocus: selectedItem.	self changed.! !I represent the messages file of a mail database. This file is treated as (mostly) append-only. All new messages or edited messages are appended to the end of this file.Messages are stored as ASCII text with seperator strings and some additional information between each message. If necessary, this file can be inspected or edited with a text editor; after editing, the index file should be recreated using the "compact" command. (This is necessary because the offsets kept in the index file will probably be different after the edits.)When a message is deleted, its delimiter is changed to mark it as deleted, but it is left in the mail file until the next time "compact" command is executed. Generally, the reduction in disk fragmentation resulting from keeping the messages in a single file more than offsets the temporary space lost by having a few deleted messages hanging around between compactions. Compaction is done into a new copy of the file, followed by a renaming operation. Thus, if compaction fails, the original messages file will not be lost.!!MessageFile methodsFor: 'file operations' stamp: 'jm 9/21/1998 16:26'!close	"Close the file."	file ifNil: [^ self].	file		ensureOpen;		setToEnd;		close.	file _ nil.! !!MessageFile methodsFor: 'file operations'!delete	"I must close my file handle before the file can be deleted."	self close.	super delete.! !!MessageFile methodsFor: 'file operations' stamp: 'jm 9/21/1998 16:30'!ensureFileIsOpen	"Make sure that my file is open. The file is automatically closed on snapshots."	file		ifNil: [file _ FileStream fileNamed: filename]		ifNotNil: [file ensureOpen].! !!MessageFile methodsFor: 'file operations'!openOn: aFileName	"Initialize myself for the message file with the given name."	filename _ aFileName.	file _ nil.	self ensureFileIsOpen.! !!MessageFile methodsFor: 'file operations'!rename: newFileName	"I must close my file handle before the file can be renamed."	self close.	super rename: newFileName.! !!MessageFile methodsFor: 'file operations' stamp: 'jm 9/21/1998 16:27'!save	"Make sure the message file is flushed to disk. This is NOT atomic because MessageFiles can get large and there might not be enough disk space to save them atomically. Besides, it would be very slow."	file ifNil: [^ self].	file		ensureOpen;		setToEnd;		close;		reopen.! !!MessageFile methodsFor: 'message operations'!append: messageText id: messageID	"Append the given message text with the given unique identifier. Answer the new location of the message."	| location |	self beginAppend.	location _ self basicAppend: messageText id: messageID.	self endAppend.	^location! !!MessageFile methodsFor: 'message operations'!assertValidMessageAt: filePosition id: msgID	"Verify that the given filePosition is, indeed, the start of a message (possibly deleted) with the given ID and raise an error if this assertion is false."	| delimiter fileMsgID |	"assume file is open"	file position: filePosition.	delimiter _ file next: 10.	((delimiter = '&&&&&start') or: [delimiter = '&&&&&XXXXX']) ifFalse:		[^self reportInconsistency].	file next. "skip cr"	fileMsgID _ MailDB readIntegerLineFrom: file.	(msgID = fileMsgID) ifFalse:		[^self reportInconsistency].! !!MessageFile methodsFor: 'message operations'!basicAppend: messageText id: messageID	"Append the given message text with the given message ID. Answer the new location of the message."	"WARNING: This operation assumes:		1. the sender positioned the stream to the end of the file (using beginAppend), and		2. the sender will do an endAppend operation after all messages are appended to flush all file buffers to disk."	| location |	file setToEnd.	location _ file position.	file nextPutAll: '&&&&&start'.	"message delimiter"	file cr.	messageID printOn: file.		"message ID"	file cr.	file nextPutAll: messageText.	^location! !!MessageFile methodsFor: 'message operations'!beginAppend	"Set the file to the end prior to performing a sequence of basicAppend operations."	self ensureFileIsOpen.	file setToEnd.! !!MessageFile methodsFor: 'message operations'!deleteMessageAt: filePosition id: msgID	"Mark as deleted the message with the given ID located at the given file position."	self ensureFileIsOpen.	self assertValidMessageAt: filePosition id: msgID.	file position: filePosition.	file nextPutAll: '&&&&&XXXXX'.		"delimiter for deleted messages"	file flush.! !!MessageFile methodsFor: 'message operations'!endAppend	"Complete an append transaction by flushing the file to disk."	self save.! !!MessageFile methodsFor: 'message operations'!getMessage: msgID at: start textLength: textSize	"Retrieve the message with the given ID, location, and text size."	self ensureFileIsOpen.	self assertValidMessageAt: start id: msgID.	^file next: textSize! !!MessageFile methodsFor: 'message operations'!update: messageText at: oldMessagePosition id: msgID	"Atomically update the message having the old location and ID with the given new text (e.g. when the user has edited a message). Answer the new location of the message."	| newLocation |	newLocation _ self append: messageText id: msgID.	self deleteMessageAt: oldMessagePosition id: msgID.	^newLocation! !!MessageFile methodsFor: 'scanning'!messagesDo: aBlock	"Scan the message file and invoke the given block for each message in it. The block arguments are:	deleted			true if this message is marked deleted	msgID			the message ID	msgBody			the message textThis operation is very expensive."	| more deleted msgID textStart textSize msgBody |	self ensureFileIsOpen.	file position: 0.	more _ self scanToNextMessageIn: file.	[more] whileTrue:		[deleted _								"deleted"			(MailDB readStringLineFrom: file) = '&&&&&XXXXX'.		 msgID _ MailDB readIntegerLineFrom: file.	"msgID"		 textStart _ file position.		 more _ self scanToNextMessageIn: file.		 textSize _ file position - textStart.		 file position: textStart.		 msgBody _ file next: textSize.				"msgBody"		 aBlock valueWithArguments:			(Array				with: deleted				with: msgID				with: msgBody)].! !!MessageFile methodsFor: 'scanning'!scanToNextAndSigns: aStream	"Scan the given stream for a pair of and-sign (&) characters and answer true if they are found before the end of the stream is reached. The stream is left positioned after the second and-sign or at the end of the stream."	| ch |	[true] whileTrue:		[ch _ aStream next.		 ((ch == $&) and:		   [aStream next == $&]) ifTrue: [^true].	"found"		 (ch == nil) ifTrue: [^false]].	"end of file"! !!MessageFile methodsFor: 'scanning'!scanToNextMessageIn: aStream	"Scan to the start of the next message. Answer true if we find a message delimiter, false if we hit the end of the file first. The stream is left positioned at the start of the next message (at the message delimiter) or at the end of the stream."	| delimiter |	[self scanToNextAndSigns: aStream] whileTrue:		[delimiter _ aStream next: 8.		 ((delimiter = '&&&start') or: [delimiter = '&&&XXXXX'])			ifTrue: [aStream skip: -10. ^true]			ifFalse: [(delimiter includes: $&) ifTrue: [aStream skip: -8]]].	^false	"end of file"! !!MessageSet methodsFor: 'message list' stamp: 'di 9/21/1998 23:04'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		source _ class sourceMethodAt: selector ifAbsent: [^ 'Missing'].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil].		^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'message list' stamp: 'wod 6/16/1998 15:08'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	messageListIndex = 0 ifTrue: [^nil].	self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'contents' stamp: 'di 6/26/1998 09:03'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector |	messageListIndex = 0 ifTrue: [^ false].	self setClassAndSelectorIn: [:class :oldSelector].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	contents _ aString copy.	^ true! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/18/1998 12:23'!open: aMessageSet name: aString 	"Create a standard system view for the messageSet, aMessageSet, whose label is aString."	| topView aListView aBrowserCodeView |	World ifNotNil: [^ self openAsMorph: aMessageSet name: aString].	topView _ (StandardSystemView new) model: aMessageSet.	topView label: aString.	topView minimumSize: 180 @ 120.	topView borderWidth: 1.	aListView _ PluggableListView on: aMessageSet		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	aListView  menuTitleSelector: #messageListSelectorTitle.	aListView window: (0 @ 0 extent: 180 @ 100).	topView addSubView: aListView.	aBrowserCodeView _ PluggableTextView on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView window: (0 @ 0 extent: 180 @ 300).	topView addSubView: aBrowserCodeView below: aListView.	topView controller open! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/19/1998 13:51'!openAsMorph: aMessageSet name: labelString 	"Create a SystemWindow aMessageSet, with the label labelString, in a Morphic project"	^ self openAsMorph: aMessageSet name: labelString inWorld: World! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 8/18/1998 17:05'!openAsMorph: aMessageSet name: labelString inWorld: aWorld	"Create a SystemWindow aMessageSet, with the label labelString."	| window aListMorph |	self flag: #newBrowsers.	window _ (SystemWindow labelled: labelString) model: aMessageSet.	aListMorph _ PluggableListMorph on: aMessageSet list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 extent: 1@0.2).	window addMorph: (PluggableTextMorph on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.2 corner: 1@1).	window openInWorld: aWorld! !My instances add instance-specific behavior to various class-describing objects in the system. This typically includes messages for initializing class variables and instance creation messages particular to a class. There is only one instance of a particular Metaclass, namely the class which is being described. A Metaclass shares the class variables of its instance.	[Subtle] In general, the superclass hierarchy for metaclasses parallels that for classes. Thus,	Integer superclass == Number, and	Integer class superclass == Number class.However there is a singularity at Object. Here the class hierarchy terminates, but the metaclass hierarchy must wrap around to Class, since ALL metaclasses are subclasses of Class. Thus,	Object superclass == nil, and	Object class superclass == Class.[Subtle detail] A class is know by name to an environment.  Typically this is the SystemDictionary named Smalltalk.  If we ever make lightweight classes that are not in Smalltalk, they must be in some environment.  Specifically, the code that sets 'wasPresent' in name:inEnvironment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:comment:changed: must continue to work.!!Metaclass methodsFor: 'initialize-release' stamp: 'tk 8/21/1998 10:03'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	| newMeta invalid |	newMeta _ self copyForValidation.	invalid _ newMeta				subclassOf: superclass				oldClass: self				instanceVariableNames: instVarString				variable: false				words: true				pointers: true				ifBad: [^false].	(invalid or: [instVarString ~= self instanceVariablesString])		ifTrue: [newMeta validateFrom: self					in: Smalltalk					instanceVariableNames: true					methods: true					wasPresent: true.	"as far as we know"				Smalltalk changes changeClass: self]! !!Metaclass methodsFor: 'initialize-release' stamp: 'tk 8/22/1998 07:45'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. oldClass is a metaclass, so we know there is just one instance.  Permute variables as necessary."	| oldInstVarNames map variable new instSize oldInstances |	oldClass soleInstance == nil ifTrue: [^self].	"no instances to convert"	oldInstVarNames _ oldClass allInstVarNames.	map _ self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].	variable _ self isVariable.	instSize _ self instSize.	"Now perform a bulk mutation of old instances into new ones"	oldInstances _ Array with: oldClass soleInstance.	oldInstances elementsExchangeIdentityWith:		(oldInstances collect: 		[:old | 		variable			ifTrue: [new _ self basicNew: old basicSize]			ifFalse: [new _ self basicNew].		1 to: instSize do: 			[:offset |  (map at: offset) > 0 ifTrue:				[new instVarAt: offset						put: (old instVarAt: (map at: offset))]].		variable 			ifTrue: [1 to: old basicSize do: 						[:offset |						new basicAt: offset put: (old basicAt: offset)]].		new])! !!Metaclass methodsFor: 'accessing' stamp: 'tk 6/17/1998 09:48'!isSystemDefined	"Answer false if I am a UniClass (an instance-specific lightweight class)"	^ true! !!Metaclass methodsFor: 'copying' stamp: 'tk 8/19/1998 16:16'!veryDeepCopyWith: deepCopier	"Return self.  Must be created, not copied.  Do not record me."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'tk 8/22/1998 10:46'!name: newName inEnvironment: environ subclassOf: sup instanceVariableNames: instVarString variable: v words: w pointers: p classVariableNames: classVarString poolDictionaries: poolString category: categoryName comment: commentString changed: changed 	"This is the standard initialization message for creating a new Metaclass. 	Answer an instance of me from the information provided in the 	arguments. Create an error notification if the name does not begin with 	an uppercase letter or if a class of the same name already exists.	1/22/96 sw: don't ever do addClass, always do changeClass"	| wasPresent oldClass newClass invalidFields invalidMethods |	newName first isUppercase		ifFalse: 			[self error: 'Class names must be capitalized'.			^false].	(wasPresent _ environ includesKey: newName)		ifTrue: 			[oldClass _ environ at: newName.			(oldClass isKindOf: Behavior)				ifFalse: 					[self error: newName , ' already exists!!  Proceed will store over it'.					wasPresent _ false.					oldClass _ self newNamed: newName]]		ifFalse: [oldClass _ self newNamed: newName.				Smalltalk flushClassNameCache].	newClass _ oldClass copy.	invalidFields _ changed | (newClass					subclassOf: sup					oldClass: oldClass					instanceVariableNames: instVarString					variable: v					words: w					pointers: p					ifBad: [^false]).	invalidFields not & (oldClass instSize = newClass instSize)		ifTrue: [newClass _ oldClass].	invalidMethods _ invalidFields | (newClass declare: classVarString) | 		(newClass sharing: poolString).	commentString == nil ifFalse: [newClass comment: commentString].	(environ includesKey: newName)		ifFalse: [environ declare: newName from: Undeclared].	environ at: newName put: newClass.	SystemOrganization classify: newClass name under: categoryName asSymbol.	newClass		validateFrom: oldClass		in: environ		instanceVariableNames: invalidFields		methods: invalidMethods		wasPresent: wasPresent.	"update subclass lists"	newClass superclass removeSubclass: oldClass.	newClass superclass addSubclass: newClass.	"Update Changes"	Smalltalk changes changeClass: newClass.	^ newClass! !!MethodNode methodsFor: 'printing' stamp: 'di 8/24/1998 12:13'!printOn: aStream 	| args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttribute: (TextColor color: Color green)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttribute: (TextColor color: Color green)				do: [temporaries do: 					[:temp | 					aStream nextPutAll: temp key.					aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[(primitive between: 256 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^block printStatementsOn: aStream indent: 0! !!MixedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:05'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur max: snd duration].	^ dur! !A morph (from the Greek "shape" or "form") is an interactive graphical object.All morphs owned by a morph are held in submorphs.  All coordinates are global screen coordinates.  (Except those that are flexed, contained inside a FlexMorph.)All show unless they are 'hidden'.  Hidden morphs: are still in submorphs have a position of about 1000000@100000 have a property #relPos that is its relative position inside its owner. has a property #hidden set to true. when fullBounds of a morph is computed, don't include morphs that have the property hidden = true. "Stop" must not move hidden morphs back onto the playfield (PasteUpMorph)!!Morph methodsFor: 'initialization' stamp: 'di 8/10/1998 13:08'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ EmptyArray.	color _ Color blue.! !!Morph methodsFor: 'initialization' stamp: 'jm 7/5/1998 12:40'!openInMVC	MorphWorldView		openWorldWith: self		labelled: self defaultLabelForInspector.! !!Morph methodsFor: 'initialization' stamp: 'di 8/17/1998 20:59'!openInWorld	"Add this morph to the world.  If in MVC, then provide a Morphic window for it."	Smalltalk isMorphic ifFalse: [^ self openInMVC].	World addMorph: self.	World startSteppingSubmorphsOf: self.! !!Morph methodsFor: 'initialization' stamp: 'sw 8/4/1998 18:20'!openInWorld: aWorld	"Add this morph to the requested World."	aWorld addMorph: self! !!Morph methodsFor: 'initialization' stamp: 'sw 9/11/1998 11:13'!standardPalette	"Answer a standard palette forced by some level of enclosing presenter, or nil if none"	| pal aPresenter itsOwner |	(aPresenter _ self presenter) ifNil: [^ nil].	^ (pal _ aPresenter ownStandardPalette)		ifNotNil: [pal]		ifNil:	[(itsOwner _ aPresenter associatedMorph owner)					ifNotNil:						[itsOwner standardPalette]					ifNil:						[nil]]! !!Morph methodsFor: 'accessing' stamp: 'sw 8/11/1998 16:46'!actorState	"This method instantiates actorState as a side-effect.	For simple queries, use actorStateOrNil"	| state |	state _ self actorStateOrNil.	state ifNil:		[state _ ActorState new initializeFor: self assuredPlayer.		self actorState: state].	^ state! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:05'!actorState: anActorState	extension == nil ifTrue: [self assureExtension].	extension actorState: anActorState! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:06'!actorStateOrNil	extension == nil ifTrue: [^ nil].	^ extension actorState! !!Morph methodsFor: 'accessing' stamp: 'sw 8/19/1998 11:55'!balloonHelpTextForHandle: aHandle	|  itsSelector |	itsSelector _ aHandle eventHandler firstMouseSelector.	#(	(startRot:with:				'Rotate')		(startGrow:with:				'Change size') 		(doDup:with:				'Duplicate')		(maybeDoDup:with:			'Duplicate')		(doGrab:with:				'Pick up')		(startDrag:with:				'Move')		(doMenu:with:				'Menu')		(doDebug:with:				'Debug')		(mouseDownOnHelpHandle:	'Help')		(tearOffTile					'Make a Tile')		(paintBackground			'Paint background')		(openViewerForArgument	'View me')		(dismiss						'Remove')		(editDrawing				'Repaint')		(startScale:with:				'Change scale') 		(chooseFont					'Change font')		(chooseStyle					'Change style')		(chooseEmphasis				'Change emphasis')		(makeNewDrawingWithin	'Paint new object'))  "This last one not currently in use"	do:		[:pair | itsSelector == pair first ifTrue: [^ pair last]].	^ 'unknown halo handle'! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:07'!balloonText	"NB: subclasses may override such that they programatically construct the text, for economy's sake, such as model phrases in a Viewer"	| val |	extension == nil ifTrue: [^ nil].	(val _  extension balloonText) ifNotNil: [^ val].	(val _ extension balloonTextSelector) ifNotNil:		[^ ScriptingSystem helpStringFor: val].	^ nil! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:07'!balloonTextSelector: aSelector	extension == nil ifTrue: [self assureExtension].	extension balloonTextSelector: aSelector! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:07'!beSticky	extension == nil ifTrue: [self assureExtension].	extension sticky: true! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:08'!eventHandler	extension == nil ifTrue: [^ nil].	^ extension eventHandler! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:08'!eventHandler: anEventHandler	"Note that morphs can share eventHandlers and all is OK.  "	extension == nil ifTrue: [self assureExtension].	extension eventHandler: anEventHandler! !!Morph methodsFor: 'accessing' stamp: 'tk 7/31/1998 13:47'!forwardDirection	"Default implementation."	^ 0.0! !!Morph methodsFor: 'accessing' stamp: 'jm 6/2/1998 15:54'!hasTranslucentColor	"Answer true if this any of this morph's colors is translucent."	^ color isColor and: [color alpha < 1.0]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:47'!highlightColor		| val |	^ (val _ self valueOfProperty: #highlightColor)		ifNotNil:			[val]		ifNil:			[owner highlightColor]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:51'!highlightColor: aColor	self setProperty: #highlightColor toValue: aColor! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:09'!isLocked	extension == nil ifTrue: [^ false].	^ extension locked! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!isSticky	extension == nil ifTrue: [^ false].	^ extension sticky! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!lock: aBoolean	extension == nil ifTrue:		[aBoolean ifFalse: [^ self].		self assureExtension].	extension locked: aBoolean! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!player	extension == nil ifTrue: [^ nil].	^ extension player! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:10'!player: anObject	extension == nil ifTrue: [self assureExtension].	extension player: anObject! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:48'!regularColor		| val |	^ (val _ self valueOfProperty: #regularColor)		ifNotNil:			[val]		ifNil:			[owner regularColor]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:51'!regularColor: aColor	self setProperty: #regularColor toValue: aColor! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 22:12'!toggleStickiness	extension == nil ifTrue: [^ self beSticky].	extension sticky: extension sticky not! !!Morph methodsFor: 'accessing' stamp: 'di 8/11/1998 12:33'!unlock	self lock: false! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:09'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	extension == nil ifTrue: [^ false].	^ extension hasProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/16/1998 11:13'!removeProperty: propName	extension == nil ifTrue: [^ self].	extension removeProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:12'!setProperty: propName toValue: aValue	aValue ifNil: [^ self removeProperty: propName].	extension == nil ifTrue: [self assureExtension].	extension setProperty: propName toValue: aValue! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:13'!valueOfProperty: propName	extension == nil ifTrue: [^ nil].	^ extension valueOfProperty: propName! !!Morph methodsFor: 'access properties' stamp: 'di 8/11/1998 22:13'!valueOfProperty: propName ifAbsent: aBlock	extension == nil ifTrue: [^ aBlock value].	^ extension valueOfProperty: propName ifAbsent: aBlock! !!Morph methodsFor: 'copying' stamp: 'di 8/11/1998 22:13'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot. It may beoverridden to avoid this behavior if so desired."	| old |	Morph instSize + 1 to: self class instSize do:		[:i | old _ self instVarAt: i.		old isMorph ifTrue:			[self instVarAt: i put: (aDictionary at: old ifAbsent: [old])]].	extension == nil ifFalse: [extension updateReferencesUsing: aDictionary]! !!Morph methodsFor: 'copying' stamp: 'sw 8/11/1998 16:55'!usableSiblingInstance	|  aName usedNames newPlayer newMorph |	self flag: #noteToTed.  "Note I've fallen back on veryDeepCopyWithoutPlayer here, because I want another instance of my Player's class rather than a new Player subclass."	newMorph _ self veryDeepCopyWithoutPlayer.	newPlayer _ self player class new costume: newMorph.	self isFlexMorph ifTrue: [newMorph renderedMorph player: newPlayer]. "???"	newMorph actorState: (self player actorState shallowCopy initializeFor: newPlayer).	(aName _ self knownName) == nil ifTrue:		[self player ~~ nil ifTrue: [aName _ newMorph innocuousName]].			"Force a difference here"	aName ~~ nil ifTrue:		[usedNames _ self world allKnownNames copyWith: aName.		newMorph setNameTo: (Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not])].	"newMorph justDuplicatedFrom: self.  NOT done for sibling inst"	newMorph privateOwner: nil.	(newMorph renderedMorph eventHandler ~~ nil) ifTrue:		[newPlayer assureEventHandlerRepresentsStatus].	self presenter flushPlayerListCache.	^ newMorph! !!Morph methodsFor: 'copying' stamp: 'tk 5/22/1998 12:17'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy.  Uses ReferenceStream.  To see where the copying stops, see DataStream.typeIDFor: and implementors of objectToStoreOnDataStream"	self allMorphsDo: [:m | m prepareToBeSaved].		"Actors fix open scriptEditors"	^ super veryDeepCopy ! !!Morph methodsFor: 'copying' stamp: 'tk 8/31/1998 15:19'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Do not copy the owner field.  That must be filled in by the owner, if he is within the tree being copied."	| class index sub subAss new absent uc |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self class.	new _ self clone.	class isSystemDefined ifFalse: ["May occur in the future"		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: class put: (uc _ self copyUniClass)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	"Morph subclasses do not have variable numbers of fields (like Array does)"	new privateBounds: bounds clone.	"Points are shared with original"		"indexes used here are checked by checkVariables"	(subAss _ deepCopier references associationAt: owner ifAbsent: [nil])		ifNil: [new privateOwner: nil]	"weak reference to owner"		ifNotNil: [new privateOwner: subAss value].	new privateSubmorphs: (submorphs veryDeepCopyWith: deepCopier).	new privateFullBounds: fullBounds.	"fullBounds is shared with original!!"	new privateColor: (color veryDeepCopyWith: deepCopier).		"color, if simple, will return self. may be complex"	new instVarAt: 6 put: (extension veryDeepCopyWith: deepCopier).		"extension is treated like any generic inst var"	index _ class instSize.	[index > 6] whileTrue: 		[sub _ self instVarAt: index.		new instVarAt: index put: (sub veryDeepCopyWith: deepCopier).		index _ index - 1].	new submorphsDo: [:morph | morph privateOwner: new].  "strengthen weak pointers"	^ new! !!Morph methodsFor: 'copying' stamp: 'sw 8/11/1998 16:56'!veryDeepCopyWithoutPlayer	| hold copy holdState |	hold _ self player.	holdState _ self actorStateOrNil.	holdState ifNotNil: [self actorState: nil].	self player: nil.	copy _ self veryDeepCopy.	holdState ifNotNil:		[copy actorState: (holdState copyWithPlayerReferenceNilled)].	self player: hold.	holdState ifNotNil: [self actorState: holdState].	^ copy! !!Morph methodsFor: 'structure' stamp: 'sw 9/21/1998 11:45'!ownerThatIsAHandOrA: aClass	"Return the first enclosing morph that is either a HandMorph or a kind of aClass, or nil if none"	| current |	current _ owner.	[current == nil] whileFalse:			[((current isKindOf: aClass) or: [current isHandMorph]) ifTrue: [^ current].			current _ current owner].	^ current! !!Morph methodsFor: 'structure' stamp: 'sw 9/21/1998 11:46'!owningHandOrPasteUpMorph	"Answer the closest containing morph that is a Hand or a PasteUp morph"	^ self ownerThatIsAHandOrA: PasteUpMorph! !!Morph methodsFor: 'structure' stamp: 'sw 7/1/1998 18:02'!pasteUpMorph	"Answer the closest containing morph that is a PasteUp morph"	^ self ownerThatIsA: PasteUpMorph! !!Morph methodsFor: 'structure' stamp: 'sw 8/30/1998 09:47'!topPasteUp	"If the receiver is in a world, return that; otherwise return the outermost pasteup morph"	^ self outermostMorphThat: [:m | m isKindOf: PasteUpMorph]! !!Morph methodsFor: 'structure' stamp: 'sw 7/1/1998 12:15'!world	^ owner ifNil: [nil] ifNotNil: [owner world]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 7/3/1998 17:11'!hasSubmorphWithProperty: aSymbol	submorphs detect: [:m | m hasProperty: aSymbol] ifNone: [^ false].	^ true! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 9/9/1998 22:38'!morphsIn: aRectangle	"Return a collection of all morphs in this morph structure that intersect the given rectangle, possibly including the receiver itself.  The order is deepest embedding first."	^ self morphsIn: aRectangle addTo: OrderedCollection new! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 9/9/1998 22:28'!morphsIn: aRectangle addTo: mList	"Return a collection of all morphs in this morph structure that intersect the given rectangle, possibly including the receiver itself.  Must do this recursively because of transforms.  "	submorphs size > 0 ifTrue:		[submorphs do: [:m | m morphsIn: aRectangle addTo: mList]].	(self bounds intersects: aRectangle) ifTrue: [mList addLast: self].	^ mList! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 7/3/1998 18:47'!submorphWithProperty: aSymbol	^ submorphs detect: [:aMorph | aMorph hasProperty: aSymbol] ifNone: [nil]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 5/29/1998 15:39'!addMorphFront: aMorph	| newSubmorphs |	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	newSubmorphs at: 1 put: aMorph.	newSubmorphs		replaceFrom: 2		to: newSubmorphs size		with: submorphs		startingAt: 1.	submorphs _ newSubmorphs.	aMorph changed.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 6/17/1998 16:04'!addMorphNearBack: aMorph	| bg |	(submorphs size > 0 and: [submorphs last mustBeBackmost]) ifTrue:		[bg _ submorphs last.		bg privateDelete].	self addMorphBack: aMorph.	bg ifNotNil: [self addMorphBack: bg]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 8/13/1998 10:09'!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	| aWorld |	owner ifNotNil:		[(extension == nil or: [self player == nil])		ifTrue: [owner privateRemoveMorph: self.				owner _ nil]		ifFalse: ["Player must be notified"				aWorld _ self world.				owner privateRemoveMorph: self.				owner _ nil.				self player noteDeletionOf: self fromWorld: aWorld]		].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 7/3/1998 11:02'!deleteSubmorphsWithProperty: aSymbol	submorphs copy do:		[:m | (m hasProperty: aSymbol) ifTrue: [m delete]]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 8/20/1998 17:32'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition |	oldMorph stopStepping.	itsPosition _ oldMorph position.	index _ submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph position: itsPosition.	newMorph arrangeToStartStepping! !!Morph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:10'!areasRemainingToFill: aRectangle	"May be overridden by any subclasses with opaque regions"	^ Array with: aRectangle! !!Morph methodsFor: 'drawing' stamp: 'tk 8/2/1998 14:33'!doesOwnRotation	"Some morphs don't want to TransformMorph to rotate their images, but we do"	^ false! !!Morph methodsFor: 'drawing' stamp: 'di 6/17/1998 12:44'!flash	| w |	w _ self world.	w ifNotNil:		[Display flash: (((self transformFrom: w) invertRect: bounds)								translateBy: w viewBox origin)].! !!Morph methodsFor: 'drawing' stamp: 'di 8/16/1998 11:19'!fullBounds	fullBounds ifNil: [		fullBounds _ self bounds.		submorphs size > 0 ifTrue: [			submorphs do: [:m | (m left < 50000 or: [(self hasProperty: #hidden) not])					ifTrue: [fullBounds _ fullBounds quickMerge: m fullBounds]]]].	^ fullBounds! !!Morph methodsFor: 'drawing' stamp: 'jm 5/30/1998 21:06'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	submorphs isEmpty		ifTrue: [self drawOn: aCanvas]		ifFalse: [			(aCanvas isVisible: bounds) ifTrue: [self drawOn: aCanvas].			submorphs reverseDo: [:m | m fullDrawOn: aCanvas]].  "draw back-to-front"! !!Morph methodsFor: 'drawing' stamp: 'tk 7/9/1998 13:44'!hide	"Move this morph way, way offstage!!  Remember its coordinates in relative form, in case window moves while hidden."	owner ifNil: [^ self].	self position < (5000@5000) ifTrue: [		self setProperty: #relPosition toValue: (self position - owner position).		self position: self position + (1000000@100000).		self setProperty: #hidden toValue: true].! !!Morph methodsFor: 'drawing' stamp: 'di 7/8/1998 12:43'!imageForm: depth forRectangle: rect	| canvas |	canvas _ FormCanvas extent: rect extent depth: depth.	self fullDrawOn: (canvas copyOffset: rect topLeft negated).	^ canvas form offset: rect topLeft! !!Morph methodsFor: 'drawing' stamp: 'di 7/8/1998 12:42'!imageFormDepth: depth	^ self imageForm: depth forRectangle: self fullBounds! !!Morph methodsFor: 'drawing' stamp: 'di 9/9/1998 22:25'!imageFormForRectangle: rect	^ self imageForm: Display depth forRectangle: rect! !!Morph methodsFor: 'drawing' stamp: 'di 9/10/1998 12:29'!shadowForm	| canvas |	canvas _ (FormCanvas extent: bounds extent depth: 1)			setShadowDrawing; stipple: Color black;			copyOffset: bounds topLeft negated.	self fullDrawOn: canvas.	^ canvas form offset: bounds topLeft! !!Morph methodsFor: 'drawing' stamp: 'tk 7/9/1998 13:57'!show	"Make sure this morph is on-stage."	| saved |	self world ifNil: [^ self].	"would like to set bounds, but we must be in a world"	(self valueOfProperty: #hidden) ifNil: [^ self].	(saved _ self valueOfProperty: #relPosition) ifNotNil: [		self position: saved + owner position.		self setProperty: #hidden toValue: nil.	"showing"		self wrap.	"be sure I'm on-stage"		"self bottomRight = owner bottomRight ifTrue: [			self error: 'Why did object lose position?']"		].! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:30'!bottomLeft: aPoint	self bottom: aPoint y.	self left: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:08'!bottomRight: aPoint	self bottom: aPoint y.	self right: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'di 7/5/1998 20:57'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta |	trialRect _ aPoint extent: self bounds extent.	delta _ trialRect amountToTranslateWithin: owner bounds.	self position: aPoint + delta! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:30'!topLeft: aPoint	self top: aPoint y.	self left: aPoint x! !!Morph methodsFor: 'geometry' stamp: 'sw 6/17/1998 14:29'!topRight: aPoint	self top: aPoint y.	self right: aPoint x! !!Morph methodsFor: 'rotate scale and flex' stamp: 'sw 8/11/1998 16:45'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph anActorState aName |	self isFlexMorph ifTrue: [^ self].	oldHalo _ self halo.	self owner addMorph:		(flexMorph _ TransformationMorph new asFlexOf: self).	(anActorState _ self actorStateOrNil) ifNotNil:		[flexMorph actorState: anActorState.		self actorState: nil].	(aName _ self knownName) ifNotNil:		[flexMorph setNameTo: aName.		self setNameTo: nil].	self player ifNotNil:		[flexMorph player: self player.		self player rawCostume: flexMorph].	oldHalo ifNotNil: [oldHalo setTarget: flexMorph]! !!Morph methodsFor: 'geometry eToy' stamp: 'di 9/9/1998 23:10'!color: sensitiveColor sees: soughtColor	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor."	| myImage sensitivePixelMask map patchBelowMe |	"make a mask with black where sensitiveColor is, white elsewhere"	myImage _ self imageForm.	sensitivePixelMask _ Form extent: myImage extent depth: 1.	map _ (Color cachedColormapFrom: myImage depth to: 1) copy.	map primFill: 0.	map at: (sensitiveColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: sensitivePixelMask boundingBox		from: myImage form		at: 0@0		colorMap: map.	"get an image of the world below me"	patchBelowMe _ self world patchAt: self fullBounds belowMorph: self.	"intersect world pixels of the color we're looking for with the sensitive pixels"	map at: (sensitiveColor indexInMap: map) put: 0.  "clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelMask copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0@0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	^ (sensitivePixelMask tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'di 9/9/1998 22:49'!colorUnder	"Return the color of under the receiver's center."	self isInWorld		ifTrue: [^ self world colorAt: (self pointInWorld: self referencePosition) belowMorph: self]		ifFalse: [^ Color black].! !!Morph methodsFor: 'geometry eToy' stamp: 'tk 7/9/1998 14:06'!goHome	| box close |	owner ifNotNil: [		close _ bounds origin x < 50000. "quick test for not hidden"		close ifFalse: ["real but slow test"			close _ (self valueOfProperty: #hidden) ~~ true].		close ifTrue: [			box _ owner.			self left < box left ifTrue: [self position: box left@self position y].			self right > box right ifTrue: [self position: (box right - self width)@self position y].			self top < box top ifTrue: [self position: self position x@box top].			self bottom > box bottom ifTrue: [				self position: self position x@(box bottom - self height)]]].! !!Morph methodsFor: 'geometry eToy' stamp: 'di 9/10/1998 12:41'!touchesColor: soughtColor	"Return true if any of my pixels overlap pixels of soughtColor."	| map patchBelowMe shadowForm |	shadowForm _ self shadowForm.	patchBelowMe _ self world patchAt: self fullBounds belowMorph: self.	"intersect world pixels of the color we're looking for with our shape."	map _ Bitmap new: (1 bitShift: (patchBelowMe depth min: 15)).	map at: (soughtColor indexInMap: map) put: 1.	shadowForm copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0@0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	^ (shadowForm tallyPixelValues at: 2) > 0! !!Morph methodsFor: 'geometry eToy' stamp: 'tk 7/8/1998 23:47'!wrap	| myBox box newX newY wrapped |	owner ifNil: [^ self].	myBox _ self fullBounds.	myBox corner < (50000@50000) ifFalse: [		self inform: 'Who is trying to wrap a hidden object?'. ^ self].	box _ owner bounds.	newX _ self position x.	newY _ self position y.	wrapped _ false.	((myBox right < box left) or: [myBox left > box right]) ifTrue: [		newX _ box left + ((self position x - box left) \\ box width).		wrapped _ true].	((myBox bottom < box top) or: [myBox top > box bottom]) ifTrue: [		newY _ box top + ((self position y - box top) \\ box height).		wrapped _ true].	self position: newX@newY.	(wrapped and: [owner isPlayfieldLike])		ifTrue: [owner changed].  "redraw all turtle trails if wrapped"! !!Morph methodsFor: 'thumbnail' stamp: 'sw 7/6/1998 14:35'!newThumbnailOfHeight: aHeight	"Answer a morph who knows about me and looks like me.  A kind of alias"	^ MorphThumbnail new height: aHeight; morphRepresented: self! !!Morph methodsFor: 'thumbnail' stamp: 'sw 7/6/1998 15:40'!thumbnailOfHeight: aHeight	"Answer a morph who knows about me and looks like me.  A kind of alias"	^ MorphThumbnail new extent: aHeight @ aHeight; morphRepresented: self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 6/30/1998 08:21'!aboutToBeGrabbedBy: aHand	| extentToHandToHand |	(extentToHandToHand _ self valueOfProperty: #expandedExtent)			ifNotNil:				[self removeProperty: #expandedExtent.				self extent: extentToHandToHand]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/3/1998 15:11'!closeDragAndDrop	self setProperty: #openToDragAndDrop toValue: false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/11/1998 13:01'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self isPartsDonor: false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'di 8/3/1998 15:11'!openDragAndDrop	self setProperty: #openToDragAndDrop toValue: true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 6/30/1998 17:02'!rootForGrabOf: aMorph	^ (self isSticky and: [self isPartsDonor not])		ifTrue:			[nil]		ifFalse:			[(owner = nil or: [owner isWorldOrHandMorph])				ifTrue:					[self]				ifFalse:					[owner allowSubmorphExtraction						ifTrue: [self]						ifFalse: [owner rootForGrabOf: aMorph]]]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 7/3/1998 12:34'!slideBackToFormerSituation: evt	| aForm formerOwner formerPosition aWorld origin startPoint endPoint |	aForm _ self imageForm offset: 0@0.	formerOwner _ evt hand formerOwner.	formerPosition _ evt hand formerPosition.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	endPoint _ formerPosition + origin.	owner privateRemoveMorph: self.	aWorld displayWorld.	aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 7/3/1998 16:29'!substituteForMorph: aMorph beingDroppedOn: aPage	"Allows a morph that is one level above aPage in the containment hierarchy to have a say on which morph should be dropped"	^ nil ! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 8/4/1998 18:41'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld origin startPoint endPoint aPresenter |	aForm _ self imageForm offset: 0@0.	aPresenter _ self presenter.	aWorld _ self world.	origin _ aWorld viewBox origin.	startPoint _ evt hand fullBounds origin + origin.	self delete.	aWorld displayWorld.	endPoint _ aPosition + origin.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	aPresenter soundsEnabled ifTrue: [TrashCanMorph playDeleteSound].! !!Morph methodsFor: 'event handling' stamp: 'sw 7/3/1998 16:45'!cursorPoint	"A convenience"	^ self primaryHand lastEvent cursorPoint! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!handlesMouseDown: evt	"Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"	"NOTE: The default response is false, except if you have added sensitivity to mouseDown events using the on:send:to: mechanism.  Subclasses that implement these messages directly should override this one to return true." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseDown: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOver: evt	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?  The default response is false, except if you have added sensitivity to mouseEnter: or mouseLeave:, using the on:send:to: mechanism." 	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOver: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOverDragging: evt	"Return true if I want to receive mouseEnterDragging: and mouseLeaveDragging: when the hand drags something over me (button up or button down), or when the mouse button is down but there is no mouseDown recipient.  The default response is false, except if you have added sensitivity to mouseEnterLaden: or mouseLeaveLaden:, using the on:send:to: mechanism."	"NOTE:  If the hand state matters in these cases, it may be tested by constructs such as		event anyButtonPressed		event hand hasSubmorphs"	self eventHandler ifNotNil: [^ self eventHandler handlesMouseOverDragging: evt].	^ false! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!keyStroke: anEvent	"Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler keyStroke: anEvent fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!mouseDown: evt	"Handle a mouse down event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:00'!mouseEnter: evt	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseEnter: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:33'!mouseEnterDragging: evt	"Handle a mouseEnterDragging event, meaning the mouse just entered my bounds with a button pressed or laden with submorphs.  The default response is to let my eventHandler, if any, handle it, or else to do nothing."	self eventHandler ifNotNil:		[^ self eventHandler mouseEnterDragging: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!mouseLeave: evt	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseLeave: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:38'!mouseLeaveDragging: evt	"Handle a mouseLeaveLaden event, meaning the mouse just left my bounds with a button pressed or laden with submorphs. The default response is to let my eventHandler, if any, handle it; else to do nothing."	self eventHandler ifNotNil:		[self eventHandler mouseLeaveDragging: evt fromMorph: self]! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:02'!mouseMove: evt	"Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseStillDown: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!mouseUp: evt	"Handle a mouse up event. The default response is to let my eventHandler, if any, handle it."	self eventHandler ifNotNil:		[self eventHandler mouseUp: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!on: eventName send: selector to: recipient	self eventHandler ifNil: [self eventHandler: EventHandler new].	self eventHandler on: eventName send: selector to: recipient! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:04'!on: eventName send: selector to: recipient withValue: value	"NOTE: selector must take 3 arguments, of which value will be the 3rd"	self eventHandler ifNil: [self eventHandler: EventHandler new].	self eventHandler on: eventName send: selector to: recipient withValue: value! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:02'!removeLink: actionCode	self eventHandler ifNotNil:		[self eventHandler on: actionCode send: nil to: nil]! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!suspendEventHandler	self eventHandler ifNotNil:		[self setProperty: #suspendedEventHandler toValue: self eventHandler.		self eventHandler: nil]! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!choosePenColor: evt	self assuredPlayer choosePenColor: evt! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!choosePenSize	self assuredPlayer choosePenSize! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenColor	^ self player ifNotNil: [self actorState getPenColor] ifNil: [Color green]! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenDown	self player ifNil: [^ false].	^ self actorState getPenDown! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:53'!getPenSize	self player ifNil: [^ 1].	^ self actorState getPenSize! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!liftPen	self assuredPlayer liftPen! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!lowerPen	self assuredPlayer lowerPen! !!Morph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:46'!penColor: aColor	self assuredPlayer penColor: aColor! !!Morph methodsFor: 'pen' stamp: 'di 9/3/1998 10:38'!penUpWhile: changeBlock 	"Suppress any possible pen trail during the execution of changeBlock"	self getPenDown		ifTrue: ["If this is a costume for a player with its pen down, suppress any line."				self liftPen.				changeBlock value.				self lowerPen]		ifFalse: ["But usually, just do it."				changeBlock value]! !!Morph methodsFor: 'pen' stamp: 'di 9/10/1998 16:18'!trailMorph	"You can't draw trails on me, but try my owner."	owner == nil ifTrue: [^ nil].	^ owner trailMorph! !!Morph methodsFor: 'naming' stamp: 'sw 8/11/1998 16:46'!choosePartNameSilently	^ self world model namePartSilently: self assuredPlayer! !!Morph methodsFor: 'naming' stamp: 'di 8/11/1998 22:10'!knownName	extension == nil ifTrue: [^ nil].	^ extension externalName! !!Morph methodsFor: 'naming' stamp: 'sw 8/30/1998 09:48'!renameTo: aName	| aPresenter putInViewer aPasteUp |	self setNameTo: aName.	(aPresenter _ self presenter) ifNotNil:		[putInViewer _ aPresenter currentlyViewing: self player.		aPresenter flushViewerCache.		putInViewer ifTrue: [aPresenter viewMorph: self]].	(aPasteUp _ self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do:			[:m | m bringUpToDate]]! !!Morph methodsFor: 'naming' stamp: 'di 8/11/1998 22:11'!setNamePropertyTo: aName	extension == nil ifTrue: [self assureExtension].	extension externalName: aName! !!Morph methodsFor: 'naming' stamp: 'tk 8/10/1998 16:00'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isKindOf: MorphicModel)		ifTrue: [^ self slotName]		ifFalse: [			self eventHandler ifNotNil: [				self eventHandler mouseDownSelector ifNotNil: [					hh _ self eventHandler mouseDownSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ self eventHandler mouseDownSelector copyFrom: 1 to: hh-1]].				self eventHandler mouseUpSelector ifNotNil: [					hh _ self eventHandler mouseUpSelector indexOfSubCollection: 'Mouse' 								startingAt: 1.					hh > 0 ifTrue: [^ self eventHandler mouseUpSelector copyFrom: 1 to: hh-1]].				]].			"	(self eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ self eventHandler mouseDownRecipient nameFor: self]]].	"			"myModel _ self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"		^ self world specialNameInModelFor: self! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/21/1998 16:31'!arrangeToStartSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld.  Like startSteppingIn:, but without the initial one to get started'"	aWorld startStepping: self.	self changed! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 7/19/1998 11:51'!startSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld"	self step.  "one to get started!!"	aWorld ifNotNil: [aWorld startStepping: self].	self changed! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/11/1998 16:55'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message"	self player ifNotNil: [self player step]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/11/1998 16:55'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^ self player ifNotNil: [125] ifNil: [1000]! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 8/11/1998 16:56'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self player ifNotNil: [^ true].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menus' stamp: 'di 9/14/1998 10:04'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	| unlockables |	aMenu addLine.	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	self player ifNotNil:		[aMenu add: 'make another instance of me' action: #makeNewPlayerInstance].	aMenu addLine.	aMenu add: 'open viewer' action: #openViewerForArgument.	(self isKindOf: MorphThumbnail) ifFalse:		[aMenu add: 'make alias' action: #makeAliasForArgument].	aMenu add: 'change costume...' action: #chooseNewCostumeForArgument.	((self isKindOf: SketchMorph) and: [Smalltalk imageImports size > 0]) ifTrue:		[aMenu add: 'use imported graphic...' action: #chooseNewFormForSketchMorph].	self colorSettable ifTrue:		[aMenu add: 'change color...' action: #changeColor].	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	self isLocked		ifFalse:			[aMenu add: 'lock' action: #lockMorph]		ifTrue:			[aMenu add: 'unlock' action: #unlockMorph].  "probably not possible -- wouldn't get halo"	unlockables _ self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: 'unlock "', unlockables first externalName, '"' action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' action: #unlockContents.		aMenu add: 'unlock...' action: #unlockOneSubpart].	"aMenu add: 'make mouse-sensitive' action: #makeMouseSensitive."	(owner == nil or: [self == owner submorphs last]) ifFalse:		[aMenu add: 'send to back' action: #goBehind]! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:14'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	aCustomMenu add: 'add drop-shadow' action: #addDropShadow.	self isSticky		ifTrue:			[aCustomMenu add: 'stop being sticky' action: #toggleStickiness]		ifFalse:			[aCustomMenu add: 'start being sticky' action: #toggleStickiness].	aCustomMenu add: 'adhere to edge...' action: #adhereToEdge! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:32'!adhereToEdge	| menu |	menu _ MenuMorph new defaultTarget: self.	#(top right bottom left topLeft topRight bottomRight bottomLeft none) do:		[:anEdge |			menu add: anEdge asString selector: #setToAdhereToEdge: argument: anEdge.			((anEdge == #left) | (anEdge == #bottomLeft))				ifTrue:					[menu addLine]].	menu popUpAt: self position forHand: self primaryHand! !!Morph methodsFor: 'menus' stamp: 'sw 7/15/1998 21:16'!adhereToEdge: edgeSymbol	(owner == nil or: [owner isHandMorph]) ifTrue: [^ self].	self perform: (edgeSymbol, ':') asSymbol withArguments: (Array with: (owner bounds perform: edgeSymbol))! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:25'!setToAdhereToEdge: anEdge	anEdge ifNil: [^ self].	anEdge == #none ifTrue: [^ self removeProperty: #edgeToAdhereTo].	self setProperty: #edgeToAdhereTo toValue: anEdge.	self layoutChanged! !!Morph methodsFor: 'menus' stamp: 'sw 8/30/1998 09:42'!snapToEdgeIfAppropriate	| edgeSymbol oldBounds aWorld |	(edgeSymbol _ self valueOfProperty: #edgeToAdhereTo) ifNotNil:		[oldBounds _ bounds.		self adhereToEdge: edgeSymbol.		bounds ~= oldBounds ifTrue: [(aWorld _ self world) ifNotNil: [aWorld viewBox ifNotNil:			[aWorld displayWorld]]]]! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 7/5/1998 12:08'!addFontHandlesTo: aHalo box: box	"Add handles for controlling font, style, and emphasis choices to the halo"	| s |	s _ aHalo handleSize.	aHalo addHandleAt: (box bottomLeft + ((s+2)@0))		color: Color lightGreen on: #mouseDown send: #chooseFont to: self.	aHalo addHandleAt: (box bottomLeft + ((s+2*2)@0))		color: Color lightRed on: #mouseDown send: #chooseStyle to: self.	aHalo addHandleAt: (box bottomRight - ((s+2)@0))		color: Color lightBrown darker on: #mouseDown send: #chooseEmphasis to: self.! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 7/6/1998 11:32'!addHalo	| halo |	halo _ HaloMorph new bounds: self fullBoundsInWorld.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 8/11/1998 12:43'!editBalloonHelpText	| str  |	str _ self balloonText.	str ifNil: [str _ self noHelpString].	self editBalloonHelpContent: str! !!Morph methodsFor: 'halos and balloon help' stamp: 'di 8/11/1998 22:11'!setBalloonText: stringOrText	extension == nil ifTrue: [self assureExtension].	extension balloonText: stringOrText! !!Morph methodsFor: 'change reporting' stamp: 'sw 9/10/1998 08:18'!colorChangedForSubmorph: aSubmorph	"The color associated with aSubmorph was changed through the UI; react if needed"! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!layoutChanged	"Note that something has changed about the size, shape, or location of the receiver or one of its submorphs, so that fullBounds must be recomputed."	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue:		["Let submorphs know about a change above"		submorphs do: [:m | m ownerChanged]].! !!Morph methodsFor: 'change reporting' stamp: 'sw 7/8/1998 13:21'!ownerChanged	"The receiver's owner, some kind of a pasteup, has changed its layout."	self snapToEdgeIfAppropriate! !!Morph methodsFor: 'change reporting' stamp: 'sw 9/10/1998 08:18'!userSelectedColor: aColor	"The user, via the UI, chose aColor to be the color for the receiver; set it, and tell my owner in case he wishes to react"	self color: aColor.	owner ifNotNil: [owner colorChangedForSubmorph: self]! !!Morph methodsFor: 'player' stamp: 'sw 9/15/1998 13:33'!newPlayerInstance	^ UnscriptedPlayer newUserInstance! !!Morph methodsFor: 'player' stamp: 'sw 8/11/1998 16:54'!okayToDuplicate	self player ifNil: [^ true].	self instantiatedUserScriptsDo:		[:aScript | aScript isAnonymous ifTrue:			[self inform: 'This object has one or moreunnamed, unsaved scripts,which would not be partof a duplicate.  So, for now,we just won''t let you dothis.  Sorry!!'.			^ false]].	^ true! !!Morph methodsFor: 'player' stamp: 'sw 8/11/1998 16:54'!showPlayerMenu	self player ifNotNil:		[self player showPlayerMenu]! !!Morph methodsFor: 'player commands' stamp: 'sw 8/4/1998 18:41'!makeFenceSound	self presenter soundsEnabled ifTrue:		[self playSoundNamed: 'scratch'].! !!Morph methodsFor: 'player viewer' stamp: 'sw 6/25/1998 08:32'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts.  This remains somewhat awkward -- color is normally there, but for objects that only wear an image/sketch costume, offering color would be perplexing, so it's left to the costumes to decide.""		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:))]		ifFalse:			[Array new]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:53'!jettisonScripts	self player ifNotNil: [self player class jettisonScripts]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:54'!justClonedFrom: aDonor	"A hook so that after the Duplicate command is issued by a user, the clone gets a chance to get things right." 	self player ifNotNil:		[self player justClonedFrom: aDonor player]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:59'!restoreTypeColor	self player ifNotNil: [self player allScriptEditors do:		[:anEditor | anEditor allMorphsDo:			[:m | m restoreTypeColor]]]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:46'!scriptEditorFor: aScriptName	^ self assuredPlayer scriptEditorFor: aScriptName! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:54'!scriptPerformer	^ self player ifNil: [self]! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:55'!tearOffTile	| aValue |	self player ifNotNil: [^ self player tearOffTileForSelf].		(aValue _ self valueAsConstant) ifNotNil:		[^ self world primaryHand attachMorph: aValue newTileMorphRepresentative]. 	^ self assuredPlayer tearOffTileForSelf! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:55'!updatingTileForArgType: typeSymbol partName: partName getSelector: getSelector putSelector: putSelector	| aColor aTile viewer |	aColor _ Color lightGray lighter.	aTile _ typeSymbol == #number		ifTrue:	[NumericReadoutTile new typeColor: aColor]		ifFalse:	[StringReadoutTile new typeColor: aColor]. 	viewer _ UpdatingStringMorph new		target: self player;		getSelector: getSelector;		growable: false;		putSelector: ((putSelector == #unused) ifTrue: [nil] ifFalse: [putSelector]).	typeSymbol == #string		ifTrue:			[viewer useStringFormat]		ifFalse:			[viewer useDefaultFormat].	aTile addMorphBack: viewer.	putSelector == #unused ifFalse: [aTile addArrows].	aTile setLiteralTo: (self scriptPerformer perform: getSelector) width: 30.	^ aTile! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:55'!useUniformTileColor	self player ifNotNil:		[self player allScriptEditors do:			[:anEditor | anEditor allMorphsDo:				[:m | m useUniformTileColor]]]! !!Morph methodsFor: 'scripting' stamp: 'sw 6/10/1998 17:33'!valueAsConstant	"If the receiver can be perceived by the end-user as bearing a data value of any type other than player-reference, return the literal representing its value at this very moment -- for the purpose of a value-tile being constructed."	^ nil! !!Morph methodsFor: 'scripting' stamp: 'sw 8/11/1998 16:56'!viewAfreshShowingScript: aScriptName at: aPosition	| anEditor |	self player updateAllViewers.	self world addMorph: (anEditor _ self player scriptEditorFor: aScriptName).	anEditor position: aPosition! !!Morph methodsFor: 'e-toy support' stamp: 'sw 6/30/1998 09:53'!clearPaletteArea	| pal |	(pal _ self standardPalette) ~~ nil ifTrue:		[pal showNoPalette]! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:17'!makeGraphPaper	| smallGrid backColor lineColor |	smallGrid _ Compiler evaluate: (FillInTheBlank request: 'Enter grid size' initialAnswer: '16').	Utilities informUser: 'Choose a background color' during: [backColor _ Color fromUser].	Utilities informUser: 'Choose a line color' during: [lineColor _ Color fromUser].	self makeGraphPaperGrid: smallGrid background: backColor line: lineColor.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/30/1998 09:41'!makeGraphPaperGrid: smallGrid background: backColor line: lineColor	| bigGrid gridForm |	bigGrid _ 40 roundTo: smallGrid.	gridForm _ Form extent: bigGrid asPoint depth: Display depth.	gridForm fillWithColor: backColor.	0 to: bigGrid by: smallGrid do: [:i |		gridForm fill: (i@0 extent: 1@bigGrid) fillColor: lineColor.		gridForm fill: (0@i extent: bigGrid@1) fillColor: lineColor].	color _ InfiniteForm with: gridForm.	self world ifNotNil: [self world fullRepaintNeeded].	self changed: #newColor.  "propagate to view"! !!Morph methodsFor: 'e-toy support' stamp: 'sw 6/26/1998 16:05'!previousPageButton	| aButton |	aButton _ SimpleButtonMorph new.	aButton target: aButton; actionSelector: #previousOwnerPage; color: Color yellow; label: '<-'.	aButton setNameTo: 'previous'.	^ aButton! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/1/1998 18:01'!referencePlayfield	| former |	owner isPlayfieldLike ifTrue: [^ owner].	((owner isKindOf: HandMorph) and: [(former _ owner formerOwner) ~~ nil])		ifTrue:			[^ former isPlayfieldLike 				ifTrue:					[former]				ifFalse:					[former referencePlayfield]].	self isInWorld ifFalse: [^ nil].	^ self world submorphNamed: 'playfield'! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:18'!setStandardTexture	| parms |	parms _ self textureParameters.	self makeGraphPaperGrid: parms first		background: parms second		line: parms third! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/11/1998 16:55'!succeededInRevealing: aPlayer	aPlayer == self player ifTrue: [^ true].	submorphs do:		[:m | (m succeededInRevealing: aPlayer) ifTrue: [^ true]].	^ false! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:17'!textureParameters	"Answer a triplet giving the preferred grid size, background color, and line color.  The choices here are as suggested by Alan, 9/13/97"	^ Array with: 16 with: Color lightYellow with: Color lightGreen lighter lighter! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 12:48'!inPartsBin	| o |	self isPartsDonor ifTrue: [^ true].	o _ self owner.	[o == nil] whileFalse:		[o isPartsBin ifTrue: [^ true].		o _ o owner].	^ false! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 22:09'!isPartsDonor	extension == nil ifTrue: [^ false].	^ extension isPartsDonor! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 22:10'!isPartsDonor: aBoolean	extension == nil ifTrue:		[aBoolean ifFalse: [^ self].		self assureExtension].	extension isPartsDonor: aBoolean! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 13:02'!markAsPartsDonor	"Mark the receiver specially so that mouse actions on it are interpreted as 'tearing off a copy'"	self isPartsDonor: true! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 18:00'!printStructureOn: aStream indent: tabCount	tabCount timesRepeat: [aStream tab].	self printOn: aStream.	aStream cr.	self submorphsDo: [:m | m printStructureOn: aStream indent: tabCount + 1].! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 17:58'!structureString	"Return a string that showing this morph and all its submorphs in an indented list that reflects its structure."	| s |	s _ WriteStream on: (String new: 1000).	self printStructureOn: s indent: 0.	^ s contents! !!Morph methodsFor: 'property extension' stamp: 'di 8/14/1998 12:55'!assureExtension	extension == nil ifTrue: [extension _ MorphExtension new initialize]! !!Morph methodsFor: 'property extension' stamp: 'di 8/11/1998 22:08'!copyPropertiesFrom: donorMorph dict: dict	(extension _ donorMorph extension copy) == nil ifTrue: [^ self].	extension copyPropertiesFrom: donorMorph dict: dict! !!Morph methodsFor: 'property extension' stamp: 'di 8/10/1998 14:25'!extension	^ extension! !!Morph methodsFor: 'property extension' stamp: 'di 8/11/1998 12:01'!otherProperties	extension == nil ifTrue: [^ nil].	^ extension otherProperties! !!Morph methodsFor: 'debug and other' stamp: 'sw 6/25/1998 15:50'!inspectOwnerChain	| c next |	c _ OrderedCollection with: self.	next _ self.	[(next _ next owner) ~~ nil] whileTrue: [c add: next].	c asArray inspectWithLabel: 'Owner chain for ', self printString! !!Morph methodsFor: 'private' stamp: 'jm 5/29/1998 21:28'!privateColor: aColor	color _ aColor.! !!Morph methodsFor: 'private' stamp: 'tk 8/30/1998 09:58'!privateFullBounds: boundsRect	"Private!! Computed automatically."	fullBounds _ boundsRect.! !!Morph methodsFor: 'private' stamp: 'di 9/10/1998 16:21'!privateMoveBy: delta	"Private!! Use 'position:' instead."	| trailMorph start |	(extension == nil or: [extension player == nil]) ifFalse:		["Most cases eliminated fast by above test"		self getPenDown ifTrue:			["If this is a costume for a player with its pen down, draw a line."			(trailMorph _ self trailMorph) ifNotNil:				[start _ self referencePosition.				trailMorph drawPenTrailFor: self from: start to: start + delta]]].	fullBounds == bounds		ifTrue: ["optimization: avoids recomputing fullBounds"				fullBounds _ bounds _ bounds translateBy: delta]		ifFalse: [bounds _ bounds translateBy: delta.				fullBounds _ nil]! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 5/26/1998 15:33'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream |	aFileName _ ('my ', self class name) asFileName.	"do better?"	aFileName _ FillInTheBlank request: 'File name? (".morph" will be added to end)' 			initialAnswer: aFileName.	aFileName size == 0 ifTrue: [^ self beep].	self allMorphsDo: [:m | m prepareToBeSaved].	fileStream _ FileStream newFileNamed: aFileName,'.morph'.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 7/11/1998 18:53'!storeDataOn: aDataStream	"Let all Morphs be written out.  All owners are weak references.  They only go out if the owner is in the tree being written."	| cntInstVars cntIndexedVars ti localInstVars |	"block my owner unless he is written out by someone else"	cntInstVars _ self class instSize.	cntIndexedVars _ self basicSize.	localInstVars _ Morph instVarNames.	ti _ 2.  	((localInstVars at: ti) = 'owner') & (Morph superclass == Object) ifFalse:			[self error: 'this method is out of date'].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: ti-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	aDataStream nextPutWeak: owner.	"owner only written if in our tree"	ti+1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!Morph methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 14:34'!convertbosfcepc0: varDict bosfce0: smartRefStrm	"These variables are automatically stored into the new instance ('bounds' 'owner' 'submorphs' 'fullBounds' 'color' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('extension' ) and deal with the information in ('eventHandler' 'properties' 'costumee' )""This method moves all property variables as well as eventHandler, and costumee into a morphicExtension."	| propVal |	"Move refs to eventhandler and costumee into extension"	(varDict at: 'eventHandler') == nil ifFalse: [self eventHandler: (varDict at: 'eventHandler')].	(varDict at: 'costumee') == nil ifFalse: [self player: (varDict at: 'costumee')].	(varDict at: 'properties') == nil ifFalse:		[(varDict at: 'properties') keys do:			[:key |  "Move property extensions into extension"			propVal _ (varDict at: 'properties') at: key.			propVal ifNotNil:				[key == #possessive				ifTrue: [propVal == true ifTrue: [self bePossessive]]				ifFalse: [key ifNotNil: [					self assureExtension.					extension convertProperty: key toValue: propVal]]]].			].! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/19/1998 11:52'!addDebuggingItemsTo: aMenu hand: aHandMorph	aMenu add: 'debug...' subMenu:  (self debuggingMenuFor: aHandMorph)! !!Morph methodsFor: 'apr98 additions' stamp: 'sw 8/19/1998 11:51'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: aHandMorph.	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: aHandMorph argument.	aMenu add: 'inspect morph' action: #inspectArgument.	World ifNil:		[aMenu add: 'inspect morph (morphic)' action: #inspectArgumentInMorphic].	aMenu add: 'browse morph class' action: #browseMorphClass.	self player ifNotNil:		[aMenu add: 'inspect player' action: #inspectPlayer.		World ifNil: [aMenu add: 'inspect player (morphic)' action: #inspectArgumentsPlayerInMorphic].		aMenu add: 'browse player class' action: #browsePlayerClass].	aMenu add: 'make own subclass' action: #subclassMorph.	aMenu add: 'internal name' action: #nameMorph.	aMenu add: 'save morph in file' action: #saveOnFile.	aMenu defaultTarget: self.	aMenu add: 'edit balloon help' action: #editBalloonHelpText.	aMenu add: 'temp command' action: #tempCommand.	^ aMenu! !!Morph methodsFor: 'dec97 additions' stamp: 'sw 8/19/1998 18:14'!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer _ self player) ifNil:		[self externalName.  "a default may be given if not named yet"		self player: (aPlayer _ self newPlayerInstance).  			"Different morphs may demand different player types"		aPlayer costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ aPlayer! !!Morph class methodsFor: 'instance creation' stamp: 'jm 5/29/1998 21:28'!newBounds: bounds color: color	^ (self new privateBounds: bounds) privateColor: color! !!Morph class methodsFor: 'misc' stamp: 'sw 8/4/1998 16:51'!morphsUnknownToTheirOwners	"Return a list of all morphs (other than HandMorphs) whose owners do not contain them in their submorph lists"	"Morph morphsUnknownToTheirOwners"	| problemMorphs itsOwner |	problemMorphs _ OrderedCollection new.	self allSubInstances do:		[:m | (m isHandMorph not and: [((itsOwner _ m owner) ~~ nil and: [(itsOwner submorphs includes: m) not])])			ifTrue:				[problemMorphs add: m]].	^ problemMorphs! !!Morph class methodsFor: 'misc' stamp: 'sw 8/4/1998 17:31'!repairMorphsUnknownToTheirOwners	"Morph repairMorphsUnknownToTheirOwners"	| aList |	(aList _ self morphsUnknownToTheirOwners) do:		[:m | m privateOwner: nil].	^ aList size printString, ' morph(s) repaired'! !MorphExtension provides access to extra instance state that is not required in most simple morphs.  This allows simple morphs to remain relatively lightweight while still admitting more complex structures as necessary.  The otherProperties field takes this policy to the extreme of allowing any number of additional named attributes, albeit at a certain cost in speed and space.!!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:53'!actorState	^ actorState! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!actorState: newValue	actorState _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:52'!balloonText	^ balloonText! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!balloonText: newValue	balloonText _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:52'!balloonTextSelector	^ balloonTextSelector! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!balloonTextSelector: newValue	balloonTextSelector _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:54'!eventHandler	^ eventHandler! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!eventHandler: newValue	eventHandler _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 14:47'!externalName	^ externalName! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 14:47'!externalName: newValue	externalName _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!isPartsDonor	^ isPartsDonor! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/11/1998 12:52'!isPartsDonor: newValue	isPartsDonor _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!locked	^ locked! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:54'!locked: newValue	locked _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:53'!player	^ player! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:56'!player: newValue	player _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!sticky	^ sticky! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!sticky: newValue	sticky _ newValue! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/14/1998 13:07'!visible	^ visible! !!MorphExtension methodsFor: 'named access' stamp: 'di 8/10/1998 12:55'!visible: newValue	visible _ newValue! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:56'!hasProperty: propName	"Answer whether the receiver has the given property.  Deemed to have it only if I have a property dictionary entry for it and that entry is neither nil nor false"	| prop |	otherProperties == nil ifTrue: [^ false].	prop _ otherProperties at: propName ifAbsent: [nil].	prop == nil ifTrue: [^ false].	prop == false ifTrue: [^ false].	^ true! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 12:02'!otherProperties	^ otherProperties! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:56'!removeProperty: propName	otherProperties == nil ifTrue: [^ self].	otherProperties removeKey: propName ifAbsent: [].	otherProperties size == 0 ifTrue: [otherProperties _ nil]! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!setProperty: propName toValue: aValue	"These special cases move old properties into named fields of the extension"	otherProperties == nil ifTrue: [otherProperties _ IdentityDictionary new].	otherProperties at: propName put: aValue.! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!valueOfProperty: propName	otherProperties == nil ifTrue: [^ nil].	^ otherProperties at: propName ifAbsent: [nil]! !!MorphExtension methodsFor: 'other properties' stamp: 'di 8/11/1998 22:57'!valueOfProperty: propName ifAbsent: aBlock	otherProperties == nil ifTrue: [^ aBlock value].	^ otherProperties at: propName ifAbsent: [^ aBlock value]! !!MorphExtension methodsFor: 'copying' stamp: 'di 8/11/1998 15:14'!copyPropertiesFrom: donorMorph dict: dict	| val |	otherProperties _ donorMorph otherProperties copy.	otherProperties ifNotNil: [		otherProperties associationsDo:			[:assn | val _ assn value.			val isMorph ifTrue: [				val owner ifNil: [assn value: (val copyRecordingIn: dict)]]]].					"note side effecting.  Any un-owned morph belongs to us."! !!MorphExtension methodsFor: 'copying' stamp: 'di 8/11/1998 15:16'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot."	| old |	eventHandler == nil ifFalse:		[self eventHandler: self eventHandler copy.		1 to: self eventHandler class instSize do:			[:i | old _ eventHandler instVarAt: i.			old isMorph ifTrue:				[eventHandler instVarAt: i put: (aDictionary at: old ifAbsent: [old])]]].	otherProperties ifNotNil: [		otherProperties associationsDo:			[:assn | assn value: (aDictionary at: assn value ifAbsent: [assn value])]].			"note side effecting"! !!MorphExtension methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 14:19'!comeFullyUpOnReload	"inst vars have default booplean values."	locked ifNil: [locked _ false].	visible ifNil: [visible _ true].	sticky ifNil: [sticky _ false].	isPartsDonor ifNil: [isPartsDonor _ false].	^ self! !!MorphExtension methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 14:31'!convertProperty: propName toValue: aValue	"These special cases move old properties into named fields of the extension"	propName == #locked ifTrue: [^ locked _ aValue].	propName == #visible ifTrue: [^ visible _ aValue].	propName == #sticky ifTrue: [^ sticky _ aValue].	propName == #balloonText ifTrue: [^ balloonText _ aValue].	propName == #balloonTextSelector ifTrue: [^ balloonTextSelector _ aValue].	propName == #actorState ifTrue: [^ actorState _ aValue].	propName == #player ifTrue: [^ player _ aValue].	propName == #name ifTrue: [^ externalName _ aValue].  "*renamed*"	propName == #partsDonor ifTrue: [^ isPartsDonor _ aValue].  "*renamed*"	otherProperties == nil ifTrue: [otherProperties _ IdentityDictionary new].	otherProperties at: propName put: aValue.! !!MorphExtension methodsFor: 'initialization' stamp: 'di 8/16/1998 12:02'!initialize	"Init all booleans to default values"	locked _ false.	visible _ true.	sticky _ false.	isPartsDonor _ false.! !!MorphExtension methodsFor: 'other' stamp: 'sw 8/20/1998 12:35'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ', self identityHashPrintString.	locked == true ifTrue: [aStream nextPutAll: ' [locked] '].	visible == true ifTrue: [aStream nextPutAll: ' [visible] '].	sticky == true ifTrue: [aStream nextPutAll: ' [sticky] '].	balloonText ifNotNil: [aStream nextPutAll: ' [balloonText] '].	balloonTextSelector ifNotNil: [aStream nextPutAll: ' [balloonTextSelector: ', balloonTextSelector printString, '] '].	externalName ifNotNil: [aStream nextPutAll: ' [externalName = ', externalName, ' ] '].	isPartsDonor == true ifTrue: [aStream nextPutAll: ' [isPartsDonor] '].	player ifNotNil: [aStream nextPutAll: ' [player = ', player printString, '] '].	eventHandler ifNotNil: [aStream nextPutAll: ' [eventHandler = ', eventHandler printString, '] '].	otherProperties size > 0 ifTrue: [aStream nextPutAll: ' [other = ', otherProperties keys asArray printString, ']']! !A morph whose appearance is a thumbnail of some other morph.!!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:07'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'reveal original morph' action: #revealOriginal.	aCustomMenu add: 'grab original morph' action: #grabOriginal.! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 17:37'!computeThumbnail	| f scale |	f _ morphRepresented imageForm.	morphRepresented fullReleaseCachedState.	scale _ self height / f height.  "keep height invariant"	self form: (f magnify: f boundingBox by: scale smoothing: 2).	self extent: originalForm extent! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:08'!grabOriginal	self primaryHand attachMorph: morphRepresented! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 8/10/1998 07:05'!initialize	| f |	super initialize.	color _ Color lightGray.  "background color"	f _ Form extent: 60@80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!MorphThumbnail methodsFor: 'all' stamp: 'jm 11/17/97 17:30'!morphRepresented	^ morphRepresented! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 6/26/1998 15:37'!morphRepresented: aMorph	morphRepresented _ aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 22:04'!revealOriginal	((owner isKindOf: PasteUpMorph) and: [owner alwaysShowThumbnail])		ifTrue:			[^ self beep].	morphRepresented owner == nil ifTrue:		[^ owner replaceSubmorph: self by: morphRepresented].	self beep.! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 8/10/1998 07:05'!smaller	self form: (self form copy: (0@0 extent: self form extent // 2))! !!MorphThumbnail methodsFor: 'all' stamp: 'sw 7/6/1998 15:39'!thumbnailOfHeight: aHeight	self height: aHeight.	self computeThumbnail.	^ self! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 9/21/1998 17:54'!openOn: aWorldMorph label: aString cautionOnClose: aBoolean	"Open a view with the given label on the given WorldMorph."	| aModel |	aModel _ aBoolean		ifTrue:		[CautiousModel new]		ifFalse:		[WorldViewModel new].	^ self openOn: aWorldMorph label: aString model: (aModel initialExtent: aWorldMorph initialExtent)! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 11:40'!openWorldWith: aMorph labelled: labelString	| w |	w _ WorldMorph new addMorph: aMorph.	w startSteppingSubmorphsOf: aMorph.	self openOn: w		label: labelString		extent: w fullBounds extent + 2.! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:16'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard was being held down when this event occurred. Macintosh specific."	^ buttons anyMask: 32! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:20'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!MorphicModel methodsFor: 'initialization' stamp: 'jm 8/20/1998 09:08'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model _ anObject.! !!MorphicModel class methodsFor: 'instance creation' stamp: 'tk 8/13/1998 12:58'!new	"Return a copy of the prototype, if there is one.	Otherwise create a new instance normally."	self hasPrototype ifTrue: [^ prototype veryDeepCopy].	^ super new! !!MorphicModel class methodsFor: 'prototype access' stamp: 'tk 8/13/1998 12:58'!prototype: aMorph	"Store a copy of the given morph as a prototype to be copied to make new instances."	aMorph ifNil: [prototype _ nil. ^ self].	prototype _ aMorph veryDeepCopy.	(prototype isKindOf: MorphicModel) ifTrue: 		[prototype model: nil slotName: nil].! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 22:44'!encounteredAtTime: ticks inScorePlayer: scorePlayer atIndex: index inEventTrack: track secsPerTick: secsPerTick	"Set frame number and milliseconds since start in case of drift"	| next |	moviePlayerMorph frameNumber: frameNumber.	moviePlayerMorph msSinceStart: scorePlayer msecsSinceStart.	"If there is a later sync point, set the appropriate frame rate until then."	(next _ self nextSyncEventAfter: index inTrack: track) == nil ifFalse:		[moviePlayerMorph msPerFrame: (next time - ticks) * secsPerTick * 1000.0						/ (next morph frameNumber - self frameNumber)].! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 14:13'!frameNumber	^ frameNumber! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/5/1998 17:04'!image: aForm player: aMoviePlayer frameNumber: n	self image: aForm.	moviePlayerMorph _ aMoviePlayer.	frameNumber _ n! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/5/1998 21:57'!nextSyncEventAfter: index inTrack: track	| evt |	index to: track size do:		[:i | evt _ track at: i.		(evt morph isMemberOf: MovieFrameSyncMorph) ifTrue: [^ evt]].	^ nil! !!MovieFrameSyncMorph methodsFor: 'all' stamp: 'di 8/6/1998 08:06'!player	^ moviePlayerMorph! !!MovieMorph methodsFor: 'menu' stamp: 'di 8/1/1998 10:03'!setRotationCenter	| frame p |	frame _ self currentFrame.	frame ifNil: [^ self].	self rotationDegrees: 0.0.   "must set rotation center with no rotation"	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld transform: p.	Sensor waitNoButton.	frame rotationCenter: p - frame bounds origin.	self setFrame: currentFrameIndex.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:21'!fullControlSpecs	^ #(				('<<>>'		invokeBookMenu 'Invoke menu')			( '<--'		firstPage		'Go to first page')			( '<<'		playReverse		'Play backward')			( '<-' 		previousPage	'Back one frame')			( '| |' 		stopPlay		'Stop playback')			('->'			nextPage		'Forward one frame')			('>>'			playForward	'Play forward')			( '-->'		lastPage			'Go to final page'))! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 14:05'!insertPage	^ self makeMyPage! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 16:56'!makeMyPage	currentPage ifNotNil: [currentPage releaseCachedState; delete].	currentPage _ ImageMorph new image: (Form extent: frameSize depth: frameDepth).	pages _ OrderedCollection with: currentPage.	self addMorphBack: currentPage.! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 22:01'!openFileNamed: fName	| f w h d n m |	movieFileName _ fName.	"Read movie file parameters from 128-byte header...		(records follow as {N=int32, N words}*)"	f _ (FileStream oldFileNamed: movieFileName) binary.		f nextInt32.		w _ f nextInt32.		h _ f nextInt32.		d _ f nextInt32.		n _ f nextInt32.		m _ f nextInt32.		f close.	pageSize _ frameSize _ w@h.	frameDepth _ d.	frameCount _ n.	frameNumber _ 1.	playDirection _ 0.	msSinceStart _ 0.0.	msPerFrame _ m/1000.0.	self makeMyPage.	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 7/6/1998 23:37'!position: newPos	super position: newPos.	(currentPage ~~ nil and: [currentPage left odd])		ifTrue: ["crude word alignment for depth = 16"				super position: newPos + (1@0)]! !!MoviePlayerMorph methodsFor: 'initialization' stamp: 'di 8/17/1998 17:12'!setInitialState	super setInitialState.	self color: Color veryLightGray.	pageSize _ frameSize _ 200@200.	frameDepth _ 8! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!frameNumber: n	frameNumber _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!msPerFrame: n	msPerFrame _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/5/1998 21:48'!msSinceStart: n	msSinceStart _ n! !!MoviePlayerMorph methodsFor: 'access' stamp: 'di 8/8/1998 11:53'!thumbnailForThisPage	"Overridden to make a MovieFrameSyncMorph"	| image |	image _ currentPage image.	self primaryHand attachMorph:		(MovieFrameSyncMorph new			image: (image magnifyBy: 50 asFloat / (image width max: image height))			player: self frameNumber: frameNumber)! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:32'!firstPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: 1! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 19:02'!goToPage: i	currentPage ifNil: [self makeMyPage].	frameNumber _ i.	playDirection _ 0.	self startRunning; step  "will stop after first step"! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!lastPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: frameCount! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!nextPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: (frameNumber _ frameNumber + 1 min: frameCount).! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 21:30'!playForward	(playDirection ~= 0 or: [frameNumber >= frameCount]) ifTrue:		[^ self]. "No-op during play or at end"	playDirection _ 1.	self startRunning! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/17/1998 21:30'!playReverse	(playDirection ~= 0 or: [frameNumber <= 1]) ifTrue:		[^ self]. "No-op during play or at end"	playDirection _ -1.	self startRunning! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 7/6/1998 19:29'!previousPage	playDirection = 0 ifFalse: [^ self]. "No-op during play"	self goToPage: (frameNumber _ frameNumber - 1 max: 1).! !!MoviePlayerMorph methodsFor: 'player control' stamp: 'di 8/5/1998 23:40'!stopPlay	playDirection _ 0.	scorePlayer _ nil! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/6/1998 22:59'!pauseFrom: player	playDirection _ 0.	scorePlayer _ nil! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/6/1998 08:46'!resetFrom: player	self pauseFrom: player.	frameNumber _ 1! !!MoviePlayerMorph methodsFor: 'score events' stamp: 'di 8/17/1998 19:02'!resumeFrom: player	playDirection _ 1.	scorePlayer _ player.	self startRunning! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 21:47'!startRunning	| ff byteCount |	movieFile _ AsyncFile new open: movieFileName forWrite: false.	ff _ currentPage image. 	byteCount _ ff bits size * 4.	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.	scorePlayer == nil ifTrue: [msSinceStart _ Time millisecondClockValue].! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 21:49'!step	"NOTE:  The movie player has two modes of play, depending on whether scorePlayer is nil or not.  If it is nil, then play runs according to the millisecond clock.  If scorePlayer is not nil, then the scorePlayer is consulted for synchronization.  In either case, ssome calls on step will skip their  action until the right time."	"ALSO: This player operates with overlapped disk i/o.  This means that while one frame is being displayed, the next frame in sequence is being read into a disk buffer.  The value of frameNumber corresponds to the frame currently visible."	|  ff byteCount ms |	movieFile == nil ifTrue: [^ self].	scorePlayer == nil		ifTrue: [ms _ Time millisecondClockValue.				ms < msSinceStart ifTrue: [msSinceStart _ ms "clock rollover"].				ms < (msSinceStart + msPerFrame) ifTrue: [^ self]]		ifFalse: [msSinceStart > scorePlayer msecsSinceStart ifTrue: [^ self]].	ff _ currentPage image. 	byteCount _ ff bits size * 4.	frameNumber _ frameNumber + playDirection.	msSinceStart _ msSinceStart + msPerFrame.	movieFile waitForCompletion.	movieFile primReadResult: movieFile fileHandle intoBuffer: ff bits			at: 1 count: byteCount//4.	currentPage changed.	(playDirection = 0		or: [(playDirection > 0 and: [frameNumber >= frameCount])		or: [playDirection < 0 and: [frameNumber <= 1]]])		ifTrue: [^ self stopRunning].		"Start the read operation for the next frame..."	movieFile primReadStart: movieFile fileHandle			fPosition: 128 + ((frameNumber+playDirection-1)*(4+byteCount)) + 4			count: byteCount.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/8/1998 11:57'!stepTime	^ 0  "step as fast as possible"! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'di 8/17/1998 19:01'!stopRunning	"Must only be called with no outstanding file read requests..."	movieFile ifNotNil:		[movieFile close.		movieFile _ nil].	playDirection _ 0.! !(out of date class....)!!MswUrl methodsFor: 'misc' stamp: 'ls 7/1/1998 02:23'!httpUrlOfServer	"return the HTTP address to make queries to"		#XXX.  "should come up with a better name for this when I'm less tired"	^HttpUrl schemeName: 'http'  authority: authority  path: path  query: nil.! !!MswUrl methodsFor: 'access' stamp: 'ls 7/12/1998 23:34'!query	"return the query.  There is never a MuSwiki URL without a query; the query defaults to 'top' if none is explicitly specified"	| q |	q _ super query.	q isNil ifTrue: [ q _ 'top' ].	^q! !!NetNameResolver class methodsFor: 'lookups' stamp: 'ls 9/5/1998 01:14'!addressForName: aString	^self addressForName: aString timeout: 60! !!NewParagraph methodsFor: 'composition' stamp: 'di 6/22/1998 12:37'!composeLinesFrom: startingIndex withLines: startingLines atY: startingY	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR |	charIndex _ startingIndex.	lines _ startingLines.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= container bottom]]		whileTrue:		[lineHeight _ lineHeightGuess.		saveCharIndex _ charIndex.		hitCR _ false.		(row _ container rectanglesAt: lineY height: lineHeight)			withIndexDo:			[:r :i | (charIndex <= text size and: [hitCR not]) ifTrue:				[line _ scanner composeFrom: charIndex inRectangle: r						firstLine: firstLine leftSide: i=1 rightSide: i=row size.				lines addLast: line.				(text at: line last) = Character cr ifTrue: [hitCR _ true].				lineHeight _ lineHeight max: line lineHeight.  "includes font changes"				charIndex _ line last + 1]].		row size >= 1 ifTrue:		[lineY _ lineY + lineHeight.		lineY > container bottom			ifTrue: ["Oops -- the line is really too high to fit -- back out"					charIndex _ saveCharIndex.					row do: [:r | lines removeLast]]			ifFalse: ["It's OK -- the line still fits."					maxRightX _ maxRightX max: scanner rightX.					1 to: row size - 1 do:  "Adjust heights across row if necess"						[:i | (lines at: lines size - row size + i)								lineHeight: lines last lineHeight								baseline: lines last baseline].					charIndex > text size ifTrue:						["end of text"						hitCR ifTrue:							["If text ends with CR, add a null line at the end"							((lineY + lineHeightGuess) <= container bottom) ifTrue:								[row _ container rectanglesAt: lineY height: lineHeightGuess.								row size > 0 ifTrue:									[line _ (TextLine start: charIndex stop: charIndex-1										internalSpaces: 0 paddingWidth: 0)									rectangle: row first;									lineHeight: lineHeightGuess baseline: textStyle baseline.									lines addLast: line]]].						lines _ lines asArray.						^ maxRightX].					firstLine _ false]]			ifFalse:			[lineY _ lineY + lineHeight]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: startingIndex stop: startingIndex-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'selection' stamp: 'di 6/22/1998 12:28'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: aPoint index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'di 9/14/1998 11:43'!defaultStartBlock	selectionStart ifNotNil: [^ selectionStart].	^ (CharacterBlock new stringIndex: firstCharacterIndex text: text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!NewParagraph methodsFor: 'selection' stamp: 'di 9/14/1998 11:45'!defaultStopBlock: aCharacterBlock	selectionStop ifNotNil: [^ selectionStop].	^ aCharacterBlock! !!NewParagraph methodsFor: 'selection' stamp: 'di 9/20/1998 10:45'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ self caretWidth.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexForCharacter: cb1 stringIndex.	line2 _ self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomRight)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [:i | rects addLast: (lines at: i) rectangle].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	^ time + duration! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:06'!pitch	"Convert my MIDI key number to a pitch and return it."	^ AbstractSound pitchForMIDIKey: midiKey! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:58'!endNoteOnMidiPort: aMidiPort	"Output a noteOff event to the given MIDI port. (Actually, output a noteOff event with zero velocity. This does the same thing, but allows running status to be used when sending a mixture of note on and off commands.)"	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: 0.! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:56'!startNoteOnMidiPort: aMidiPort	"Output a noteOn event to the given MIDI port."	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: velocity.! !!Number methodsFor: 'mathematical functions' stamp: 'di 9/8/1998 17:10'!log	"Answer the base-10 log of the receiver."	^self asFloat log! !!Number methodsFor: 'printing' stamp: 'sw 7/1/1998 12:33'!stringForReadout	^ self rounded printString! !!Object methodsFor: 'accessing' stamp: 'jm 6/1/1998 12:41'!do: aBlock	"Obsolete!! Replaced by Object>in:. Apply the given block to the receiver, as if the receiver were contained in a collection with itself as the only element."	"Note: Calling this method 'do:' turned out to mask errors. For example, an initialized instance variable will respond to 'do:', passing nil as an argument. This method will be entirely removed in the future."	self notify:'Only collections should respond to "do:". The "do:" method in Object will soon be removed; clients depending on it should use "in:" instead. If you get this message in system code, please report it to johnm@wdi.disney.com. Proceed from this notifier to get the old behavior.'.	^ self in: aBlock! !!Object methodsFor: 'accessing' stamp: 'jm 5/29/1998 14:51'!in: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'testing' stamp: 'ls 7/14/1998 21:45'!isWebBrowser	"whether this object is a web browser.  See class: Scamper"	^false! !!Object methodsFor: 'comparing' stamp: 'sw 8/20/1998 12:34'!identityHashPrintString	"'fred' identityHashPrintString"	^ '(', self identityHash printString, ')'! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 16:01'!copyAddedStateFrom: anotherObject	"Copy over the values of instance variables added by the receiver's class from anotherObject to the receiver.  These will be remapped in mapUniClasses, if needed."	self class superclass instSize + 1 to: self class instSize do:		[:index | self instVarAt: index put: (anotherObject instVarAt: index)]! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 22:16'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  Both pointers point to one new copy."	| copier new |	copier _ DeepCopier new initialize.	new _ self veryDeepCopyWith: copier.	copier mapUniClasses.	^ new! !!Object methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new absent uc |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	class _ self class.	class isMeta ifTrue: [^ self].		"a class"	new _ self clone.	class isSystemDefined ifFalse: [		uc _ deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [deepCopier uniClasses at: class put: (uc _ self copyUniClass)].		new _ uc new].	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index _ self basicSize.		[index > 0] whileTrue: 			[sub _ self basicAt: index.			(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index _ index - 1]].	index _ class instSize.	[index > 0] whileTrue: 		[sub _ self instVarAt: index.		(subAss _ deepCopier references associationAt: sub ifAbsent: [nil])			ifNil: [new instVarAt: index put: (sub veryDeepCopyWith: deepCopier)]			ifNotNil: [new instVarAt: index put: subAss value].		index _ index - 1].	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!Object methodsFor: 'updating' stamp: 'jm 8/20/1998 18:26'!windowIsClosing	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!modelWakeUp	"A window with me as model is being entered.  Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowActiveOnFirstClick	"Return true if my window should be active on first click."	^ false! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowReqNewLabel: labelString	"My window's title has been edited.	Return true if this is OK, and override for further behavior."	^ true! !!Object methodsFor: 'private' stamp: 'di 5/28/1998 12:50'!primitiveError: aString 	"This method is called when the error handling results in a recursion in calling	on error: or halt or halt:."	| context |	(String streamContents:		[:s |		s nextPutAll: '**System error handling failed** '.		s cr; nextPutAll: aString.		context _ thisContext sender sender.		20 timesRepeat: 			[context == nil ifFalse: [s cr; print: (context _ context sender)]].		s cr; nextPutAll: '**Type any character to restart.**'])		displayAt: 0@0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard.	Smalltalk isMorphic ifTrue:		[^ World install "To init hand events and redisplay world"].	ScheduledControllers searchForActiveController! !!Object methodsFor: 'converting' stamp: 'jm 6/1/1998 12:58'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ (OrderedCollection new: 1) add: self; yourself! !!Object methodsFor: 'macpal' stamp: 'sw 6/16/1998 15:07'!instanceVariableValues	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class"	| c |	c _ OrderedCollection new.	self class superclass instSize + 1 to: self class instSize do:		[:i | c add: (self instVarAt: i)].	^ c! !!Object methodsFor: 'objects from disk' stamp: 'tk 8/19/1998 15:03'!rehash	"Do nothing.  Here so sending this to a Set does not have to do a time consuming respondsTo:"! !!Object class methodsFor: 'instance creation' stamp: 'tk 8/22/1998 08:22'!initialInstance	"Answer the first instance of the receiver, generate an error if there is one already"	"self instanceCount > 0 ifTrue: [self error: 'instance(s) already exist.']."		"Debugging test that is very slow"	^ self new! !!Object class methodsFor: 'instance creation' stamp: 'tk 8/22/1998 08:27'!instanceOfUniqueClassWithInstVarString: instVarString andClassInstVarString: classInstVarString	"Create a unique class for the receiver, and answer an instance of it"	^ (self newUniqueClassInstVars: instVarString 		classInstVars: classInstVarString) initialInstance! !!Object class methodsFor: 'instance creation' stamp: 'tk 6/29/1998 12:11'!newUniqueClassInstVars: instVarString classInstVars: classInstVarString	"Create a unique class for the receiver"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass newUniqueClassInstVars: instVarString classInstVars: classInstVarString].	aName _ self chooseUniqueClassName.	aClass _ self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	^ aClass! !!ObjectScanner methodsFor: 'as yet unclassified' stamp: 'tk 8/15/1998 15:26'!initialize	"remove all old class vars that are not instance-specific classes being renamed"	self clear.	"Most importantly, return self, so a fileIn will let ObjectScanner seize control.  So UniClasses can be remapped.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"!]style[(10 247 22 17)f1b,f1,f1LReadWriteStream fileIn;,f1! !!PCXReadWriter methodsFor: 'accessing' stamp: 'tao 10/6/97 10:11'!nextImage	"Read in the next PCX image from the stream."	| bytes form |	self readHeader.	bytes _ self readBody.	colorPalette _ self readPalette.	self close.	form _ ColorForm extent: width@height depth: bitsPerPixel.	(Form new hackBits: bytes) displayOn: (Form new hackBits: form bits).	form colors: colorPalette.	^ form! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:38'!nextWord	^self next + (self next bitShift: 8)! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 10:07'!readBody	| array scanLine rowBytes position byte count pad |	pad _ #(0 3 2 1) at: (width \\ 4 + 1).	array _ ByteArray new: ((width + pad) * height * bitsPerPixel) // 8.	scanLine _ ByteArray new: rowByteSize.	position _ 1.	1 to: height do:		[:line |		rowBytes _ 0.		[rowBytes < rowByteSize] whileTrue:			[byte _ self next.			byte < 16rC0				ifTrue:					[rowBytes _ rowBytes + 1.					scanLine at: rowBytes put: byte]				ifFalse:					[count _ byte - 16rC0.					byte _ self next.					1 to: count do: [:i | scanLine at: rowBytes + i put: byte].					rowBytes _ rowBytes + count]].		array			replaceFrom: position			to: position + width - 1			with: scanLine			startingAt: 1.		position _ position + width + pad].	^ array! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 09:42'!readHeader	| xMin xMax yMin yMax |	self next.	"skip over manufacturer field"	version _ self next.	encoding _ self next.	bitsPerPixel _ self next.	xMin _ self nextWord.	yMin _ self nextWord.	xMax _ self nextWord.	yMax _ self nextWord.	width _ xMax - xMin + 1.	height _ yMax - yMin + 1.	self next: 4. "skip over device resolution"	self next: 49. "skip over EGA color palette"	colorPlanes _ self next.	rowByteSize _ self nextWord.	isGrayScale _ (self next: 2) = 2.	self next: 58. "skip over filler".! !!PCXReadWriter methodsFor: 'private-decoding' stamp: 'tao 10/6/97 08:29'!readPalette	| r g b array |	self next = 12 ifFalse: [self error: 'no Color Palette!!'].	array _ Array new: (1 bitShift: bitsPerPixel).	1 to: array size do:		[:i |		r _ self next.  g _ self next.  b _ self next.		array at: i put: (Color r: r g: g b: b range: 255)].	^ array.! !Post Office Protocol.  This is used to download email over the network, usually from an intermittent connection.  To see how to use it, see POPSocket classe>>example.!!POPSocket methodsFor: 'private-initialization' stamp: 'ls 9/7/1998 05:27'!initialize	super initialize.	progressObservers _ IdentitySet new.! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:14'!addProgressObserver: anObserver	"progress will be sent to anObserver.  anObserver should respond to show:, endEntry, cr....  Transcript things"	progressObservers add: anObserver! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!password: aString	"set the password to use"	password _ aString ! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:22'!serverName: aString	"set the server name to connect to"	serverName _ aString! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!userName: aString	"set the username to use"	userName _ aString! !!POPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 19:57'!reportToObservers: aString	"send aString to all observers"	progressObservers do: [ :observer |		observer show: aString.		aString last = Character cr ifFalse: [ observer show: String cr ]].! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/14/1998 06:40'!connectToPOP	"connect to the POP server"	| address response |	Socket initializeNetwork.	address _ NetNameResolver addressForName: serverName timeout: 15.	address = nil ifTrue: [		self error: 'Could not find the address for ', serverName	].	"connect the socket"	self connectTo: address port: 110.	(self waitForConnectionUntil: POPSocket standardDeadline) ifFalse: [		self close.		self reportToObservers: 'failed to connect to server'.		^false ].	"get a hello message"	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close.  ^false ].	"login"	self sendCommand: 'USER ', userName.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	self sendCommand: 'PASS ', password.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	^true! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:55'!deleteAllMessages	"delete all messages"	1 to: self numMessages do: [ :num |		self deleteMessage: num ]! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/7/1998 06:07'!deleteMessage: num	"delete the numbered message"	self sendCommand: 'DELE ', num printString.	self reportToObservers: self getResponse.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 20:00'!disconnectFromPOP	"send a QUIT message and disconnect"	self reportToObservers: 'closing connection'.	numMessages _ nil.	self sendCommand: 'QUIT'.	self reportToObservers: self getResponse.	self closeAndDestroy.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:54'!messagesDo: aBlock	"perform aBlock on each message text"	| thisMessage |	1 to: self numMessages do: [ :num |		thisMessage _ self retrieveMessage: num.		aBlock value: thisMessage.	].	! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 02:02'!numMessages	"query the number of messages that are in the POP mailbox"	| response answerString |	numMessages ifNotNil: [ ^numMessages ].	self sendCommand: 'STAT'.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [ 		"ERROR"		^0 ].	[			answerString _ (response findTokens: Character separators) second.		numMessages _ answerString asNumber asInteger.		^numMessages	] ifError: [ :a :b |	].	"parse error"	^0! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/7/1998 06:04'!retrieveMessage: number	"retrieve the numbered message"	| response |	self sendCommand: 'RETR ', number printString.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [		self error: 'error: ', response ].	^self getMultilineResponse.! !!POPSocket class methodsFor: 'as yet unclassified' stamp: 'ls 9/10/1998 19:44'!example	"POPSocket example"	"download a user's messages into an OrderedCollection and inspect the OrderedCollection"	| ps messages |	ps _ POPSocket new.	ps serverName: (FillInTheBlank request: 'POP server').	ps userName: (FillInTheBlank request: 'POP username').	ps password: (FillInTheBlank request: 'POP password').	ps addProgressObserver: Transcript.	messages _ OrderedCollection new.	ps connectToPOP.	ps messagesDo: [ :messageText |		messages add: messageText ].	ps disconnectFromPOP.	messages inspect.! !!POPSocket class methodsFor: 'as yet unclassified' stamp: 'RAA 7/19/1998 22:43'!getMessagesNotifying: aProgressReporter andForEachDo: aBlock	|  s |		self initializeNetwork.	s _ self createIfFail: [self error: 'For some reason I could not create a POP socket'].	^s getMessagesNotifying: aProgressReporter andForEachDo: aBlock.! !!PSwikiAction methodsFor: 'all' stamp: 'mjg 9/10/1998 15:35'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit"	| coreRef page |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			(HTMLformatter evalEmbedded: (self fileContents:source, 'results.html')				with: (urlmap searchFor: (request fieldsat: 'searchFor' ifAbsent: ['nothing']))).		^ #return].	(request fields includesKey: 'text') ifTrue: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			username: (request fields at: 'username' ifAbsent:[''])			password: (request fields at: 'password' ifAbsent: [''])			privs: (request fields at: 'privs' ifAbsent: [''])			text: (request fields at: 'text' ifAbsent: ['blanktext'])			from: request peerName.		page user: request userID.  "Address is machine, user onlyif logged in"		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!PSwikiAction methodsFor: 'all' stamp: 'tk 9/16/1998 16:21'!process: request	"URLs are of the form:	{swikiname} to browse Front Page	{swikiname}.{coreID} to browse the page	{swikiname}.{coreID}.edit  to edit the page	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.{coreID}.versions displays the last three versions of the page	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for references to coreID's key	{swikiname}.{picName}.gif (or jpeg, jpg, jpe, upper or lower case) 		return the picture stored in the {swikiname} folder."	"Transcript show: 'Got request ',(request url); cr."	| coreRef pageRef command formattedPage theLast |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"		(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf, (HTMLformatter					evalEmbedded: (self fileContents: source, 'recent.html')					with: urlmap recent).			^ self]."	request reply: PWS crlf.		End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue: ["SearchResult, All, Versions, or Edit"		command _ request message at: 3.		command = 'edit' ifTrue:			[^self edit: pageRef from: request].		command = 'versions' ifTrue:					[request reply: ((self formatterFor: 'versions') format: pageRef).					^self].		command = 'searchresult' ifTrue:			[request reply: (HTMLformatter evalEmbedded:							(self fileContents: source , 'results.html')						with: (urlmap searchFor: pageRef name)).			^ self].		command = 'all' ifTrue:			[formattedPage _ urlmap allPagesFrom: pageRef for: request.			request reply: (HTMLformatter evalEmbedded:							(self fileContents: source, 'page.html')						with: formattedPage).			^ self].		(request message at: 1) = (request message at: 2) ifTrue: [			request reply: '<h1>Your original url has a slash after it.  Please remove it.</h1>'.			request message: (request message copyFrom: 2 to: request message size).			^ self process: request].	"(success and contentHTML will be sent twice!!)"		Transcript show: 'Unknown command: ', command; cr.		^ self].	"Just a browse"	^ self browse: pageRef from: request! !!PSwikiPage methodsFor: 'all' stamp: 'BJP 9/10/1998 14:33'!outputFormat	| formatCollection textBlock |"Ah, yes, my first experience with class vars. I need to think about thisscheme a bit, but it's only	 a placeholder anyway. BJP"	formatCollection _ OrderedCollection newFrom: super outputFormat.	textBlock _ formatCollection last.	^ formatCollection		add: [:thePage | 'authName: ', thePage usernameprintString, '; ']before: textBlock;		add: [:thePage | 'authPW: ', thePage password printString,'; ']before: textBlock;		add: [:thePage | 'privs: ', thePage privs printString, '; ']before: textBlock.! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:40'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse:[peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (action formatter swikify: (pageRef text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo: refPages]).	refPages _ refPages reject: [:page | page pageStatus = #new].	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPageformatted.	refPages do: [:page |		(page privs includesSubString: 'read') ifTrue:			[(action auth user: request userID) = page coreID			ifFalse: [self error: (PWS unauthorizedFor: (pagename))]].		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo:(OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THEpage"	^formattedPage! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:36'!newpage: label from: peer	| newpage newfile |		newpage _ PSwikiPage new.		self at: label put: newpage.		newfile _ pages size printString.		newpage address: peer.		newpage date: (Date today).		newpage coreID: newfile.		newpage name: label.		newpage username: ''.		newpage password: ''.		newpage privs: ''.		newpage pageStatus: #new.		newpage file: ((ServerAction serverDirectory),			directory, (ServerAction pathSeparator), newfile).		newpage text: 'Describe ',label,' here'.		newpage map: self.		newpage url: (action name),'.',newfile.	^newpage! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:39'!recent	| response sortedPages currentDate |	sortedPages _ pages reject: [:page | page pageStatus = #new].	sortedPages _ sortedPages asSortedCollection: [:a :b | (a date = bdate) ifTrue: [a time > b time]			ifFalse: [a date > b date]].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'.	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDateprintString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL:page),'...',(page address).		(page privs includesSubString: 'read') ifTrue:			[response nextPutAll: '  <b>Read protected</b>'.].		(page privs includesSubString: 'write') ifTrue:			[response nextPutAll: '  <b>Write protected</b>'.].].	response nextPutAll: '</ul>'.	^response contents! !!PURLmap methodsFor: 'all' stamp: 'BJP 9/10/1998 14:41'!storeID: id  username: theUsername password: thePassword privs: thePrivstext: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page address: peer.	(theUsername size > 1) ifTrue: [		page username: theUsername.		page password: thePassword.		page privs: thePrivs.		"Set up the authorization"		action auth mapName: theUsername password: thePassword			to: id.].	page text: text.	^ page! !!PWS methodsFor: 'Accessing' stamp: 'tk 9/16/1998 15:50'!message: anArray   message _ anArray! !!PWS methodsFor: 'Initializing' stamp: 'ls 7/22/1998 22:47'!initializeFrom: aSocket	"Initialize me from aSocket."	| request idx |	log _ WriteStream on: ''.	connection _ aSocket.	request _ self readRequest.	"sets header"	header _ header substrings.	url _ self unEscape: (header at: 2).	((idx _ header indexOf: 'Authorization:') ~= 0 and: [(header at:idx + 1)			= 'Basic'])		ifTrue: [userId _ header at: idx + 2].	peerName _ self clientName: connection remoteAddress.	log		nextPutAll: Time totalSeconds asString; tab;		nextPutAll: peerName asString; tab;		nextPutAll: userId asString; tab;		nextPutAll: url; tab;		nextPutAll: request last asString; tab.	request last notNil		ifTrue: [ fields := self decodeFields: request last ]		ifFalse: [ (url includes: $?) ifTrue: [			idx _ url indexOf: $?.			idx = url size				ifTrue: [ "empty request" fields _Dictionary new ]				ifFalse: [					fields _ self decodeFields:						(url copyFrom: idx+1 to:url size) ].			url _ url copyFrom: 1 to: idx-1 ] ].	message := url findTokens: '/.\?:='.! !!PWS methodsFor: 'Initializing' stamp: 'ls 7/22/1998 22:44'!readRequest	"Read the request and return an array of header and query."	| idx request query length |	request := ''.	[	request := request, connection getData.		(idx := request findString: (self class crlfcrlf)startingAt: 1) = 0 ] whileTrue.	header := request copyFrom: 1 to: idx - 1.	(request beginsWith: 'POST') ifTrue: [		(length := request asUppercase findString:'CONTENT-LENGTH:' startingAt: 1) = 0			ifTrue: [ self error: '* noLength' ].		length := (request copyFrom: length + 15 to:		  (request indexOf: Character cr startingAt: lengthifAbsent: []))			withBlanksTrimmed asNumber + idx + 3.		[ request size < length ] whileTrue: [ request := request,connection getData ].		query := (request copyFrom: idx + 3 to: request size)withBlanksTrimmed ].	"Transcript show: request."	^{ header. query }! !!PWS methodsFor: 'Processing' stamp: 'tk 7/15/1998 12:06'!report: msg for: rec	"Write an error report."	| s |	self log: '*** ', rec asString, ': ', msg.	s _ (msg indexOfSubCollection: 'HTTP' startingAt: 1) = 1		ifTrue: [msg]		ifFalse: ['HTTP/1.0 400 Bad Request -- ', self classcrlfcrlf, msg].	[self reply: s] ifError: [:m :r | "ignore errors"].! !!PWS methodsFor: 'Processing' stamp: 'ls 7/28/1998 01:09'!unEscape: aString  "Convert escape sequences to their proper characters."	| rs ws c |	rs := ReadStream on: aString.	ws := WriteStream on: ''.	[ rs atEnd ] whileFalse: [		c := rs next.		ws nextPut:			(c = $+ ifTrue: [ $  ] ifFalse: [				c = $%					ifTrue: [ (Number readFrom: (rsnext: 2) asUppercase base: 16) asCharacter ]					ifFalse: [ c ]				]).		].	^ws contents ! !!PWS class methodsFor: 'HTTPcodes' stamp: 'tk 6/24/1998 16:24'!unauthorizedFor: realm	^'HTTP/1.0 401 Unauthorized', self crlf, 'WWW-Authenticate: Basic realm="Squeak/',realm,'"',	self crlfcrlf, '<html><title>Unauthorized</title><body><h2>Unauthorized for ',realm, '</h2></body></html>'! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:36'!checkVersion	"This is Squeak 2.2.  Make sure that the Server:swiki folder is the version for 2.2."	| fName |	fName _ ServerAction serverDirectory, 'swiki', (ServerAction pathSeparator), 				'page.html'.	(FileDirectory new fileExists: fName) ifFalse: [self inform: 'The path to the Server folder is wrong.Please modify the following method ...'. 	Browser openMessageBrowserForClass: ServerAction class 		selector: #serverDirectory editString: nil.	^ false].	fName _ ServerAction serverDirectory, 'swiki', (ServerAction pathSeparator), 				'render.html'.	(FileDirectory new fileExists: fName) ifFalse: [self inform: 'Initialization failed.  ''swiki'' folder is out of date.Get one from:http://guzdial.cc.gatech.edu/st/Swiki-GuzPWS2.tar orhttp://guzdial.cc.gatech.edu/st/Swiki-GuzPWS2.sea'. ^ false].	^ true! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:03'!howToStart	"To set up your new Swiki, you need a copy of the 'Server' folderfound at:http://www.cc.gatech.edu/fac/mark.guzdial/squeak/pws/Put the 'Server' folder into the folder that your image is in.Modify this method to be a path to your Server folder, select it, andchoose fileItIn:!!ServerAction class methodsFor: 'System Services' stamp: 'tk 1/19/98 12:52'!!serverDirectory	^ 'Hard Disk:Squeak1.31:Server:'!! !!Then do:	PWS initializeAll.To enable a new Swiki called OurOwnArea.Make a folder named OurOwnArea in the Server folder.  Then do:	SwikiAction setUp: 'OurOwnArea'.	(its main URL is http://thisMachine:80/OurOwnArea.1)<<<<There has been a major change between Squeak 2.1 and 2.2.  If you are reloading an existing Swiki for the first time in Squeak 2.2, Do this instead of the normal reload.	SwikiAction new restore: 'myswiki'.		'<- New line for each additional Swiki area'.	SwikiAction new restore: 'myswiki'.		'Case DOES matter in the name of Swiki here.'.	(PWS actions select: [ :action | action isKindOf: SwikiAction ])		do: [ :action | action fixAllLineEndings ].	PWS serveOnPort: 80 loggingTo: 'log.txt'.(This to converts LineFeeds to CarriageReturns in all of your swiki data files.  Only do this the first time!!)>>>>>Suppose you already have a Swiki called 'myswiki'.To start up:	SwikiAction new restore: 'myswiki'.		'<- New line for each additional Swiki area'.	SwikiAction new restore: 'myswiki'.		'Case DOES matter in the name of Swiki here.'.	PWS serveOnPort: 80 loggingTo: 'log.txt'.To stop the server:	PWS stopServer.-----------------------To purge a particular file of all except the latest version:	((PWS actions at: 'myswiki' asLowercase) urlmap atID: '3') condenseChanges.To roll the entire wiki back to a previous time:	""This does not erase data, it just copies the older page to the end""	(PWS actions at: 'myswiki' asLowercase) rollBack: '1/28/98' asDate			at: '1:30 am' asTime.The look of a served page is controlled by a template.  Templates live inthe 'swiki' folder in the 'Server' folder.  Beware that templates arecached by HTMLformatter.  If you change a template, you will not see theeffect until you reload the Swiki.To set up a Swiki with a password (same for all users), seeAuthorizedSwikiAction comment.To enable a privledged user to execute code remotely (on a workspace page):	(PWS actions at: 'authorized') mapName: 'JSmith' password:'hard2guess' to: 'JSmith'.	(URL is http://thisMachine:80/authorized.workspace.html)To backup the user data to the disk, do nothing.  All info is alreadyinside the page files on the disk.To enable a new Swiki that evaluates Squeak code submitted by the user.Make a folder named SqkEval in the Server folder.  Then do:	ActiveSwikiAction setUp: 'SqkEval'.	(this is dangerous, because there are still ways a user could crashyour server)To convert a Swiki with LineFeed line endings to CarriageReturn lineendings, execute these lines:          (PWS actions select: [ :action | action isKindOf: SwikiAction ])		do: [ :action | action fixAllLineENdings ]To convert from an old pre-Squeak1.3 Swiki to the new page format:	(In the old image, do a backup:)		| mine | mine _ PWS actions at: 'myswiki'.		mine saveTo: mine path,'backup28JanA'.	(Quit.  Start the new image which has this version of the Swiki code)	(Do not start the server!!!!!!)		PWS initializeAll.		SwikiAction restore: 'myswiki' from:			(ServerAction serverDirectory), 'myswiki:backup28JanA'.		(PWS actions at: 'myswiki' asLowercase) convert.	(do these steps for each Swiki you have)	(now, start the server)	PWS serveOnPort: 80 loggingTo: 'log.txt'."!]style[(10 712 46 2904)f1b,f1,f3,f1! !!PWS class methodsFor: 'Initializing' stamp: 'tk 9/13/1998 18:20'!initializeAll	| anAuthorizer |	(self checkVersion) ifFalse: [^ false].	anAuthorizer _ Authorizer new.	anAuthorizer realm: 'AuthorizedSpace'."	anAuthorizer mapName: 'JSmith' password: 'hard2guess' to: 'JSmith'.  "		"No default account!!  See howToStart to enable remote code execution."	self link: 'authorized' to: (AuthorizedServerAction new authorizer: anAuthorizer).	self link: 'chat' to: ChatPage new.	self link: 'default' to: ServerAction new.	self link: 'embedded' to: EmbeddedServerAction new.	self link: 'smtlk' to: CodeServer new.	self link: 'chunk' to: CodeServer new.	Comment setUpExample.	self link: 'comment' to: (SinglePlugServerAction new 			processBlock: [:request | Comment process: request]).! !!PWS class methodsFor: 'Serving' stamp: 'tk 7/15/1998 11:27'!serveShowingErrorsOnPort: portNumber	"Start up the HTTP server loop for debugging!!  Operate in thisprocess, synchronously.  Force errors to stop the server and show on thescreen.."	| socket logEntry inst |	self stopServer.	Socket initializeNetwork.	ServerLog _ FileStream fileNamed: 'dummy.log'.	ServerLog position: ServerLog size.	ServerPort _ ConnectionQueue portNumber: portNumber queueLength: 6.	ClientNameCache _ Dictionary new.	[true] whileTrue: [		socket _ ServerPort getConnectionOrNil.		socket notNil			ifTrue: ["serve:"				inst _ self new.				inst initializeFrom: socket.				inst getReply.				socket closeAndDestroy: 30.				logEntry _ inst log contents]		"nologging for now"			ifFalse: [(Delay forMilliseconds: 100) wait]].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 6/11/1998 11:25'!pickup: actionButton action: aSelector cursor: aCursor	"Special version for pickup: and stamp:, because of these tests"	| ss picker old map stamper |	self tool: actionButton action: aSelector cursor: aCursor.	aSelector == #stamp: ifTrue: [		(stampHolder pickupButtons includes: actionButton) ifTrue: [				stamper _ stampHolder otherButtonFor: actionButton.				^ self pickup: stamper action: #stamp: cursor: (stamper arguments at: 3)].		(stampHolder stampFormFor: actionButton) 			ifNil: [				"If not stamp there, go to pickup mode"				picker _ stampHolder otherButtonFor: actionButton.				picker state: #on.				^ self pickup: picker action: #pickup: cursor: (picker arguments at: 3)]			ifNotNil: [				old _ stampHolder stampFormFor: actionButton.				currentCursor _ ColorForm extent: old extent depth: 8.				old displayOn: currentCursor.				map _ Color indexedColors copy.				map at: 1 put: Color transparent.				currentCursor colors: map.				currentCursor offset: currentCursor extent // 2.				"Emphisize the stamp button"				actionButton owner "layoutMorph" "color: (Color r: 1.0 g: 0.645 b: 0.419);"					borderColor: (Color r: 0.65 g: 0.599 b: 0.8).				]].	aSelector == #pickup: ifTrue: [		ss _ self world findA: SketchEditorMorph.		ss ifNotNil: [currentCursor _ aCursor]	 			ifNil: [self notCurrentlyPainting.				self setAction: #paint:]].! !!PaintBoxMorph class methodsFor: 'all' stamp: 'tk 8/13/1998 13:00'!new	| pb button dualUse formCanvas rect |	pb _ Prototype fullCopy.		"Assume that the PaintBox does not contain any scripted Players!!"	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button _ pb findButton: sel.		button offImage: button offImage deepCopy.		dualUse _ button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas _ FormCanvas on: button onImage.		formCanvas _ formCanvas			copyOrigin: 0@0			clipRect: (rect _ 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect _ rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	^ pb! !!PaintInvokingMorph methodsFor: 'all' stamp: 'sw 7/16/1998 00:02'!initialize	super initialize.	self image: (ScriptingSystem formAtKey: 'Painting')! !!PaintInvokingMorph methodsFor: 'all' stamp: 'di 8/11/1998 13:03'!justDroppedInto: aPasteUpMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	self isPartsDonor ifFalse: [^ self].	aPasteUpMorph isPlayfieldLike ifFalse: [self beep.  ^ self].	self delete.	anEvent hand makeNewDrawingInBounds: (aPasteUpMorph paintingBoundsAround: anEvent cursorPoint) pasteUpMorph: aPasteUpMorph! !!PaintInvokingMorph class methodsFor: 'all' stamp: 'sw 7/15/1998 21:24'!authoringPrototype	^ self new image: (ScriptingSystem formAtKey: 'Painting'); markAsPartsDonor; yourself! !!Paragraph methodsFor: 'accessing' stamp: 'jm 5/29/1998 14:48'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'composition' stamp: 'jm 5/29/1998 14:48'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ CompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'character location' stamp: 'di 9/14/1998 11:42'!defaultStartBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!Paragraph methodsFor: 'character location' stamp: 'di 9/14/1998 11:45'!defaultStopBlock: aCharacterBlock	^ aCharacterBlock! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 9/14/1998 11:45'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	startBlock _ paragraph defaultStartBlock.	stopBlock _ paragraph defaultStopBlock: startBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/23/1998 11:08'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass isNil ifTrue: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/21/1998 23:03'!prettyPrint	"Reformat the contents of the receiver's view, formatted, if the view is unlocked. "	| selectedClass aCompiler newText |	model messageListIndex = 0 ifTrue: [^view flash].	selectedClass _ model selectedClassOrMetaClass.		aCompiler _ selectedClass compilerClass new.		self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		newText _ aCompiler			format: model contents			in: selectedClass			notifying: nil.		newText == nil ifFalse: 			[self replaceSelectionWith:				(newText asText makeSelectorBoldIn: selectedClass).			self selectAt: 1].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/26/1998 10:04'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectionInterval isEmpty ifTrue: [self selectWord].	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 8/24/1998 09:56'!shiftedYellowButtonMessages	"Answer the set of messages that go with the shifted menu.  Inconvenient to have it here in this separate method; when/if we consolidate via a class variable, as for unshifted, the problem will go away.  1/17/96 sw	 3/7/96 sw: added methodSourceContainingIt	 3/13/96 sw: merged ParagraphEditor and StringHolderController versions into ParagraphEditor, and deleted the StringHolderController versions	 5/27/96 sw: added offerFontMenu	 8/20/96 sw: makeover"	^ #(offerFontMenu changeStyle explain prettyPrint fileItIn recognizeCharacters spawn browseIt sendersOfIt implementorsOfIt referencesToIt  methodNamesContainingIt methodStringsContainingit methodSourceContainingIt  presentSpecialMenu unshiftedYellowButtonActivity)"set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with itmethod source with itspecial menu...more..."! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 11:58'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	| cr lf |	sensor keyboard.		"flush the triggering cmd-key character"	cr _ Character cr.  lf _ Character linefeed.	self replaceSelectionWith: (Text fromString:			(self selection string collect: [:c | c = lf ifTrue: [cr] ifFalse: [c]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:06'!makeCapitalized: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	| prev |	sensor keyboard.		"flush the triggering cmd-key character"	prev _ $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 6/26/1998 15:04'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNamesAndSizes.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 8/24/1998 09:57'!prettyPrint: characterStream 	"Triggered by Cmd-shift-P; reformat this code by prettyPrinting the parse tree"	sensor keyboard.		"flush character"	self prettyPrint.	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock _ nil! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				^self selectAndScroll; updateMarker].			self openTypeIn].		startBlock = stopBlock ifFalse: "save highlighted characters"			[UndoSelection _ self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		startBlock _ stopBlock copy.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'di 8/24/1998 09:58'!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256.  "use temp in case of a crash"	cmdMap atAllPut: #noop:.	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$p	prettyPrint:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$u	changeLfToCr:		$v	pasteInitials:		$w	methodNamesContainingIt:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1)			put: (cmds at: i + 1).		cmdMap at: (((cmds at: i) asciiValue - 96) + 1)	put: (cmds at: i + 1).	].	ShiftCmdActions _ cmdMap.! !!Parser methodsFor: 'scanning' stamp: 'sn 9/19/97 19:32'!advance    | this |    prevMark _ hereMark.    prevToken _ "Now means prev size"        self previousTokenSize.    this _ here.    here _ token.    hereType _ tokenType.    hereMark _ mark.    self scanToken.    ^this! !!Parser methodsFor: 'error correction' stamp: 'tk 8/11/1998 21:52'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ tryHard		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).	tryHard ifFalse:		[aStream cr; nextPutAll: 'try harder'.		lines _ lines copyWith: (alternatives size + firstLine + 1)].		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	tryHard not & (choice > lines last) ifTrue:		[^ self correctSelector: proposedKeyword wordIntervals: spots				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~~ $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!Parser methodsFor: 'private' stamp: 'sn 9/19/97 19:31'!previousTokenSize    "Answer the size of the previous token. Bugfix for Strings."    hereType == #number ifTrue: [^mark - prevMark].    hereType == #string ifTrue: [^here size + 2].    "One for eachsingle quote"    ^here size! !!PartsBinMorph methodsFor: 'extraction support' stamp: 'tk 8/13/1998 16:52'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. Otherwise, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner = self ifTrue:			[^ openToDragNDrop				ifTrue: [root]				ifFalse: [root fullCopy isPartsDonor: false]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PartsBinMorph class methodsFor: 'all' stamp: 'sw 8/19/1998 15:18'!includeInNewMorphMenu	"Not to be instantiated from the menu. The PartsBinMorph is misleadingly named, and is extremely special-purpose"	^ false! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 9/10/1998 14:45'!aRowForPart: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector	"Return a row representing the given part of my target morph."	| r anArrow |	r _ AlignmentMorph newRow		color: self color;		centering: #center;		inset: 1.	r addMorphBack: (self infoButtonFor: partName).	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: self tileForSelf bePossessive.	r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"	r addMorphBack: (self getterButtonFor: partName type: partType).	readOnly ifFalse:		[r addMorphBack: (Morph new color: self color; extent: 2@10).  " spacer"		r addMorphBack: (anArrow _ self arrowSetterButtonFor: partName type: partType)].	r addMorphBack: (AlignmentMorph new color: self color).  "flexible spacer"	(#(colorSees isOverColor) includes: partName) ifFalse: 		[r addMorphBack: (self readoutFor: partName type: partType readOnly: readOnly getSelector: getSelector putSelector: putSelector)].	anArrow ifNotNil: [anArrow step].	^ r! !!PartsViewer methodsFor: 'initialization' stamp: 'sw 7/6/1998 22:42'!setPlayer: aPlayer	scriptedPlayer _ aPlayer.	self removeAllMorphs.	self addMorphBack: self rowBeforeParts.	self addTilesForPlayerParts.	self addTransparentSpacerOfSize: 1 @ 8.	self addMorphBack: self rowBeforeScripts.	self addMorphBack: self commandTilesPartsBin.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].	self beRepelling.	self layoutChanged! !!PartsViewer methodsFor: 'getter/setter' stamp: 'sw 9/10/1998 14:46'!makeGetter: evt from: aMorph forPart: args	| m selfTile selector aType firstArg |	(aType _ args last) == #unknown ifTrue: [^ self beep].	(#(colorSees isOverColor) includes: (firstArg _ args first))		ifFalse:			[m _ PhraseTileMorph new setSlotRefOperator: args first asSymbol type: aType]		ifTrue:			[(firstArg == #colorSees) ifTrue: [m _ self colorSeesPhrase].			(firstArg == #isOverColor) ifTrue: [m _ self seesColorPhrase]].	selfTile _ self tileForSelf bePossessive.	selfTile position: m firstSubmorph position.	m firstSubmorph addMorph: selfTile.	selector _ m submorphs at: 2.	(aType == #number) ifTrue:		[selector addSuffixArrow].	selector updateLiteralLabel.	self presenter coloredTilesEnabled ifFalse:		[m makeAllTilesGreen].	self primaryHand attachMorph: m.! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:55'!caretColor	^ CaretColor! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:56'!controlButtonColor	^ ControlButtonColor! !!PartsViewer methodsFor: 'private' stamp: 'sw 9/15/1998 13:28'!newEmptyScript	| aMorph |	self scriptedPlayer assureUniClass.	aMorph _ ImageMorph new image: (ScriptingSystem formAtKey: 'newScript').	aMorph setProperty: #newAnonymousScript toValue: true.	aMorph setProperty: #player toValue: self scriptedPlayer.	self primaryHand attachMorph: aMorph! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:08'!nextCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[1]		ifNotNil:	[anIndex + 1].	newIndex > aList size ifTrue: [newIndex _ 1].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:09'!previousCostume	| aList aPlayer itsCurrent anIndex newIndex |	aList _ (aPlayer _ scriptedPlayer) availableCostumesForArrows.	aList size == 0 ifTrue: [^ self beep].	itsCurrent _ aPlayer costume renderedMorph.	anIndex _ aList indexOf: itsCurrent ifAbsent: [nil].	newIndex _ anIndex		ifNil:		[aList size]		ifNotNil:	[anIndex - 1].	newIndex < 1 ifTrue: [newIndex _ aList size].	aPlayer renderedCostume: (aList at: newIndex).	self presenter updatePartsViewer: self! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:57'!rowBeforeParts	| r nail aButton aTextMorph aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aFont _ ScriptingSystem fontForScriptorButtons.	r addMorph: (aButton _ SimpleButtonMorph new label: 'X' font: aFont).	aButton target: self;			color:  Color lightRed;			actionSelector: #delete;			setBalloonText: 'Hit the X to remove this Viewer'.	r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousPartsBank; label: '<' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'Show previous bank of parts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextPartsBank; label: '>' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'Show next bank of parts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 7@5.	scriptedPlayer assureExternalName.	aTextMorph _ UpdatingStringMorph new		useStringFormat;		target:  scriptedPlayer;		getSelector: #getName;		putSelector: #setName:;		setNameTo: 'name';		font: ScriptingSystem fontForNameEditingInScriptor.	aTextMorph setProperty: #okToTextEdit toValue: true.	r  addMorphBack: aTextMorph.	aTextMorph setBalloonText: 'Click here to edit the player''s nameuse backspace to delete unwanted characters'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousCostume; label: '<' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to previous costume'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextCostume; label: '>' font: aFont; color: Color veryLightGray; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'switch to next costume'.	r addTransparentSpacerOfSize: 10@5.	nail _ ThumbnailMorph new objectToView: scriptedPlayer viewSelector: #costume.	nail on: #mouseDown send: #thumbnailMenuEvt:forMorph: to: scriptedPlayer.	r addMorphBack: nail.	nail setBalloonText: 'click here to get a menuto specify new costume,tear off a tile, etc..'.		^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 8/19/1998 17:57'!rowBeforeScripts	| r aButton aFont |	r _ AlignmentMorph newRow color: self color; centering: #center.	aButton _ SimpleButtonMorph new target: self; actionSelector: #previousScriptsBank; label: '<' font: (StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	r addMorphBack: aButton.	aButton setBalloonText: 'show previous bank of scripts'.		r addTransparentSpacerOfSize: 5@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #nextScriptsBank; label: '>' font: (StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'show next bank of scripts'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: self; actionSelector: #newEmptyScript; label: 'add script' font: (aFont _ StrikeFont familyName: #ComicBold size: 16); color: self controlButtonColor; borderWidth: 0; actWhen: #buttonDown.	aButton setBalloonText: 'drag from here tocreate a new scriptfor this object'.		r addMorphBack: aButton.	r addTransparentSpacerOfSize: 18@5.	aButton _ SimpleButtonMorph new target: scriptedPlayer; actionSelector: #addInstanceVariable; label: 'add inst var' font: aFont; color: self controlButtonColor; borderWidth: 0; actWhen: #buttonUp.	aButton setBalloonText: 'click here to addan instance variableto this object.'.	r addMorphBack: aButton.	^ r! !!PartsViewer methodsFor: 'private' stamp: 'sw 9/10/1998 14:32'!seesColorPhrase	| outerPhrase seesColorTile |	outerPhrase _ PhraseTileMorph new setOperator: #+ "temp dummy" 				type: #boolean rcvrType: #player argType: #color.	"Install (ColorSeerTile new) in middle position"	(outerPhrase submorphs at: 2) delete.	"operator"	seesColorTile _ TileMorph new setOperator: #seesColor:.	outerPhrase addMorphBack: seesColorTile.	(outerPhrase submorphs at: 2) goBehind.		"Make it third""	selfTile _ self tileForSelf bePossessive.	Done by caller.	selfTile position: 1.	outerPhrase firstSubmorph addMorph: selfTile."	outerPhrase submorphs last addMorph: (ColorTileMorph new typeColor: 		(TilePadMorph colorForType: #color)).	^ outerPhrase! !!PartsViewer methodsFor: 'private' stamp: 'sw 7/3/1998 17:31'!tileForArgType: typeSymbol	| aColor |	typeSymbol == #player ifTrue:		[^ self tileForPlayer:  self presenter standardPlayer].	aColor _ TilePadMorph colorForType: typeSymbol.	typeSymbol == #number ifTrue: [^ 5 newTileMorphRepresentative typeColor: aColor].	typeSymbol == #string ifTrue: [^ 'abc' newTileMorphRepresentative typeColor: aColor].	typeSymbol == #boolean ifTrue: [^ true newTileMorphRepresentative typeColor: aColor].	typeSymbol == #sound ifTrue: [^ SoundTile new typeColor: aColor].	typeSymbol == #object ifTrue: [^ nil newTileMorphRepresentative typeColor: aColor].	typeSymbol == #color ifTrue: [^ Color blue newTileMorphRepresentative].	self error: 'Unrecognized type'! !!PartsViewer class methodsFor: 'all' stamp: 'sw 8/19/1998 17:55'!includeInNewMorphMenu	^ false! !!PartsViewer class methodsFor: 'all' stamp: 'sw 8/19/1998 18:00'!initialize	"PartsViewer initialize"	CaretColor _ Color green muchLighter.	ControlButtonColor _  Color green muchLighter! !!PasteUpMorph methodsFor: 'initialization' stamp: 'di 9/3/1998 09:19'!initialize	owner _ nil.	submorphs _ EmptyArray.	borderWidth _ 1.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	gradientDirection _ #vertical.	color _ Color r: 0.8 g: 1.0 b: 0.6.	fillColor2 _ color.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	autoLineLayout _ false.	openToDragNDrop _ true.	self isWorldMorph ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'display' stamp: 'di 9/3/1998 09:16'!drawOn: aCanvas	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	super drawOn: aCanvas.	turtleTrailsForm ifNotNil: [aCanvas image: turtleTrailsForm at: self position].	(submorphs size > 0 and: [self indicateCursor]) ifTrue:		[aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PasteUpMorph methodsFor: 'display' stamp: 'sw 7/2/1998 15:09'!padding	^ padding! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 8/11/1998 16:56'!acceptDroppingMorph: aMorph event: evt	| slotSpecs aValue incomingName nameObtained |	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	incomingName _ aMorph knownName.	self changed.	self layoutChanged.	self autoLineLayout ifTrue: [self fixLayout].	self world startSteppingSubmorphsOf: aMorph.	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	slotSpecs _ aMorph slotSpecifications.  "A Fabrik component, for example.  Just a hook at this time"	slotSpecs size > 0 ifTrue:		[self assuredPlayer.		slotSpecs do:			[:tuple |				aValue _ aMorph initialValueFor: tuple first.				nameObtained _ self player addSlotNamedLike: tuple first withValue: aValue.				nameObtained ~= incomingName ifTrue:					[aMorph setNameTo: nameObtained]].		self player updateAllViewers]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/18/1998 09:10'!automaticPhraseExpansion	^ self hasProperty: #automaticPhraseExpansion! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 6/17/1998 12:58'!automaticViewing	^ (self standardPalette ~~ nil) and: [self hasProperty: #automaticViewing]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 9/15/1998 13:40'!morphToDropFrom: aMorph	| itsSelector aScriptor adjustment anEditor actualObject aUserScript ownersChoice aNail |	owner ifNotNil:		[(ownersChoice _ owner substituteForMorph: aMorph beingDroppedOn: self)			ifNotNil:	[^ ownersChoice]].	self alwaysShowThumbnail ifTrue:		[aNail _ aMorph thumbnailOfHeight: self heightForThumbnails.		aNail == aMorph ifFalse:			[aNail position: (self primaryHand position - ((self primaryHand targetOffset - self primaryHand formerPosition) * (aNail extent / aMorph extent)) rounded)].		^ aNail].	self expandPhrasesToScripts ifFalse: [^ aMorph].	(aMorph hasProperty: #newAnonymousScript) ifTrue: [^ self emptyAnonymousScriptorFrom: aMorph].	(aMorph isKindOf: PhraseTileMorph) ifFalse: [^ aMorph].	(actualObject _ aMorph actualObject) ifNil: [^ aMorph].	actualObject assureUniClass.	aScriptor _ (itsSelector _ aMorph userScriptSelector) size > 0		ifTrue:			[actualObject isFlagshipForClass				ifFalse:					["We can set the status for our instantiation of this script, but cannot allow script editing"					anEditor _ actualObject scriptEvaluatorFor: itsSelector phrase: aMorph.					adjustment _ 50 @ 40.					anEditor]				ifTrue:					["old note: ambiguous case: if there's a script editor on the world, drop down a button, else drop down the script editor"					aUserScript _ actualObject class userScriptForPlayer: actualObject selector: itsSelector.					aUserScript isTextuallyCoded						ifTrue: [^ self scriptorForTextualScript: itsSelector ofPlayer: actualObject].					((anEditor _ actualObject scriptEditorFor: itsSelector) isInWorld and:							[anEditor owner == self])						ifFalse:							[adjustment _ 50 @ 30.							anEditor]						ifTrue:							[adjustment _ 60 @ 20.							actualObject anonymousScriptEditorFor: aMorph]]]		ifFalse:   "It's a system-defined selector; construct an anonymous scriptor around it"			[adjustment _ 60 @ 20.			actualObject anonymousScriptEditorFor: aMorph].	aScriptor position: (self primaryHand position - adjustment).	^ aScriptor! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 8/8/1998 17:41'!repelsMorph: aMorph event: ev	isPartsBin == true ifTrue: [^ true].	openToDragNDrop ifFalse: [^ true].	((Preferences valueOfFlag: #SystemWindowsDroppable) not and: [		aMorph isKindOf: SystemWindow]) ifTrue: [^ false].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/6/1998 17:37'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow submorph to be extracted. If parts bin, copy the submorph."	| root |	root _ aMorph.	[root = self] whileFalse:		[root owner == self ifTrue:			[self isPartsBin				ifTrue:					[(root renderedMorph isKindOf: MorphThumbnail)						ifTrue:							[^ root renderedMorph morphRepresented veryDeepCopy position: root renderedMorph position]						ifFalse:							[^ root topRendererOrSelf veryDeepCopy]].			self openToDragNDrop					ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/2/1998 14:51'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the world and its hands."	^ self submorphs select:		[:m | (m fullContainsPoint: aPoint) and: [m isLocked not]]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'tk 8/8/1998 17:42'!wantsDroppedMorph: aMorph event: evt^ ((self openToDragNDrop and: [self isPartsBin not]) and: [	self bounds containsPoint: evt cursorPoint]) and: [		((Preferences valueOfFlag: #SystemWindowsDroppable) not and: [			aMorph isKindOf: SystemWindow]) not]! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 8/3/1998 13:43'!laySubpartsOutInOneRow	| aPosition |	aPosition _ 0 @ padding.	submorphs do:	[:aMorph |		aMorph position: (aPosition + (padding @ 0)).		aPosition _ aMorph topRight]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 7/6/1998 13:22'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	self addStackMenuItems: menu hand: aHandMorph.	self addPenMenuItems: menu hand: aHandMorph.	self addPlayfieldMenuItems: menu hand: aHandMorph.	menu addLine! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/15/1998 15:01'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #paintBackground to: self."	aHalo addHandleAt: box leftCenter color: Color veryVeryLightGray on: #mouseDown send: #makeNewDrawingWithin to: self."! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/17/1998 12:11'!addPenMenuItems: menu hand: aHandMorph	| subMenu |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'clear pen trails' action: #clearTurtleTrails.	subMenu add: 'all pens up' action: #liftAllPens.	subMenu add: 'all pens down' action: #lowerAllPens.	menu add: 'pens trails within...' subMenu: subMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 8/5/1998 18:25'!addPlayfieldMenuItems: menu hand: aHandMorph	| subMenu prefix hasPalette |	subMenu _ MenuMorph new defaultTarget: self.	subMenu add: 'save on file...' action: #saveOnFile.	subMenu add: 'navigate to...' action: #navigateTo.	subMenu add: 'round up strays' action: #roundUpStrays.	subMenu addLine.	#(	(autoLineLayout			'auto layout'			toggleAutoLineLayout)		(resizeToFit				'resize-to-fit'			toggleResizeToFit)		(indicateCursor			'showing cursor'		toggleIndicateCursor)		(isPartsBin				'being a parts bin'		toggleIsPartsBin)		(wantsMouseOverHalos	'mouse-over halos'		toggleMouseOverHalos))	do:		[:triplet |			prefix _ (self perform: triplet first) ifTrue: ['stop '] ifFalse: ['start '].			subMenu add:  (prefix, triplet second) action: triplet third].	prefix _ (self hasProperty: #automaticPhraseExpansion) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'phrase expansion') action: #toggleAutomaticPhraseExpansion.	prefix _ (self hasProperty: #alwaysShowThumbnail) ifTrue: ['stop '] ifFalse: ['start '].	subMenu add: (prefix, 'showing thumbnails') action: #toggleAlwaysShowThumbnail.	(self hasProperty: #alwaysShowThumbnail) ifTrue:		[subMenu add: 'set thumbnail height...' action: #setThumbnailHeight].	(hasPalette _ self standardPalette ~~ nil) ifTrue:		[prefix _ self automaticViewing ifTrue: ['stop '] ifFalse: ['start '].		subMenu add: (prefix, 'automatic viewing') action: #toggleAutomaticViewing].	subMenu addLine.	hasPalette ifTrue: [subMenu add: 'clear palette area' action: #clearPaletteArea].	(self resizeToFit & self indicateCursor & self autoLineLayout) ifFalse:		[subMenu add: 'behave like a Holder' action: #behaveLikeHolder].	self backgroundSketch ifNotNil: [subMenu add: 'delete background painting' action: #deleteBackgroundPainting].	presenter ifNil:		[subMenu add: 'make detachable' action: #impartPrivatePresenter].	subMenu addLine.	subMenu add: 'use standard texture' action: #setStandardTexture.	subMenu add: 'make graph paper...' action: #makeGraphPaper.	subMenu addTitle: 'Playfield'.	menu add: 'playfield options...' subMenu: subMenu.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/17/1998 12:10'!addStackMenuItems: menu hand: aHandMorph	| subMenu |	self isStackLike		ifTrue:			[subMenu _ MenuMorph new defaultTarget: self.			subMenu add: 'new card' action: #newCard.			subMenu add: 'delete this card' action: #deleteCard.			subMenu add: 'go to next card' action: #goToNextCard.			subMenu add: 'go to previous card' action: #goToPreviousCard.			menu add: 'card & stack...' subMenu: subMenu]		ifFalse:			[menu add: 'become a stack' action: #becomeStack]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 9/9/1998 13:21'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ super debuggingMenuFor: aHandMorph.	aMenu add:  'abandon costume history' target: self action: #abandonCostumeHistory.	^ aMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/5/1998 18:13'!wantsHaloFor: aSubMorph	^ (isPartsBin ~~ true and: [openToDragNDrop ~~ false]) and:		[self wantsMouseOverHalos]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:16'!setThumbnailHeight	|  reply |	reply _ FillInTheBlank		request: 'New height for thumbnails? '		initialAnswer: self heightForThumbnails printString.	reply isEmpty ifTrue: [^ self].	reply _ reply asNumber.	(reply > 0 and: [reply <= 150]) ifFalse:		[^ self inform: 'Please be reasonable!!'].	self setProperty: #heightForThumbnails toValue: reply.	self updateSubmorphThumbnails! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:26'!toggleAlwaysShowThumbnail	(self hasProperty: #alwaysShowThumbnail)		ifTrue:			[self removeProperty: #alwaysShowThumbnail]		ifFalse:			[self setProperty: #alwaysShowThumbnail toValue: true].	self updateSubmorphThumbnails! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:12'!toggleAutomaticPhraseExpansion	| expand |	expand _ self hasProperty: #automaticPhraseExpansion.	expand		ifTrue:			[self removeProperty: #automaticPhraseExpansion]		ifFalse:			[self setProperty: #automaticPhraseExpansion toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:13'!toggleAutomaticViewing	| current |	current _ self automaticViewing.	current		ifTrue:			[self removeProperty: #automaticViewing]		ifFalse:			[self setProperty: #automaticViewing toValue: true]! !!PasteUpMorph methodsFor: 'options' stamp: 'di 8/11/1998 13:04'!toggleIsPartsBin	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	isPartsBin _ self isPartsBin not.	openToDragNDrop _ isPartsBin not.	isPartsBin		ifTrue:			[submorphs do:				[:m | m isPartsDonor: true.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m isPartsDonor: false.					m restoreSuspendedEventHandler]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/8/1998 10:58'!toggleMouseOverHalos	wantsMouseOverHalos _ self wantsMouseOverHalos not! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1998 16:24'!updateSubmorphThumbnails	| thumbsUp aHeight itsThumbnail |	thumbsUp _ self alwaysShowThumbnail.	aHeight _ self heightForThumbnails.	self submorphs do:		[:aMorph | thumbsUp			ifTrue:				[itsThumbnail _ aMorph thumbnailOfHeight: aHeight.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos	^ wantsMouseOverHalos == true! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos: aBoolean	wantsMouseOverHalos _ aBoolean! !!PasteUpMorph methodsFor: 'painting' stamp: 'jm 6/1/1998 19:16'!makeNewDrawingWithin	| bnds |	bnds _ self paintingBoundsAround: self boundsInWorld center.	self primaryHand makeNewDrawingInBounds: bnds pasteUpMorph: self.! !!PasteUpMorph methodsFor: 'painting' stamp: 'jm 6/1/1998 18:52'!paintingBoundsAround: aPoint	"Return a rectangle for painting centered on the given point. Both the argument point and the result rectangle are in world coordinates."	| paintExtent maxPaintArea myBnds |	paintExtent _ ScriptingSystem reasonablePaintingExtent.	maxPaintArea _ paintExtent x * paintExtent y.	myBnds _ self boundsInWorld.	(myBnds area <= maxPaintArea) ifTrue: [^ myBnds].	^ (aPoint - (paintExtent // 2) extent: paintExtent) intersect: myBnds! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/3/1998 09:27'!createOrResizeTrailsForm	"If necessary, create a new turtleTrailsForm or resize the existing one to fill my bounds. On return, turtleTrailsForm exists and is the correct size."	| newForm |	turtleTrailsForm ifNil: [		"create new turtleTrailsForm if needed"		turtleTrailsForm _ Form extent: self extent depth: 8.		turtlePen _ Pen newOnForm: turtleTrailsForm.		^ self].	turtleTrailsForm extent = self extent ifFalse: [		"resize turtleTrailsForm if my size has changed"		newForm _ Form extent: self extent depth: 8.		newForm copy: self bounds from: turtleTrailsForm					to: 0@0 rule: Form paint.		turtleTrailsForm _ newForm.		turtlePen _ Pen newOnForm: turtleTrailsForm].! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/3/1998 10:44'!drawPenTrailFor: aMorph from: oldPoint to: newPoint	"Draw a pen trail for aMorph, using its pen state (the pen is assumed to be down)."	"The turtleTrailsForm is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| origin mPenSize offset |	self createOrResizeTrailsForm.	origin _ self topLeft.	mPenSize _ aMorph getPenSize.	turtlePen sourceForm width ~= mPenSize		ifTrue: [turtlePen squareNib: mPenSize].	offset _ (mPenSize // 2)@(mPenSize // 2).	turtlePen color: aMorph getPenColor.	turtlePen drawFrom: (oldPoint - origin - offset) asIntegerPoint				to: (newPoint - origin - offset) asIntegerPoint.	self invalidRect: ((oldPoint rect: newPoint) expandBy: mPenSize)! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:47'!liftAllPens	submorphs do: [:m | m assuredPlayer liftPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 8/11/1998 16:47'!lowerAllPens	submorphs do: [:m | m assuredPlayer lowerPen]! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 9/10/1998 16:17'!trailMorph	"Yes, you can draw trails on me."	^ self! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 8/30/1998 09:44'!allTileScriptingElements	^ self allMorphs select:		[:s | s isTileScriptingElement]! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 9/15/1998 13:37'!emptyAnonymousScriptorFrom: aPlaceHoldingMorph	| aScriptor aPlayer |	aPlayer _ aPlaceHoldingMorph valueOfProperty: #player.	aPlayer assureUniClass.	aScriptor _  aPlayer anonymousScriptEditorFor: nil.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'scripting' stamp: 'sw 6/18/1998 09:17'!expandPhrasesToScripts	^ self hasProperty: #automaticPhraseExpansion! !!PasteUpMorph methodsFor: 'scripting' stamp: 'tk 6/14/1998 15:18'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	self world ifNil: [^ nil].	aScriptor _ ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 8/11/1998 16:47'!becomeStack	currentDataInstance _ self assuredPlayer.	dataInstances _ OrderedCollection with: currentDataInstance.	isStackLike _ true.	self borderWidth: (self borderWidth + 1).	submorphs do:		[:aMorph | aMorph holdsDataForEachInstance			ifTrue:				[aMorph becomeField]].! !!PasteUpMorph methodsFor: 'stack/card' stamp: 'sw 8/11/1998 16:50'!installAsCurrent: anInstance	self flag: #deferred.	currentDataInstance _ anInstance.	"aList _ self world allViewersOn: currentDataInstance."	anInstance costume: self.	self player: anInstance.	self morphsForInstanceData do:			[:m | m dockUpToInstance: anInstance]."	aList do:		[:aViewer |  ... remove it, or install the new instance into it."! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 9/9/1998 10:45'!abandonCostumeHistory	self allMorphsDo:		[:m | m player ifNotNil: [m player forgetOtherCostumes]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 19:46'!allScriptEditors	^ self allMorphs select:		[:s | s isKindOf: ScriptEditorMorph]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/6/1998 14:19'!alwaysShowThumbnail	^ self hasProperty: #alwaysShowThumbnail! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/6/1998 14:39'!heightForThumbnails	^ self valueOfProperty: #heightForThumbnails ifAbsent: [40]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/23/1998 17:08'!impartPrivatePresenter	presenter ifNil:		[presenter _ Presenter new associatedMorph: self.		presenter initializeToggles.		presenter addStopStepGoButtons.		presenter addTrashCan.		presenter standardPlayer]! !!PasteUpMorph methodsFor: 'misc' stamp: 'jm 9/11/1998 09:40'!invalidRect: damageRect	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	owner ifNotNil: [owner invalidRect: (damageRect intersect: bounds)].! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/3/1998 16:45'!mouseX	^ (self cursorPoint x) - self left! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/3/1998 16:45'!mouseY	^ self bottom - (self cursorPoint y)! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/17/1998 12:06'!navigateTo	self inform: 'Not quite yet!!Later, you can directly retargetthis area so that it displays thecontents of any url'.! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 9/3/1998 09:19'!prepareToBeSaved	super prepareToBeSaved.	turtlePen _ nil! !!PasteUpMorph methodsFor: 'misc' stamp: 'tk 8/3/1998 17:52'!releaseCachedState	presenter ifNotNil: [presenter flushViewerCache].	super releaseCachedState! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 22:02'!removeScriptingControls	self deleteSubmorphsWithProperty: #scriptingControl! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/5/1998 22:53'!replaceSubmorph: oldMorph by: newMorph	super replaceSubmorph: oldMorph by: newMorph.	self autoLineLayout		ifTrue:			[self fixLayout]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/25/1998 09:26'!roundUpStrays	self submorphsDo:		[:m |			m goHome.			m isPlayfieldLike ifTrue: [m roundUpStrays]]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 18:13'!slotNamesAndTypesForBank: aBank	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts"	aBank == 1 ifTrue: [^ Array new].	aBank == 2 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(color			color		readWrite	getColor				setColor:)		(borderWidth 	number		readWrite	getBorderWidth		setBorderWidth:)		(borderColor		color		readWrite	getBorderColor		setBorderColor:)		(mouseX			number		readOnly	getMouseX			unused)		(mouseY		number		readOnly	getMouseY			unused))].	aBank == 3 ifTrue: 	[^ #("		name			type		r/w			get selector			put selector		-----------		---------		-----------	---------------------	-------------   "		(cursor 			number		readWrite	getCursor			setCursor:)		(valueAtCursor	player		readOnly	getValueAtCursor	unused)									"readWrite						setValueAtCursor:")].	^ #()! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 8/8/1998 14:09'!smallThumbnailForPageSorter	^ BookPageThumbnailMorph new smaller page: self! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:34'!startRunningAll	"Start running all scripted morphs.  Triggered by user hitting GO button"	self presenter flushPlayerListCache.  "Inefficient, but makes sure things come right whenever GO hit"	self presenter allExtantPlayers do: [:aPlayer | aPlayer costume residesInPartsBin ifFalse: [aPlayer startRunning]].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:35'!stepAll	self presenter allExtantPlayers do:		[:aPlayer | 			aPlayer startRunning; step; stopRunning.			aPlayer costume goHome]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/29/1998 17:33'!stopRunningAll	"Stop running all scripted morphs.  Triggered by user hitting STOP button"	self presenter allExtantPlayers  do:		[:aPlayer |			aPlayer stopRunning.			aPlayer costume goHome].	self world updateStatusForAllScriptEditors! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/23/1998 17:38'!thumbnailForPageSorter	^ BookPageThumbnailMorph new page: self! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/24/1998 19:47'!updateStatusForAllScriptEditors	self allScriptEditors do: [:anEditor | anEditor updateStatus]! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcep0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from ClippingMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcepc0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from ClippingMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'di 9/3/1998 09:19'!convertbosfcepcbbfgcc0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"Conversion from BookPageMorph, used to read in old BookMorphs."	borderWidth _ 1.	borderColor _ Color black.	gradientDirection _ #vertical.	fillColor2 _ color.	presenter _ nil.	model _ nil.	cursor _ 1.	padding _ 3.	backgroundMorph _ nil.	turtleTrailsForm _ nil.	turtlePen _ nil.	openToDragNDrop _ true.	isPartsBin _ nil.	autoLineLayout _ false.	indicateCursor _ nil.	resizeToFit _ false.	fileName _ nil.	isStackLike _ nil.	dataInstances _ nil.	currentDataInstance _ nil.	userFrameRectangle _ nil.! !!PasteUpMorph methodsFor: 'object fileIn' stamp: 'jm 6/18/1998 10:31'!convertbosfcepcbbfgccpmcpbttloiairfidcuw0: varDict bosfcepcbbfgccpmcpbttloiairfidcu0: smartRefStrm	"These variables are automatically stored into the new instance ('presenter' 'model' 'cursor' 'padding' 'backgroundMorph' 'turtleTrailsForm' 'turtlePen' 'lastTurtlePositions' 'openToDragNDrop' 'isPartsBin' 'autoLineLayout' 'indicateCursor' 'resizeToFit' 'fileName' 'isStackLike' 'dataInstances' 'currentDataInstance' 'userFrameRectangle')."	"Incoming morphs have extra inst var: 'wantsMouseOverHalos'"! !!PasteUpMorph class methodsFor: 'all' stamp: 'sw 6/30/1998 17:00'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| proto |	proto _ self new markAsPartsDonor.	proto color: Color green muchLighter; borderWidth: 1; 		borderColor: Color green darker; extent: 100 @ 80.	proto setProperty: #expandedExtent toValue: 300 @ 240.	proto beSticky.	^ proto! !!Pen methodsFor: 'operations' stamp: 'di 6/21/1998 09:37'!fill: drawBlock color: color	| region tileForm tilePen shape saveColor recorder |	drawBlock value: (recorder _ self as: PenPointRecorder).	region _ Rectangle encompassing: recorder points.	tileForm _ Form extent: region extent+6.	tilePen _ Pen newOnForm: tileForm.	tilePen location: location-(region origin-3)		direction: direction		penDown: penDown.	drawBlock value: tilePen.  "Draw the shape in B/W"	saveColor _ halftoneForm.	drawBlock value: self.	halftoneForm _ saveColor.	shape _ (tileForm findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: tileForm to: 0@0 rule: Form erase.	destForm fillShape: shape fillColor: color at: region origin-3! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/11/1998 22:01'!dragon: n  "Display restoreAfter: [Display fillWhite. Pen new dragon: 10]."	"Display restoreAfter: [Display fillWhite. 1 to: 4 do:				[:i | Pen new color: i; turn: 90*i; dragon: 10]]"	"Draw a dragon curve of order n in the center of the screen."	n = 0		ifTrue: [self go: 5]		ifFalse: [n > 0				ifTrue: [self dragon: n - 1; turn: 90; dragon: 1 - n]				ifFalse: [self dragon: -1 - n; turn: -90; dragon: 1 + n]]! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/14/1998 13:42'!filberts: n side: s   "Display restoreAfter: [Pen new filberts: 4 side: 5]"	"Two Hilbert curve fragments form a Hilbert tile. Draw four interlocking 	tiles of order n and sides length s."	| n2 |	Display fillWhite.	n2 _ 1 bitShift: n - 1.	self up; go: 0 - n2 * s; down.	1 to: 4 do: 		[:i | 		self fill: [:p |				p hilbert: n side: s.				p go: s.				p hilbert: n side: s.				p go: s.				p up.				p go: n2 - 1 * s.				p turn: -90.				p go: n2 * s.				p turn: 180.				p down]			color: (Color perform: (#(yellow red green blue) at: i))]! !!Pen methodsFor: 'private' stamp: 'di 6/11/1998 16:09'!location: aPoint direction: aFloat penDown: aBoolean	location _ aPoint.	direction _ aFloat.	penDown _ aBoolean! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!drawFrom: p1 to: p2.	"Overridden to skip drawing but track bounds of the region traversed."	points == nil ifTrue:		[points _ OrderedCollection new: 1000.		points addLast: p1].	points addLast: p2! !!PenPointRecorder methodsFor: 'all' stamp: 'di 6/21/1998 09:35'!points	^ points! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:39'!actualObject	"Answer the player that's the object of my attention"	^ self associatedPlayer! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:39'!associatedPlayer	"Answer the player that's the object of my attention"	^ self firstSubmorph firstSubmorph actualObject! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!catchDivideByZero: aStream indent: tabCount	"See if I am have divide as my operator. If so, insert a test in the argument to divide."	(submorphs at: 2) type = #operator ifFalse: [^ false].		"not me"	(submorphs at: 2) operatorOrExpression == #/ ifFalse: [^ false].	"not me"	aStream space.	aStream nextPutAll: '(self beNotZero: '.	(submorphs at: 3) storeCodeOn: aStream indent: tabCount.	aStream nextPut: $).	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:07'!codeString	| aStream |	aStream _ ReadWriteStream on: ''.	self storeCodeOn: aStream indent: 1.	^ aStream contents! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:24'!handlesDragOver: evt	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:57'!handlesMouseOverDragging: evt	^ true! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 6/29/1998 09:22'!inPartsBin	| o |	o _ self owner.	[o == nil] whileFalse:		[(o isKindOf: PartsBinMorph) ifTrue: [^ true].  "special case for ancient Parts Viewer stuff"		o _ o owner].	^ super inPartsBin! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 8/11/1998 13:15'!isPossessive	^ false! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!PhraseTileMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!PhraseTileMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!storeCodeOn: aStream indent: tabCount	"Add in some smarts for division by zero."	aStream nextPut: $(.	(submorphs at: 1) storeCodeOn: aStream indent: tabCount.	aStream space.	(submorphs at: 2) storeCodeOn: aStream indent: tabCount.	submorphs size > 2 ifTrue: [		(self catchDivideByZero: aStream indent: tabCount) ifFalse: [			aStream space.			(submorphs at: 3) storeCodeOn: aStream indent: tabCount]].	aStream nextPut: $).! !!PhraseTileMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:57'!try	| aPlayer |	userScriptSelector == nil		ifFalse:			[aPlayer _ self objectViewed player.			aPlayer perform: userScriptSelector]		ifTrue:			[Compiler evaluate:				self codeString				for: self associatedPlayer				logged: false].	(Delay forMilliseconds: 200) wait! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:16'!buildKeyboard	| wtWid bkWid noteR octavePt nWhite nBlack |	wtWid _ 8. bkWid _ 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite _ 7.  nBlack _ 5]						ifFalse: [nWhite _ 1.  nBlack _ 0 "High C"].		octavePt _ self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | 			noteR _ octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: noteR color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)].		1 to: nBlack do:			[:j |			noteR _ octavePt + ((#(6 15 29 38 47) at: j)@0) extent: bkWid@22.			self addMorph: ((Morph newBounds: noteR color: blackKeyColor)				on: #mouseDown send: #mouseDownEvent:noteMorph:pitch: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j);				on: #mouseUp send: #mouseUpEvent:noteMorph:pitch: to: self;				on: #mouseEnterDragging send: #mouseDownEvent:noteMorph:pitch: to: self;				on: #mouseLeaveDragging send: #mouseUpEvent:noteMorph:pitch: to: self)]].	self extent: (self fullBounds extent + borderWidth - 1)! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 17:05'!initialize	super initialize.	self color: Color black.	whiteKeyColor _ Color veryLightGray.	blackKeyColor _ Color black.	playingKeyColor _ Color red.	nOctaves _ 6.	self buildKeyboard.	soundPrototype _ FMSound brass1 duration: 9.9! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/20/1998 14:00'!mouseDownEvent: event noteMorph: noteMorph pitch: midiKey	| pitch wasPlaying |	noteMorph color: playingKeyColor.	pitch _ AbstractSound pitchForMIDIKey: midiKey + 24.	wasPlaying _ false.	soundPlaying		ifNil: [			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]		ifNotNil: [			wasPlaying _ soundPlaying samplesRemaining > 0.			wasPlaying ifFalse: [soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3]].	soundPlaying		pitch: pitch;		internalizeModulationAndRatio;		duration: 100.0.	wasPlaying		ifTrue: [soundPlaying envelopes do: [:e | e centerPitch: pitch]]		ifFalse: [soundPlaying reset].	SoundPlayer resumePlaying: soundPlaying quickStart: wasPlaying not.! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'jm 9/9/1998 10:45'!mouseUpEvent: event noteMorph: noteMorph pitch: pitch	noteMorph color: ((#(0 1 3 5 6 8 10) includes: pitch\\12)					ifTrue: [whiteKeyColor]					ifFalse: [blackKeyColor]).	soundPlaying ifNotNil: [soundPlaying stopGracefully].! !!PianoKeyboardMorph methodsFor: 'all' stamp: 'di 9/4/1998 12:57'!soundPrototype: aSound	soundPrototype _ aSound! !PianoRollNoteMorphs, as their name implies, are used to display musical notes on a piano roll.  The design is centered around speed of display, compact representation through sharing, and the ability to display in any color without having to make new note forms.The note shapes are stored as ColorForms, which are then displayed in paint mode (0 is transparent) using the individual note color in the color map.Each note carries an offset which can be used to display complex note shapes so that the center of the note ellipse appears in the proper location.!!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 8/28/1998 15:51'!drawOn: aCanvas	image replaceColorAtIndex: NoteColorIndex with: color.	super drawOn: aCanvas! !!PianoRollNoteMorph methodsFor: 'as yet unclassified' stamp: 'di 8/31/1998 11:31'!newBounds: boundRect color: fillColor image: noteForm	"This message incorporates all necessary initialization for enhanced performance"	bounds _ boundRect.	owner _ nil.	submorphs _ EmptyArray.	color _ fillColor.	image _ noteForm! !!PianoRollNoteMorph class methodsFor: 'class initialization' stamp: 'di 8/29/1998 06:07'!initialize  "PianoRollNoteMorph initialize"	| j1 dot j2 noteColor |	NoteForms _ Array new: 200.	NoteColorIndex _ 250.	noteColor _ Color indexedColors at: NoteColorIndex.	j1 _ 1.	6 to: 28 do: 		[:i | dot _ ((EllipseMorph newBounds: (0@0 extent: i@i) color: noteColor)					imageFormDepth: 8) as8BitColorForm.		j2 _ i*i//4.		j1 to: j2 do: [:j | NoteForms at: j put: dot].		j1 _ j2+1].	j1 to: NoteForms size do: [:j | NoteForms at: j put: dot].! !!PianoRollNoteMorph class methodsFor: 'instance creation' stamp: 'di 8/31/1998 11:32'!newBounds: boundsRect color: trackColor	"boundsRect is the rectangle for old-style piano roll notes."	| noteForm locPoint |	noteForm _ NoteForms atPin: boundsRect width.	locPoint _ boundsRect topLeft + (0@(1 - (noteForm height//2))).	^ self basicNew		newBounds: (locPoint extent: noteForm extent)		color: trackColor		image: noteForm! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:08'!acceptDroppingMorph: aMorph event: evt	"In addition to placing this morph in the pianoRoll, add a corresponding	event to the score so that it will always appear when played, in addition	to possibly triggering other actions"	| ambientEvent |	ambientEvent _ AmbientEvent new morph: aMorph;							time: (self timeForX: aMorph left).	super acceptDroppingMorph: aMorph event: evt.	score addAmbientEvent: ambientEvent.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 15:09'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'expand time' action: #expandTime.	aCustomMenu add: 'contract time' action: #contractTime.	(self valueOfProperty: #openToDragAndDrop) == true	ifTrue: [aCustomMenu add: 'close drag anddrop' action: #closeDragAndDrop]	ifFalse: [aCustomMenu add: 'open drag and drop' action: #openDragAndDrop]! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 9/7/1998 22:13'!addNotes	| visibleMorphs rightEdge topEdge track trackColor i done n nLeft nTop nRight evt m |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	"Add ambient morphs first (they will be front-most)"		track _ score ambientTrack.		i _ indexInTrack at: indexInTrack size.		done _ i > track size.		[done | (i > track size)] whileFalse: [			evt _ track at: i.			nLeft _ self xForTime: evt time.			nLeft > rightEdge				ifTrue: [done _ true]				ifFalse: [m _ evt morph.						m position: nLeft @ (self bottom - borderWidth - m height).						visibleMorphs add: evt morph].			i _ i + 1].	"Then add note morphs"	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size.		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated.							visibleMorphs add:								("PianoRollNoteMorph"  Morph  "<-- Change comment quotes here**"									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)]]].			i _ i + 1]].	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:37'!contractTime	timeScale _ timeScale / 1.5.	lastUpdateTick _ lastUpdateTick - 1.  "force update"	self changed.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:20'!drawOn: aCanvas	| innerBox center |	super drawOn: aCanvas.	self drawStaffOn: aCanvas.	innerBox _ self innerBounds.	center _ innerBox center x.	aCanvas		fillRectangle: (center@innerBox top corner: (center + 1)@innerBox bottom)		color: Color red.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:01'!drawStaffOn: aCanvas	| blackKeyColor l r topEdge y |	blackKeyColor _ Color gray: 0.7.	l _ self left + borderWidth.	r _ self right - borderWidth.	topEdge _ self top + borderWidth + 3.	lowestNote to: 127 do: [:k |		y _ self yForMidiKey: k.		y <= topEdge ifTrue: [^ self].  "over the top!!"		(self isBlackKey: k) ifTrue: [			aCanvas				fillRectangle: (l@y corner: r@(y + 1))				color: blackKeyColor]].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:37'!expandTime	timeScale _ timeScale * 1.5.	lastUpdateTick _ lastUpdateTick - 1.  "force update"	self changed.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/11/1998 09:33'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	fullBounds ifNil: [fullBounds _ bounds].	^ bounds! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 08:03'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds."	| clippingCanvas |	(aCanvas isVisible: self fullBounds) ifFalse: [^ self].	self drawOn: aCanvas.	submorphs isEmpty ifFalse: [		clippingCanvas _ aCanvas copyClipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]].  "draw back-to-front"! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 8/27/1998 16:39'!goToTime: scoreTime	| track trackSize index |	scoreTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size+1 withAll: 1].	leftEdgeTime _ scoreTime.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) endTime < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/28/1998 18:59'!initialize	super initialize.	borderWidth _ 1.	color _ Color white.	self extent: 400@300.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 07:52'!isBlackKey: midiKey	"Answer true if the given MIDI key corresponds to a black key on the piano keyboard."	| note |	note _ midiKey \\ 12.	note = 1 ifTrue: [^ true].	note = 3 ifTrue: [^ true].	note = 6 ifTrue: [^ true].	note = 8 ifTrue: [^ true].	note = 10 ifTrue: [^ true].	^ false! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/11/1998 09:20'!layoutChanged	"Override this to avoid propagating 'layoutChanged' when just adding/removing note objects."	fullBounds = bounds ifTrue: [^ self].	super layoutChanged.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/28/1998 19:03'!on: aScorePlayer	scorePlayer _ aScorePlayer.	score _ aScorePlayer score.	colorForTrack _ Color wheel: score tracks size.	lowestNote _ 24.	leftEdgeTime _ 0.	timeScale _ 0.1.	indexInTrack _ Array new: score tracks size withAll: 1.	lastUpdateTick _ -1.! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:48'!privateRemoveMorph: aMorph	score removeAmbientEventWithMorph: aMorph.	^ super privateRemoveMorph: aMorph! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 9/22/1998 09:33'!step	| t fudge |	score ifNil: [^ self].	approximateScreenUpdateTime ifNil: [approximateScreenUpdateTime _ 1000].	lastStepMSec ifNotNil: [		"compute the approximate redisplay time"		"Details: lastStepMSecs is set only when we've updated the piano roll, so		 this display time estimate is done on the cycle following an actual piano roll		 update. The goal is to adjust for different processor speeds automatically."		t _ Time millisecondClockValue - lastStepMSec.		(t > 0 and: [t < (4 * approximateScreenUpdateTime)]) ifTrue: [			"ignore clock wrap (i.e., t < 0) and very large values of t for stability"			approximateScreenUpdateTime _ (approximateScreenUpdateTime + t) // 2].		lastStepMSec _ nil].  "don't do this calculation again until the next real piano roll update"	t _ scorePlayer ticksSinceStart.	t = lastUpdateTick ifFalse: [		lastStepMSec _ Time millisecondClockValue.		fudge _ 5.  "alignment tweak, in pixels"		self goToTime:			t - (((self width // 2) - borderWidth + fudge) asFloat / timeScale) truncated +			(scorePlayer ticksForMSecs: approximateScreenUpdateTime).		self addNotes.		lastUpdateTick _ t].! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:07'!stepTime	^ 0! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:35'!timeForX: aNumber	^ ((aNumber - bounds left - borderWidth) asFloat / timeScale + leftEdgeTime) asInteger! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'di 8/3/1998 21:29'!xForTime: aNumber	^ ((aNumber - leftEdgeTime) asFloat * timeScale) asInteger + bounds left + borderWidth! !!PianoRollScoreMorph methodsFor: 'all' stamp: 'jm 7/10/1998 14:35'!yForMidiKey: midiKey	^ (bounds bottom - borderWidth - 4) - (3 * (midiKey - lowestNote))! !!PinMorph methodsFor: 'events' stamp: 'jm 5/29/1998 14:33'!handlesMouseDown: evt	^ (evt yellowButtonPressed | evt blueButtonPressed) not! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!bend	^ bend! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend	bend _ midiPitchBend.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend channel: midiChannel	bend _ midiPitchBend.	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isPitchBend	^ true! !!PitchBendEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rE0		channel: channel		byte: (bend bitAnd: 16r7F)		byte: (bend bitShift: -7).! !!PitchBendEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 09:42'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': bend '.	bend printOn: aStream.	aStream nextPut: $).! !!Player methodsFor: 'card/stack commands' stamp: 'sw 8/17/1998 17:23'!deleteCard	"Still underway"	true ifTrue: [^ self beep].	self costume deleteCard! !!Player methodsFor: 'clone' stamp: 'tk 8/31/1998 15:46'!copyUniClass	"my class is a subclass of Player.  Return another class just like my class.  Share the costume list."	| newCls |	newCls _ self class officialClass 		newUniqueClassInstVars: self class instanceVariablesString 		classInstVars: self class class instanceVariablesString.	newCls copyMethodDictionaryFrom: self class.	newCls class copyMethodDictionaryFrom: self class class.	newCls scripts: self class privateScripts.	"duplicate this in mapUniClasses"	newCls slotInfo: self class privateSlotInfo deepCopy.	newCls copyAddedStateFrom: self class.  "All class inst vars for inter Player refs"	^ newCls! !!Player methodsFor: 'clone' stamp: 'sw 9/15/1998 13:12'!initializeCostumesFrom: aPlayer	"Used to copy costume info over from an UnscriptedPlayer to a Player UniClass"	costume _ aPlayer costume.	costumes _ aPlayer costumes! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 21:42'!availableCostumesForArrows	^ costumes! !!Player methodsFor: 'costume' stamp: 'sw 9/21/1998 11:50'!costume: aMorph	"Make aMorph be the receiver's current costume"	| itsBounds |	costume == aMorph ifTrue: [^ self].	costume ifNotNil:		[self rememberCostume: costume renderedMorph.		itsBounds _ costume bounds.		costume owningHandOrPasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.		aMorph position: itsBounds origin.		aMorph actorState: costume actorState.		aMorph setNameTo: costume externalName].	aMorph player: self.	costume _ aMorph.	aMorph arrangeToStartStepping! !!Player methodsFor: 'costume' stamp: 'sw 8/18/1998 11:47'!costumeRespondingTo: aSelector	"Answer a costume that responds to the given selector, or nil if none"	| aMorph |	((aMorph _ self costume renderedMorph) respondsTo: aSelector) ifTrue: [^ aMorph].	costumes size > 0 ifTrue:  "This catches the nil and empty cases both"		[costumes do: [:aCostume | (aCostume respondsTo: aSelector) ifTrue: [^ aCostume]]].	^ nil "usually an error will result"! !!Player methodsFor: 'costume' stamp: 'sw 9/15/1998 13:12'!costumes	^ costumes! !!Player methodsFor: 'costume' stamp: 'sw 8/21/1998 17:19'!costumesDo: aBlock	"Evaluate aBlock against every real (not flex) costume known to the receiver)"	aBlock value: costume renderedMorph.	costumes ifNotNil:		[(costumes copyWithout: costume) do:			[:aCostume | aBlock value: aCostume]]! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 17:46'!forgetOtherCostumes	costumes _ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:39'!getValueFromCostume: aSelector	| aCostume |	(aCostume _ self costumeRespondingTo: aSelector) ifNotNil:		[^ aCostume perform: aSelector].	^ nil! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 16:37'!knownSketchCostumeWithSameFormAs: aSketchMorph	| itsForm rend |	itsForm _ aSketchMorph form.	(((rend _ costume renderedMorph) isKindOf: SketchMorph) and: [rend form == itsForm])		ifTrue:	[^ rend].	^ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rawCostume: aMorph	costume _ aMorph! !!Player methodsFor: 'costume' stamp: 'sw 8/20/1998 17:35'!rememberCostume: aCostume	"Put aCostume in my remembered-costumes list, as the final element"	| costumeToRemember existing |	costumeToRemember _ aCostume renderedMorph.		"Remember real morphs, not their transformations"	costumes ifNil: [costumes _ OrderedCollection new].	existing _ (costumeToRemember isKindOf: SketchMorph)		ifTrue:			[self knownSketchCostumeWithSameFormAs: costumeToRemember]		ifFalse:			[costumes detect: [:c | c == costumeToRemember] ifNone: [nil]].	costumes _ costumes copyWithout: existing.	costumes addLast: costumeToRemember! !!Player methodsFor: 'costume' stamp: 'sw 9/21/1998 11:46'!renderedCostume: aMorph	"Make aMorph be the receiver's rendered costume; if flexing is currently in effect, make the new morph be flexed correspondingly"	| renderedMorph |	renderedMorph _ costume renderedMorph.	renderedMorph == aMorph ifTrue: [^ self].	self rememberCostume: renderedMorph.	costume isFlexMorph		ifTrue:			[costume adjustAfter:				[costume replaceSubmorph: renderedMorph by: aMorph]]		ifFalse:			[costume owningHandOrPasteUpMorph replaceSubmorph: costume topRendererOrSelf by: aMorph.			aMorph player: self.			aMorph actorState: costume actorState.			aMorph setNameTo: costume knownName.			costume _ aMorph]! !!Player methodsFor: 'costume' stamp: 'sw 8/17/1998 15:45'!setCostumeSlot: setterSelector toValue: aValue	| aCostume |	(aCostume _ self costumeRespondingTo: setterSelector) ifNotNil:		[aCostume perform: setterSelector with: aValue]! !!Player methodsFor: 'costume' stamp: 'sw 8/22/1998 21:51'!wearCostumeOf: anotherPlayer	"Put on a costume similar to the one currently worn by anotherPlayer"	| itsCostume |	itsCostume _ anotherPlayer costume renderedMorph.	(itsCostume isKindOf: SketchMorph)		ifTrue:			[self wearSketchCostumeResembling: itsCostume]		ifFalse:			[anotherPlayer costume player: nil.			self renderedCostume: itsCostume veryDeepCopy.			anotherPlayer costume player: anotherPlayer].	costume layoutChanged! !!Player methodsFor: 'costume' stamp: 'sw 8/19/1998 17:39'!wearCostumeOfClass: aClass	"Assume that the costume in the library has player = nil"	| newCostume |	(costume isKindOf: aClass) ifTrue: [^ self].	costumes ifNotNil:		[costumes do:			[:aCostume | (aCostume class  == aClass)				ifTrue:					[^ self renderedCostume: aCostume]]].	newCostume _ aClass new.	self renderedCostume: newCostume! !!Player methodsFor: 'costume' stamp: 'sw 9/11/1998 16:02'!wearSketchCostumeResembling: aSketchMorph	| newCostume itsForm cur degs chgd |	itsForm _ aSketchMorph form.	((cur _ costume renderedMorph) isKindOf: SketchMorph)		ifTrue:			[cur form == itsForm ifTrue: [^ self]].	costumes size > 0 ifTrue:		[newCostume _ costumes detect: [:c | (c isKindOf: SketchMorph) and: [c form == itsForm]]					ifNone: [nil]].	chgd _ false.	newCostume ifNil:		[newCostume _ SketchMorph new player: self.		newCostume originalForm: itsForm;		rotationCenter: aSketchMorph rotationCenter;		framesToDwell: aSketchMorph framesToDwell.		chgd _ true].	((cur isKindOf: SketchMorph) and: [cur rotationStyle ~~ #normal])			ifTrue:				[newCostume rotationStyle: cur rotationStyle.				newCostume rotationDegrees: cur rotationDegrees.				degs _ cur valueOfProperty: #setupAngle ifAbsent: [nil].				degs ifNotNil: [newCostume setupAngle: degs].				chgd _ true].	chgd ifTrue: [newCostume layoutChanged].	self renderedCostume: newCostume! !!Player methodsFor: 'name' stamp: 'sw 8/17/1998 17:12'!assureExternalName	| aCostume |	(aCostume _ self costume) knownName ifNil:		[aCostume setNameTo: aCostume externalName]! !!Player methodsFor: 'name' stamp: 'sw 8/17/1998 17:20'!renameTo: aName	self costume topRendererOrSelf renameTo: aName! !!Player methodsFor: 'pen' stamp: 'sw 8/17/1998 17:22'!choosePenColor: evt	evt hand changeColorTarget:  self costume  selector: #penColor:! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!clearTurtleTrails	self costume clearTurtleTrails! !!Player methodsFor: 'pen' stamp: 'sw 8/17/1998 17:12'!colorUnder	^ self costume colorUnder! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!liftAllPens	self costume liftAllPens! !!Player methodsFor: 'pen' stamp: 'sw 8/3/1998 16:10'!lowerAllPens	self costume lowerAllPens! !!Player methodsFor: 'slots-kernel' stamp: 'sw 9/10/1998 14:48'!standardSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	(self costume isKindOf: WorldMorph) ifTrue: [^ self standardWorldSlotsForBank: aBank].	aBank = 1 ifTrue: [^ #(		(heading	number		readWrite	getHeading			setHeading:)		(x 			number		readWrite	getX					setX:)		(y			number		readWrite	getY				setY:)		(colorUnder	color		readOnly	getColorUnder		unused))].	aBank = 3 ifTrue: [^ #(		(penDown	boolean		readWrite	getPenDown			setPenDown:)		(penColor	color		readWrite	getPenColor			setPenColor:)		(penSize 	number		readWrite	getPenSize			setPenSize:))].	aBank = 4 ifTrue: [^ #(		(isOverColor	boolean		readOnly	dummy				unused)		(colorSees	boolean		readOnly	dummy				unused)		(scaleFactor	number		readWrite	getScaleFactor		setScaleFactor:)		(width 		number		readWrite	getWidth			setWidth:)		(height 		number		readWrite	getHeight			setHeight:)		(left 		number		readWrite	getLeft				setLeft:)		(right 		number		readWrite	getRight			setRight:)		(top 		number		readWrite	getTop				setTop:)		(bottom 		number		readWrite	getBottom			setBottom:)		)].	^ #()! !!Player methodsFor: 'slots-kernel' stamp: 'sw 8/3/1998 16:46'!standardWorldSlotsForBank: aBank	"Return an array of slot names and slot info for use in a viewer on the receiver, special-cased for the situation where the receiver's costume is the World""		name		type		r/w			get selector			put selector		-----------	---------		-----------	---------------------	-------------   "	aBank = 1 ifTrue: [^ #(		(x 			number		readOnly	getX					unused)		(y			number		readOnly	getY				unused))].	aBank = 4 ifTrue: [^ #(		(colorSees	boolean		readOnly	dummy				unused)		(width 		number		readOnly	getWidth			unused)		(height 		number		readOnly	getHeight			unused)		(left 		number		readOnly	getLeft				unused)		(right 		number		readOnly	getRight			unused)		(top 		number		readOnly	getTop				unused)		(bottom 		number		readOnly	getBottom			unused)		)].	^ #()! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:40'!getAmount	self getValueFromCostume: #amount! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:40'!getAngle	^ self getValueFromCostume: #angle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getBorderColor	^ self getValueFromCostume: #borderColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getBorderWidth	^ self getValueFromCostume: #borderWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!getColor	^ self costume renderedMorph color! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!getColorUnder	^ self costume colorUnder! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getCursor	^ self getValueFromCostume: #cursor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/22/1998 19:51'!getHeadingUnrounded	^ self costume forwardDirection asSmallAngleDegrees! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:41'!getLeftRight	^ self getValueFromCostume: #leftRight! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:15'!getMouseX	^ self costume mouseX! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:18'!getMouseY	^ self costume mouseY! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/9/1998 17:12'!getRotationStyle	^ self getValueFromCostume: #rotationStyle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:18'!getScaleFactor	| aCostume |	^ (aCostume _ self costume) isFlexMorph		ifTrue: [aCostume scale]		ifFalse: [1.0]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:42'!getUpDown	^ self getValueFromCostume: #upDown! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:43'!getValueAtCursor	| anObject |	anObject _ self getValueFromCostume: #valueAtCursor.	^ anObject == 0  "weird return from GraphMorph"		ifTrue:			[nil]		ifFalse:			[anObject assuredPlayer]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:23'!getX		"emergency patch; unclear why not needed in getY; in any case, have		 removed the getX/getY retrievals from the viewer in 2.0-final anyway"	| aCostume |	(aCostume _ self costume) isInWorld ifFalse: [^ 100].	^ aCostume x! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/22/1998 19:50'!getY	^ self costume y! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:46'!setBorderColor: aColor	self setCostumeSlot: #borderColor: toValue: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:46'!setBorderWidth: aWidth	self setCostumeSlot: #borderWidth: toValue: aWidth! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:24'!setColor: aColor	self costume renderedMorph color: aColor! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:16'!setCostume: someOtherMorph	^ self costume wearCostume: someOtherMorph! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 15:47'!setCursor: aNumber	self setCostumeSlot: #cursor: toValue: aNumber! !!Player methodsFor: 'slots-standard-get/set' stamp: 'di 9/9/1998 20:13'!setHeading: newHeading	| aCostume |	aCostume _ self costume.	newHeading = 0.0		ifTrue: 			[self getScaleFactor = 1.0 ifTrue:				[aCostume isFlexMorph ifTrue:					[aCostume rotationDegrees: newHeading.					aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	self costume rotationDegrees: newHeading.! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!setName: aName	^ self costume renameTo: aName! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 9/9/1998 17:12'!setRotationStyle: aStyle	self setCostumeSlot: #rotationStyle toValue: aStyle! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/18/1998 11:53'!setScaleFactor: aNumber	| aCostume |	aCostume _ self costume.	1.0 = aNumber		ifTrue:			[0.0 = self getHeading ifTrue:				[aCostume isFlexMorph ifTrue: [aCostume removeFlexShell].				^ self]]		ifFalse:			[aCostume isFlexMorph ifFalse: [aCostume addFlexShell]].	aCostume scale: (aNumber asFloat max: 0.125)! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:15'!setValueAtCursor: aPlayer	| renderedMorph aCostume |	aCostume _ self costume.	((renderedMorph _ aCostume renderedMorph) respondsTo: #valueAtCursor:) ifTrue: [^ renderedMorph valueAtCursor: aPlayer costume].	(aCostume respondsTo: #valueAtCursor:) ifTrue: [aCostume valueAtCursor: aPlayer costume]! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:13'!setX: val	^ self costume x: val! !!Player methodsFor: 'slots-standard-get/set' stamp: 'sw 8/17/1998 17:22'!setY: val	^ self costume y: val! !!Player methodsFor: 'slots-user' stamp: 'sw 9/15/1998 14:01'!addInstanceVariable	| itsName initialValue typeChosen suggestedNames usedNames initialAnswer setterSelector |	suggestedNames _ #('cargo' 'speed' 'weight' 'mzee' 'friml' 'verp' 'znak').	usedNames _ self class instVarNames.	initialAnswer _ suggestedNames detect: [:aName |  (usedNames includes: aName) not] ifNone:		[Utilities keyLike: 'var1'  satisfying: [:aKey | (usedNames includes: aKey) not]].	itsName _ FillInTheBlank request: 'name for new inst var: ' initialAnswer: initialAnswer. 	itsName size == 0 ifTrue: [^ self].	(Utilities isLegalInstVarName: itsName) ifFalse: [^ self inform: 'sorry, illegal name, try again.'].	itsName _ itsName asSymbol.	(self class allInstVarNames includes: itsName) ifTrue: [^ self inform: 'that name is already used.'].		self assureUniClass.	typeChosen _ self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: typeChosen.	initialValue _ self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileAccessorsFor: itsName.	setterSelector _ Utilities setterSelectorFor: itsName.	(self class allInstances copyWithout: self) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewers! !!Player methodsFor: 'slots-user' stamp: 'sw 8/11/1998 12:47'!compileInstVarAccessorsFor: varName	| nameString |	nameString _ varName asString capitalized.	self class compileUnlogged: ('get', nameString, '	^ ', varName)		classified: 'access' notifying: nil.	self class compileUnlogged: ('set', nameString, ': val	', varName, ' _ val')		classified: 'access' notifying: nil.! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/1998 18:06'!initialValueForSlotOfType: aType	aType == #number ifTrue: [^ (1 to: 9) atRandom].	aType == #boolean ifTrue: [^ true].	aType == #player ifTrue: [^ self costume presenter standardPlayer].	aType == #color ifTrue: [^ Color random].	aType == #string ifTrue: [^ 'abc'].	aType == #sound ifTrue: [^ 'croak'].	aType == #point ifTrue: [^ 20 @ 30].	^ nil! !!Player methodsFor: 'slots-user' stamp: 'sw 8/17/1998 17:20'!tearOffFancyWatcherFor: aSlotName	| aWatcher aTile getSel aLine aColor aTower |	aColor _ Color r: 0.903 g: 0.903 b: 1.0.	aLine _ AlignmentMorph newRow vResizing: #shrinkWrap; color: aColor.	aLine borderWidth: 1; borderColor: aColor darker.	aLine addMorphBack: (self tileReferringToSelf borderWidth: 0; typeColor: aColor; color: aColor; bePossessive).	aLine addTransparentSpacerOfSize: (4@0).	aTower _ AlignmentMorph newColumn color: aColor.	aTower addTransparentSpacerOfSize: (0 @ 1).	aTower addMorphBack: (StringMorph contents: aSlotName, ' = ' font: ScriptingSystem fontForTiles).	aLine addMorphBack: aTower.	aTile _ NumericReadoutTile new typeColor: aColor.	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true.	aWatcher growable: true;		getSelector: (getSel _ Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName).	aTile addMorphBack: aWatcher.	aTile addArrows.	aTile setLiteralTo: (self perform: getSel) width: 30.	aLine addMorphBack: aTile.	aWatcher step; fitContents.	self costume primaryHand attachMorph: aLine! !!Player methodsFor: 'slots-user' stamp: 'sw 8/17/1998 17:23'!tearOffWatcherFor: aSlotName	| aWatcher |	aWatcher _ UpdatingStringMorph new target: self.	aWatcher growable: true;		getSelector: (Utilities getterSelectorFor: aSlotName);		putSelector: (Utilities setterSelectorFor: aSlotName);		setNameTo: aSlotName.	aWatcher step.	self costume primaryHand attachMorph: aWatcher! !!Player methodsFor: 'slots-user' stamp: 'sw 7/4/1998 18:03'!valueOfType: aType from: oldValue	"The user has changed a slot's type to aType; convert its former value, oldValue, to something of the appropriate type.  For now, does not take oldValue into account"	^ self initialValueForSlotOfType: aType! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/11/1998 12:45'!acceptScript: aScriptEditorMorph for: aSelector	| classif |	classif _ aScriptEditorMorph isAnonymous ifTrue: ['anonymous scripts'] ifFalse: ['named scripts'].	self class		compileUnlogged: aScriptEditorMorph methodString		classified: classif		notifying: nil.	self class atSelector: aSelector putScriptEditor: aScriptEditorMorph! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/18/1998 11:56'!infoFor: aSlotName	"The user made a gesture asking for info/menu relating"	| aMenu slotSym reply aType |	aType _ self typeForSlot: aSlotName asSymbol.	aMenu _ MVCMenuMorph new.	aType == #number "later others" ifTrue:		[aMenu add: 'simple watcher' action: #simpleWatcher.		aMenu add: 'fancier watcher' action: #fancyWatcher].	(self slotInfo includesKey: (slotSym _ aSlotName asSymbol))		ifTrue:  "User slot"			[aMenu add: 'change data type' action: #chooseSlotType.			aMenu add: 'remove "', aSlotName, '"' action: #removeSlot.			aMenu add: 'rename  "', aSlotName, '"' action: #renameSlot].	aMenu items size == 0 ifTrue:		[aMenu add: 'ok' action: nil].	aMenu addTitle: (aSlotName asString, ' (', aType, ')').	reply _  aMenu invokeAt: self costume primaryHand position in: self costume world.	reply == nil ifTrue: [^ self].	reply == #chooseSlotType ifTrue: [^ self chooseSlotTypeFor: slotSym].	reply == #removeSlot ifTrue: [^ self removeSlotNamed:  slotSym].	reply == #renameSlot ifTrue: [^ self renameSlot: slotSym].	reply == #simpleWatcher ifTrue: [^ self tearOffWatcherFor: slotSym].	reply == #fancyWatcher ifTrue: [^ self tearOffFancyWatcherFor: slotSym]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/20/1998 17:40'!instantiatedUserScriptsDo: aBlock	| aState |	(aState _ self costume actorState) ifNotNil:		[aState instantiatedUserScriptsDictionary do: aBlock]! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/1998 17:13'!okayToDestroyScriptNamed: scriptName	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptInvoking: scriptName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-kernel' stamp: 'sw 8/17/1998 17:21'!okayToRemoveSlotNamed: aSlotName	self costume world presenter allExtantPlayers do:		[:aPlayer | (aPlayer hasScriptReferencing: aSlotName ofPlayer: self)			ifTrue:				[^ false]].	^ true! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:22'!runAllClosingScripts	"Run all the receiver's scripts marked as #closing.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any _ false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfClosing ifTrue: [any _ true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 7/3/1998 20:21'!runAllOpeningScripts	"Run all the receiver's scripts marked as #opening.  Return a boolean indicating whether any such scripts were encountered and run"	| any |	any _ false.	self instantiatedUserScriptsDo:		[:aScriptInstantiation | aScriptInstantiation runIfOpening ifTrue: [any _ true]].	^ any! !!Player methodsFor: 'scripts-execution' stamp: 'sw 8/21/1998 16:34'!startRunning	self costume arrangeToStartStepping.	self instantiatedUserScriptsDo:		[:aScript | aScript startRunningIfPaused]! !!Player methodsFor: 'scripts-execution' stamp: 'sw 8/21/1998 16:34'!startRunningScripts	self startRunning.	self costume arrangeToStartStepping.  "emergency patch, if not going already"	self costume presenter startRunningScripts! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!beep: soundName	self costume presenter soundsEnabled		ifTrue: [self playSoundNamed: soundName]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:22'!bounce: soundName	| box bounced aCostume |	(aCostume _ self costume) ifNil: [^ self].	(aCostume owner == nil or: [aCostume owner isHandMorph]) ifTrue: [^ self].	box _ aCostume owner bounds.	bounced _ false.	(aCostume left < box left)			ifTrue: [self headRight. bounced _ true].	(aCostume right > box right)		ifTrue: [self headLeft. bounced _ true].	(aCostume top < box top)			ifTrue: [self headDown. bounced _ true].	(aCostume bottom > box bottom)	ifTrue: [self headUp. bounced _ true].	bounced ifTrue: [^ self makeBounceSound: soundName].! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:17'!changeScript: scriptName toStatus: statusSymbol	scriptName ifNil: [^ self].	Symbol hasInterned: scriptName ifTrue:		[:sym | self instantiatedUserScriptsDo:			[:aUserScript | aUserScript selector == sym				ifTrue:					[aUserScript status: statusSymbol.					^ self costume world updateStatusForAllScriptEditors]]]! !!Player methodsFor: 'scripts-standard' stamp: 'di 9/3/1998 00:43'!forward: dist 	| rho radians delta didStray p fractionalP newP aCostume |	(aCostume _ self costume) isInWorld ifFalse: [^ self].	aCostume isWorldOrHandMorph ifTrue: [^ self].	rho _ (aCostume asNumber: dist) asFloat.	radians _ (self getHeadingUnrounded asFloat - 90.0) degreesToRadians.	delta _ (radians cos @ radians sin) * rho.	((aCostume owner isHandMorph not) and:	 [aCostume presenter fenceEnabled]) ifTrue:		[(aCostume owner bounds containsRect: aCostume bounds) ifFalse:			["If I stray out of the bounds of my owner, pull me back, but			 without changing my heading as bounce would. Do nothing if			 bounce has already corrected the direction."			didStray _ false.			((aCostume left < aCostume owner left and: [delta x < 0]) or:			 [aCostume right > aCostume owner right and: [delta x > 0]]) ifTrue: [				delta _ delta x negated @ delta y.				didStray _ true].			((aCostume top < aCostume owner top and: [delta y < 0]) or:			 [aCostume bottom > aCostume owner bottom and: [delta y > 0]]) ifTrue: [				delta _ delta x @ delta y negated.				didStray _ true].			didStray ifTrue: [aCostume makeFenceSound]]].	"use and record the fractional position"	p _ aCostume referencePosition.	fractionalP _ aCostume actorState fractionalPosition.	(fractionalP == nil or: [fractionalP asIntegerPoint ~= p])		ifTrue: [newP _ p asFloatPoint + delta]		ifFalse: [newP _ fractionalP + delta]."Transcript cr; print: p; space; print: fractionalP;cr; cr; print: newP asIntegerPoint; space; print: newP; show: ''."	aCostume actorState fractionalPosition: newP.	aCostume referencePosition: newP asIntegerPoint.! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:17'!goToRightOf: aPlayer	| hisCostume aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	(hisCostume _ aPlayer costume) isInWorld ifFalse: [^ self].	((aCostume _ self costume) owner == hisCostume owner) ifFalse:		[hisCostume owner addMorphFront: aCostume].	aCostume position:		(hisCostume bounds rightCenter - (0 @ (aCostume height // 2)))! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!hide	self costume hide! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:18'!initiatePainting	(self costume isKindOf: PasteUpMorph) ifTrue:		[self costume makeNewDrawingWithin]! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:24'!moveToward: aPlayer	| angle aCostume |	(aPlayer == nil or: [aPlayer == self]) ifTrue: [^ self].	((aCostume _ self costume) bounds intersects: aPlayer costume bounds) ifTrue: [^ self].	angle _ aCostume referencePosition bearingToPoint: aPlayer costume referencePosition.	self setHeading: angle.	self forward: self getSpeed! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!pauseScript: scriptName	self changeScript: scriptName toStatus: #paused! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:24'!show	self costume show! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/18/1998 11:52'!standardCommandsForBank: aBank	"Return a list of typed-command arrays of the form:		<result type> <command> <argType>" 	self costume isWorldOrHandMorph ifTrue:		[^ #((command beep: sound)			(command stopScript: string)			(command pauseScript: string)			(command startScript: string)			(command initiatePainting))].	(aBank = 1) ifTrue:		[^ #((command forward: number)			(command turn: number)			(command wearCostumeOf: player)			(command moveToward: player)			(command beep: sound))].	(aBank = 2) ifTrue:		[^ #((command show)			(command hide)			(command bounce: sound)			(command wrap)			(command goToRightOf: player)		"	(command stopProgramatically)  "			(command stopScript: string)			(command pauseScript: string)			(command startScript: string))].	(aBank == 3 and: [self costume isKindOf: PasteUpMorph]) ifTrue:		[^ #((command liftAllPens)			(command lowerAllPens)			(command clearTurtleTrails)			(command goToNextCard)			(command goToPreviousCard)			(command newCard)			(command deleteCard)			(command initiatePainting))].	^ #()! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!startScript: scriptName	self changeScript: scriptName toStatus: #ticking! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/4/1998 23:57'!stopScript: scriptName	self changeScript: scriptName toStatus: #normal! !!Player methodsFor: 'scripts-standard' stamp: 'sw 8/17/1998 17:13'!wrap	self costume wrap! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:17'!actorState	^ self costume actorState! !!Player methodsFor: 'misc' stamp: 'sw 9/15/1998 13:19'!assureUniClass	"If I am not currently a member of a UniClass, become one now"! !!Player methodsFor: 'misc' stamp: 'sw 8/22/1998 21:44'!checkCostume	| found |	costumes ifNotNil:		[found _ costumes detect: [:c | c isInWorld] ifNone: [nil].		(found ~~ nil and: [found ~~ costume renderedMorph]) ifTrue:			[self halt: 'wrong costume'.			costume _ found]]! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:13'!color: myColor sees: externalColor	^ self costume color: myColor sees: externalColor! !!Player methodsFor: 'misc' stamp: 'sw 6/25/1998 17:14'!getInfo	"Open up some kind of editing window on the receiver's class comment, perhaps -- to be hooked up, perhaps, both via the viewer thumbnail and from the player's costume's red-dot menu" 	self notYetImplemented	"self class comment editxxx"! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:17'!grabPlayerIn: aWorld	aWorld primaryHand attachMorph: self costume		! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:21'!lastEvent	"A convenience for user scripts written in Squeak to call"	^ self costume primaryHand lastEvent! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:12'!makeBounceSound: soundName	self costume presenter soundsEnabled		ifTrue: [self playSoundNamed: soundName].! !!Player methodsFor: 'misc' stamp: 'sw 8/18/1998 11:54'!owningPlayer	"Answer the player who wears my costume's owner as its costume.  Speculative, not currently used"	| itsOwner |	self costume ifNotNil:		[(itsOwner _ self costume owner) ifNotNil:			[^ itsOwner player]].	^ nil! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:21'!presenter	"Convenience for calling from user scripts"	^ self costume presenter! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:14'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: (' (', self asOop printString, ')').	self costume ifNil: [aStream nextPutAll: ' (with nil costume)'.  ^ self].	aStream nextPutAll: ' named ', self externalName! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:13'!renderedCostumeRespondsTo: aSelector	^ self costume renderedMorph respondsTo: aSelector! !!Player methodsFor: 'misc' stamp: 'sw 6/25/1998 08:42'!revealPlayerIn: aWorld	| aMorph |	(aMorph _ self costume) isInWorld ifTrue: [^ aMorph goHome].	"It's hidden somewhere; search for it"	aWorld submorphs do:		[:m | (m succeededInRevealing: self) ifTrue: [^ self]].	self inform: 'Sorry.  Unaccountably, this objectseems to be irretrievably lost'			! !!Player methodsFor: 'misc' stamp: 'sw 9/15/1998 14:39'!revertToUnscriptedPlayerIfAppropriate	| anInstance |	((self class selectors size > 0) or: [self class instVarNames size > 0]) ifTrue: [^ self].	anInstance _ UnscriptedPlayer new.	anInstance initializeCostumesFrom: self.	self become: anInstance! !!Player methodsFor: 'misc' stamp: 'sw 9/10/1998 14:35'!seesColor: aColor	^ self costume touchesColor: aColor! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:20'!standardHolder	| aCostume |	aCostume _ self costume.	^ aCostume ifNotNil: [aCostume presenter ifNotNil: [aCostume presenter standardHolder]]! !!Player methodsFor: 'misc' stamp: 'sw 8/17/1998 17:25'!tearOffTileForSelf	self costume world primaryHand attachMorph: self tileReferringToSelf! !!Player methodsFor: 'misc' stamp: 'sw 8/22/1998 21:46'!thumbnailMenuEvt: anEvent forMorph: aMorph	"The mouse went down in the thumbnail of a Viewer for the receiver"	| aMenu aWorld |	aWorld _ aMorph world.	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'set new costume...' action: #newCostume.	aMenu add: 'forget other costumes' target: self selector: #forgetOtherCostumes.	aMenu addLine.	aMenu add: 'tile representing me' action: #tearOffTileForSelf.	aMenu addLine.	aMenu add: 'reveal me' target: self selector: #revealPlayerIn: argument: aWorld.	aMenu add: 'grab me' target: self selector: #grabPlayerIn: argument: aWorld.	aMenu popUpAt: aWorld primaryHand position event: aWorld primaryHand lastEvent"	aMenu add: 'switch costume...' target: self selector: #chooseCostumeIn: argument: aWorld.""	aMenu add: 'get info...' action: #getInfo.  "! !!Player methodsFor: 'object fileIn' stamp: 'ack 8/27/1998 13:33'!convertdc0: varDict dcc0: smartRefStrm	"These variables are automatically stored into the new instance ('costume' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('costumes' ) and deal with the information in ()"! !!Player class methodsFor: 'initialization' stamp: 'sw 6/16/1998 15:32'!copyStateFrom: anotherClass	| dupScript |	scripts _ IdentityDictionary new.	anotherClass userScriptsDo:		[:aScript | 			aScript isAnonymous ifFalse:				[dupScript _ aScript shallowCopy.				dupScript initializeForPlayer: self flagshipInstance afterShallowCopyFrom: aScript.				scripts at: aScript selector put: dupScript]].	slotInfo _ anotherClass slotInfo deepCopy.	self copyAddedStateFrom: anotherClass.  "The player-ref jump table"! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'sw 8/2/1998 22:52'!tileScriptNames	scripts ifNil: [^ OrderedCollection new].	"The following is an emergency workaround for damaged script dictionaries occurring in Alan's demo image 8/2/98; no selector should be nil but somehow some is, so here we filter such damaging things out"	^ scripts collect: [:aScript | aScript selector] thenSelect: [:n | n ~~ nil]! !!Player class methodsFor: 'slots' stamp: 'tk 8/31/1998 15:45'!privateSlotInfo	"for copying"	^ slotInfo! !!Player class methodsFor: 'slots' stamp: 'tk 8/31/1998 15:44'!slotInfo: aDict	"for copying"	slotInfo _ aDict! !!Player class methodsFor: 'other' stamp: 'tk 6/26/1998 18:21'!chooseUniqueClassName	| ii className |	ii _ BiggestSubclassNumber ifNil: [1] ifNotNil: [BiggestSubclassNumber+1].	[className _ (self name , ii printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [ii _ ii + 1].	BiggestSubclassNumber _ ii.	^ className	! !!Player class methodsFor: 'other' stamp: 'sw 8/17/1998 07:33'!isSystemDefined	^ name endsWithDigit not! !!Player class methodsFor: 'scripts' stamp: 'sw 8/22/1998 21:35'!anonymousUserScriptFor: aSelector player: aPlayer	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	self flag: #deferred.  "That anonymous script will of course contain refs to aPlayer who may well not be the class's prototype.  So if it is then saved, there's a problem"	entry _ UserScript new initializeAnonymousScriptFor: aPlayer.	scripts at: aSelector put: entry.	^ entry! !!Player class methodsFor: 'scripts' stamp: 'tk 8/31/1998 15:42'!privateScripts	"for copying"	^ scripts! !!Player class methodsFor: 'scripts' stamp: 'sw 8/11/1998 12:52'!removeScriptNamed: aScriptName	aScriptName ifNotNil:		[scripts removeKey: aScriptName.		self removeSelectorUnlogged: aScriptName]! !!Player class methodsFor: 'scripts' stamp: 'tk 8/31/1998 15:41'!scripts: aDict	"for copying"	scripts _ aDict! !!Player class methodsFor: 'scripts' stamp: 'sw 8/22/1998 21:33'!userScriptForPlayer: aPlayer selector: aSelector	|  entry |	scripts ifNil: [scripts _ IdentityDictionary new].	entry _ scripts at: aSelector ifAbsent: [nil].	entry ifNil:		[entry _ UserScript new player: aPlayer selector: aSelector.		scripts at: aSelector put: entry].	^ entry! !!Player class methodsFor: 'namespace' stamp: 'sw 8/11/1998 12:46'!compileReferenceAccessorFor: varName	self class compileUnlogged: ((self referenceAccessorSelectorFor: varName), '	^ ', varName)		classified: 'reference' notifying: nil! !!Player class methodsFor: 'housekeeping' stamp: 'sw 9/15/1998 16:28'!abandonUnnecessaryUniclasses	"Player abandonUnnecessaryUniclasses"	| oldCount oldFree newFree newCount report |	oldCount _ self subclasses size - 1.	oldFree _ Smalltalk garbageCollect.	self allSubInstances do:		[:aPlayer | aPlayer revertToUnscriptedPlayerIfAppropriate].	aPlayer _ nil.  "encourage last one to get garbage-collected"	ScriptingSystem spaceReclaimed.	newFree _ Smalltalk garbageCollect.	newCount _ self subclasses size - 1.	report _ 'Before: ', oldCount printString, ' uniclasses, ', oldFree printString, ' bytes freeAfter:  ', newCount printString, ' uniclasses, ', newFree printString, ' bytes free'.	Transcript cr; show: 'abandonUnnecessaryUniclasses:'; cr; show: report.	^ report	! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/4/1998 17:25'!cleansePlayersWithDamagedScripts	"Track down all Players with damaged scripts and repair their script dictionaries.  Report how many were fixed."	"Player cleansePlayersWithDamagedScripts"	| aList |	aList _ self class allSubInstances select:		[:c | c scripts ~~ nil and: [c scripts includesKey: nil]].	aList do:		[:c | c scripts removeKey: nil].	^ aList size printString, ' uniclasses fixed up'! !!Player class methodsFor: 'housekeeping' stamp: 'jm 5/20/1998 20:54'!freeUnreferencedSubclasses	"Player classes may hold in their class instance variables references to instances of themselves that are housekeepingwise unreachable. This method allows such loops to be garbage collected. This is done in three steps:	1. Remove user-created subclasses from the 'subclasses' set and from Smalltalk. Only remove classes whose name begins with 'Player' and which have not references.	2. Do a full garbage collection.	3. Enumerate all Metaclasses and find those whose soleInstance's superclass is this class. Reset the subclasses set to this set of classes, and add back to Smalltalk."	"Player freeUnreferencedSubclasses"	| newSubclasses |	subclasses _ subclasses select: [:c |		((c name asString beginsWith: 'Player') and:		 [(Smalltalk allCallsOn: (Smalltalk associationAt: c name)) size = 0])			ifTrue: [Smalltalk removeKey: c name ifAbsent: []. false]			ifFalse: [true]].	Smalltalk garbageCollect.	newSubclasses _ Set new.	Metaclass allInstancesDo: [:mClass |		c _ mClass soleInstance.		((c superclass = self) and:		 [(c name beginsWith: 'AnObsolete') not]) ifTrue: [			newSubclasses add: c.			Smalltalk at: c name put: c]].	subclasses _ newSubclasses.	SystemOrganization removeMissingClasses.! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/4/1998 17:06'!playersWithDamagedScripts	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithDamagedScripts"	^ self allSubInstances select:		[:p | p class scripts ~~ nil and: [p class scripts includesKey: nil]]! !!Player class methodsFor: 'housekeeping' stamp: 'sw 9/15/1998 14:33'!playersWithUnnecessarySubclasses	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithUnnecessarySubclasses size"	^ self class allSubInstances select:		[:p | p isSystemDefined not and: [p scripts size == 0 and: [p instVarNames size == 0]]] ! !!Player class methodsFor: 'housekeeping' stamp: 'sw 8/11/1998 13:23'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval _ candidatesForRemoval select:		[:aClass | aClass isSystemDefined not].	candidatesForRemoval do: [:c | c removeFromSystemUnlogged].	^ Smalltalk garbageCollect - oldFree! !!PlayerReferenceReadout methodsFor: 'all' stamp: 'sw 8/11/1998 16:47'!mouseDown: evt	"Allow the user to respecify this by direct clicking"	| aMorph |	putSelector == #unused ifTrue: [^ self].	Sensor waitNoButton.	aMorph _ self world chooseClickTarget.	aMorph ifNil: [^ self].	objectToView perform: putSelector with: aMorph assuredPlayer.	self changed! !!PluckedSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	| p sz |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	initialCount _ (d * self samplingRate asFloat) asInteger.	ring _ SoundBuffer newMonoSampleCount:		(((2.0 * self samplingRate) / p) asInteger max: 2).	sz _ ring monoSampleCount.	scaledIndexLimit _ (sz + 1) * ScaleFactor.	scaledIndexIncr _ (p * sz * ScaleFactor) // (2.0 * self samplingRate).	self reset.! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:40'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/8/1998 16:18'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive: 181>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex _ (startIndex + n) - 1.	scaledThisIndex _ scaledNextIndex _ scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex _ scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex _ ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average _			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample _ (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex _ scaledNextIndex.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]]].	scaledIndex _ scaledNextIndex.	count _ count - n.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 6/26/1998 11:07'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu _ view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self controlTerminate.				menu invokeOn: model.				self controlInitialize].! !!PluggableButtonMorph methodsFor: 'accessing'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol.! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!getMenu: shiftPressed	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: shiftPressed].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt shiftPressed.	menu ifNotNil: [menu popUpAt: evt cursorPoint event: evt].! !!PluggableButtonMorph class methodsFor: 'instance creation'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 16:19'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:20'!changeModelSelection: anInteger	"Let the view handle this."	terminateDuringSelect ifTrue: [self controlTerminate].	view changeModelSelection: anInteger.	terminateDuringSelect ifTrue: [self controlInitialize].! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:15'!initialize	super initialize.	self terminateDuringSelect: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:14'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableListController methodsFor: 'all' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect _ trueOrFalse! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableListController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:28'!font	^ font! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	font _ aFontOrNil.	self list: self getList.  "update display"! !!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:30'!list: listOfStrings	| morphList handler h loc index |	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	morphList _ list collect: [:item | StringMorph contents: item font: font].	"Sensitize first morph and copy handler to all the rest"	morphList first on: #mouseDown send: #mouseDown:onItem: to: self.	handler _ morphList first eventHandler.	morphList do: [:m | m eventHandler: handler].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	index _ self getCurrentSelectionIndex.	self selectedMorph: (index = 0 ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 8/14/1998 15:11'!setScrollDeltas	| range |	scroller hasSubmorphs ifFalse: [^ self].	range _ self totalScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2].	"Set up for one line, or a full pane less one line"	scrollBar scrollDelta: (scroller firstSubmorph height / range) asFloat 			pageDelta: (self innerBounds height - scroller firstSubmorph height / range) asFloat ! !!PluggableListMorph methodsFor: 'events' stamp: 'di 6/26/1998 13:33'!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 6/21/1998 22:19'!getListSelector	^ getListSelector! !!PluggableListMorphByItem methodsFor: 'as yet unclassified' stamp: 'jm 8/20/1998 09:44'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setIndexSelector with: item].	self update: getIndexSelector.! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	super font: aFontOrNil.	self list: self getList.  "update display"! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 17:12'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: textStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 8/18/1998 12:04'!menuTitleSelector: getMenuTitleSel	getMenuTitleSelector _ getMenuTitleSel! !!PluggableListView methodsFor: 'model access' stamp: 'sw 8/18/1998 12:07'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue:			[aMenu _ model perform: getMenuSelector with: menu.			getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].			^ aMenu].	getMenuSelector numArgs = 2		ifTrue: [aMenu _ model perform: getMenuSelector with: menu with: shiftKeyDown.				getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].				^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'updating' stamp: 'di 5/25/1998 10:24'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[self list: self getList.		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue:		[^ self moveSelectionBox: self getCurrentSelectionIndex].! !!PluggableListViewByItem methodsFor: 'all' stamp: 'jm 9/20/1998 17:13'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: textStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableTest methodsFor: 'music type pane' stamp: 'sw 8/18/1998 12:31'!musicTypeListTitle	^ 'Choose a command'! !!PluggableTest methodsFor: 'menu commands' stamp: 'sw 8/18/1998 12:29'!perform: sel orSendTo: otherObject	(self respondsTo: sel) ifTrue: [self perform: sel] ifFalse: [otherObject perform: sel]! !!PluggableTest class methodsFor: 'example' stamp: 'sw 8/18/1998 12:25'!open	"PluggableTest open"	| model listView1 topView listView2 |	model _ self new initialize.	listView1 _		PluggableListView on: model			list: #musicTypeList			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu:			keystroke: #musicTypeKeystroke:.	listView1  menuTitleSelector: #musicTypeListTitle.	listView2 _		PluggableListView on: model			list: #artistList			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	topView _ StandardSystemView new		label: 'Pluggable Test';		minimumSize: 300@200;		borderWidth: 1;		addSubView: listView1;		addSubView: listView2 toRightOf: listView1.	topView borderWidth: 1.	topView controller open.! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:13'!shiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: true! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:17'!unshiftedYellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: false! !!PluggableTextController methodsFor: 'all' stamp: 'di 6/26/1998 13:20'!yellowButtonActivity	"Invoke the model's menu."	^ self pluggableYellowButtonActivity: Sensor leftShiftDown! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:46'!appendEntry	"Append the text in the model's writeStream to the editable text. "	self deselect.	paragraph text size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: paragraph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect _ paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet _ self visibleAreas.	bottomStrip _ paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController class methodsFor: 'as yet unclassified' stamp: 'di 8/24/1998 09:57'!shiftedYellowButtonMessages	"Answer the set of messages that go with the shifted menu.  "	^ #(offerFontMenu changeStyle explain prettyPrint fileItIn recognizeCharacters spawn browseIt sendersOfIt implementorsOfIt referencesToIt  methodNamesContainingIt methodStringsContainingit methodSourceContainingIt  presentSpecialMenu yellowButtonActivity "<-note change")"set font... (k)set style... (K)explainformatfile it inrecognizer (r)spawn (o)browse it (b)senders of it (n)implementors of it (m)references to it (N)selectors containing it (W)method strings with itmethod source with itspecial menu...more..."! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 9/11/1998 15:46'!acceptOnCR: trueOrFalse	textMorph acceptOnCR: trueOrFalse! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 8/14/1998 15:55'!setScrollDeltas	| range |	scroller hasSubmorphs ifFalse: [^ self].	range _ self totalScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2].	scrollBar scrollDelta: (scroller firstSubmorph defaultLineHeight / range) asFloat 			pageDelta: (self innerBounds height - scroller firstSubmorph defaultLineHeight / range) asFloat ! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 6/22/1998 01:32'!selectionInterval: sel	selectionInterval _ sel! !!PluggableTextMorph methodsFor: 'model access' stamp: 'wod 5/26/1998 17:03'!setSelection: sel	selectionInterval _ sel.	textMorph editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [scroller changed].! !!PluggableTextMorph methodsFor: 'model access' stamp: 'ls 7/20/1998 22:50'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph _ TextMorphForEditView new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 8/24/1998 09:57'!prettyPrint	self handleEdit: [textMorph editor prettyPrint]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 6/26/1998 11:09'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu: event shiftPressed) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!PluggableTextMorph methodsFor: 'updating' stamp: 'ls 7/23/1998 03:47'!update: aSymbol	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #autoSelect ifTrue:			[self handleEdit:				[textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self world ifNotNil: [ self world displayWorld]].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self world displayWorld].! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 6/22/1998 15:15'!correctFrom: start to: stop with: aString	^ self handleEdit: [textMorph editor correctFrom: start to: stop with: aString]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 6/22/1998 15:14'!handleEdit: editBlock	| result |	textMorph editor model: model.  "For evaluateSelection"	textMorph handleEdit: [result _ editBlock value].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 7/3/1998 00:53'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform invert: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform invertRect: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'jm 8/20/1998 08:39'!mouseLeave: event	textMorph ifNotNil: [selectionInterval _ textMorph editor selectionInterval].	super mouseLeave: event.	event hand newKeyboardFocus: nil.! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 8/20/1998 11:55'!model: aLockedModel 	"Refer to the comment in View|model:." 	self model: aLockedModel controller: controller.	self editString: self getText.! !!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!rounded	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x rounded @ y rounded! !!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x truncated @ y truncated! !!Point methodsFor: 'point functions' stamp: 'di 9/11/1998 16:22'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	^ (x * aPoint x) + (y * aPoint y)! !!Point methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!PolygonMorph methodsFor: 'access' stamp: 'di 6/21/1998 12:23'!quickFill: trueOrFalse	quickFill _ trueOrFalse.	filledForm _ nil.	self changed! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 6/21/1998 21:10'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color white with:Color black).		^ (filledForm pixelValueAt: aPoint - boundstopLeft + 1) = 1]	ifFalse:		[self lineSegmentsDo:			[:p1 :p2 | (aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2) asFloat)					ifTrue: [^ true]].		arrowForms ifNotNil: [arrowForms do:			[:f | (f pixelValueAt: aPoint - f offset) > 0					ifTrue: [^ true]]].		^ false]! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:36'!areasRemainingToFill: aRectangle	"Could be improved by quick check of inner rectangle"	^ Array with: aRectangle! !!PolygonMorph methodsFor: 'drawing' stamp: 'di 6/21/1998 21:10'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not ifTrue:		[self filledForm colors: (Array with: Color transparent with: color).		aCanvas image: self filledForm at: bounds topLeft-1].	lineColor _ borderColor.  bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: [topLeftColor _ color lighter.						bottomRightColor _ color darker.  bevel _ true].	borderColor == #inset ifTrue: [topLeftColor _ owner colorForInsets darker.						bottomRightColor _ owner colorForInsets lighter.  bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth+1//2.	brush _ nil.	self lineSegmentsDo:		[:p1 :p2 | p1i _ p1 asIntegerPoint.  p2i _ p2 asIntegerPoint.		(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"					((p1i min: p2i) max: bigClipRect origin) <=					((p1i max: p2i) min: bigClipRect corner)]) ifTrue:			[bevel ifTrue: [((p1i quadrantOf: p2i) > 2)						ifTrue: [lineColor _ topLeftColor]						ifFalse: [lineColor _ bottomRightColor]].			(borderWidth > 3 and: [borderColor isColor])			ifTrue: [brush == nil ifTrue:						[brush _ (ColorForm dotOfSize: borderWidth)								colors: (Array with: Color transparent with: borderColor)].					aCanvas line: p1i to: p2i brushForm: brush]			ifFalse: [aCanvas line: p1i to: p2i							width: borderWidth color: lineColor]]].	self arrowForms ifNotNil:		[self arrowForms do:			[:f | f colors: (Array with: Color transparent with: borderColor).			aCanvas image: f at: f offset]]! !!PolygonMorph methodsFor: 'editing' stamp: 'jm 6/3/1998 14:29'!newVertex: evt fromHandle: handle afterVert: ix	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	pt _ evt cursorPoint.	self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).	evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1).! !!PolygonMorph methodsFor: 'menu' stamp: 'di 6/21/1998 12:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles == nil		ifTrue: [aCustomMenu add: 'show handles' action: #addHandles]		ifFalse: [aCustomMenu add: 'hide handles' action: #removeHandles].	quickFill		ifTrue: [aCustomMenu add: 'proper fill' selector: #quickFill: argument: false]		ifFalse: [aCustomMenu add: 'quick fill' selector: #quickFill: argument: true].	closed ifTrue: [aCustomMenu add: 'open polygon' action: #makeOpen]		ifFalse:		[aCustomMenu add: 'close polygon' action: #makeClosed.		arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].		arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].		arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].		arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]]! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 15:24'!curveBounds	^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 21:15'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ ColorForm extent: bounds extent+2. "for anyShapeFill"	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: [filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill].	^ filledForm! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 6/21/1998 10:24'!shapeFromPen: penBlock color: c borderWidth: bw borderColor: bc	"World addMorph: (PolygonMorph		shapeFromPen: [:p |				p hilbert: 4 side: 5.				p go: 5.				p hilbert: 4 side: 5.				p go: 5.]		color: Color red borderWidth: 1 borderColor: Color black)"	| pen |	penBlock value: (pen _ PenPointRecorder new).	^ (self vertices: pen points color: c borderWidth: bw borderColor: bc)		quickFill: false! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'di 6/3/1998 16:43'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	nLines _ (frame height - 4) // marker height.	allLabels := labelString findTokens: Character cr asString.	lineArray ifNil: [lineArray _ Array new].	nLinesPer _ segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])			before: subset first.		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines _ (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines) startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PositionableStream methodsFor: 'positioning' stamp: 'di 5/25/1998 15:16'!padToNextLongPut: char 	"Make position be on long word boundary, writing the padding 	character, char, if necessary."	[self position \\ 4 = 0]		whileFalse: [self nextPut: char]! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'ls 9/14/1998 22:46'!nextString	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."	| aString length |	"read the length in binary mode"	self binary.	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ length - 192.		1 to: 3 do: [:ii | length _ length * 256 + self next]].	aString _ String new: length.	"read the characters in ASCII mode"	self ascii.	self nextInto: aString.	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 6/8/1998 21:01'!nextStringOld	"Read a string from the receiver. The first byte is the length of the 	string, unless it is greater than 192, in which case the first *two* bytes 	encode the length.  Max size 16K. "	| aString length |	length _ self next.		"first byte."	length >= 192 ifTrue: [length _ (length - 192) * 256 + self next].	aString _ String new: length.	1 to: length do: [:ii | aString at: ii put: self next asCharacter].	^aString! !!PositionableStream methodsFor: 'nonhomogeneous accessing' stamp: 'tk 5/29/1998 09:41'!nextStringPut: s 	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."	| length |	(length _ s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length digitAt: 4)+192.			self nextPut: (length digitAt: 3).			self nextPut: (length digitAt: 2).			self nextPut: (length digitAt: 1)].	self nextPutAll: s.	^s! !!Preferences class methodsFor: 'initialization' stamp: 'di 9/22/1998 15:56'!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	self disable: #browseWithPrettyPrint.	self enable: #cautionBeforeClosing.	self enable: #cmdDotEnabled.	self enable: #confirmFirstUseOfStyle.	self disable: #disableSounds.	self disable: #editPlayerScriptsInPlace.	self disable: #fastDragWindowForMorphic.	self enable: #ignoreStyleIfOnlyBold.	self enable: #logDebuggerStackToFile.	self disable: #noviceMode.	self enable: #reverseWindowStagger.	self enable: #showDebugHaloHandle.	self disable: #showTimeStampsInMenuTitles.	self disable: #suppressCheckForSlips.	self enable: #thoroughSenders.	self disable: #uniformWindowColors.	self enable: #warnIfNoChangesFile.	self enable: #warnIfNoSourcesFile.! !!Preferences class methodsFor: 'initialization' stamp: 'sw 9/19/1998 22:47'!initialize	"Preferences initialize"	"Sometimes placed in a change-set even though unchanged, to trigger reinitialization upon update."	FlagDictionary _ Dictionary new.	self chooseInitialSettings.! !!Preferences class methodsFor: 'parameters' stamp: 'sw 9/10/1998 16:09'!defaultAuthorName	"Answer the author name to be planted, by default, in a changeset-preamble template.  You can hard-code this to hold your name, thus saving you time when writing the preambles of subsequent changesets"	^ 'Your Name'! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'di 9/22/1998 15:54'!disable: preferenceNameSymbol	"Shorthand access"	self setPreference: preferenceNameSymbol toValue: false! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'di 9/22/1998 15:54'!enable: preferenceNameSymbol	"Shorthand access"	self setPreference: preferenceNameSymbol toValue: true! !Optionally associated with a PasteUpMorph, provides presentation services.Holds control buttons:	stopButton stepButton goButton.Holds state flags:	mouseOverHalosEnabled soundsEnabled fenceEnabled coloredTilesEnabledHolds a viewerCache Holds, optionally three 'standard items' originally providing idiomatic support of ongoing squeak-team internal work, but now extended to more general applicability:   standardPlayer standardPlayfield standardPalette !!Presenter methodsFor: 'button creation' stamp: 'sw 9/14/1998 12:38'!addTrashCan	| aPosition aCan |	(aCan _ associatedMorph findA: TrashCanMorph) ifNotNil: [^ aCan].	aCan _ TrashCanMorph newSticky.	aPosition _ associatedMorph positionNear: (associatedMorph bottomRight - aCan extent) forExtent: aCan extent adjustmentSuggestion:  (-10 @ 0).	aCan position: aPosition.	associatedMorph addMorph: aCan.	aCan startStepping.	aCan setProperty: #scriptingControl toValue: true.	aCan setToAdhereToEdge: #bottomRight.	^ aCan! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/24/1998 15:14'!goButton	| aDict |	goButton == nil  ifTrue:		[aDict _ ScriptingSystem formDictionary.		goButton _ ThreePhaseButtonMorph new.		goButton image:  (aDict at: 'GoPicOn');			offImage: (aDict at: 'GoPic');			pressedImage: (aDict at: 'GoPicOn');			actionSelector: #goUp:with:; 			arguments: (Array with: nil with: goButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Go Button';			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			setBalloonText:'Resume runningall paused scripts'].	goButton isInWorld ifFalse:		[associatedMorph addMorph: (goButton beRepelling position: (self stepButton topRight + (1@0)))].	^ goButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/25/1998 12:10'!stepButton	| aDict aPosition |	stepButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stepButton _ ThreePhaseButtonMorph new.		stepButton image:  (aDict at: 'StepPicOn');			offImage: (aDict at: 'StepPic'); pressedImage:  (aDict at: 'StepPicOn');				arguments: (Array with: nil with: stepButton);			setNameTo: 'Step Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottom;			on: #mouseDown send: #stepDown:with: to: self;			on: #mouseStillDown send: #stepStillDown:with: to: self;			on: #mouseUp send: #stepUp:with: to: self;			setBalloonText:'Run every pausedscript exactly once.  Keepthe mouse button down over "Step"and everything will keep runninguntil you release it'].	stepButton isInWorld ifFalse:		[aPosition _ associatedMorph			positionNear:				(self stopButton topRight + (1@0))			 forExtent:				stepButton extent			adjustmentSuggestion:				(0 @ (stepButton height negated)).		associatedMorph addMorph: (stepButton beRepelling position: aPosition)].	^ stepButton! !!Presenter methodsFor: 'button creation' stamp: 'sw 6/30/1998 15:54'!stopButton	| aDict aPosition anExtent |	stopButton ifNil:		[aDict _ ScriptingSystem formDictionary.		stopButton _ ThreePhaseButtonMorph new.		stopButton image:  (aDict at: 'StopPic');			offImage: (aDict at: 'StopPic'); pressedImage:  (aDict at: 'StopPicOn').		stopButton actionSelector: #stopUp:with:; 			arguments: (Array with: nil with: stopButton);			actWhen: #buttonUp; target: self;			setNameTo: 'Stop Button'; 			setProperty: #scriptingControl toValue: true;			setToAdhereToEdge: #bottomLeft;			setBalloonText:'Pause all ticking scripts.'].	stopButton isInWorld ifFalse:		[anExtent _ stopButton extent.		aPosition _ (associatedMorph left + 128) @ (associatedMorph bottom - 30).		aPosition _ associatedMorph positionNear: aPosition forExtent:  anExtent adjustmentSuggestion: (0 @ (anExtent y negated)).		associatedMorph addMorph: (stopButton beRepelling position: aPosition)].		^ stopButton! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/3/1998 12:25'!classNamesForStandardPartsBin	^	#(			(RectangleMorph EllipseMorph StarMorph  CurveMorph PolygonMorph TextMorph ImageMorph		PasteUpMorph PaintInvokingMorph  StringMorph)		(TabbedPalette)		(BasicButton JoystickMorph ClockMorph RecordingControlsMorph))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 8/3/1998 14:17'!controlPanel	|  aPanel |	(aPanel _ associatedMorph world allMorphs detect:		[:aMorph | ((aMorph isKindOf: PasteUpMorph) and: [aMorph hasProperty: #controlPanel])]				ifNone: [nil]) notNil			ifTrue:				[^ aPanel].	aPanel _ PasteUpMorph new extent:  128 @ 48.	aPanel color: Color white; padding: 9; borderWidth: 1; borderColor: Color blue.	aPanel addAllMorphs: self toggleButtons. 	aPanel laySubpartsOutInOneRow.	aPanel setProperty: #controlPanel toValue: true; setNameTo: 'Control Panel'.	^ aPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/6/1998 14:07'!createControlPanel	associatedMorph primaryHand attachMorph: self controlPanel ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 8/5/1998 00:16'!customPagesForPartsBin	| aPage |	^ #(BookMorph WebBookMorph) collect:		[:sym |			aPage _ self newPageForStandardPartsBin.			aPage addMorphBack: (Smalltalk at: sym) authoringPrototype.			aPage addMorphBack: Morph new previousPageButton markAsPartsDonor.			aPage addMorphBack: Morph new nextPageButton markAsPartsDonor.			aPage fixLayout.			aPage]! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 8/5/1998 00:13'!launchMyPartsBin	associatedMorph primaryHand attachMorph: ScriptingSystem partsBin ! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/30/1998 17:06'!newStandardPartsBin	| aBook aPage aSize |	aSize _ 340 @ 160.	aBook _ BookMorph new color: Color blue veryMuchLighter.	aBook borderWidth: 2.	aBook removeEverything.	aBook openToDragNDrop: false.	aBook addMorphBack: (aBook makeMinimalControlsWithColor: Color transparent title: 'Parts Bin').	self classNamesForStandardPartsBin do:		[:aList |			aPage _ self newPageForStandardPartsBin.			aList do:				[:sym | aPage addMorphBack: (Smalltalk at: sym) authoringPrototype].			aPage fixLayout.			aBook insertPage: aPage pageSize: aSize].	self customPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	self tilesPagesForPartsBin do:		[:pg | aBook insertPage: pg pageSize: aSize].	aBook goToPage: 1.	^ aBook! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/16/1998 16:17'!standardPalette: aPalette	standardPalette _ aPalette! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 7/15/1998 19:44'!standardPaletteIsAlready: aPalette	^ standardPalette == aPalette! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 8/3/1998 16:39'!tilesPagesForPartsBin	| aPage bools aTile aPhrase |	aPage _ self newPageForStandardPartsBin padding: 30.	bools _ self booleanTiles.	aPage addMorphBack: bools first markAsPartsDonor.	aPage addMorphBack: bools last markAsPartsDonor.	aPage addMorphBack: self arithmeticTiles first markAsPartsDonor.	aPage addMorphBack: RandomNumberTile new markAsPartsDonor.	#(('(Sensor anyButtonPressed)' 'button down?')	('(Sensor noButtonPressed)' 'button up?')	"('(Sensor keyboardPressed)' 'key hit?')   sucker doesn't work for some reason") do:		[:pair |			aPhrase _ SystemQueryPhrase new.			aTile _ BooleanTile new.			aTile setExpression: pair first label: pair second.			aPhrase addMorph: aTile.			aPage addMorphBack: aPhrase].	aPage makeAllTilesGreen.	aPage fixLayout.	^ OrderedCollection with: aPage  "room to grow"! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 9/20/1998 22:12'!createStandardPlayer	| aMorph |	aMorph _ ImageMorph new image: (ScriptingSystem formDictionary at: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	standardPlayer _ aMorph assuredPlayer renameTo: 'dot'.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 7/4/1998 14:29'!positionStandardPlayer	standardPlayer costume position: (associatedMorph bottomLeft - (0 @ standardPlayer costume height))! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 6/17/1998 16:05'!standardPlayer	standardPlayer ifNil:		[self createStandardPlayer].	standardPlayer costume isInWorld ifFalse: [associatedMorph addMorphNearBack: standardPlayer costume].	^ standardPlayer! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:44'!borderColorWhenRunning	borderColorWhenRunning ifNil:		[borderColorWhenRunning _ ScriptingSystem runningPlayfieldBorderColor].	^ borderColorWhenRunning! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 15:27'!borderColorWhenStopped	borderColorWhenStopped ifNil:		[borderColorWhenStopped _ ScriptingSystem frozenPlayfieldBorderColor].	^ borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:58'!startRunningScripts	self stopButtonState: false.	self stepButtonState: false.	self goButtonState: true.	associatedMorph startRunningAll.	associatedMorph borderColor: self borderColorWhenRunning.	ThumbnailMorph recursionReset.  "needs to be done once in a while"! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:37'!stepStillDown: dummy with: theButton	self stepButtonState: true.	self stopButtonState: false.	associatedMorph stepAll.	associatedMorph world displayWorld.	(Delay forMilliseconds: 200) wait.	self stepButtonState: false.	self stopButtonState: true! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/30/1998 08:45'!stopRunningScripts	self stopButtonState: true.	self stepButtonState: false.	self goButtonState: false.	associatedMorph stopRunningAll.	associatedMorph borderColor: self borderColorWhenStopped! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:23'!stopUp: dummy with: theButton	self flushPlayerListCache.  "catch guys not in cache but who're running"	self stopRunningScripts! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 8/5/1998 07:37'!balloonHelpEnabled	"Because the Hand logic wants to get the balloon-help state from the World rather than from any more local morph, this option always gets referred directly to the world -- perforce non-uniform with the other toggles"	^ associatedMorph world balloonHelpEnabled! !!Presenter methodsFor: 'toggle-state flags' stamp: 'sw 6/8/1998 11:06'!mouseOverHalosEnabled	^ mouseOverHalosEnabled == true! !!Presenter methodsFor: 'toggles-actions' stamp: 'sw 8/5/1998 07:37'!toggleShowBalloons	"Because the Hand logic wants to get the balloon-help state from the World rather than from any more local morph, this option always gets referred directly to the world -- perforce non-uniform with the other toggles"	self world toggleShowBalloons! !!Presenter methodsFor: 'tile support' stamp: 'sw 6/25/1998 13:29'!valueTiles	| tiles |	tiles _ OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (TilePadMorph colorForType: #number)).	tiles add: ((4 @ 9) newTileMorphRepresentative typeColor: (TilePadMorph colorForType: #point)).	tiles add: (ColorTileMorph new typeColor: (TilePadMorph colorForType: #color)).	tiles add: (TileMorph new typeColor: (TilePadMorph colorForType: #number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'viewer' stamp: 'sw 8/11/1998 16:47'!viewMorph: aMorph	| aPlayer aViewer aPalette |	Sensor leftShiftDown ifFalse:		[(aPalette _ aMorph standardPalette) ifNotNil:			[^ aPalette viewMorph: aMorph]].	aPlayer _ aMorph assuredPlayer.	associatedMorph addMorph: (aViewer _ self nascentPartsViewer).	aViewer setPlayer: aPlayer.	aViewer makeAllTilesGreen.	aMorph primaryHand attachMorph: aViewer! !!Presenter methodsFor: 'misc' stamp: 'sw 7/8/1998 13:04'!drawingJustCompleted: aSketchMorph	| pal aPaintBox |	(aPaintBox _ associatedMorph world paintBox) ifNotNil:		[aPaintBox delete].	(aSketchMorph pasteUpMorph hasProperty: #automaticViewing)		ifTrue:			[(pal _ aSketchMorph standardPalette) ifNotNil:				[pal viewMorph: aSketchMorph]]! !!Presenter methodsFor: 'misc' stamp: 'sw 8/5/1998 07:38'!initializeToggles	mouseOverHalosEnabled _ true.	soundsEnabled _ true.	fenceEnabled _ true.	coloredTilesEnabled _ false! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:58'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	aPasteUpMorph automaticViewing ifTrue: [aPasteUpMorph standardPalette viewMorph: aMorph]! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:16'!standardPlayfield: aPlayfield	standardPlayfield _ aPlayfield! !!Presenter methodsFor: 'misc' stamp: 'sw 8/5/1998 07:35'!toggleButtons	| aButton aDict aList |	aDict _ ScriptingSystem formDictionary.	aList _ #(	('Balloons'	'BalloonsOn'		'BalloonsOff' 	toggleShowBalloons	balloonHelpEnabled)	('Sounds'	'SoundOn'		'SoundOff'  		toggleSoundsEnabled	soundsEnabled)	('Fence'		'FenceOn'		'FenceOff'  		toggleFence			fenceEnabled)) with:	#('Balloon Help:If green, then when thecursor pauses over an objectthat has balloon help,that help balloon is shown''Sounds:If green, sounds will be heard when appropriate; ifred, sounds are suppressed.''Fence:If green, an invisible "fence"keeps your objects from strayingoutside their containers whentheir scripts move them.')	collect:			[:q :helpString |			aButton _ ToggleButtonMorph new setNameTo: q first.			aButton onImage: (aDict at: q second);				offImage: (aDict at: q third);				pressedImage: nil;				actionSelector: q fourth;				stateSelector: q last;				actWhen: #buttonDown;				target: self;				setInitialState;  "Obtains it from target"				setBalloonText: helpString;				extent: (aDict at: q second) extent.			aButton].	^ aList! !!Presenter methodsFor: 'playerList' stamp: 'sw 8/11/1998 16:58'!allExtantPlayers	"Inefficient and ultimately unacceptable, but for the current round of demos it will help keep things from stalling just because they're on hidden book pages.  Produces a list of all Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  Call #flushPlayerListCache to force recomputation."	playerList ifNotNil:		[^ playerList].	^ playerList _ (associatedMorph allMorphsIncludingBookPages select: [:m | m player ~~ nil] thenCollect: [:m | m player]) asArray! !!Presenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!flushPlayerListCache	playerList _ nil! !!Presenter methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 18:51'!convertassgbmsfcvsssspbb0: varDict assgmsfcvsssspbb0: smartRefStrm	"These variables are automatically stored into the new instance ('associatedMorph' 'stopButton' 'stepButton' 'goButton' 'mouseOverHalosEnabled' 'soundsEnabled' 'fenceEnabled' 'coloredTilesEnabled' 'viewerCache' 'standardPlayer' 'standardPlayfield' 'standardPalette' 'standardHolder' 'playerList' 'borderColorWhenRunning' 'borderColorWhenStopped' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in () and deal with the information in ('balloonHelpEnabled' )"! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!program	^ program! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange	program _ midiProgramChange.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange channel: midiChannel	program _ midiProgramChange.	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:46'!isProgramChange	^ true! !!ProgramChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rC0		channel: channel		byte: program.! !!ProgramChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:28'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': prog '.	program printOn: aStream.	aStream nextPut: $).! !!Project methodsFor: 'initialization' stamp: 'di 6/10/1998 13:54'!windowActiveOnFirstClick	^ true! !!Project methodsFor: 'initialization' stamp: 'di 6/12/1998 15:58'!windowReqNewLabel: newLabel	newLabel isEmpty ifTrue: [^ false].	newLabel = changeSet name ifTrue: [^ true].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ false].	changeSet name: newLabel.	^ true! !!Project methodsFor: 'accessing' stamp: 'tk 6/26/1998 22:17'!labelString	^ changeSet name! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 15:42'!enter: returningFlag	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we are return to the project from whence the current project was entered; don't change its previousProject link in this case."	| newDisplay entering vanishingPoint showZoom |	self == CurrentProject ifTrue: [^ self].	Smalltalk at: #ScorePlayer ifPresent: [:playerClass |		playerClass allInstancesDo: [:player | player pause]].	returningFlag ifFalse: [		"record link to previous project unless we're returning via that link"		previousProject _ CurrentProject].	"Same code runs for enter and exit; test which for zoom"	entering _ self ~~ CurrentProject parent.	displayDepth == nil ifTrue: [displayDepth _ Display depth].	CurrentProject makeThumbnail.	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	showZoom _ Preferences showProjectZoom		and: [Smalltalk garbageCollectMost > (Display boundingBox area*displayDepth//8+200000)].	Display replacedBy:			(showZoom				ifTrue: [newDisplay _ DisplayScreen extent: Display extent													depth: displayDepth]				ifFalse: [Display newDepthNoRestore: displayDepth])		do: [world isMorph				ifTrue: [World _ world.  "Signifies Morphic"						world install]				ifFalse: [World _ nil.  "Signifies MVC"						Smalltalk at: #ScheduledControllers put: world.						ScheduledControllers restore]].	showZoom		ifTrue: ["Show animated zoom to new display"				vanishingPoint _ Sensor cursorPoint.				(entering ifTrue: [self] ifFalse: [previousProject]) dependents do:					[:v | (v isKindOf: StandardSystemView)						ifTrue: [vanishingPoint _ v windowBox center]].				Display zoomIn: entering orOutTo: newDisplay at: 0@0							vanishingPoint: vanishingPoint.				displayDepth ~= Display depth ifTrue:					[Display newDepthNoRestore: displayDepth.					newDisplay displayOn: Display at: 0@0]].	world isMorph		ifTrue: [self spawnNewProcessAndTerminateOld: true]		ifFalse: [world searchForActiveController]! !!Project methodsFor: 'menu messages' stamp: 'di 6/20/1998 10:25'!exit	"Leave the current project and return to the project in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	parentProject enter: false.! !!Project methodsFor: 'menu messages' stamp: 'di 6/17/1998 14:14'!makeThumbnail	"Make a thumbnail image of this project from the Display."	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).! !!Project methodsFor: 'menu messages' stamp: 'di 6/23/1998 09:36'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	world isMorph		ifTrue: [world _ World.				self dependents do:					[:d | (d isKindOf: SystemWindow)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]].				world sleep "Release all space possible in old world"]		ifFalse: [world _ ScheduledControllers.				ScheduledControllers unCacheWindows.				self dependents do:					[:d | (d isKindOf: StandardSystemView)						ifTrue: [d label ~= changeSet name ifTrue: [self changed: #relabel]]]].	transcript _ Transcript.	displayDepth _ Display depth.	activeProcess _ nil! !!Project methodsFor: 'release' stamp: 'sw 7/6/1998 11:16'!canDiscardEdits	"Don't regard a window of mine as one to be discarded as part of a 'closeUnchangedWindows' sweep"	^ false! !!Project methodsFor: 'release' stamp: 'di 6/22/1998 09:40'!okToChange	| ok hasSubProjects |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ (world isMorph not and: [world scheduledControllers size <= 1]) or:			[self confirm:'Really delete the project', self name printString, 'and all its windows?'].	ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	Project allInstancesDo: [:p | p deletingProject: self].	ProjectViewMorph allInstancesDo: [:p | p deletingProject: self].	^ true! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:14'!activeProcess	^ activeProcess! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:20'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	projectProcess _ Project current activeProcess.	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!Project methodsFor: 'active process' stamp: 'sw 9/15/1998 16:42'!maybeForkInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: [[self interruptName: 'User Interrupt'] fork]			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 14:07'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	activeProcess _ aProcess.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:21'!spawnNewProcess	exitFlag _ false.	activeProcess _		[[World doOneCycle.  Processor yield.  exitFlag] whileFalse: [].		self exit]			newProcess priority: Processor userSchedulingPriority.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:22'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor activeProcess suspend]! !!Project class methodsFor: 'class initialization' stamp: 'di 6/20/1998 10:31'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject _ super new initialProject.		CurrentProject spawnNewProcessAndTerminateOld: true].	NavList _ OrderedCollection with: CurrentProject.	"Project initialize"! !!Project class methodsFor: 'instance creation' stamp: 'di 6/20/1998 13:14'!activeProcess	^ CurrentProject activeProcess! !!Project class methodsFor: 'instance creation' stamp: 'sw 7/6/1998 11:23'!newMorphicConstruction	"ProjectView open: Project newMorphicConstruction"	| aProject |	aProject _ self newMorphic.	aProject world configureForConstruction.	^ aProject! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:29'!addItem: item toMenu: menu selection: action	(menu isKindOf: MenuMorph)		ifTrue: [menu add: item selector: #jumpToSelection: argument: action]		ifFalse: [menu add: item action: action]! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:28'!buildJumpToMenu: menu	"Present a list of potential projects."	"Time millisecondsToRun: [Project jumpToMenu]"	| prev |	"First a FIFO list"	(prev _ CurrentProject previousProject) ifNotNil:		[1 to: 5 do:			[:i | 			prev ifNotNil: 				[self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: '%back' , i printString.				prev _ prev previousProject]].		menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: [		self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent.		menu addLine].	"Finally all the projects"	Project allNames do: [:n | self addItem: n toMenu: menu selection: n].	^ menu! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:24'!jumpToProject		"Project jumpToProject"	"Present a list of potential projects and enter the one selected."	self jumpToSelection: (self buildJumpToMenu: CustomMenu new) startUp! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:03'!jumpToSelection: selection	"Enter the project corresponding to this menu selection."	"Project jumpToProject"	| nBack prev |	selection ifNil: [^ self].	(selection beginsWith: '%back') ifTrue:		[nBack _ (selection copyFrom: 6 to: selection size) asNumber.		prev _ CurrentProject previousProject.		1 to: nBack-1 do:			[:i | prev ifNotNil: [prev _ prev previousProject]].		prev ifNotNil: [prev enter: true]].	selection = #parent ifTrue: [CurrentProject parent enter: false. ^ self].	(Project named: selection) enter: false! !!ProjectView methodsFor: 'initialization' stamp: 'sw 8/4/1998 19:15'!maybeRelabel: newLabel	"If the change set name given by newLabel is already in use, do nothing; else relabel the view"	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [^ self].	self relabel: newLabel! !!ProjectView methodsFor: 'initialization' stamp: 'sw 8/4/1998 19:15'!update: aSymbol	aSymbol = #relabel		ifTrue: [^ self maybeRelabel: model labelString].	^ super update: aSymbol! !!ProjectView methodsFor: 'displaying' stamp: 'di 5/27/1998 16:58'!displayView	super displayView.	self label = model name		ifFalse: [super relabel: model name].	self isCollapsed ifTrue: [^ self].	model thumbnail ifNil: [^ self].	self insetDisplayBox extent = model thumbnail extent		ifTrue: [model thumbnail displayAt: self insetDisplayBox topLeft]		ifFalse: [(model thumbnail					magnify: model thumbnail boundingBox					by: self insetDisplayBox extent asFloatPoint / model thumbnail extent) 				displayAt: self insetDisplayBox topLeft]! !!ProjectView methodsFor: 'displaying' stamp: 'sw 9/14/1998 13:01'!release	super release.	Smalltalk garbageCollect! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'sw 7/6/1998 19:44'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView).	ScheduledControllers schedulePassive: topView controller.	aProject enter: false! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/22/1998 09:41'!deletingProject: aProject	"My project is being deleted.  Delete me as well."	project == aProject ifTrue: [self delete].! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/15/1998 16:21'!enter	"Enter my project."	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	project enter: false.! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/13/1998 12:36'!extent: aPoint	"Set my image form to the given extent."	| newExtent scaleP scale |	((bounds extent = aPoint) and:	 [image depth = Display depth]) ifFalse: [		lastProjectThumbnail			ifNil: [newExtent _ aPoint]			ifNotNil: [				scaleP _ aPoint / lastProjectThumbnail extent.				scale _ scaleP "scaleP x asFloat max: scaleP y asFloat".				newExtent _ (lastProjectThumbnail extent * scale) rounded].		self image: (Form extent: newExtent depth: Display depth).		lastProjectThumbnail _ nil].! !!ProjectViewMorph methodsFor: 'all' stamp: 'di 6/13/1998 11:46'!mouseDown: evt	"Quick hack: use old-fashioned menu."	| menu selection |	menu _ CustomMenu new		add: 'enter' action: #enter;		add: 'jump to project...' action: #jumpToProject.	selection _ (menu build preSelect: #enter) startUpCenteredWithCaption: nil.	selection = #enter ifTrue: [^ self enter].	selection = #jumpToProject ifTrue: [Project jumpToProject. ^ self].! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'sw 7/6/1998 11:27'!newMorphicConstruction	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphicConstruction.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !I am a parser for news files in the format output by the Unix 'rn' program.!!RNInboxFile methodsFor: 'scanning'!nextStringOf: aStream equals: aString	aString do:		[: c | (c == (aStream next) ) ifFalse: [^false]].	^true! !!RNInboxFile methodsFor: 'scanning'!parse: aStream do: aBlock	"Parse the given stream into newsgroup articles, invoking the given block once for each article in the stream. The stream is divided into articles by delimiters that includes the newsgroup name. Ignore text before the first article delimiter."	| done line groupName |	currentNewsgroup _ nil.  "have not found start of article"	msgBuffer _ WriteStream on: (String new: 5000).	done _ false.	[done] whileFalse:		[(aStream atEnd) ifTrue:			["end of stream"			 self endOfArticleDo: aBlock.			 done _ true].		 line _ MailDB readStringLineFrom: aStream.		 groupName _ self startOfArticle: line.		 (groupName notNil) ifTrue:			[self endOfArticleDo: aBlock.			 currentNewsgroup _ groupName.			 line _ MailDB readStringLineFrom: aStream].		 (currentNewsgroup notNil) ifTrue: [self appendLine: line]].! !!RNInboxFile methodsFor: 'scanning'!startOfArticle: aString	"Answer the newsgroup name if the given string is the start of a news article, for example:		Article 2958 of comp.lang.smalltalk:	Otherwise, answer nil."	| s name |	s _ ReadStream on: aString.	(self nextStringOf: s equals: 'Article ') ifFalse: [^nil].	[s next isDigit] whileTrue.	"consumes digits plus the following space"	(self nextStringOf: s equals: 'of ') ifFalse: [^nil].	name _ s through: $:.	((name size > 1) & (s atEnd)) ifFalse: [^nil].	^name copyFrom: 1 to: (name size - 1)! !!RadioButtonInput methodsFor: 'access' stamp: 'ls 8/11/1998 19:52'!valueIfPressed	^value! !!RadioButtonInput methodsFor: 'private-initialization' stamp: 'ls 8/11/1998 20:46'!inputSet: anInputSet  value: aString	inputSet _ anInputSet.	value _ aString.	state _ false.! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 19:51'!pressed	^state! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 19:51'!pressed: aBoolean	state _ aBoolean.	self changed: #pressed.	^true! !!RadioButtonInput methodsFor: 'button state' stamp: 'ls 8/11/1998 20:28'!toggle	"my button has been clicked on!!"	self pressed: self pressed not.	inputSet  buttonToggled: self.	^true! !!RadioButtonInput class methodsFor: 'instance creation' stamp: 'ls 8/11/1998 20:47'!inputSet: anInputSet  value: aString	^self new inputSet: anInputSet  value: aString! !!RadioButtonSetInput methodsFor: 'private-initialization' stamp: 'ls 8/11/1998 20:25'!name: aString	name _ aString.	buttons _ OrderedCollection new.! !!RadioButtonSetInput methodsFor: 'testing' stamp: 'ls 8/11/1998 20:43'!isRadioButtonSetInput	^true! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:48'!addInput: buttonInput	buttons add: buttonInput! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:30'!defaultButton: aButton	"set which button to toggle on after a reset"	defaultButton _ aButton! !!RadioButtonSetInput methodsFor: 'access' stamp: 'ls 8/11/1998 20:24'!name	^name! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:31'!active	"we are active if and only if one of our buttons is pressed"	buttons do: [ :b |		b pressed ifTrue: [ ^true ] ].	^false! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:27'!buttonToggled: aButton	"a button was toggled; turn all other buttons off"	buttons do: [ :b |		b == aButton ifFalse: [			b pressed: false  ] ].! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:30'!reset	buttons do: [ :b |		b pressed: (b == defaultButton) ].! !!RadioButtonSetInput methodsFor: 'input handling' stamp: 'ls 8/11/1998 20:31'!value	buttons do: [ :b |		b pressed ifTrue: [ ^b valueIfPressed ] ].	self error: 'asked for value when inactive!!'.! !!RadioButtonSetInput class methodsFor: 'instance creation' stamp: 'ls 8/11/1998 20:29'!name: aString	^self new name: aString! !!RandomEnvelope methodsFor: 'initialization' stamp: 'jm 8/13/1998 21:25'!initialize	rand _ Random new.	lowLimit _ 0.996.	highLimit _ 1.004.	delta _ 0.0001.	currValue _ 1.0.	scale _ 1.0.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:18'!centerPitch: aNumber	"If this envelope controls pitch, set its scale to the given number. Otherwise, do nothing."	updateSelector = #pitch: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta	^ delta! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!delta: aNumber	delta _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit	^ highLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!highLimit: aNumber	highLimit _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:05'!lowLimit	^ lowLimit! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:06'!lowLimit: aNumber	lowLimit _ aNumber.! !!RandomEnvelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:17'!volume: aNumber	"If this envelope controls volume, set its scale to the given number. Otherwise, do nothing."	updateSelector = #volume: ifTrue: [self scale: aNumber].! !!RandomEnvelope methodsFor: 'applying' stamp: 'jm 8/13/1998 18:25'!updateTargetAt: mSecs	"Send my updateSelector to the given target object with the value of this envelope at the given number of milliseconds from its onset. Answer true if the value changed."	| r |	r _ rand next.	r > 0.5		ifTrue: [			currValue _ currValue + delta.			currValue > highLimit ifTrue: [currValue _ highLimit]]		ifFalse: [			currValue _ currValue - delta.			currValue < lowLimit ifTrue: [currValue _ lowLimit]].	currValue = lastValue ifTrue: [^ false].	((target == nil) or: [updateSelector == nil]) ifTrue: [^ false].	target		perform: updateSelector		with: scale * currValue.	lastValue _ currValue.	^ true! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:29'!duration	^ 1.0! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25'!duration: seconds	"Do nothing."! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:25'!name	^ 'random ', updateSelector! !!RandomEnvelope methodsFor: 'envelope compatibility' stamp: 'jm 8/13/1998 17:30'!sustainEnd: seconds	"Do nothing."! !!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 18:21'!for: aSelector	"Answer a random envelope for the given selector."	^ self new updateSelector: aSelector! !!RandomEnvelope class methodsFor: 'instance creation' stamp: 'jm 8/13/1998 17:09'!new	^ super new initialize! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/26/1998 16:17'!initialize	| m1 m2 |	super initialize.	self typeColor: (TilePadMorph colorForType: #number).	self addArrows.	m1 _ StringMorph contents: 'random' font: ScriptingSystem fontForTiles.	self addMorph: m1.	m2 _ StringMorph contents: '180' font: ScriptingSystem fontForTiles.	m2 position: m1 topRight.	self addMorphBack: m2.	literal _ 180.	self updateLiteralLabel! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/25/1998 17:44'!numericValue	^ super numericValue atRandom! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/25/1998 17:45'!storeCodeOn: aStream indent: tabCount	aStream			nextPut: $(;			nextPutAll: literal printString;			nextPutAll: ' atRandom)'.! !!RandomNumberTile methodsFor: 'all' stamp: 'sw 6/26/1998 16:14'!updateLiteralLabel	|  desiredW leader myLabel myReadout |	(myLabel _ self labelMorph) ifNil: [^ self].	myReadout _ submorphs reversed detect: [:m | m isKindOf: StringMorph].	myReadout contents: literal stringForReadout.	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width + myReadout width + 5.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myReadout position: (self left + (leader + 0)) @ (bounds top + 2); fullBounds.	myLabel position: myReadout topRight + (5@0).	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !I am a parser for news files in the format output by the Unix 'readnews' program.!!ReadNewsInboxFile methodsFor: 'read-write'!readFrom: aStream	"This operation is a noop for news inboxes. Use 'messagesDo:' to enumerate the messages in the inbox."! !!ReadNewsInboxFile methodsFor: 'read-write'!writeOn: aStream	"This operation is illegal for news inboxes."	self error: 'News inboxes are read only!!'! !!ReadNewsInboxFile methodsFor: 'scanning'!allDashes: aString	"Answer true if the given string is not empty and consists entirely of dash characters."	(aString isEmpty) ifTrue: [^false].	aString detect: [: ch | ch ~= $-] ifNone: [^true].	^false	"we must have detected a non-dash"! !!ReadNewsInboxFile methodsFor: 'scanning'!appendLine: aString	"Append the given line to the buffer."	msgBuffer nextPutAll: aString; cr.! !!ReadNewsInboxFile methodsFor: 'scanning'!endOfArticleDo: aBlock	"We've just hit the end of an article. Evaluate the given block on the article we've been accumulating in the buffer (if any) and reset the buffer for the next article."	| msgText end |	"get text and remove trailing separators (blanks, cr's, etc)"	msgText _ msgBuffer contents.	end _ msgText size.	[(end > 0) and: [(msgText at: end) isSeparator]] whileTrue: [end _ end - 1].	(end > 1) ifTrue:		[aBlock value: currentNewsgroup value: (msgText copyFrom: 1 to: end)].	msgBuffer reset.	"reset the buffer for the next message"! !!ReadNewsInboxFile methodsFor: 'scanning'!newsMessagesDo: aBlock	"Invoke the given block for each message in the news inbox file. The block arguments are the newsgroup name and the text of a new message."	| fileStream stream |	fileStream _ FileStream fileNamed: filename.	(fileStream size < 50000)		ifTrue:			["for small inboxes, buffer the entire file in memory for speed"			 stream _ ReadStream on: (fileStream contentsOfEntireFile)]		ifFalse:			["otherwise, use the actual file stream, reading from disk"			 stream _ fileStream].	self parse: stream do: aBlock.	fileStream close.! !!ReadNewsInboxFile methodsFor: 'scanning'!parse: aStream do: aBlock	"Parse the given stream into newsgroup articles, invoking the given block once for each article in the stream. The stream is divided into articles by two kinds of delimiters. The first kind indicates the start of a new newsgroup and includes the newsgroup name. The second kind indicates the start of a new article within a newsgroup."	| done line nextLine |	currentNewsgroup _ 'unknown newsgroup'.	msgBuffer _ WriteStream on: (String new: 5000).	done _ false.	[done] whileFalse:		[(aStream atEnd) ifTrue:			["end of stream"			 self endOfArticleDo: aBlock.			 done _ true].		 line _ MailDB readStringLineFrom: aStream.		 (self allDashes: line) ifTrue:	"leading line of dashes"			["could be a newsgroup header"			 nextLine _ MailDB readStringLineFrom: aStream.			 ((nextLine size >= 10) and:			  [(nextLine copyFrom: 1 to: 10) = 'Newsgroup '])				ifTrue:					["yep, it is a newsgroup header"					 self endOfArticleDo: aBlock.					 self setNewsGroup: nextLine.					 MailDB skipRestOfLine: aStream.	"skip trailing line of dashes"					 MailDB skipRestOfLine: aStream.	"skip blank line"					 MailDB skipRestOfLine: aStream.	"skip next article delimiter"					 line _ MailDB readStringLineFrom: aStream]				ifFalse:					["nope, it's not a newsgroup header"					 self appendLine: line.					 line _ nextLine]].		 (self startOfArticle: line) ifTrue:			[self endOfArticleDo: aBlock.			 line _ MailDB readStringLineFrom: aStream].		 self appendLine: line].	"normal line: append it to the message buffer"! !!ReadNewsInboxFile methodsFor: 'scanning'!setNewsGroup: aLine	"Set the current newsgroup name from the given line of text, which is of the form:		Newsgroup comp.lang.smalltalk"	(aLine size > 11)		ifTrue: [currentNewsgroup _ aLine copyFrom: 11 to: aLine size]		ifFalse: [currentNewsgroup _ 'unknown newsgroup'].! !!ReadNewsInboxFile methodsFor: 'scanning'!startOfArticle: aString	"Answer true if the given string is the start of a new news article. That is, does it start with the string 'Article ' and end with a period?"	^((aString size >= 8) and:	   [((aString copyFrom: 1 to: 8) = 'Article ') & (aString last = $.)])! !!ReadStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:46'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upTo: anObject	"fast version using indexOf:"	| start end |	start _ position+1.	end _ collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position _ end.	^collection copyFrom: start to: (end-1)! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upToEnd	| start |	start _ position+1.	position _ collection size.	^collection copyFrom: start to: position! !!ReadWriteStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:47'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:25'!checkForPreamble: chunk	((chunk beginsWith: '"Change Set:') and: [Smalltalk changes preambleString == nil])		ifTrue: [Smalltalk changes preambleString: chunk].	((chunk beginsWith: '"Postscript:') and: [Smalltalk changes postscriptString == nil])		ifTrue: [Smalltalk changes postscriptString: chunk].							! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:25'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	| val chunk |	'Reading ' , self name		displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				val _ (self peekFor: $!!)					ifTrue: [(Compiler evaluate: self nextChunk logged: false)								scanFrom: self]					ifFalse: [chunk _ self nextChunk.							self checkForPreamble: chunk.							Compiler evaluate: chunk logged: true].				self skipStyleChunk].		self close].	^ val! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:59'!initialFrameFor: aView	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen.  5/22/96 sw"	| allOrigins screenRight screenBottom initialExtent putativeOrigin putativeFrame allowedArea staggerOrigin |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView].	allowedArea _ Display usableArea.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	initialExtent _ aView initialExtent.	allOrigins _ ScheduledControllers windowOriginsInUse.	self standardPositions do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ self standardPositions first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:43'!initialize	"Initialize the class variables in the receiver.  5/22/96 sw"	"RealEstateAgent initialize"	StaggerOffset _ 6 @ 20.	ReverseStaggerOffset _ -6 @ 20.	StaggerOrigin _ 200 @ 30.! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:58'!screenTopSetback	Smalltalk isMorphic		ifTrue: [^ 0]		ifFalse: [^ 18]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:58'!scrollBarSetback	Smalltalk isMorphic		ifTrue: [^ 16-3]  "width = 16; inset from border by 3"		ifFalse: [^ 24]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:00'!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ Display usableArea.	midX _ self scrollBarSetback +   ((anArea width - self scrollBarSetback)  // 2).	midY _ self screenTopSetback + ((anArea height - self screenTopSetback) // 2).	aList _ OrderedCollection with: (self scrollBarSetback @ self screenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ self screenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (self scrollBarSetback @ (midY+self screenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+self screenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:01'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ Display usableArea extent					- (self scrollBarSetback @ self screenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ self scrollBarSetback @ self screenTopSetback						corner: Display usableArea bottomRight.		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: 600@400].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 21:01'!strictlyStaggeredInitialFrameFor: aStandardSystemView	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ self scrollBarSetback @ self screenTopSetback					corner: Display usableArea bottomRight.	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((aStandardSystemView initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:43'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	self addButtonRows.	self addRecordLevelSlider.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 8/17/1998 20:35'!show	"Show my samples in a WaveEditor."	| ed w |	recorder pause.	ed _ WaveEditor new.	ed data: recorder condensedSamples.	ed samplingRate: recorder samplingRate.	w _ self world.	w activeHand		ifNil: [w addMorph: ed]		ifNotNil: [w activeHand attachMorph: ed].! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 7/4/1998 14:49'!addRecordLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: recorder;		actionSelector: #recordLevel:;		adjustToValue: recorder recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed. Answer the receiver if its coordinates are already integral."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 7/12/1998 13:30'!beginInstance: aClass size: anInteger	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.	In ReferenceStream, class is just 5 bytes for shared symbol.	SmartRefStream puts out the names and number of class's instances variables for checking.6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "	| short ref |	short _ true.	"All tests for object header that can be written in 4 bytes"	anInteger <= 254 ifFalse: [short _ false].	"one byte size"	ref _ references at: aClass name ifAbsent: [short _ false. nil].	ref isInteger ifFalse: [short _ false].	short ifTrue: [short _ (ref < 65536) & (ref > 0) "& (ref ~= self vacantRef)"].  "vacantRef is big"	short ifTrue: [		byteStream skip: -1.		short _ byteStream next = 9.		byteStream skip: 0].	"ugly workaround"	short 		ifTrue: ["passed all the tests!!"			byteStream skip: -1; nextPut: 16; "type = short header"				nextPut: anInteger + 1;	"size is short"				nextNumber: 2 put: ref]		ifFalse: [			"default to normal longer object header"			byteStream nextNumber: 4 put: anInteger + 1.			self nextPut: aClass name].! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:38'!reset	"PRIVATE -- Reset my internal state.	   11/15-17/92 jhm: Added transients and fwdRefEnds.	   7/11/93 sw: Give substantial initial sizes to avoid huge time spent growing.	   9/3/93 sw: monster version for Sasha"	super reset.	references _ IdentityDictionary new: 4096 * 5."	objects _ IdentityDictionary new: 4096 * 5.	fwdRefEnds _ IdentityDictionary new."	blockers ifNil: [blockers _ IdentityDictionary new]. ! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:58'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	super setStream: aStream reading: isReading.	"isReading ifFalse: [  when we are sure"	references _ IdentityDictionary new: 4096 * 5.	isReading ifTrue: [		objects _ IdentityDictionary new: 4096 * 5.		fwdRefEnds _ IdentityDictionary new].	blockers ifNil: [blockers _ IdentityDictionary new].	"keep blockers we just passed in"! !!ReferenceStream class methodsFor: 'all' stamp: 'tk 5/26/1998 14:51'!versionCode    "Answer a number representing the 'version' of the ReferenceStream facility; this is stashed at the beginning of ReferenceStreams, as a secondary versioning mechanism (the primary one is the fileTypeCode).   At present, it serves for information only, and is not checked for compatibility at reload time, but could in future be used to branch to variant code. "	" 1 = original version 1992"	" 2 = HyperSqueak.  PathFromHome used for Objs outside the tree.  SqueakSupport SysLibrary for shared globals like Display and StrikeFonts.  File has version number, class structure, then an IncomingObjects manager.  8/16/96 tk.  	Extended to SmartRefStream.  class structure also keeps superclasse chain.  Does analysis on structure to see when translation methods are needed.  Embedable in file-ins.  (factored out HyperSqueak support)  Feb-May 97 tk"	" 3 = Reference objects are byte offsets relative to the start of the object portion of the file.  Rectangles with values -2048 to 2047 are encoded compactly."	" 4 = If UniClasses (subclasses of Player) have class instance variables, append their values in the form (#Class43 (val1 val2 vla3)).  An array of those.  Can still read version 3."	^ 4! !!RemoteHandMorph methodsFor: 'other' stamp: 'di 7/5/1998 21:07'!processEvents	"Process user input events from the remote input devices."	| evt |	evt _ self getNextRemoteEvent.	[evt ~~ nil] whileTrue: [		evt type == #worldExtent ifTrue: [			remoteWorldExtent _ evt cursorPoint.			^ self].		(evt anyButtonPressed and:		 [evt controlKeyPressed and:		 [lastEvent anyButtonPressed not]]) ifTrue:			[eventTransform _ MorphicTransform identity.			lastEvent _ evt.			^ self invokeMetaMenu: evt].		evt blueButtonPressed ifTrue:			[lastEvent blueButtonPressed 				ifTrue: [^ self specialDrag: evt]				ifFalse: [eventTransform _ MorphicTransform identity.						lastEvent _ evt.						^ self specialGesture: evt]].		self handleEvent: evt.		lastEvent _ evt.		evt _ self getNextRemoteEvent]! !Used for creating the right HTML links for Rendered Files!!RenderedSwikiAction methodsFor: 'as yet unclassified' stamp: 'BJP 9/9/199821:35'!pageURL: aPage	"make the url suited to rendered aPage"	^aPage coreID! !This class only exists to provide a different pageURL for the rendered pagesHere's how to set them up:For FTP rendering:| sd auth |sd _ ServerDirectory new.sd directory: '/net/www/fac/mark.guzdial/testSwiki'; server:'cleon.cc.gatech.edu';	user: 'fred'; password: 'flintstone'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.For local rendering:| sd auth |sd _ 'Guz 7600:WebSTAR 2.0:testSwiki:'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.!!RendererSwikiAction methodsFor: 'as yet unclassified' stamp: 'BJP 9/9/199821:35'!pageURL: aPage	"make the url suited to rendered aPage"	^aPage coreID,'.html'! !An authorized Swiki that can generate cached pages with no link back to theSwikiExamples of setting them up:Here's one that renders to an external, FTP-accessible website:| sd auth |sd _ ServerDirectory new.sd directory: '/net/www/fac/mark.guzdial/testSwiki'; server: 'flintstone.com';	user: 'fred'; password: 'flintstone'.RenderingSwikiAction new restore: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.Here's one that renders to a local directory accessible from a webserver:| sd auth |sd _ 'Guz 7600:WebSTAR 2.0:testSwiki:'.RenderingSwikiAction setUp: 'testSwiki'.(PWS actions at: 'testswiki') serverDirectory: sd.auth _ Authorizer new mapName: 'user' password: 'testSwiki' to: 'user'.(PWS actions at: 'testswiki') authorizer: auth.!!RenderingSwikiAction methodsFor: 'accessing' stamp: 'mjg 8/31/1998 14:40'!serverDirectory: anObject	serverDirectory _ anObject. "Should be an instance ofServerDirectory, or a path string."! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg8/31/1998 12:57'!browse: pageRef from: request	"Just reply with a page in HTML format -- use the rendering pagetemplate rpage.html"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'rpage') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file''rpage.html'' not found'].	request reply: htmlForUser.! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg9/23/1998 09:14'!generate: pageRef	"Generate the page to the serverDirectory. Use the render.html page as a template"	| formattedPage renderedFile newmap file|	"Make a copy, then format the text."	formattedPage _ pageRef copy.	newmap _ urlmap copy.		" Create a new action with different action for cached form."	newmap action: (RendererSwikiAction new).	newmap action name: '.'.	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | newmap					linkFor: link					from: 'Nowhere'					storingTo: OrderedCollection new]).	(serverDirectory isKindOf: String)	ifTrue: [ "Just save the file into the directory"		renderedFile _ (serverDirectory),(pageRef coreID),'.html'.		(StandardFileStream isAFileNamed: renderedFile)			ifTrue: [FileDirectory deleteFilePath: renderedFile].		file _ FileStream fileNamed: renderedFile.		file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents: source ,'render.html')								with: formattedPage).		file close.]	ifFalse: [ "Assume it's FTP and send it off"		renderedFile _ (pageRef coreID),'.html'.		(StandardFileStream isAFileNamed: renderedFile)			ifTrue: [FileDirectory deleteFilePath: renderedFile].		file _ FileStream fileNamed: renderedFile.		file nextPutAll: (HTMLformatter evalEmbedded: (self fileContents: source ,'render.html')								with: formattedPage).		file close.		serverDirectory putFile: (FileStream fileNamed: renderedFile) named: renderedFile.		"FileDirectory deleteFilePath: renderedFile"]! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'BJP9/9/1998 21:35'!pageURL: aPage	"make the URL suited to aPage"	^(self name),'.',aPage coreID! !!RenderingSwikiAction methodsFor: 'process and generate' stamp: 'mjg9/9/1998 14:24'!process: request	"Handle requests of the form {swikiname}.{coreRef}.render"	(request message size > 2) ifTrue: [		((request message at: 3) = 'render') ifTrue:		[ self generate: (urlmap atID: (request message at: 2)).		request reply: (PWS success) ; reply: (PWS contentHTML).		^self browse: (urlmap atID: (request message at: 2)) from:request].		((request message at: 3) = 'html') ifTrue: "Handle 1.html refs"		[^self browse: (urlmap atID: (request message at: 2)) from:request]].	super process: request.! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:28'!reset	super reset.	sound reset.	samplesPerIteration _ sound samplesRemaining.	iterationCount == #forever		ifTrue: [iteration _ 1]		ifFalse: [iteration _ iterationCount].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:29'!samplesRemaining	iteration > 0		ifTrue: [^ sound samplesRemaining + ((iteration - 1) * samplesPerIteration)]		ifFalse: [^ 0].! !!RestSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!RestSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:42'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:16'!addFirst: value	"Add value as the first element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values first ~= value])	  ifTrue:		[runs addFirst: 1.		values addFirst: value]	  ifFalse:		[runs at: 1 put: runs first+1]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!addLast: value	"Add value as the last element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs addLast: 1.		values addLast: value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!addLast: value  times: times	"Add value as the last element of the receiver, the given number of times"	times = 0 ifTrue: [ ^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs add: times.		values add: value]	  ifFalse:		[runs at: runs size put: runs last+times]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!repeatLast: times  ifEmpty: defaultBlock	"add the last value back again, the given number of times.  If we are empty, add (defaultBlock value)"	times = 0 ifTrue: [^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:		[runs addLast: times.		values addLast: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+times] ! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!repeatLastIfEmpty: defaultBlock	"add the last value back again.  If we are empty, add (defaultBlock value)"	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:[		 runs addLast: 1.		values addLast: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'copying' stamp: 'ls 8/20/1998 10:56'!copyFrom: start to: stop	| newRuns | 	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:run1 :offset1 :value1 | value1].	self at: stop setRunOffsetAndValue: [:run2 :offset2 :value2 | value2].	run1 = run2		ifTrue: 			[newRuns _ Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns _ runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 10:12'!new	^self runs: OrderedCollection new values: OrderedCollection new! !!RunArray class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 10:12'!new: size withAll: value 	"Answer a new instance of me, whose every element is equal to the	argument, value."	size = 0 ifTrue: [^self new].	^self runs: (OrderedCollection with: size) values: (OrderedCollection with: value)! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/14/1998 10:15'!connectToSMTPServer: serverName	"connect to the given server on the SMTP port"	| addr |	addr _ NetNameResolver addressForName: serverName.	addr == nil ifTrue: [		self error: 'could not resolve host name' ].	Transcript show: 'connecting to ', serverName, '...'.	self connectTo: addr  port: 25.	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [		^false ].	self checkSMTPResponse.	self sendCommand: 'HELO aSqueakSystem'.	self checkSMTPResponse.	^true! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:38'!data: messageData	"send the data of a message"	| cookedLine |	"inform the server we are sending the message data"	self sendCommand: 'DATA'.	self checkSMTPResponse.	"process the data one line at a time"	messageData linesDo:  [ :messageLine |		cookedLine _ messageLine.		(cookedLine beginsWith: '.') ifTrue: [ 			"lines beginning with a dot must have the dot doubled"			cookedLine _ '.', cookedLine ].		self sendCommand: cookedLine ].	"inform the server the entire message text has arrived"	self sendCommand: '.'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:13'!getSMTPResponse	"wait for an SMTP response, and return the number of the response"	| line |	[ line _ self getResponse.	Transcript show: line.	(line at: 4) = $- ] whileTrue.	^(line copyFrom: 1 to: 3) asNumber! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:21'!mailFrom: fromAddress	self sendCommand: 'MAIL FROM: <', fromAddress, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:31'!quit	"send a QUIT command.  This is polite to do, and indeed some servers might drop messages that don't have an associated QUIT"	self sendCommand: 'QUIT'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:20'!recipient: aRecipient	"specify a recipient for the message.  aRecipient should be a bare email address"	self sendCommand: 'RCPT TO: <', aRecipient, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 22:37'!checkSMTPResponse	"get an SMTP response, and check that it's in the 200's or 300's.  If it's not, close the socket and issue an error:"	(#(2 3) includes: self getSMTPResponse // 100) ifFalse: [		self close.		self error: 'server responded with an error' ].! !!SMTPSocket class methodsFor: 'as yet unclassified' stamp: 'ls 9/10/1998 22:32'!deliverMailTo: server from: fromAddress to: recipientList text: messageText	^self notYetImplemented! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:40'!example	"SMTPSocket example"	"send a message over SMTP"	self deliverMailFrom: 'lex@cc.gatech.edu' to: #(root src) text:'From: testTo: "not listed"Subject: this is a testHello from Squeak!!'	usingServer: 'localhost'.! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:36'!example2	"SMTPSocket example2"	"send a message using the low-level protocol methods.  Normally one would just use the high-level class message"	| sock |	sock _ self new.	sock connectToSMTPServer: 'localhost'.	sock mailFrom: 'lex@cc.gatech.edu'.	sock recipient: 'lex@localhost'.	sock recipient: 'root'.	sock data:'From: testTo: "not listed"Subject: this is a testHi, this is a test message.'.	sock quit.	sock close.! !!SMTPSocket class methodsFor: 'sending mail' stamp: 'ls 9/13/1998 02:49'!deliverMailFrom: fromAddress to: recipientList text: messageText usingServer: serverName	"deliver mail to a list of users.  NOTE: the recipient list should be a collection of bare addresses--no '<>' or '()' stuff"	| sock |	Socket initializeNetwork.	sock _ self new.	(sock connectToSMTPServer: serverName)		ifFalse: [ ^false ].	sock mailFrom: fromAddress.	recipientList do: [ :recipient |		sock recipient: recipient ].	sock data: messageText.	sock quit.	sock closeAndDestroy.	^true! !See SameGame>>helpString for an explanation of how to play!!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:39'!buildButton: aButton target: aTarget label: aLabel selector: aSelector	"wrap a button or switch in an alignmentMorph to allow a row of buttons to fill space"	| a |	aButton 		target: aTarget;		label: aLabel;		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 2;		color: color.	a _ AlignmentMorph newColumn		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		color: color.	a addMorph: aButton.	^ a! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 19:36'!initialize	| |	super initialize.	orientation _ #vertical.	centering _ #center.	vResizing _ #shrinkWrap.	hResizing _ #spaceFill.	inset _ 3.	color _ Color lightGray.	self addMorph: self makeControls.	self addMorph: self board.	helpText _ nil.	self newGame.! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:39'!makeControls	| row |	row _ AlignmentMorph newRow		color: color;		borderWidth: 0;		inset: 3.	row hResizing: #spaceFill; vResizing: #shrinkWrap; centering: #center; extent: 5@5.	row addMorph:		(self			buildButton: SimpleSwitchMorph new			target: self			label: 'Help'			selector: #help:).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'Quit'			selector: #delete).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self board			label: 'Hint'			selector: #hint).	row addMorph:		(self			buildButton: SimpleButtonMorph new			target: self			label: 'New game'			selector: #newGame).	selectionDisplay _ LedMorph new		digits: 2;		extent: (2*10@15).	row addMorph: (self wrapPanel: selectionDisplay label: 'Selection:').	scoreDisplay _ LedMorph new		digits: 4;		extent: (4*10@15).	row addMorph: (self wrapPanel: scoreDisplay label: 'Score:').	^ row! !!SameGame methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:40'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	| a |	a _ AlignmentMorph newRow		centering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 0;		inset: 3;		color: color lighter.	a addMorph: anLedPanel.	a addMorph: (StringMorph contents: aLabel). 	^ a! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 18:07'!board	board ifNil:		[board _ SameGameBoard new			target: self;			actionSelector: #selection].	^ board! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 16:19'!board: aSameGameBoard	board _ aSameGameBoard! !!SameGame methodsFor: 'access' stamp: 'tao 5/23/1998 10:32'!helpString^ 'The object of SameGame is to maximize your score by removing tiles from the board.  Tiles are selected and removed by clicking on a tile that has at least one adjacent tile of the same color (where adjacent is defined as up, down, left, or right).The first click selects a group of adjacent tiles, a second click in that group will remove it from the board, sliding tiles down and right to fill the space of the removed group.  If you wish to select a different group, simply click on it instead.The score increases by "(selection - 2) squared", so you want to maximize the selection size as much as possible.  However, making small strategic selections may allow you to increase the size of a later selection.If you are having a hard time finding a group, the "Hint" button will find one and select it for you (although it is likely not the best group to select!!).When there are no more groups available, the score display will flash with your final score.  Your final score is reduced by 1 for each tile remaining on the board.  If you manage to remove all tiles, your final score is increased by a bonus of 5 times the number of tiles on a full board.Come on, you can beat that last score!!  Click "New game"  ;-)SameGame was originally written by Eiji Fukumoto for UNIX and X; this version is based upon the same game concept, but was rewritten from scratch.'! !!SameGame methodsFor: 'access' stamp: 'tao 5/18/1998 19:43'!helpText	helpText ifNil:		[helpText _ PluggableTextMorph new			width: board width;			editString: self helpString].	^ helpText! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 19:45'!help: helpState	helpState		ifTrue: [self addMorphBack: self helpText]		ifFalse: [helpText delete]! !!SameGame methodsFor: 'actions' stamp: 'tao 5/18/1998 18:35'!newGame	scoreDisplay value: 0; flash: false.	selectionDisplay value: 0.	self board resetBoard.! !!SameGame methodsFor: 'actions' stamp: 'tao 5/23/1998 10:51'!selection	"a selection was made on the board; get its count and update the displays"	| count score |	count _ self board selectionCount.	count = 0 ifTrue:		[score _ scoreDisplay value + (selectionDisplay value - 2) squared.		board findSelection ifNil:			[count _ board tilesRemaining.			count = 0				ifTrue: [score _ score + (5 * board rows * board columns)]				ifFalse: [score _ score - count].			scoreDisplay flash: true].		scoreDisplay value: score].	selectionDisplay value: count.! !I am an MxN array of SameGameTiles, and implement most of the logic to play the SameGame, including adjacent tile selection and removal.!!SameGameBoard methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:25'!initialize	super initialize.	target _ nil.	actionSelector _ #selection.	arguments _ #().	hResizing _ #rigid.	vResizing _ #rigid.	borderWidth _ 2.	borderColor _ Color black.	rows _ self preferredRows.	columns _ self preferredColumns.	color _ Color gray.	palette _ (Color wheel: self preferredTileTypes + 1) asOrderedCollection.	flashColor _ palette removeLast.	flash _ false.	self extent: self protoTile extent * (columns @ rows).	self fixLayout.	self resetBoard.! !!SameGameBoard methodsFor: 'initialization' stamp: 'tao 5/17/1998 09:39'!resetBoard	selection _ nil.	self submorphsDo:		[:m |		m disabled: false.		m setSwitchState: false.		m color: palette atRandom]! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredColumns	^ 20! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:24'!preferredRows	^ 10! !!SameGameBoard methodsFor: 'preferences' stamp: 'tao 5/17/1998 09:34'!preferredTileTypes	^ 5! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!actionSelector	^ actionSelector! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 17:00'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector _ nil].	actionSelector _ aSymbolOrString asSymbol.! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!columns	^ columns! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns	self extent: self protoTile extent * (newColumns @ rows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!columns: newColumns rows: newRows	self extent: self protoTile extent * (newColumns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:47'!protoTile	protoTile ifNil: [protoTile _ SameGameTile new].	^ protoTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:48'!protoTile: aTile	protoTile _ aTile! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:45'!rows	^ rows! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/15/1998 12:57'!rows: newRows	self extent: self protoTile extent * (columns @ newRows)! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:56'!selectionCount	^ selection isNil		ifTrue: [0]		ifFalse: [selection size]! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target	^ target! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 16:59'!target: anObject	target _ anObject! !!SameGameBoard methodsFor: 'accessing' stamp: 'tao 5/17/1998 10:31'!tileAt: aPoint	^ submorphs at: (aPoint x + (aPoint y * columns) + 1)! !!SameGameBoard methodsFor: 'geometry' stamp: 'tao 5/18/1998 20:41'!extent: aPoint	"constrain the extent to be a multiple of the protoTile size during resizing"	(bounds extent // protoTile extent) = (aPoint // protoTile extent)		ifFalse:			[self changed.			bounds _ bounds topLeft extent: (aPoint truncateTo: protoTile extent).			self layoutChanged.			self changed]! !!SameGameBoard methodsFor: 'dropping/grabbing' stamp: 'tao 5/15/1998 14:15'!acceptDroppingMorph: aMorph event: evt	"Allow the user to set the protoTile just by dropping it on this morph."	self protoTile: aMorph.	self removeAllMorphs.! !!SameGameBoard methodsFor: 'stepping' stamp: 'tao 5/17/1998 11:38'!step	| newColor |	selection ifNotNil:		[newColor _ flash			ifTrue: [selectionColor]			ifFalse: [flashColor].		selection do: [:loc | (self tileAt: loc) color: newColor].		flash _ flash not]! !!SameGameBoard methodsFor: 'stepping' stamp: 'tao 5/18/1998 11:16'!stepTime	^ 500! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 12:01'!collapseColumn: col fromRow: row	| targetTile sourceTile |	(targetTile _ self tileAt: col@row) disabled ifTrue:		[row - 1 to: 0 by: -1 do:			[:r |			(sourceTile _ self tileAt: col@r) disabled ifFalse:				[targetTile color: sourceTile color.				targetTile disabled: false.				sourceTile disabled: true.				^ true]]].	^ false! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:47'!collapseColumns: columnsToCollapse	| columnsToRemove |	columnsToRemove _ OrderedCollection new.	columnsToCollapse do:		[:c |		rows - 1 to: 0 by: -1 do: [:r | self collapseColumn: c fromRow: r].		(self tileAt: c@(rows-1)) disabled ifTrue: [columnsToRemove add: c]].	self world displayWorld.	columnsToRemove reverseDo: [:c | self removeColumn: c].! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:38'!deselectSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) setSwitchState: false; color: selectionColor].		selection _ nil.		flash _ false]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 18:52'!findSelection	"find a possible selection and return it, or nil if no selection"	| tile k testTile |	0 to: rows-1 do:		[:r |		0 to: columns-1 do:			[:c |			tile _ self tileAt: c@r.			tile disabled  ifFalse:				[k _ tile color.				c+1 < columns ifTrue:					[testTile _ self tileAt: (c+1)@r.					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]].				r+1 < rows ifTrue:					[testTile _ self tileAt: c@(r+1).					(testTile disabled not and: [testTile color = k]) ifTrue: [^ tile]]]]].	 ^ nil			! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 17:57'!hint	"find a possible selection and select it"	| tile |	self deselectSelection.	tile _ self findSelection.	tile ifNotNil: [tile mouseDown: MorphicEvent new]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 15:54'!removeColumn: column	| sourceTile |	column+1 to: columns-1 do:		[:c |		0 to: rows-1 do:			[:r |			sourceTile _ self tileAt: c@r.			(self tileAt: c-1@r)				color: sourceTile color;				disabled: sourceTile disabled]].	0 to: rows-1 do:		[:r | (self tileAt: columns-1@r) disabled: true]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 16:53'!removeSelection	selection ifNotNil:		[selection do: [:loc | (self tileAt: loc) disabled: true; setSwitchState: false].		self collapseColumns: (selection collect: [:loc | loc x]) asSet asSortedCollection.		selection _ nil.		flash _ false.		(target ~~ nil and: [actionSelector ~~ nil])			ifTrue: [target perform: actionSelector withArguments: arguments]]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/17/1998 11:37'!selectTilesAdjacentTo: location	| al at |	{-1@0. 0@-1. 1@0. 0@1} do:		[:offsetPoint |		al _ location + offsetPoint.		((al x between: 0 and: columns - 1) and: [al y between: 0 and: rows - 1]) ifTrue:			[at _ self tileAt: al.			(at color = selectionColor and: [at switchState not and: [at disabled not]]) ifTrue:				[selection add: al.				at setSwitchState: true.				self selectTilesAdjacentTo: al]]]! !!SameGameBoard methodsFor: 'actions' stamp: 'tao 5/18/1998 20:20'!tileClickedAt: location newSelection: isNewSelection	| tile |	isNewSelection		ifTrue:			[self deselectSelection.			tile _ self tileAt: location.			selectionColor _ tile color.			selection _ OrderedCollection with: location.			self selectTilesAdjacentTo: location.			selection size = 1				ifTrue: [self deselectSelection]				ifFalse:					[(target ~~ nil and: [actionSelector ~~ nil])					ifTrue: [target perform: actionSelector withArguments: arguments]]]		ifFalse:			[self removeSelection].! !!SameGameBoard methodsFor: 'private' stamp: 'tao 5/18/1998 20:42'!fixLayout	"add or remove new protoTile submorphs to fill out my new bounds"	| newSubmorphs requiredSubmorphs count r c |	columns _ self width // protoTile width.	rows _ self height // protoTile height.	requiredSubmorphs _ rows * columns.	newSubmorphs _ OrderedCollection new.	r _ 0.	c _ 0.	self submorphCount > requiredSubmorphs		ifTrue: "resized smaller -- delete rows or columns"			[count _ 0.			submorphs do:				[:m | 				count < requiredSubmorphs					ifTrue:						[m position: self position + (protoTile extent * (c @ r)).						m arguments: (Array with: c @ r).						newSubmorphs add: m]					ifFalse: [m privateOwner: nil].				count _ count + 1.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]]		ifFalse: "resized larger -- add rows or columns"			[submorphs do:				[:m |				m position: self position + (self protoTile extent * (c @ r)).				m arguments: (Array with: c @ r).				newSubmorphs add: m.				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]].			1 to: (requiredSubmorphs - self submorphCount) do:				[:m |				newSubmorphs add:					(protoTile copy						position: self position + (self protoTile extent * (c @ r));						actionSelector: #tileClickedAt:newSelection:;						arguments: (Array with: c @ r);						target: self;						privateOwner: self).				c _ c + 1.				c >= columns ifTrue: [c _ 0. r _ r + 1]]].	submorphs _ newSubmorphs asArray.! !!SameGameBoard methodsFor: 'private' stamp: 'di 7/1/1998 00:04'!tilesRemaining	^ (submorphs reject: [:m | m disabled]) size! !I am a single tile for the SameGame.  I act much like a switch.!!SameGameTile methodsFor: 'initialization' stamp: 'tao 5/17/1998 09:59'!initialize	super initialize.	self label: ''.	self borderWidth: 2.	bounds _ 0@0 corner: 16@16.	offColor _ Color gray.	onColor _ Color gray.	switchState _ false.	oldSwitchState _ false.	disabled _ false.	! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/18/1998 20:51'!color: aColor	color _ aColor.	onColor _ aColor.	offColor _ aColor.	self changed.! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 08:46'!disabled	^ disabled! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!disabled: aBoolean	disabled _ aBoolean.	disabled		ifTrue:			[self color: owner color.			self borderColor: owner color]		ifFalse:			[self setSwitchState: self switchState]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:21'!setSwitchState: aBoolean	switchState _ aBoolean.	disabled ifFalse:		[switchState			ifTrue:				[self borderColor: #inset.				self color: onColor]			ifFalse:				[self borderColor: #raised.				self color: offColor]]! !!SameGameTile methodsFor: 'accessing' stamp: 'tao 5/15/1998 09:19'!switchState	^ switchState! !!SameGameTile methodsFor: 'drawing' stamp: 'tao 5/15/1998 12:31'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color *and* the inset border color are generated	from the receiver's own color, instead of having the inset border color	generated from the owner's color, as in BorderedMorph."	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color lighter			bottomRightColor: color darker].	borderColor == #inset ifTrue: [		^ aCanvas frameAndFillRectangle: bounds			fillColor: color			borderWidth: borderWidth			topLeftColor: color darker			bottomRightColor: color lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: color		borderWidth: borderWidth		borderColor: borderColor.! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/17/1998 09:53'!doButtonAction	"Perform the action of this button. The last argument of the message sent to the target is the new state of this switch."	(target ~~ nil and: [actionSelector ~~ nil]) ifTrue: [		target			perform: actionSelector			withArguments: (arguments copyWith: switchState)].! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:43'!mouseDown: evt	disabled ifFalse:		[oldSwitchState _ switchState.		self setSwitchState: (oldSwitchState = false).		self doButtonAction].! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:43'!mouseMove: evt	"don't do anything, here"! !!SameGameTile methodsFor: 'events' stamp: 'tao 5/18/1998 17:42'!mouseUp: evt	"don't do anything, here"! !I represent a collection of individual notes at different pitches, volumes, and articulations. On request, I can select the best note to use for a given pitch, duration, and volume. I currently only support two volumes, loud and soft, and two articulations, normal and staccato, but I can easily be extended to include more. The main barrier to keeping more variations is simply the memory space (assuming my component notes are sampled sounds).!!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:30'!allSampleSets: sortedNotes	| keyMap |	keyMap _ self midiKeyMapFor: sortedNotes.	sustainedSoft _ keyMap.	sustainedLoud _ keyMap.	staccatoSoft _ keyMap.	staccatoLoud _ keyMap.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 19:04'!initialize	sustainedThreshold _ 0.15.	loudThreshold _ 0.5.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!loudThreshold	^ loudThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!loudThreshold: aNumber	loudThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:02'!staccatoLoudAndSoftSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.	staccatoSoft _ staccatoLoud.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoLoudSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoSoftSampleSet: sortedNotes	staccatoSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedLoudSampleSet: sortedNotes	sustainedLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedSoftSampleSet: sortedNotes	sustainedSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!sustainedThreshold	^ sustainedThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!sustainedThreshold: aNumber	sustainedThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 18:53'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	| keymap note |	l >= loudThreshold		ifTrue: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedLoud]				ifFalse: [keymap _ staccatoLoud]]		ifFalse: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedSoft]				ifFalse: [keymap _ staccatoSoft]].	keymap ifNil: [keymap _ sustainedLoud].	note _ (keymap at: midiKey) copy.	^ note		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: (l * note gain)! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 16:53'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	"Note:  Generally, SampledInstruments are expected to be played via MIDI key numbers rather than by pitches, since finding the MIDI key for a given pitch is expensive."	^ self soundForMidiKey: (AbstractSound midiKeyForPitch: pitchNameOrNumber)		dur: d		loudness: l! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 12:39'!allNotes	"Answer a collection containing of all the unique sampled sounds used by this instrument."	| r |	r _ IdentitySet new.	r addAll: sustainedLoud.	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].	^ (r asSortedCollection: [:n1 :n2 | n1 pitch < n2 pitch]) asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 12:55'!chooseSamplesForPitch: pitchInHz from: sortedNotes	"From the given collection of LoopedSampledSounds, choose the best one to be pitch-shifted to produce the given pitch."	"Assume: the given collection is sorted in ascending pitch order."	| i lower higher |	i _ 1.	[(i < sortedNotes size) and: [(sortedNotes at: i) pitch < pitchInHz]]		whileTrue: [i _ i + 1].	i = 1 ifTrue: [^ sortedNotes at: 1].	lower _ sortedNotes at: i - 1.	higher _ sortedNotes at: i.	"note: give slight preference for down-shifting a higher-pitched sample set"	(pitchInHz / lower pitch) < ((0.95 * higher pitch) / pitchInHz)		ifTrue: [^ lower]		ifFalse: [^ higher].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 9/8/1998 16:24'!memorySpace	"Answer the number of bytes required to store the samples for this instrument."	| total |	total _ 0.	self allNotes do: [:n |		total _ total + (n leftSamples monoSampleCount * 2).		n isStereo ifTrue: [total _ total + (n leftSamples monoSampleCount * 2)]].	^ total! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 16:42'!midiKeyMapFor: sortedNotes	"Return a 128 element array that maps each MIDI key number to the sampled note from the given set with the closests pitch. A precise match isn't necessary because the selected note will be pitch shifted to play at the correct pitch."	^ (0 to: 127) collect: [:k |		self			chooseSamplesForPitch: (AbstractSound pitchForMIDIKey: k)			from: sortedNotes].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/18/1998 10:57'!playChromaticRunFrom: startPitch to: endPitch	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 15:52'!pruneNoteList: aNoteList notesPerOctave: notesPerOctave	"Return a pruned version of the given note list with only the given number of notes per octave. Assume the given notelist is in sorted order."	| r interval lastPitch |	r _ OrderedCollection new: aNoteList size.	interval _ (2.0 raisedTo: (1.0 / notesPerOctave)) * 0.995.	lastPitch _ 0.0.	aNoteList do: [:n |		n pitch > (lastPitch * interval) ifTrue: [			r addLast: n.			lastPitch _ n pitch]].	^ r! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/6/1998 00:39'!pruneToNotesPerOctave: notesPerOctave	"Prune all my keymaps to the given number of notes per octave."	sustainedLoud _ self midiKeyMapFor:		(self pruneNoteList: sustainedLoud notesPerOctave: notesPerOctave).	sustainedSoft _ self midiKeyMapFor:		(self pruneNoteList: sustainedSoft notesPerOctave: notesPerOctave).	staccatoLoud _ self midiKeyMapFor:		(self pruneNoteList: staccatoLoud notesPerOctave: notesPerOctave).	staccatoSoft _ self midiKeyMapFor:		(self pruneNoteList: staccatoSoft notesPerOctave: notesPerOctave).! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 14:44'!pruneToSingleNote: aNote	"Fill all my keymaps with the given note."	| oneNoteMap |	oneNoteMap _ Array new: 128 withAll: aNote.	sustainedLoud _ oneNoteMap.	sustainedSoft _ oneNoteMap.	staccatoLoud _ oneNoteMap.	staccatoSoft _ oneNoteMap.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 18:22'!readSampleSetFrom: dirName	"Answer a collection of sounds read from AIFF files in the given directory and sorted in ascending pitch order."	| all dir fullName snd |	all _ SortedCollection sortBlock: [:s1 :s2 | s1 pitch < s2 pitch].	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		Utilities			informUser: 'Reading AIFF file ', n			during:				[snd _ LoopedSampledSound new					fromAIFFFileNamed: fullName					mergeIfStereo: true].		all add: snd].	^ all asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 20:32'!readSampleSetInfoFrom: dirName	"MessageTally spyOn: [SampledInstrument new readSampleSetFrom: 'Tosh:Desktop Folder:AAA Squeak2.0 Beta:Organ Samples:Flute8'] timeToRun"	| all dir fullName info |	all _ OrderedCollection new.	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		info _ AIFFFileReader new readFromFile: fullName			mergeIfStereo: false			skipDataChunk: true.		all add: n -> info].	^ all! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 17:15'!tempTest	(AbstractSound bachFugueVoice1On: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 23:13'!testAtPitch: aPitch	"SampledInstrument testAtPitch: 'c4'"	| pattern |	pattern _ (#(		(c4 0.64 100) 		(c4 0.64 200) 		(c4 0.64 400) 		(c4 0.64 600) 		(c4 0.64 800) 		(c4 1.28 1000) 		(c4 1.28 400) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.64 500))			collect: [:triple | triple copy at: 1 put: aPitch; yourself]).	(AbstractSound noteSequenceOn: self from: pattern) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 15:16'!trimAttackOf: sampleBuffer threshold: threshold	"Trim 'silence' off the initial attacks of the given sound buffer."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 11:07'!trimAttacks: threshold	"Trim 'silence' off the initial attacks all my samples."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:27'!new	^ super new initialize! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readLoudAndStaccatoInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readLoudAndStaccatoInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter loud short snd |	sampleSetDir _ orchestraDir, ':', instName.	memBefore _ Smalltalk garbageCollect.	loud _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' f'.	short _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' stacc'.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f&stacc' put:		(snd _ SampledInstrument new			allSampleSets: loud;			staccatoLoudAndSoftSampleSet: short).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 500)].	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new			allSampleSets: loud).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 1000)].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readPizzInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readPizzInstrument: 'violin'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' pizz'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-pizz' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 18:06'!readSimpleInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readSimpleInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' f'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:10'!setPitch: pitchNameOrNumber dur: d loudness: vol	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"	| p |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	samples _ DefaultSampleTable.	samplesSize _ samples size.	initialCount _ (d * self samplingRate asFloat) rounded.	originalSamplingRate _		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self setLoudness: vol.	self reset.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:39'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!SampledSound methodsFor: 'playing' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !a basic web browser.It downloads things in a background thread; the background thread puts downloaded objects onto downloadQueue as they arrive.  The queue is checked in the step method.A custom start page is provided for.  It's not as convenient as bookmarks are, but it does have a lot of flexibility--the user can put anything on the start page that is desired.There is a hook for displaying the "lint" of a page; currently it's not a very effective linter.!!Scamper methodsFor: 'not yet categorized' stamp: 'ls 9/14/1998 20:15'!doItContext	^nil! !!Scamper methodsFor: 'not yet categorized' stamp: 'ls 9/14/1998 20:15'!doItReceiver	^nil! !!Scamper methodsFor: 'not yet categorized' stamp: 'ls 7/29/1998 03:28'!release	self stopEverything.	super release.! !!Scamper methodsFor: 'lint' stamp: 'ls 8/1/1998 03:10'!hasLint	"whether the current page has any questionable HTML in it"	document ifNil: [ ^false ].	^document lint ~= ''! !!Scamper methodsFor: 'lint' stamp: 'ls 9/14/1998 20:38'!lint	"return a string describing any questionable HTML that was noticed in the current page"	"(not currently very comprehensive)"	document ifNil: [ ^'' ].	^document lint! !!Scamper methodsFor: 'lint' stamp: 'ls 7/29/1998 00:07'!showLint	(StringHolder new contents: self lint) openLabel: 'lint for ', self currentUrl printString.! !!Scamper methodsFor: 'testing' stamp: 'ls 7/14/1998 21:44'!isWebBrowser	^true! !!Scamper methodsFor: 'menus' stamp: 'ls 8/12/1998 01:43'!displayHistory	"let the user selecet a previous page to view"	| menu |	menu _ MenuMorph entitled: 'Recent URLs'.	menu defaultTarget: self.	menu addStayUpItem.	menu addLine.	recentDocuments reverseDo: [ :doc |		menu add: doc url toText selector: #displayDocument: argument: doc ].	menu popUpAt: Sensor mousePoint  forHand: World primaryHand! !!Scamper methodsFor: 'menus' stamp: 'ls 8/8/1998 03:59'!editStartPage	| win textMorph |	World ifNil: [ self error: 'only works for morphic currently' ].	win _ SystemWindow labelled: 'edit Bookmark page'.	textMorph _ PluggableTextMorph on: self text: #startPage  accept: #startPage:.	win addMorph: textMorph frame: (0@0 extent: 1@1).	win openInWorld.	^true! !!Scamper methodsFor: 'menus' stamp: 'ls 7/14/1998 17:54'!inspectParseTree	"inspect a parse tree of the current page's source"	document ifNotNil: [ document inspect ]! !!Scamper methodsFor: 'menus' stamp: 'ls 9/7/1998 07:48'!menu: menu  shifted: shifted	| lines selections linePositions |	lines _ 'new URLhistoryview sourceinspect parse treego to start pageedit start page'.	linePositions _ #(2 4).	selections _ #(jumpToNewUrl displayHistory viewSource inspectParseTree visitStartPage editStartPage ).	downloadingProcess ifNotNil: [ 		lines _ lines, String cr, 'stop downloading'.		linePositions _ linePositions, selections size.		selections _ selections, #(stopEverything) ].	menu labels: lines lines: linePositions selections: selections.	^menu.! !!Scamper methodsFor: 'menus' stamp: 'ls 7/14/1998 02:28'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!Scamper methodsFor: 'menus' stamp: 'ls 7/27/1998 23:16'!viewSource	"view the source HTML of this page"	(StringHolder new contents: (pageSource withSqueakLineEndings)) openLabel: 'source for ',currentUrl printString.! !!Scamper methodsFor: 'menus' stamp: 'ls 8/12/1998 02:01'!visitStartPage	self jumpToAbsoluteUrl: 'browser:start'.	^true! !!Scamper methodsFor: 'changing page' stamp: 'di 9/23/1998 11:46'!displayDocument: mimeDocument	"switch to viewing the given MIMEDocument"	| newUrl  newSource handled  formatter fileName file image imageMorph attrib text |	newUrl _ mimeDocument url.	newSource _ mimeDocument.	handled _ false.	"add it to the history"	recentDocuments removeAllSuchThat: [ :d | d url = mimeDocument url ].	recentDocuments addLast: mimeDocument.	recentDocuments size > 20 ifTrue: [ recentDocuments removeFirst ].			newSource mainType = 'image' ifTrue: [		"an image--embed it in a text"		document _ nil.		formattedPage _ [			image _ ImageReadWriter formFromStream: (RWBinaryOrTextStream with: newSource content) binary reset.			imageMorph _ ImageMorph new image: image.			attrib _ TextAnchor new anchoredMorph: imageMorph.			text _ ' * ' asText.			text addAttribute: attrib from: 2 to: 2.			text		] ifError: [ :msg :ctx | msg ].		currentUrl _ newUrl.		pageSource _ newSource content.		handled _ true. 		self status: 'sittin'.		self changed: #currentUrl.			self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.		self changed: #formattedPageSelection.  		"remove it from the history--these thigns are too big!!"		"ideally, there would be a smarter history mechanism that can do things like remove items when memory consumption gets too high...."		recentDocuments removeLast.	].	newSource contentType = 'text/html' ifTrue: [		"HTML page--format it"		currentUrl _ newUrl.		pageSource _ newSource content.		self status: 'parsing...'.		document _ (HtmlParser parse: (ReadStream on: pageSource)).		self status: 'laying out...'.		formatter _ HtmlFormatter new.		formatter browser: self.		formatter baseUrl: currentUrl.		document addToFormatter: formatter.		formattedPage _ formatter text.		currentUrl fragment			ifNil: [ currentAnchorLocation _ nil ]			ifNotNil: [ currentAnchorLocation _				formatter anchorLocations 					at: currentUrl fragment asLowercase					ifAbsent: [ nil ] ].		self startDownloadingMorphState: (formatter incompleteMorphs).		handled _ true.		self status: 'sittin'.		self changed: #currentUrl.			self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.		self changed: #formattedPageSelection.  ].	(#('audio/midi' 'audio/x-midi') includes: newSource contentType) ifTrue: [		Smalltalk at: #MIDIFileReader ifPresent:			[:reader |			reader playStream: (RWBinaryOrTextStream with: newSource content) reset binary.			self status: 'sittin'.			handled _ true]].	(handled not and: [ newSource mainType = 'text']) ifTrue: [		"treat as plain text"		pageSource _ newSource content.		document _ nil.		formattedPage _ pageSource withSqueakLineEndings.		currentUrl _ newUrl.				self status: 'sittin'.		self changed: #currentUrl.		self changed: #title.		self changed: #hasLint.		self changed: #lint.		self changed: #formattedPage.  		handled _ true].	handled ifFalse: [		"offer to save it to a file"		self status: 'sittin'.		(self confirm: 'unkown content-type ', newSource contentType,'--Would you like to save to a file?') ifFalse: [			^self ].		fileName _ ''.		[			fileName _ FillInTheBlank request: 'file to save in' initialAnswer: fileName.			fileName isEmpty ifTrue: [ ^self ].			file _ FileStream fileNamed: fileName.			file == nil		] whileTrue.		file reset.		file binary.		file nextPutAll: newSource content.		file close.	].! !!Scamper methodsFor: 'changing page' stamp: 'ls 9/13/1998 07:14'!jumpToAbsoluteUrl: urlText	"start downloading a new page.  The page source is downloaded in a background thread"	|  newUrl newSource |	self stopEverything.	"get the new url"	newUrl _ urlText asUrl.	"if it fundamentally doesn't fit the pages-and-contents model used internally, spawn off an external viewer for it"	newUrl hasContents ifFalse: [ newUrl activate.  ^true ].	"fork a Process to do the actual downloading, parsing, and formatting.  It's results will be picked up in #step"	self status: 'downloading ', newUrl toText, '...'.	downloadingProcess _ [ 	  	newSource _ [ newUrl retrieveContentsForBrowser: self ] ifError: [ :msg :ctx |			MIMEDocument contentType: 'text/plain' content: msg ].		newSource 			ifNil: [ newSource _ MIMEDocument contentType: 'text/plain' content: 'Error retrieving this URL' ].			newSource url ifNil: [				newSource _ MIMEDocument contentType: newSource contentType  content: newSource content  url: newUrl ].			documentQueue nextPut: newSource.			downloadingProcess _ nil.	] newProcess.	downloadingProcess resume.	^true! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/20/1998 08:56'!jumpToNewUrl	"change to a new, user-specified page"	| newUrl |	newUrl _ FillInTheBlank request: 'url to visit' initialAnswer: currentUrl toText.	(newUrl isNil or: [ newUrl isEmpty ]) ifTrue: [ ^self ].	self jumpToAbsoluteUrl: newUrl! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/20/1998 11:22'!jumpToUrl: urlText	"start downloading a new page.  The page source is downloaded in a background thread"	self jumpToAbsoluteUrl: (urlText asUrlRelativeTo: currentUrl)! !!Scamper methodsFor: 'changing page' stamp: 'ls 9/5/1998 18:12'!startDownloadingMorphState: morphs	downloadingProcess _ [		morphs do: [ :m | m downloadState ].	] newProcess.	downloadingProcess resume.! !!Scamper methodsFor: 'changing page' stamp: 'ls 8/12/1998 00:56'!startDownloadingStateIn: aDocument  url: aUrl	"download the state for the given document in a background thread.  signal the foreground when the data has arrived"	downloadingProcess _ [			aDocument allSubentitiesDo: [ :e |			e downloadState: aUrl ].		documentQueue nextPut: #stateDownloaded.		downloadingProcess _ nil. ] newProcess.	downloadingProcess resume.! !!Scamper methodsFor: 'changing page' stamp: 'ls 7/24/1998 01:28'!stopEverything	"stop all background threads and empty queues for communicating with them; bring this Scamper to a sane state before embarking on something new"		downloadingProcess ifNotNil: [		downloadingProcess terminate.		downloadingProcess _ nil. ].	[ documentQueue isEmpty ] whileFalse: [ documentQueue next ].	self status: 'sittin'.! !!Scamper methodsFor: 'changing page' stamp: 'tk 9/22/1998 20:26'!submitFormWithInputs: inputs  url: url  method: method	| newUrl newSource | 	self stopEverything.	(method asLowercase ~= 'get' and: [ method asLowercase ~= 'post' ]) ifTrue: [		self notify: 'unkown FORM method: ', method.		^false ].	newUrl _ url asUrlRelativeTo: currentUrl.		newUrl schemeName ~= 'http' ifTrue: [		self notify: 'I can only submit forms via HTTP'.		^false ].	self status: 'submitting form...'.	downloadingProcess _ [			method asLowercase = 'get' 				ifTrue: [newSource _ newUrl retrieveContentsArgs: inputs] 				ifFalse: [newSource _ newUrl postFormArgs: inputs].			documentQueue nextPut:  newSource.			downloadingProcess _ nil.		] newProcess.		downloadingProcess resume.		^true! !!Scamper methodsFor: 'access' stamp: 'ls 7/14/1998 03:18'!currentUrl	^currentUrl! !!Scamper methodsFor: 'access' stamp: 'ls 7/14/1998 02:47'!document	"return the current parsed HTML document, or nil if we aren't viewing a page"	^document! !!Scamper methodsFor: 'access' stamp: 'ls 7/21/1998 01:16'!formattedPage	"format the current page and return it as a Text" 	^formattedPage ifNil: [ ^Text new ].	! !!Scamper methodsFor: 'access' stamp: 'ls 9/10/1998 03:38'!formattedPageSelection	currentAnchorLocation ifNil: [ ^0 to: -1 ].	^currentAnchorLocation to: currentAnchorLocation! !!Scamper methodsFor: 'access' stamp: 'ls 8/1/1998 03:10'!title	"return the title of the current page, or nil if there is none"	document == nil		ifTrue: [ ^nil ]		ifFalse: [ ^self document head title ifNil: ['(untitled)'] ]! !!Scamper methodsFor: 'stepping' stamp: 'ls 8/12/1998 01:39'!step	"check if a new document has arrived"	| results |	[documentQueue isEmpty] whileFalse: [		results _ documentQueue next.		results == #stateDownloaded ifTrue: [ 			"images and such have been downloaded; update the page"			self status: 'reformatting page...'.			formattedPage _ document formattedTextForBrowser: self defaultBaseUrl: currentUrl.			self changed: #formattedPage.			self status: 'sittin'. ]		 ifFalse: [					self displayDocument: results 			] ]! !!Scamper methodsFor: 'initialization' stamp: 'ls 8/12/1998 01:21'!initialize	documentQueue _ SharedQueue new.	recentDocuments _ OrderedCollection new.	currentUrl _ 'http://minnow.cc.gatech.edu/squeak.1' asUrl.	pageSource _ ''.	document _ HtmlParser parse: (ReadStream on: '').	self status: 'sittin'.	self jumpToUrl: currentUrl.! !!Scamper methodsFor: 'browser urls' stamp: 'ls 8/12/1998 01:23'!browserUrlContents: aRequest	aRequest = 'start' ifTrue: [ 		^MIMEDocument contentType: 'text/html' content: self startPage ].	^ nil! !!Scamper methodsFor: 'status' stamp: 'ls 7/16/1998 22:18'!status	^status! !!Scamper methodsFor: 'status' stamp: 'ls 7/16/1998 22:18'!status: aSymbol	status _ aSymbol.	self changed: #status.! !!Scamper methodsFor: 'start page' stamp: 'ls 8/8/1998 04:01'!startPage	"return the contents of the user's personal start page"	| file |	file _ FileStream oldFileOrNoneNamed: 'StartPage.html'.	file 		ifNil: [ ^'<title>Personal Start Page</title>\<h1>Personal Start Page</h1>\This space is empty' withCRs ]		ifNotNil: [ ^file contentsOfEntireFile ]! !!Scamper methodsFor: 'start page' stamp: 'ls 8/8/1998 04:02'!startPage: newPage	"fill in the contents of the user's personal start page"	| file |	FileDirectory default deleteFileNamed: 'StartPage.html'.	file _ FileStream fileNamed: 'StartPage.html'.	file ifNil: [ self error: 'could not save file' ].	file nextPutAll: newPage asString.	file close.		self changed: #startPage.	^true! !!Scamper methodsFor: 'user interface' stamp: 'ls 9/18/1998 06:43'!openAsMorph	"open a set of windows for viewing this browser"	|win urlMorph |	"create a window for it"	win _ SystemWindow labelled: 'Scamper'.	win model: self.	win setProperty: #webBrowserView toValue: true.	"create a title view"	win addMorph: (PluggableTextMorph on: self text: #title accept: nil) frame: (0.0@0 extent: 1@0.1).	"create a view of the current url"	"win addMorph: (RectangleMorph new) frame: (0@0.1 extent: 0.3@0.1)."	urlMorph _  PluggableTextMorph on: self text: #currentUrl accept: #jumpToAbsoluteUrl:.	urlMorph acceptOnCR: true.	win addMorph: urlMorph frame: (0@0.1 extent: 1@0.1).	"create a status view"	win addMorph: (PluggableTextMorph on: self text: #status accept: nil) frame: (0@0.9 extent: 1.0@0.1).	"create the text area"	win addMorph: (PluggableTextMorph on: self text: #formattedPage accept: nil readSelection: #formattedPageSelection menu: #menu:shifted:)		frame: (0@0.2 extent: 1@0.7).		win openInWorld.	^win! !!Scamper class methodsFor: 'instance creation' stamp: 'ls 7/17/1998 23:02'!new	^super new initialize! !!Scamper class methodsFor: 'instance creation' stamp: 'ls 9/14/1998 23:21'!openAsMorph	"Scamper openAsMorph"	^self new openAsMorph! !!Scamper class methodsFor: 'initialization' stamp: 'ls 8/5/1998 21:42'!StartUrl: aUrl	"specify the URL to start from"	StartUrl _ aUrl asUrl.! !!Scamper class methodsFor: 'initialization' stamp: 'ls 8/5/1998 21:42'!initialize	self StartUrl: 'http://minnow.cc.gatech.edu/squeak'.  "the Squeak home page"! !This is a real-time player for MIDI scores (i.e., scores read from MIDI files). Score can be played using either the internal sound synthesis or an external MIDI synthesizer on platforms that support MIDI output.!!ScorePlayer methodsFor: 'initialization' stamp: 'jm 7/4/1998 08:38'!initialize	super initialize.	score _ MIDIScore new initialize.	instruments _ Array new.	overallVolume _ 0.5.	leftVols _ Array new.	rightVols _ Array new.	muted _ Array new.	rate _ 1.0.	repeat _ false.! !!ScorePlayer methodsFor: 'initialization' stamp: 'jm 7/4/1998 09:54'!onScore: aMIDIScore	| trackCount totalVol incr curr pan |	score _ aMIDIScore.	trackCount _ score tracks size.	instruments _ (1 to: trackCount) collect: [:i | FMSound oboe1].	leftVols _ Array new: trackCount.	rightVols _ Array new: trackCount.	muted  _ Array new: trackCount withAll: false.	rate _ 1.0.	repeat _ false.	tempo _ 120.0.	trackCount = 0 ifTrue: [^ self].	1 to: trackCount do: [:i |		leftVols at: i put: ScaleFactor // 4.		rightVols at: i put: ScaleFactor // 4].	"distribute inital panning of tracks left-to-right"	totalVol _ 1.0.	incr _ totalVol / (((trackCount // 2) + 1) * 2).	curr _ 0.	1 to: trackCount do: [:t |		t even			ifTrue: [pan _ curr]			ifFalse: [				curr _ curr + incr.				pan _ totalVol - curr].		self panForTrack: t put: pan].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:07'!doControl	super doControl.	1 to: activeSounds size do: [:i | (activeSounds at: i) first doControl].	ticksSinceStart _ ticksSinceStart + ticksClockIncr.	self processAllAtTick: ticksSinceStart asInteger.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!isDone	| track |	activeSounds size > 0 ifTrue: [^ false].	activeMIDINotes size > 0 ifTrue: [^ false].	1 to: score tracks size do: [:i |		track _ score tracks at: i.		(trackEventIndex at: i) <= track size ifTrue: [^ false]].	^ true! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 8/5/1998 23:07'!isPlaying	^ SoundPlayer isPlaying: self! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 7/4/1998 08:21'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| myLeftVol myRightVol someSoundIsDone pair snd trk left right |	myLeftVol _ (leftVol * overallVolume) asInteger.	myRightVol _ (rightVol * overallVolume) asInteger.	someSoundIsDone _ false.	1 to: activeSounds size do: [:i |		pair _ activeSounds at: i.		snd _ pair at: 1.		trk _ pair at: 2.		left _ (myLeftVol * (leftVols at: trk)) // ScaleFactor.		right _ (myRightVol * (rightVols at: trk)) // ScaleFactor.		snd samplesRemaining > 0			ifTrue: [				snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]			ifFalse: [someSoundIsDone _ true]].	someSoundIsDone ifTrue: [		activeSounds _ activeSounds select: [:p | p first samplesRemaining > 0]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:06'!processAllAtTick: scoreTick	self processTempoMapAtTick: scoreTick.	midiPort		ifNil: [self processNoteEventsAtTick: scoreTick]		ifNotNil: [self processMIDIEventsAtTick: scoreTick].	self processAmbientEventsAtTick: scoreTick.	self isDone ifTrue: [		repeat			ifTrue: [self reset]			ifFalse: [done _ true]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:50'!processAmbientEventsAtTick: scoreTick	"Process ambient events through the given tick."	| i evt |	i _ trackEventIndex at: trackEventIndex size.	[evt _ score ambientEventAfter: i ticks: scoreTick.	 evt ~~ nil] whileTrue: [		i _ i + 1.		evt occurAtTime: scoreTick inScorePlayer: self atIndex: i inEventTrack: score ambientTrack secsPerTick: secsPerTick].	trackEventIndex at: trackEventIndex size put: i.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:49'!processNoteEventsAtTick: scoreTick	"Process note events through the given score tick using internal Squeak sound synthesis."	| instr j evt snd |	1 to: score tracks size do: [:i |		instr _ instruments at: i.		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			(evt isNoteEvent and: [(muted at: i) not]) ifTrue: [				snd _ instr					soundForMidiKey: evt midiKey					dur: secsPerTick * evt duration					loudness: evt velocity asFloat / 127.0.				activeSounds add: (Array with: snd with: i)].			j _ j + 1.			trackEventIndex at: i put: j]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:51'!processTempoMapAtTick: scoreTick	"Process tempo changes through the given score tick."	| map |	map _ score tempoMap.	map ifNil: [^ self].	[(tempoMapIndex <= map size) and:	 [(map at: tempoMapIndex) time <= scoreTick]] whileTrue: [		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex) tempo)) roundTo: 0.01.		self tempoOrRateChanged.		tempoMapIndex _ tempoMapIndex + 1].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	"one index for each sound track, plus one for the ambient track..."	trackEventIndex _ Array new: score tracks size+1 withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.	activeMIDINotes _ OrderedCollection new.	score resetFrom: self.	overallVolume ifNil: [overallVolume _ 0.5].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/21/1998 17:55'!closeMIDIPort	"Close my MIDI port, if it is open. Music will be played using the built-in sound synthesis."	self pause.	midiPort ifNil: [^ self].	midiPort close.	midiPort _ nil.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 21:37'!midiPlayLoop	| mSecsPerStep tStart mSecs |	mSecsPerStep _ 10.	[done] whileFalse: [		tStart _ Time millisecondClockValue.		self processAllAtTick: ticksSinceStart asInteger.		(Delay forMilliseconds: mSecsPerStep) wait.		mSecs _ Time millisecondClockValue - tStart.		mSecs < 0 ifTrue: [mSecs _ mSecsPerStep].  "clock wrap"		ticksSinceStart _ ticksSinceStart + (mSecs asFloat / (1000.0 * secsPerTick))].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/21/1998 17:55'!openMIDIPort: portNum	"Open the given MIDI port. Music will be played as MIDI commands to the given MIDI port."	self closeMIDIPort.	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 18:31'!processMIDIEventsAtTick: scoreTick	"Process note events through the given score tick using MIDI."	| j evt |	1 to: score tracks size do: [:i |		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			evt isNoteEvent				ifTrue: [					(muted at: i) ifFalse: [						evt startNoteOnMidiPort: midiPort.						activeMIDINotes add: (Array with: evt with: i)]]				ifFalse: [evt outputOnMidiPort: midiPort].			j _ j + 1.			trackEventIndex at: i put: j]].	self turnOffActiveMIDINotesAt: scoreTick.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:45'!startMIDIPlaying	"Start up a process to play this score via MIDI."	midiPort ensureOpen.	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ [self midiPlayLoop] newProcess.	midiPlayerProcess		priority: Processor userInterruptPriority;		resume.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:44'!stopMIDIPlaying	"Terminate the MIDI player process and turn off any active notes."	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ nil.	activeMIDINotes do: [:pair | pair first endNoteOnMidiPort: midiPort].	activeMIDINotes _ activeMIDINotes species new.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 17:48'!turnOffActiveMIDINotesAt: scoreTick	"Turn off any active MIDI notes that should be turned off at the given score tick."	| evt someNoteEnded |	midiPort ifNil: [^ self].	someNoteEnded _ false. 	activeMIDINotes do: [:pair |		evt _ pair first.		evt endTime <= scoreTick ifTrue: [			evt endNoteOnMidiPort: midiPort.			someNoteEnded _ true]].	someNoteEnded ifTrue: [		activeMIDINotes _ activeMIDINotes select: [:p | p first endTime > scoreTick]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:54'!msecsSinceStart	"Answer the approximate number of milliseconds of real time since the beginning of the score. Since this calculation uses the current tempo, which can change throughout the piece, it is safer to use ticksSinceStart for synchronization."	^ (secsPerTick * ticksSinceStart * 1000) asInteger! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 17:25'!mutedForTrack: trackIndex put: aBoolean	muted at: trackIndex put: aBoolean.	aBoolean ifFalse: [^ self].	"silence any currently sounding notes for this track"	activeSounds do: [:pair |		pair last = trackIndex ifTrue: [activeSounds remove: pair ifAbsent: []]].	midiPort ifNotNil: [		activeMIDINotes do: [:pair |			pair last = trackIndex ifTrue: [				pair first endNoteOnMidiPort: midiPort.				activeMIDINotes remove: pair ifAbsent: []]]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:17'!overallVolume	^ overallVolume! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:18'!overallVolume: aNumber	"Set the overally playback volume to a value between 0.0 (off) and 1.0 (full blast)."	overallVolume _ (aNumber asFloat min: 1.0) max: 0.0.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:32'!panForTrack: i	| left right fullVol pan |	left _ leftVols at: i.	right _ rightVols at: i.	left = right ifTrue: [^ 0.5].  "centered"	fullVol _ left max: right.	left < fullVol		ifTrue: [pan _ left asFloat / (2.0 * fullVol)]		ifFalse: [pan _ 1.0 - (right asFloat / (2.0 * fullVol))].	^ pan roundTo: 0.001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:58'!panForTrack: i put: aNumber	"Set the left-right pan for this track to a value in the range [0.0..1.0], where 0.0 means full-left."	| fullVol pan left right |	fullVol _ (leftVols at: i) max: (rightVols at: i).	pan _ (aNumber asFloat min: 1.0) max: 0.0.	pan <= 0.5		ifTrue: [  "attenuate right channel"			left _ fullVol.			right _ 2.0 * pan * fullVol]		ifFalse: [  "attenuate left channel"			left _ 2.0 * (1.0 - pan) * fullVol.			right _ fullVol].	rightVols at: i put: right asInteger.	leftVols at: i put: left asInteger.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/22/1998 09:32'!ticksForMSecs: mSecs	^ (mSecs asFloat / (1000.0 * secsPerTick)) rounded! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:48'!ticksSinceStart	"Answer the number of score ticks that have elapsed since this piece started playing. The duration of a tick is determined by the MIDI score."	^ ticksSinceStart! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:16'!volumeForTrack: i	| vol |	vol _ (leftVols at: i) max: (rightVols at: i).	^ (vol asFloat / ScaleFactor) roundTo: 0.0001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/30/1998 20:22'!volumeForTrack: i put: aNumber	| newVol oldLeft oldRight oldFullVol left right |	newVol _ ((aNumber asFloat max: 0.0) min: 1.0) * ScaleFactor.	oldLeft _ leftVols at: i.	oldRight _ rightVols at: i.	oldFullVol _ oldLeft max: oldRight.	oldFullVol = 0 ifTrue: [oldFullVol _ 1.0].	oldLeft < oldFullVol		ifTrue: [			left _ newVol * oldLeft / oldFullVol.			right _ newVol]		ifFalse: [			left _ newVol.			right _ newVol * oldRight / oldFullVol].	leftVols at: i put: left asInteger.	rightVols at: i put: right asInteger.! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:46'!pause	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	score pauseFrom: self.	super pause.	activeSounds _ activeSounds species new.	midiPort ifNotNil: [self stopMIDIPlaying].! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:45'!resumePlaying	"Resume playing. Start over if done."	done ifTrue: [self reset].	score resumeFrom: self.	midiPort		ifNil: [super resumePlaying]  "let the sound player drive sound generation" 		ifNotNil: [self startMIDIPlaying].  "start a process to drive MIDI output"! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:56'!tempoOrRateChanged	"This method should be called after changing the tempo or rate."	secsPerTick _ 60.0 / (tempo * rate * score ticksPerQuarterNote).	ticksClockIncr _ (1.0 / self controlRate) / secsPerTick.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!closeMIDI	scorePlayer closeMIDIPort.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:14'!instrumentChoicesForTrack: trackIndex	| names inst |	names _ AbstractSound soundNames asOrderedCollection.	names _ names collect: [:n |		inst _ AbstractSound soundNamed: n.		(inst isKindOf: UnloadedSound)			ifTrue: [n, '(out)']			ifFalse: [n]].	names add: 'clink'.	names add: 'edit ', (instrumentSelector at: trackIndex) contents.	^ names asArray! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:40'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('reload instruments'		updateInstrumentsFromLibrary)		('play via built in synth'	closeMIDI)		('play via MIDI port 0'		openMIDIPort0)		('play via MIDI port 1'		openMIDIPort1)).	aMenu invokeOn: self defaultSelection: nil.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:43'!makeControls	| b r reverbSwitch repeatSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;														actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Piano Roll';		actionSelector: #makePianoRoll).	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	b target: scorePlayer.	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #resumePlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: scorePlayer;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	repeatSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Repeat';		actionSelector: #repeat:;		target: scorePlayer;		setSwitchState: scorePlayer repeat.	r addMorphBack: repeatSwitch.	b target: self.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/28/1998 19:05'!makePianoRoll	"Create a piano roll viewer for this score player."	| pianoRoll h |	pianoRoll _ PianoRollScoreMorph new on: scorePlayer.	h _ self world activeHand.	h		ifNil: [self world addMorph: pianoRoll]		ifNotNil: [h attachMorph: pianoRoll].	pianoRoll startStepping.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 08:32'!onScorePlayer: aScorePlayer title: scoreName	| divider col |	scorePlayer _ aScorePlayer reset.	self addMorph: self makeControls.	instrumentSelector _ Array new: scorePlayer score tracks size.	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	self addMorphBack: self rateControl.	self addMorphBack: self volumeControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!openMIDIPort0	scorePlayer openMIDIPort: 0.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/21/1998 17:57'!openMIDIPort1	scorePlayer openMIDIPort: 1.! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 08:29'!panAndVolControlsFor: trackIndex	| volSlider panSlider c r middleLine |	volSlider _ SimpleSliderMorph new		color: color;		extent: 101@2;		target: scorePlayer;		arguments: (Array with: trackIndex);		actionSelector: #volumeForTrack:put:;		minVal: 0.0;		maxVal: 1.0;		adjustToValue: (scorePlayer volumeForTrack: trackIndex).	panSlider _ volSlider fullCopy		actionSelector: #panForTrack:put:;		minVal: 0.0;		maxVal: 1.0;				adjustToValue: (scorePlayer panForTrack: trackIndex).	c _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(panSlider height - 4);		position: panSlider center x@(panSlider top + 2).	panSlider addMorphBack: middleLine.	r _ self makeRow.	r addMorphBack: (StringMorph contents: '0').	r addMorphBack: volSlider.	r addMorphBack: (StringMorph contents: '10').	c addMorphBack: r.	r _ self makeRow.	r addMorphBack: (StringMorph contents: 'L').	r addMorphBack: panSlider.	r addMorphBack: (StringMorph contents: 'R').	c addMorphBack: r.	^ c! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 09:52'!rateControl	| rateSlider middleLine r |	rateSlider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #setLogRate:;		minVal: -1.0;		maxVal: 1.0;		adjustToValue: 0.0.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(rateSlider height - 4);		position: rateSlider center x@(rateSlider top + 2).	rateSlider addMorphBack: middleLine.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'slow ').	r addMorphBack: rateSlider.	r addMorphBack: (StringMorph contents: ' fast').	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 6/1/1998 09:10'!scorePlayer	^ scorePlayer! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:09'!trackNumAndMuteButtonFor: trackIndex	| muteButton instSelector r |	muteButton _ SimpleSwitchMorph new		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		offColor: color;		color: color;		label: 'Mute';		target: scorePlayer;		actionSelector: #mutedForTrack:put:;		arguments: (Array with: trackIndex).	instSelector _ PopUpChoiceMorph new		extent: 95@14;		contentsClipped: 'oboe1';		target: self;		actionSelector: #atTrack:from:selectInstrument:;		getItemsSelector: #instrumentChoicesForTrack:;		getItemsArgs: (Array with: trackIndex).	instSelector arguments:		(Array with: trackIndex with: instSelector).	instrumentSelector at: trackIndex put: instSelector.	r _ self makeRow		hResizing: #rigid;		vResizing: #spaceFill;		extent: 70@10.	r addMorphBack:		(StringMorph			contents: trackIndex printString			font: (TextStyle default fontOfSize: 24)).	trackIndex < 10		ifTrue: [r addMorphBack: (Morph new color: color; extent: 19@8)]  "spacer"		ifFalse: [r addMorphBack: (Morph new color: color; extent: 8@8)].  "spacer"	r addMorphBack:		(StringMorph new			extent: 140@14;			contentsClipped: (scorePlayer infoForTrack: trackIndex)).	r addMorphBack: (Morph new color: color; extent: 8@8).  "spacer"	r addMorphBack: instSelector.	r addMorphBack: (AlignmentMorph newRow color: color).  "spacer"	r addMorphBack: muteButton.	^ r! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 9/12/1998 22:14'!updateInstrumentsFromLibrary	"The instrument library has been modified. Update my instruments with the new versions from the library. Use a single instrument prototype for all parts with the same name; this allows the envelope editor to edit all the parts by changing a single sound prototype."	| unloadPostfix myInstruments name displaysAsUnloaded isUnloaded |	unloadPostfix _ '(out)'.	myInstruments _ Dictionary new.	1 to: instrumentSelector size do: [:i |		name _ (instrumentSelector at: i) contents.		displaysAsUnloaded _ name endsWith: unloadPostfix.		displaysAsUnloaded ifTrue: [			name _ name copyFrom: 1 to: name size - unloadPostfix size].		(myInstruments includesKey: name) ifFalse: [			myInstruments at: name put:				(name = 'clink'					ifTrue: [						(SampledSound							samples: SampledSound coffeeCupClink							samplingRate: 11025) copy]					ifFalse: [						(AbstractSound							soundNamed: name							ifAbsent: [								(instrumentSelector at: i) contentsClipped: 'default'.								FMSound default]) copy])].		scorePlayer instrumentForTrack: i put: (myInstruments at: name).		"update loaded/unloaded status in instrumentSelector if necessary"		isUnloaded _ (myInstruments at: name) isKindOf: UnloadedSound.		(displaysAsUnloaded and: [isUnloaded not])			ifTrue: [(instrumentSelector at: i) contentsClipped: name].		(displaysAsUnloaded not and: [isUnloaded])			ifTrue: [(instrumentSelector at: i) contentsClipped: name, unloadPostfix]].! !!ScorePlayerMorph methodsFor: 'all' stamp: 'jm 7/4/1998 09:52'!volumeControl	| volumeSlider r |	volumeSlider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: scorePlayer;		actionSelector: #overallVolume:;		adjustToValue: scorePlayer overallVolume.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'soft  ').	r addMorphBack: volumeSlider.	r addMorphBack: (StringMorph contents: ' loud').	^ r! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/4/1998 14:32'!aboutThisSystem 	"Identify software version"	| aString eToySystem aNumber |	aString _ Smalltalk version.	(eToySystem _ Smalltalk at: #EToySystem ifAbsent: [nil]) ifNotNil:		[aString _ aString, 'EToy System: ', eToySystem version, ' of ', eToySystem versionDate].	aNumber _ ChangeSorter highestNumberedChangeSet.	(aNumber notNil and: [aNumber > 0]) ifTrue:		[aString _ aString, 'Highest-numbered update: ', aNumber printString].	aString _ aString, 'Current Change Set: ', Smalltalk changes name.	^ self inform: aString! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 8/5/1998 18:40'!browseChangedMessages	Smalltalk browseChangedMessages! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:09'!durableChangesMenu 	Utilities windowFromMenu: self changesMenu target: self title: 'Changes'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:29'!durableHelpMenu 	Utilities windowFromMenu: self helpMenu target: self title: 'Help'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 14:40'!durableOpenMenu 	Utilities windowFromMenu: self openMenu target: self title: 'Openers'		colorPattern:		#(blue lightGreen lightYellow lightMagenta  lightOrange lightCyan lightBlue lightBlue white white lightOrange lightOrange lightOrange )! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 14:36'!durableScreenMenu 	Utilities windowFromMenu: self projectScreenMenu target: self title: 'Squeak'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/22/1998 15:15'!durableWindowMenu 	Utilities windowFromMenu: self windowMenu target: self title: 'Window controls'! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/23/1998 02:06'!fontSizeSummary	Utilities fontSizeSummary! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/4/1998 10:17'!newChangeSet	ChangeSorter newChangeSet! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 11:07'!openConstructionProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView openAndEnter: Project newMorphicConstruction! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 10:58'!openMorphicConstructionWorld 	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	WorldMorph openWithStandardPartsBinShowing! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 11:06'!openMorphicProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView open: Project newMorphic.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/21/1998 10:58'!openMorphicWorld 	"Create and schedule a StringHolderView for use as a workspace."	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	WorldMorph new open.! !!ScreenController methodsFor: 'menu messages' stamp: 'tk 8/31/1998 16:18'!openSelectorBrowser	"Create and schedule a selector fragment window."	SelectorBrowser new open! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 18:59'!openSimpleChangeSorter	ChangeSorter new open! !!ScreenController methodsFor: 'menu messages' stamp: 'di 6/2/1998 15:37'!soundOnOrOff	Preferences setPreference: #disableSounds		toValue: (Preferences valueOfFlag: #disableSounds) not! !!ScreenController methodsFor: 'menu messages' stamp: 'di 9/14/1998 10:14'!viewImageImports	"Open an inspector on forms imported from Image files."	Smalltalk viewImageImports! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 14:54'!changesMenu	"Answer a menu for changes-related items"	^ SelectionMenu labelList:		#(	'keep this menu up'			'file out changes'			'create new change set...'			'browse changed methods'			'simple change sorter'			'dual change sorter'			'browse recent submissions'			'recent change log'			)		lines: #(1 4 6)		selections: #(durableChangesMenufileOutChanges newChangeSet browseChangedMessagesopenSimpleChangeSorter openChangeManagerbrowseRecentSubmissions browseRecentLog )"ScreenController new changesMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/23/1998 02:07'!helpMenu 	"Answer the help menu to be put up as a screen submenu"	^ SelectionMenu labelList:		#(	'keep this menu up'			'edit preferences...'			'command-key help'			'font size summary'			'useful expressions'			'view image imports'			'full screen on'			'full screen off'			'set display depth...'			'set desktop color...' ) , 			(Array with: ((Preferences valueOfFlag: #disableSounds)							ifTrue: ['turn sound on']							ifFalse: ['turn sound off'])) ,		#(	'update code from server'			'about this system'			'set author initials...'			'vm statistics'			'space left')		lines: #(1 6 11)		selections: #(durableHelpMenueditPreferences  openCommandKeyHelp fontSizeSummary openStandardWorkspace viewImageImportsfullScreenOn fullScreenOff setDisplayDepth setDesktopColor soundOnOrOffabsorbUpdatesFromServer aboutThisSystem setAuthorInitials vmStatistics garbageCollect)"ScreenController new helpMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 14:29'!openMenu	^ SelectionMenu labelList:		#(	'keep this menu up'			'browser'			'workspace'			'file list'			'transcript'			'selector finder'			'simple change sorter'			'dual change sorter'			'morphic window'			'construction window'			'project (mvc)'			'project (morphic)'			'project (construction)'			)		lines: #(1 8 10)		selections: #(durableOpenMenuopenBrowser openWorkspace openFileList openTranscript openSelectorBrowser openSimpleChangeSorter openChangeManageropenMorphicWorld openMorphicConstructionWorldopenProject  openMorphicProject  openConstructionProject )"ScreenController  new openMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:05'!popUpMenuFor: aSymbol	| reply |	reply _ (self perform: aSymbol) startUp.	reply ifNil: [^ self].	self perform: reply! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:14'!presentChangesMenu	self popUpMenuFor: #changesMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentHelpMenu	self popUpMenuFor: #helpMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentOpenMenu	self popUpMenuFor: #openMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:16'!presentWindowMenu	self popUpMenuFor: #windowMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 22:46'!projectScreenMenu	"Answer the project screen menu."	^ SelectionMenu labelList:		#(	'keep this menu up'			'previous project'			'jump to project...'			'restore display'			'open window...'			'windows...'			'changes...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit')		lines: #(1 4 9)		selections: #(durableScreenMenureturnToPreviousProject jumpToProject restoreDisplaypresentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu commonRequestssnapshot saveAs snapshotAndQuit quit )"ScreenController new projectScreenMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/22/1998 15:14'!windowMenu	"Answer a menu for windows-related items.  "	^ SelectionMenu labelList:		#(	'keep this menu up'			'find window...'			'find changed browsers...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows' ) , 			(Array with: (StandardSystemView cachingBits							ifTrue: ['dont save bits (compact)']							ifFalse: ['save bits (fast)'])				with: ((Preferences valueOfFlag: #reverseWindowStagger)							ifTrue: ['tile windows']							ifFalse: ['stagger windows']))		lines: #(1 4 7)		selections: #(durableWindowMenufindWindow chooseDirtyBrowser chooseDirtyWindowcollapseAll expandAll closeUnchangedWindowsfastWindows changeWindowPolicy)"ScreenController new windowMenu startUp"! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:06'!yellowButtonActivity	"Put up the alternate yellow button activity if appropriate, else defer to the old way.  2/7/96 sw	 : if shift key down, do find window.	 : project screen menu different from regular (top) screen menu"	| reply aMenu |	Sensor leftShiftDown ifTrue: [^ self findWindow].	aMenu _ self projectScreenMenu.	(reply _ aMenu startUp) isNil ifTrue: [^ super controlActivity].	(#(changesMenu helpMenu openMenu windowMenu miscMenu) includes: reply)		ifTrue:  "submenu called for"			[^ self popUpMenuFor: reply].	^ self perform: reply! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 8/11/1998 16:58'!setMorph: anActorMorph	"Not really the way to do this any more"	playerScripted _ anActorMorph player! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 8/11/1998 16:41'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph." 	| i slideMorph p1 p2 |		self prepareToUndoDropOf: aMorph.		"Find where it will go, and prepare to animate the move..."	i _ self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph _ aMorph imageForm offset: 0@0.	p1 _ aMorph screenRectangle topLeft.	aMorph delete.	self stopStepping.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue: [aMorph unbrightenTiles].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i _ i + 1].	self removeSpaces.	self layoutChanged.	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 _ (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 9/14/1998 14:47'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"	| aMenu reply standardStati aScriptInstantiation |	standardStati _ #(normal paused ticking mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging opening closing "keyStroke").	aScriptInstantiation _ self scriptInstantiation.	aMenu _ SelectionMenu labelList:  #(		'normal -- run when called'		'paused -- ready to run all the time'		'ticking -- run all the time'		'mouseDown -- run when mouse goes down on me'		'mouseStillDown -- while mouse still down'		'mouseUp -- when mouse comes back up'		'mouseEnter -- when mouse enters my bounds, button up'		'mouseLeave -- when mouse exits my bounds, button up'		'mouseEnterDragging -- when mouse enters my bounds, button down'		'mouseLeaveDragging -- when mouse exits my bounds, button down'		'opening -- when I am being opened'		'closing -- when I am being closed'	"	'keyStroke -- run when user hits a key' "		)		lines: #(1 3 6 10 "12")		selections: standardStati.	reply _ aMenu startUpWithCaption: 'When should this script run?'.	(reply == #keyStroke) ifTrue: [^ self inform: 'user-scripted fieldingof keystrokes is notyet available.'].	reply ifNotNil: 		[aScriptInstantiation status: reply.  "Gets event handlers fixed up"		reply == #ticking ifTrue: [playerScripted costume arrangeToStartStepping].		self updateStatus]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 9/11/1998 11:22'!editScriptTextually	| newBrowser |	self becomeTextuallyCoded.	(newBrowser _ Browser new) setClass: playerScripted class selector: scriptName.	Preferences editPlayerScriptsInPlace		ifTrue:			[self addTextualScript: newBrowser]		ifFalse:			[Browser openBrowserView: (newBrowser openMessageEditString: nil) label: ('textual script for "', scriptName, '" in ', playerScripted externalName)]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/28/1998 19:11'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 8/3/1998 15:08'!isTextuallyCoded	(self topEditor isKindOf: ScriptEditorMorph) ifFalse: [^ false].  "workaround for the case where the receiver is embedded in a free-standing CompoundTileMorph.  Yecch!!"	^ self userScriptObject isTextuallyCoded! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/29/1998 10:43'!storeCodeOn: aStream indent: tabCount	| lastOwner |	lastOwner _ nil.	self tileRows do: [:r |		r do: [:m |			((m isKindOf: TileMorph) or:			 [(m isKindOf: CompoundTileMorph) or:			 [m isKindOf: PhraseTileMorph]]) ifTrue: [				tabCount timesRepeat: [aStream tab].				((m owner ~= lastOwner) and: [lastOwner ~= nil])					ifTrue:						[aStream nextPut: $.; cr; tab.						m storeCodeOn: aStream indent: tabCount]					ifFalse:						[(lastOwner ~= nil) ifTrue: [aStream space].						m storeCodeOn: aStream indent: tabCount].				lastOwner _ m owner]]].! !!ScriptEditorMorph methodsFor: 'other' stamp: 'jm 5/28/1998 17:40'!userScriptObject	^ self topEditor playerScripted class userScriptForPlayer: playerScripted selector: scriptName! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'tk 8/6/1998 13:59'!addTextualScript: aBrowser	"Put a message browser right into the header alignment morph"	| window aMorph codePane |	submorphs last class == PluggableTextMorph ifTrue: [^ self].	window _ self.	aMorph _ PluggableListMorph on: aBrowser list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:.	aMorph bounds: (window topLeft extent: 200@12).	"will get moved"	window addMorphBack: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor).	codePane _ PluggableTextMorph on: aBrowser text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true]."	codePane bounds: (window topLeft extent: 200@120).	"will get moved"	window addMorphBack: codePane.	codePane borderWidth: 1; retractableOrNot; "make it stay"		color: (Color perform: aBrowser defaultBackgroundColor)."	self addMorph: aMorph.	aMorph borderWidth: 1;		color: (Color perform: aBrowser defaultBackgroundColor);		bounds: "! !!ScriptEvaluatorMorph methodsFor: 'all' stamp: 'sw 7/4/1998 18:02'!wantsDroppedMorph: aMorph	^ false   "though later we could drop onto formal args in the header"! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 7/3/1998 20:20'!runIfClosing	| result |	(result _ status == #closing) ifTrue:		[player perform: selector].	^ result! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 7/3/1998 20:19'!runIfOpening	| result |	(result _ status == #opening) ifTrue:		[player perform: selector].	^ result! !!ScriptInstantiation methodsFor: 'status & running' stamp: 'sw 5/7/1998 22:06'!status: newStatus	| stati actualMorph |	actualMorph _ player costume renderedMorph.	((stati _ ScriptingSystem standardEventStati) includes: status)		ifTrue:			[actualMorph on: status send: nil to: nil].  			"remove old link in event handler"	(stati includes: newStatus)		ifTrue:			[actualMorph on: newStatus send: selector to: player].  "establish new link in evt handler"	status _ newStatus! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 22:38'!initializeDownButton	downButton := RectangleMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: Color lightGray.	downButton on: #mouseDown send: #scrollDownInit to: self.	downButton on: #mouseStillDown send: #scrollDown to: self.	downButton on: #mouseUp send: #borderRaised to: downButton.	downButton addMorphCentered: (ImageMorph new image: 		(UpArrow rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi]) centerAt: 0@0)).	downButton setBorderWidth: 2 borderColor: #raised.	self addMorph: downButton! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 23:43'!initializePagingArea	pagingArea := RectangleMorph newBounds: self totalSliderArea								color: (Color r: 0.6 g: 0.6 b: 0.8).	pagingArea borderWidth: 0.	pagingArea on: #mouseDown send: #resetTimer to: self.	pagingArea on: #mouseStillDown send: #scrollByPage: to: self.	self addMorph: pagingArea! !!ScrollBar methodsFor: 'initialize' stamp: 'di 8/15/1998 22:38'!initializeUpButton	upButton := RectangleMorph		newBounds: ((bounds isWide ifTrue: [menuButton bounds topRight]									ifFalse: [menuButton bounds bottomLeft])					extent: self buttonExtent)		color: Color lightGray.	upButton on: #mouseDown send: #scrollUpInit to: self.	upButton on: #mouseStillDown send: #scrollUp to: self.	upButton on: #mouseUp send: #borderRaised to: upButton.	upButton addMorphCentered: (ImageMorph new image: 		(bounds isWide ifTrue: [UpArrow rotateBy: #left centerAt: 0@0] ifFalse: [UpArrow])).	upButton setBorderWidth: 2 borderColor: #raised.	self addMorph: upButton! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:39'!nextPage: event	"Note: this method is no longer called, except by old scrollBars"	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	event cursorPoint y >= slider center y		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:39'!scrollByPage: event	nextPageDirection == nil ifTrue:		[nextPageDirection _ event cursorPoint y >= slider center y].	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	nextPageDirection		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:40'!scrollDown	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value + scrollDelta + 0.000001 min: 1.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/15/1998 22:44'!scrollDownInit	downButton borderInset.	self resetTimer.! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:40'!scrollUp	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value - scrollDelta - 0.000001 max: 0.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/15/1998 22:45'!scrollUpInit	upButton borderInset.	self resetTimer.! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/14/1998 15:19'!setValue: newValue	^ super setValue: (newValue truncateTo: scrollDelta)! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:22'!resetTimer	timeOfMouseDown _ Time millisecondClockValue.	timeOfLastScroll _ timeOfMouseDown - 1000 max: 0.	nextPageDirection _ nil.	currentScrollDelay _ nil! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:38'!waitForDelay1: delay1 delay2: delay2	"Return true if an appropriate delay has passed since the last scroll operation.	The delay decreases exponentially from delay1 to delay2."	| now scrollDelay |	timeOfLastScroll == nil ifTrue: [self resetTimer]. "Only needed for old instances"	now _ Time millisecondClockValue.	now < timeOfLastScroll ifTrue: [self resetTimer  "rare clock rollover"].	(scrollDelay _ currentScrollDelay) == nil ifTrue: [scrollDelay _ delay1  "initial delay"].	now > (timeOfLastScroll + scrollDelay) ifFalse: [^ false  "not time yet"].	currentScrollDelay _ scrollDelay*9//10 max: delay2.  "decrease the delay"	timeOfLastScroll _ now.	^ true! !!ScrollController methodsFor: 'control defaults' stamp: 'di 6/26/1998 13:11'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's menu."	| menu sel |	menu _ view getMenu: shiftKeyState.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [(sel _ menu startUp) ifNil: [^ self].			self controlTerminate.			model perform: sel orSendTo: self.			self controlInitialize].! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor _ sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !The scroller (a transform) of a scrollPane is driven by the scrollBar.  The scroll values vary from 0.0, meaning zero offset to 1.0 meaning sufficient offset such that the bottom of the scrollable material appears halfway down the pane.  The total distance to achieve this range is called the totalScrollRange.!!ScrollPane methodsFor: 'initialization' stamp: 'tk 8/13/1998 13:05'!fullCopy	| copy |	self mouseEnter: nil.		 "Make sure scrollBar is in morphic structure"	copy _ super fullCopy.		"So that references are updated properly"		"Will fail of any Players with scripts are in the ScrollPane"	self mouseLeave: nil.	^ copy mouseLeave: nil! !!ScrollPane methodsFor: 'geometry' stamp: 'di 8/16/1998 01:09'!scrollBarFills: aRectangle	"Return true if a flop-out scrollbar fills the rectangle"	^ (retractableScrollBar and: [submorphs includes: scrollBar]) and:		[scrollBar bounds containsRect: aRectangle]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 7/6/1998 13:11'!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component"	| newYoffset r |	newYoffset _ scroller offset y - delta y max: 0.	scroller offset: scroller offset x @ newYoffset.	(r _ self totalScrollRange) = 0		ifTrue: [scrollBar value: 0.0]		ifFalse: [scrollBar value: newYoffset asFloat / r]! !!ScrollPane methodsFor: 'geometry' stamp: 'di 8/14/1998 15:52'!totalScrollRange	^ (scroller submorphBounds encompass: 0@0) height - (bounds height * 3 // 4) max: 0! !!ScrollPane methodsFor: 'retractable scroll bar' stamp: 'di 8/13/1998 10:14'!mouseLeave: event	retractableScrollBar ifTrue:		[self privateRemoveMorph: scrollBar.		scrollBar privateOwner: nil]! !!ScrollPane methodsFor: 'pane events' stamp: 'di 7/3/1998 12:07'!handlesMouseOver: evt	^ true! !!ScrollPane methodsFor: 'pane events' stamp: 'di 6/30/1998 08:48'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!scrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!shiftedYellowButtonActivity	^ self yellowButtonActivity: true! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:32'!unshiftedYellowButtonActivity	^ self yellowButtonActivity: false! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:29'!yellowButtonActivity: shiftKeyState	| menu event |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[event _ self primaryHand lastEvent.		menu setInvokingView: self.		menu popUpAt: event cursorPoint event: event]! !!ScrollPane methodsFor: 'menu' stamp: 'sw 9/23/1998 08:47'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	aTitle _ getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	getMenuSelector numArgs = 2 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu with: shiftKeyState.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!ScrollPane methodsFor: 'menu' stamp: 'sw 8/18/1998 12:38'!menuTitleSelector: aSelector	getMenuTitleSelector _ aSelector! !allows a user to select from a number of options!!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/11/1998 21:38'!active	^listMorph getCurrentSelectionIndex > 0! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/5/1998 07:15'!name	^name! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/5/1998 07:16'!reset	listMorph selection: defaultValue! !!SelectionInput methodsFor: 'handling input' stamp: 'ls 8/11/1998 21:39'!value	^values at: listMorph getCurrentSelectionIndex! !!SelectionInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 07:55'!name: name0  defaultValue: defaultValue0  list: list0 values: values0	name _ name0.	defaultValue _ defaultValue0.	listMorph _ list0.	values _ values0.! !!SelectionInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 07:55'!name: name0  defaultValue: defaultValue  list: list  values: values	^self new name: name0  defaultValue: defaultValue  list: list  values: values! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'di 8/20/1998 09:18'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray. Record the given array of selections	corresponding to the items in labelsArray."	"Labels can be either a sting with embedded crs, or a collection of strings"	| labelString |	(labels isMemberOf: String)		ifTrue: [labelString _ labels]		ifFalse: [labelString _ String streamContents:					[:s |					labels do: [:l | s nextPutAll: l; cr].					s skip: -1]].	^ (self labels: labelString lines: linesArray) selections: selectionsArray! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:20'!classList	^ classList! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:23'!classListIndex	^ classListIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/27/1998 17:46'!classListIndex: anInteger	classListIndex _ anInteger.	classListIndex > 0 ifTrue: [		Browser fullOnClass: self selectedClass selector: self selectedMessageName.		"classListIndex _ 0"]! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:33'!classListSelectorTitle	^ 'Class List Menu'! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/31/1998 16:08'!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	contents _ aString.	classList _ #().  classListIndex _ 0.	selectorIndex _ 0.   	selectorList _ Cursor wait showWhile: [		(Symbol selectorsContaining: contents asString) asSortedArray].	self changed: #messageList.	self changed: #classList.	^ true! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/21/1998 17:35'!defaultBackgroundColor	^ #lightCyan! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:35'!implementors	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil:		[Smalltalk browseAllImplementorsOf: aSelector]! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:19'!messageList	"Find all the selectors containing what the user typed in."	^ selectorList! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 10:58'!messageListIndex	"Answer the index of the selected message selector."	^ selectorIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/31/1998 19:28'!messageListIndex: anInteger 	"Set the selected message selector to be the one indexed by anInteger.  Find all classes it is in."	selectorIndex _ anInteger.	selectorIndex = 0 ifFalse: [		classList _ Smalltalk allImplementorsOf: (selectorList at: selectorIndex).		classListIndex _ 0.		self changed: #messageListIndex.		"update my selection"		self changed: #classList]! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 17:04'!open	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spwns a full browser on it.	SelectorBrowser new open   "	|  selectorListView typeInView topView classListView |	World ifNotNil: [^ self openAsMorph].	selectorIndex _ classListIndex _ 0.	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	typeInView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	typeInView window: (0@0 extent: 100@14);		askBeforeDiscardingEdits: false.	topView addSubView: typeInView.	selectorListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	selectorListView window: (0 @ 0 extent: 100 @ 86).	topView addSubView: selectorListView below: typeInView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil	"never anything selected"		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	classListView window: (0 @ 0 extent: 100 @ 100).	topView addSubView: classListView toRightOf: typeInView.	topView label: 'Full Browser from Selector Fragment'.	topView minimumSize: 300 @ 200; maximumSize: 450@200.	topView subViews do: [:each | each controller].	topView controller open.! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 17:05'!openAsMorph	"Create a Browser that lets you type part of a selector, shows a list of selectors, shows the classes of the one you chose, and spwns a full browser on it.	SelectorBrowser new open   "	| window typeInView selectorListView classListView |	window _ (SystemWindow labelled: 'later') model: self.	selectorIndex _ classListIndex _ 0.	typeInView _ PluggableTextMorph on: self 		text: #contents accept: #contents:notifying:		readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	"typeInView askBeforeDiscardingEdits: false."	window addMorph: typeInView frame: (0@0 corner: 0.5@0.14).	selectorListView _ PluggableListMorph on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #selectorMenu:		keystroke: #messageListKey:from:.	selectorListView menuTitleSelector: #selectorMenuTitle.	window addMorph: selectorListView frame: (0@0.14 corner: 0.5@1).	classListView _ PluggableListMorph on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: nil		keystroke: #arrowKey:from:.	classListView menuTitleSelector: #classListSelectorTitle.	window addMorph: classListView frame: (0.5@0 corner: 1@1).	window setLabel: 'Full Browser from Selector Fragment'.	window openInWorldExtent: 450@200! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/27/1998 17:50'!selectedClass	"Answer the currently selected class."	classListIndex = 0 ifTrue: [^nil].	MessageSet parse: (classList at: classListIndex) 		toClassAndSelector: [:cls :sel | ^ cls].! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/27/1998 17:48'!selectedClassName	"Answer the name of the currently selected class."	classListIndex = 0 ifTrue: [^nil].	^ self selectedClass name! !!SelectorBrowser methodsFor: 'all' stamp: 'tk 8/26/1998 14:29'!selectedMessageName	"Answer the name of the currently selected message."	selectorIndex = 0 ifTrue: [^nil].	^ selectorList at: selectorIndex! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:32'!selectorMenu: aMenu	^ aMenu labels: 'sendersimplementors'	lines: #()	selections: #(senders implementors)! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:37'!selectorMenuTitle	^ self selectedMessageName ifNil: ['<no selection>']! !!SelectorBrowser methodsFor: 'all' stamp: 'sw 9/2/1998 16:35'!senders	| aSelector |	(aSelector _ self selectedMessageName) ifNotNil:		[Smalltalk browseAllCallsOn: aSelector]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ls 8/18/1998 00:36'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	^self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 1/20/98 16:22'!replaceAll: oldObject with: newObject 	"Replace all occurences of oldObject with newObject"	| index |	index _ self				indexOf: oldObject				startingAt: 1				ifAbsent: [0].	[index = 0]		whileFalse: 			[self at: index put: newObject.			index _ self						indexOf: oldObject						startingAt: index + 1						ifAbsent: [0]]! !!SequentialSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:04'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur + snd duration].	^ dur! !Holds all the information needed to read or write on a directory of an internet server.  I am used for FTP and HTTP (and STMP?  NNTP?).  The password policy is: unless it is a public password (like annomyous), clear all passwords before any snapshot.  There is a way to store passwords on the disk.server 		'www.disney.com'  or '123.34.56.08' or the ServerDirectory above me 			(if I am a subdirectory sharing the info in a master directory)directory 	'ftp/pubs/'  name of my directory within the server or superdirectory.			(for file://, directory is converted to local delimiters.)type 		#ftp	what you can do in this directoryuser 		'Jones45'password 	an instance of Password.  group 		an Association ('group name' -> an array of ServerDirectorys)			If this first one is down, try the next one.  Store on all of them.  I am in the list.moniker 	'Main Squeak Directory'  Description of this directory.altURL		When a FTP server holds some web pages, the altURL of those pages is often			different from the FTP directory.  Put the altURL here.  If the directory is 			'public_html/Squeak/', the altURL might be 'www.webPage.com/~kaehler2/			Squeak/'.urlObject	An instance of a subclass of Url.  It is very good at parsing complex urls.			Relative references.  file:// uses this.  Use this in the future instead of 			server and directory inst vars.			!]style[(677 8 685)f1,f1LPassword Comment;,f1!!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 9/18/1998 23:25'!getFileNamed: fileNameOnServer into: dataStream	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| so dd resp rr |	type == #file ifTrue: [		dataStream nextPutAll: (resp _			FileStream oldFileNamed: server,(self serverDelimiter asString), self bareDirectory,				(self serverDelimiter asString),fileNameOnServer) contentsOfEntireFile.		^ resp].	type == #http ifTrue: [].	type ifNil: [type _ #ftp].	"type == #ftp"	so _ self openFTP.	"Open passive.  Do everything up to RETR or STOR"	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RETR ', fileNameOnServer.	dd _ so dataSocket.	dd connectTo: so remoteAddress port: dd portNum.	dd waitForConnectionUntil: FTPSocket standardDeadline.	Transcript show: 'retrieve from port ', dd portNum printString; cr.	resp _ dd getDataTo: dataStream whileWatching: so.		"Later use the length to pre-allocate the buffer"	(resp == #error:) ifTrue: [^ resp].	dd close.	(rr _ so responseOK) == true ifFalse: [^ rr].	"150 Opening binary conn on foo (3113 bytes)"	(rr _ so responseOK) == true ifFalse: [^ rr].	"226 Transfer complete."	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"	dd destroy.	^ resp	"String with just the data"! !!ServerDirectory methodsFor: 'do ftp' stamp: 'tk 9/16/1998 08:46'!openNoDataFTP	"Open a connection to the directory and server I hold.  Return a FTPSocket.  No dataPort is opened.  When you are done, be sure to tell the socket to QUIT, and then destroy it."	| so rr serverIP |	Socket initializeNetwork.	FTPSocket retry: [serverIP _ NetNameResolver addressForName: server timeout: 20.				serverIP ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', server].	so _ FTPSocket new.	so portNum: 21.	so connectTo: serverIP port: 21.  "21 is for the control connection"	so waitForConnectionUntil: FTPSocket standardDeadline.	Transcript cr; show: server; cr.	(rr _ so lookFor: '220 ') == true ifFalse: [^ rr].	"220 para1 Microsoft FTP Service"	so sendCommand: 'USER ', user.	(rr _ so lookFor: '331 ') == true ifFalse: [^ rr].	"331 Password required"	so sendCommand: 'PASS ', self password.	(rr _ so lookFor: '230 ') == true ifFalse: [^ rr].	"230 User logged in"	so sendCommand: 'CWD ', directory.	(rr _ so lookFor: '250 ') == true ifFalse: [^ rr].	"250 CWD successful"	"Need to ask for name of directory to make sure?"	^ so! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:20'!checkNames: list	"Look at these names for update and see if they are OK"list do: [:local |	(local count: [:char | char == $.]) > 1 ifTrue: [		self inform: 'File name ',local,'may not have more than one period'.	^ false].	(local at: 1) isDigit ifTrue: [		self inform: 'File name ',local,'may not begin with a number'.	^ false].	(local findDelimiters: '%/* ' startingAt: 1) <= local size ifTrue: [		self inform: 'File name ',local,'may not contain % / * or space'.	^ false]].^ true! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 9/5/1998 17:20'!checkServers	"Check that all servers are up and have the latest Updates.list.  Return the servers that ready to receiver this update"	| final fileSize this serverList theUpdates decided myUpdates abort strm res |	serverList _ group 			ifNil: [Array with: self] 			ifNotNil: [group value].	final _ OrderedCollection new.	fileSize _ 0.  theUpdates _ ''.	"list of updates"	abort _ false.	serverList do: [:aServer |		decided _ false.		this _ aServer getFileNamed: 'updates.list'.		(this class == String) & (altURL size > 0) ifTrue: [			strm _ HTTPSocket httpGet: altURL accept: 'application/octet-stream'.			strm class == String 				ifTrue: [res _ (PopUpMenu  						labels: 'Install even though not visible\Cancel entire update' withCRs)						startUpWithCaption: 'Server ', aServer moniker, 						' is a weird state.\You cannot store, but users can get updates.\If you store on other servers, the file will not be visible.\Strongly advise that you Cancel.' withCRs]				ifFalse: [					res _ (PopUpMenu labels: 'Install on others\Cancel entire update' withCRs)							startUpWithCaption: 'Server ', aServer moniker, 							' is unavailable\' withCRs, this].			abort _ res ~= 1.			decided _ true].		decided not & (this size > fileSize) ifTrue: ["new has a longer update.list"			fileSize _ this size.			final do: [:each | abort _ self outOfDate: each].			(final _ OrderedCollection new) add: aServer.			theUpdates _ this contentsOfEntireFile. 			decided _ true].		decided not & (this size < fileSize) ifTrue: [abort _ self outOfDate: aServer.  decided _ true].		decided not ifTrue: [myUpdates _ this contentsOfEntireFile.			myUpdates = theUpdates 				ifTrue: [final add: aServer]				ifFalse: [abort _ self outOfDate: this]].		abort ifTrue: [^ Array new].		].	^ final! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:25'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence newName myName response local restOfText seq |"	(ScheduledControllers scheduledControllers detect: [:each |		each model == Transcript] ifNone: [nil]) ifNil: [			^ self inform: 'Please open a Transcript window, and then start putting out this update again.']."	local _ fileStrm localName.	(self checkNames: (Array with: local)) ifFalse: [^ nil].	"allowed characters"	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast the file ', local, 			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	sequence _ Utilities lastUpdateNum: updateStrm.	seq _ (sequence+1) printString.	seq size = 1 ifTrue: [seq _ '00', seq].	seq size = 2 ifTrue: [seq _ '0', seq].	newName _ seq, local.	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: newName; nextPut: Character cr; nextPutAll: restOfText.	myServers do: [:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName.		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		Transcript cr; show: 'Update succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: local toBe: newName.!]style[(19 225 39 2051)f1b,f1,f1LUtilities class absorbUpdatesFromServer;,f1! !!ServerDirectory methodsFor: 'updates' stamp: 'tk 6/30/1998 15:24'!putUpdateMulti: list	"Put these files out as an Update on the servers of my group.  List is an array of local file names without number prefixes.  Each version of the system has its own set of update files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class absorbUpdatesFromServer."	| myServers updateStrm sequence myName response restOfText seq start add newNames file |	(self checkNames: list) ifFalse: [^ nil].	myName _ group ifNil: [self moniker] ifNotNil: [group key].	response _ (PopUpMenu labels: 'Install update\Cancel update' withCRs)		startUpWithCaption: 'Do you really want to broadcast ', list size printString, ' updates',			'\to every Squeak user who updates from ' withCRs, myName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	(myServers _ self checkServers) size = 0 ifTrue: [^ self].	updateStrm _ myServers first getFileNamed: 'updates.list'.	"get last number and add 1"	start _ sequence _ Utilities lastUpdateNum: updateStrm.	add _ WriteStream on: (String new: 200).	newNames _ list collect: [:each | 		seq _ (sequence _ sequence+1) printString.		seq size = 1 ifTrue: [seq _ '00', seq].		seq size = 2 ifTrue: [seq _ '0', seq].		add nextPutAll: seq; nextPutAll: each; cr.		seq, each].	restOfText _ Utilities position: updateStrm 	"sets the postion!!!!"			atVersion: (Smalltalk at: #EToySystem) version.	restOfText size > 0 ifTrue: [		response _ (PopUpMenu labels: 'Make update for my older version\Cancel update' withCRs)			startUpWithCaption: 'This system, ', (Smalltalk at: #EToySystem) version,				' is not the latest version'.		response = 1 ifFalse: [^ nil].	"abort"		].	"append name to updates"	(updateStrm skip: -1; next) == Character cr ifFalse: [		updateStrm nextPut: Character cr].	updateStrm nextPutAll: add contents; nextPutAll: restOfText.	myServers do: [:aServer |		list doWithIndex: [:local :ind |			file _ FileStream oldFileNamed: local.			aServer putFile: file named: (newNames at: ind).			file close].		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list'.		Transcript cr; show: 'Updates succeeded on server ', aServer moniker].			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	file _ FileStream oldFileNamed: (list first).	file close.	list doWithIndex: [:local :ind |		file directory rename: local toBe: (newNames at: ind)].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:24'!bareDirectory	^ directory first == $/ 		ifTrue: [directory copyFrom: 2 to: directory size]		ifFalse: [directory]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/19/1998 18:54'!copy	| new |	new _ self clone.	new urlObject: urlObject copy.	^ new! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 11:50'!directory	^ directory! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:18'!fullPath: serverAndDirectory	"Parse and save a full path.  Convention:  if ftp://user@server/dir, then dir is relative to user's directory.  dir has no slash at beginning.  If ftp://server/dir, then dir is absolute to top of machine, give dir a slash at the beginning."	| start bare sz userAndServer both slash |	bare _ serverAndDirectory.	sz _ serverAndDirectory size.	bare size > 0 ifTrue: [ 		start _ (bare copyFrom: 1 to: (8 min: sz)) asLowercase.		(start beginsWith: 'ftp:') 			ifTrue: [type _ #ftp.				bare _ bare copyFrom: (7 min: sz) to: bare size].		(start beginsWith: 'http:') 			ifTrue: [type _ #http.				bare _ bare copyFrom: (8 min: sz) to: serverAndDirectory size].		((start beginsWith: 'file:') or: [type == #file])			ifTrue: [type _ #file.				urlObject _ FileUrl absoluteFromText: serverAndDirectory.				^ self]].	userAndServer _ bare copyUpTo: self pathNameDelimiter.	both _ userAndServer findTokens: '@'.	slash _ both size.	"absolute = 1, relative = 2"	server _ both last.	both size > 1 ifTrue: [user _ both at: 1].	bare size > (userAndServer size + 1) 		ifTrue: [directory _ bare copyFrom: userAndServer size + slash to: bare size]		ifFalse: [directory _ ''].! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:23'!moniker	"a plain language name for this directory"	moniker ifNotNil: [^ moniker].	directory ifNotNil: [^ self slashDirectory].	urlObject ifNotNil: [^ urlObject toText].	^ ''! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/23/1998 09:41'!printOn: aStrm	aStrm nextPutAll: self class name; nextPut: $<.	aStrm nextPutAll: self moniker.	aStrm nextPut: $>.! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/18/1998 23:22'!slashDirectory	^ directory first == $/ 		ifTrue: [directory]		ifFalse: ['/', directory]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 00:43'!type	^ type! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/5/1998 17:20'!url	^ altURL! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/5/1998 17:20'!url: aString	altURL _ aString! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/6/1998 00:44'!urlObject	^ urlObject! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/8/1998 11:56'!urlObject: aUrl	urlObject _ aUrl! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/17/1998 18:04'!createDirectory: localName	"Create a new sub directory within the current one"	| so rr |	type == #file ifTrue: [FileDirectory createDirectory: localName].	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'MKD ', localName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/17/1998 18:20'!deleteDirectory: localName	"Delete the sub directory within the current one.  Call needs to ask user to confirm."	| so rr |	type == #file ifTrue: [FileDirectory deleteFileNamed: localName].		"Is this the right command???"	so _ self openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RMD ', localName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 08:49'!deleteFileNamed: fullName	"Detete a remote file.  fullName is directory path, and does include name of the server.  Or it can just be a fileName."	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			deleteFileNamed: file fileName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'DELE ', file fileName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:58'!directoryNamed: localFileName	"Return a copy of me pointing at this directory below me"	| new |	new _ self copy.	urlObject ifNotNil: [		new urlObject path: (new urlObject path) copy.		(new urlObject path) removeLast; addLast: localFileName; addLast: ''.		^ new].	new directory: directory, self pathNameDelimiter asString, localFileName.	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:44'!entries	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| ftpEntries thisYear tokens dateInSeconds longy |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	type == #file ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForFile) entries].	ftpEntries _ self getDirectory contentsOfEntireFile findTokens: FTPSocket crLf.	thisYear _ Date today year.	^ ftpEntries collect:		[:ftpEntry | tokens _ ftpEntry findTokens: ' '.		tokens size >= 9		ifTrue:		[tokens size > 9 ifTrue:			[longy _ tokens at: 9.			10 to: tokens size do: [:i | longy _ longy , ' ' , (tokens at: i)].			tokens at: 9 put: longy].		dateInSeconds _ ((tokens at: 8) includes: $:)			ifTrue: ["Date has no year -- assume this year"					(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: thisYear) asSeconds +					(Time readFrom: (ReadStream on: (tokens at: 8))) asSeconds]			ifFalse: [(Date newDay: (tokens at: 7) asNumber								month: (tokens at: 6)								year: (tokens at: 8) asNumber) asSeconds].		DirectoryEntry name: (tokens at: 9)  "file name"			creationTime: dateInSeconds "creation date"			modificationTime: dateInSeconds "modification time"			isDirectory: tokens first first = $d "is-a-directory flag"			fileSize: tokens fifth asNumber "file size"]		ifFalse:		[nil]]		thenSelect: [:entry | entry notNil]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 19:29'!fullNameFor: aFileName	"Convention: 	If it is an absolute path, directory stored with a leading slash, and url has no user@.	If relative path, directory stored with no leading slash, and url begins user@.	Should we include ftp:// on the front?"	urlObject ifNotNil: [^ urlObject pathString, aFileName].	(aFileName includes: self pathNameDelimiter)		ifTrue: [^ aFileName].	directory isEmpty ifTrue: [^ server, 		self pathNameDelimiter asString, aFileName].	^ (directory first == $/ ifTrue: [''] ifFalse: [user,'@']), 		server, self slashDirectory, 		self pathNameDelimiter asString, aFileName! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:27'!newFileNamed: fullName	"Create a RemoteFileStream.  If the file exists, and complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm selection |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readWrite.	file type == #file ifTrue: [		^ FileStream newFileNamed: (file fileNameRelativeTo: self)].	file exists 		ifTrue: [			selection _ (PopUpMenu labels: 'overwrite that filechoose another namecancel')				startUpWithCaption: (file fullNameFor: file fileName) , 'already exists.']		ifFalse: [selection _ 1].	selection = 1 ifTrue:		[remoteStrm _ RemoteFileStream on: (String new: 2000).		remoteStrm remoteFile: file.		^ remoteStrm].	"no actual writing till close"	selection = 2 ifTrue: [		^ self newFileNamed:			(FillInTheBlank request: 'Enter a new file name'				initialAnswer: file fileName)].	^ nil	"cancel"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 08:40'!oldFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile remoteStrm |	rFile _ self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	rFile readOnly.	rFile type == #file ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: rFile.	rFile getFileNamed: rFile fileName into: remoteStrm.	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/6/1998 23:25'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data."	| file remoteStrm |Cursor wait showWhile: 	[type ifNil: [type _ #ftp].	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file readOnly.	file type == #file ifTrue: [		^ FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self)].	file exists ifFalse: [^ nil].		"on the server"	remoteStrm _ RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	file getFileNamed: file fileName into: remoteStrm].	"prefetch data"	^ remoteStrm! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:59'!on: fullName	"Answer another ServerDirectory on the partial path name.  fullName is directory path, and does include the name of the server."	| new |	new _ self copy.	new fullPath: fullName.		"sets server, directory(path)"	^ new! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/18/1998 23:26'!pathName	urlObject ifNotNil: [^ urlObject pathForFile].	directory size = 0 ifTrue: [^ server].	^ (directory at: 1) = self pathNameDelimiter		ifTrue: [server, directory]		ifFalse: [user, '@', server, self pathNameDelimiter asString, directory]! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/3/1998 12:34'!pathNameDelimiter	"the separator that is used in URLs"	^ $/! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/8/1998 12:12'!pathParts	"Return the path from the root of the file system to this directory as an array of directory names.  On a remote server."	urlObject ifNotNil: [^ (urlObject path copy) removeLast; yourself].	^ (OrderedCollection with: server) addAll: 		(directory findTokens: self pathNameDelimiter asString);			yourself.! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/16/1998 15:11'!rename: fullName toBe: newName	"Rename a remote file.  fullName is just be a fileName, or can be directory path that includes name of the server.  newName is just a fileName"	| file so rr |	file _ self as: ServerFile.	(fullName includes: self pathNameDelimiter)		ifTrue: [file fullPath: fullName]		"sets server, directory(path), fileName"		ifFalse: [file fileName: fullName].	"JUST a single NAME, rest is here"			"Mac files that include / in name, must encode it as %2F "	file type == #file ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			rename: file fileName toBe: newName].		so _ file openNoDataFTP.	so class == String ifTrue: ["error, was reported" ^ so].	so sendCommand: 'RNFR ', file fileName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'RNTO ', newName.	(rr _ so responseOK) == true ifFalse: [^ rr].	""	so sendCommand: 'QUIT'.	(rr _ so responseOK) == true ifFalse: [^ rr].	"221"	so destroy.	"Always OK to destroy"! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/3/1998 12:36'!serverDelimiter	"the separator that is used in the place where the file actually is.  ftp server or local disk."	^ type == #file: ifTrue: [FileDirectory default pathNameDelimiter]		ifFalse: [^ $/]	"for ftp, http"! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:50'!group	"NOTE: This is an association whose key is the anme of the group, and	whose value is an array of serverDirectories, the first of which is	deemed to be the group directory."	^ group! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:50'!group: anObject	group _ anObject! !!ServerDirectory methodsFor: 'server groups' stamp: 'di 5/24/1998 15:54'!removeFromGroup	"Allowable if not in a group presently"	group ifNotNil:		["Group is an association shared by all members.		Therefore all will feel this removal"		group value: (group value copyWithout: self).		group _ nil  "...and I'm outa here"]! !!ServerDirectory class methodsFor: 'misc' stamp: 'tk 9/8/1998 11:57'!newFrom: aSimilarObject	"Must copy the urlObject, so they won't be shared"	| inst |	inst _ super newFrom: aSimilarObject.	inst urlObject: aSimilarObject urlObject copy.	^ inst! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 16:01'!addGroup: serverArray named: nameString	| groupAssn |	serverArray do: [:server | server removeFromGroup].	groupAssn _ nameString -> serverArray asArray copy.	serverArray do: [:server | server group: groupAssn].! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:24'!addServer: server named: nameString	Servers at: nameString put: server! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:15'!groupNamed: nameString	"Return the first server in the group of this name."	| grp server |	Servers associationsDo: [:assn |		server _ assn value.		grp _ server group.  "Note: this is an association"		(grp == nil or: [server == grp value first])			ifTrue: [nameString = server groupName						ifTrue: [^ server]]].	^ self error: 'Server name not found'! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:03'!groupNames	"Return the names of all registered groups of servers, including individual servers not in any group.  Note: A serverDirectory that is a member of a group will return an array of the servers in its group.  The first server in that array represents the group, and its name is the name of the goup."	| grp names server |	names _ OrderedCollection new.	Servers associationsDo: [:assn |		server _ assn value.		grp _ server group.  "Note: this is an association"		(grp == nil or: [server == grp value first])			ifTrue: [names add: server groupName]].	^ names asSortedArray! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 14:29'!removeServerNamed: nameString	Servers removeKey: nameString! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 15:16'!serverNamed: nameString	^ Servers at: nameString		ifAbsent: [self error: 'Server name not found']! !!ServerDirectory class methodsFor: 'available servers' stamp: 'di 5/24/1998 13:30'!serverNames	^ Servers keys asSortedArray! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 9/8/1998 10:59'!fileNameRelativeTo: aServerDir	"Produce an absolute fileName from me and an absolute directory"	urlObject isAbsolute ifFalse: [		(aServerDir urlObject ~~ nil and: [aServerDir urlObject isAbsolute]) 			ifTrue: [urlObject 				privateInitializeFromText: urlObject pathString 				relativeTo: aServerDir urlObject]			ifFalse: [urlObject default]].	"relative to Squeak directory"	^ urlObject pathForFile, fileName! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 9/6/1998 17:29'!fullPath: serverAndDirectory	"Parse and save a full path.  Separate out fileName at the end."	| delim ii |	super fullPath: serverAndDirectory.		"set server and directory"	type == #file ifTrue: [fileName _  ''. ^ self].	delim _ self pathNameDelimiter.	ii _ directory findLast: [:c | c = delim].	ii = 0		ifTrue: [self error: 'expecting directory and fileName']		ifFalse: [fileName _ directory copyFrom: ii+1 to: directory size.			directory _ (directory copyFrom: 1 to: directory size - fileName size - 1)].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'jm 6/17/1998 09:01'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue: [self color: (oldColor mixed: 1/2 with: Color white).				(actWhen == #whilePressed and: [evt anyButtonPressed])					 ifTrue: [self doButtonAction]]		ifFalse: [self color: oldColor].! !This class supports client for simple network protocols based on sending textual commands and responses. Examples of such protocols include POP3 (mail retrieval), SMTP (mail posting), HTTP (web browsing), and NTTP (network news). Some simple examples are presented as class methods, but a full-service client of some service should be implemented as a subclass.The basic services provided by this class are:	sendCommand:			-- sends a command line terminate with <CR><LF>	getResponse				-- gets a single-line response to a command	getMultilineResponse	-- gets a multiple line response terminated by a period							-- on a line by itselfThere are variants of the getResponse commands that display lines on the screen as they are being received. Linefeeds are stripped out of all responses.The 'get' commands above make use of an internal buffer.  So intermixing these two commands and regular Socket recieve commands can cause problems.!!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 03:34'!getMultilineResponseShowing: showFlag	"Get a multiple line response to the last command. A multiple line response ends with a line containing only a single period (.) character. Linefeed characters are filtered out. If showFlag is true, each line is shown in the upper-left corner of the Display as it is received."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		showFlag			ifTrue: [chunk _ self getResponseShowing: true]			ifFalse: [chunk _ self getResponse].		(chunk beginsWith: '.')			ifTrue: [ response nextPutAll: (chunk copyFrom: 2 to: chunk size) ]			ifFalse: [ response nextPutAll: chunk ].		done _ (chunk = ('.', String cr)) ].	^ response contents! !!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 02:10'!getResponse	"Get a one-line response from the server.  The final LF is removed from the line, but the CR is left, so that the line is in Squeak's text format"	^ self getResponseShowing: false! !!SimpleClientSocket methodsFor: 'all' stamp: 'ls 9/11/1998 03:27'!getResponseShowing: showFlag	| line idx |	line _ WriteStream on: String new.	buffer ifNil: [		buffer _ String new.		bufferPos _ 0 ].	[		"look for a LF in the buffer"		idx _ buffer indexOf: Character lf startingAt: bufferPos+1 ifAbsent: [ 0 ].		idx > 0 ifTrue: [			"found it!! we have a line"			line nextPutAll: (buffer copyFrom: bufferPos+1 to: idx-1).			bufferPos _ idx.			^line contents ].				"didn't find it.  add the whole buffer to the line, and retrieve some more data"		line nextPutAll: (buffer copyFrom: bufferPos+1 to: buffer size).		bufferPos _ 0.		buffer _ String new.		self waitForDataQueryingUserEvery: 30.		buffer _ self getData.		true	] whileTrue.! !!SimpleClientSocket methodsFor: 'all' stamp: 'jm 9/16/1998 14:37'!waitForDataQueryingUserEvery: seconds	"Wait for data to arrive, asking the user periodically if they wish to keep waiting. If they don't wish to keep waiting, destroy the socket and raise an error."	| gotData |	gotData _ false.	[gotData]		whileFalse: [			gotData _ self waitForDataUntil: (Socket deadlineSecs: seconds).			gotData ifFalse: [				self isConnected ifFalse: [					self destroy.					self error: 'server closed connection'].				(self confirm: 'server not responding; keep trying?')					ifFalse: [						self destroy.						self error: 'no response from server']]].! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 6/8/1998 16:05'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.disney.com' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr _ NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 10).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result _ WriteStream on: (String new: 10000).	buf _ String new: 10000.	totalBytes _ 0.	t _ Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes _ s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes _ totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	(StringHolder new contents: (result contents))		openLabel: 'HTTP Test Result: URL Contents'.! !This is a first cut at a simple MIDI output port.!!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:48'!close	"Close this MIDI port."	portNumber ifNil: [^ self].	self primMIDIClosePort: portNumber.		portNumber _ nil.	lastCommandByteOut _ nil.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:40'!ensureOpen	"Make sure this MIDI port is open. It is good to call this before starting to use a port in case an intervening image save/restore has caused the underlying hardware port to get closed."	| portNum |	portNumber ifNil: [^ self openOnPortNumber: 'Use "openOn:" to open a MIDI port initially'].	portNum _ portNumber.	self close.	self openOnPortNumber: portNum.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 9/10/1998 18:48'!openOnPortNumber: portNum	"Open this MIDI port on the given port number."	self close.	portNumber _ portNum.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: InterfaceClockRate.	lastCommandByteOut _ Array new: 16 withAll: 0.  "initialize running status state for output"! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 15:55'!midiCmd: cmd channel: channel byte: dataByte	"Immediately output the given MIDI command with the given channel and argument byte to this MIDI port. Assume that the port is open."	self primMIDIWritePort: portNumber		from: (ByteArray			with: (cmd bitOr: channel)			with: dataByte)		at: 0.! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 15:54'!midiCmd: cmd channel: channel byte: dataByte1 byte: dataByte2	"Immediately output the given MIDI command with the given channel and argument bytes to this MIDI port. Assume that the port is open."	self primMIDIWritePort: portNumber		from: (ByteArray			with: (cmd bitOr: channel)			with: dataByte1			with: dataByte2)		at: 0.! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/10/1998 18:39'!midiOutput: aByteArray	"Output the given bytes to this MIDI port immediately. Assume that the port is open."	self primMIDIWritePort: portNumber from: aByteArray at: 0.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:11'!primMIDIClosePort: portNum	<primitive: 521>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:11'!primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."	<primitive: 526>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:14'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	<primitive: 529>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'class initialization' stamp: 'jm 9/10/1998 15:33'!initialize	"SimpleMIDIPort initialize"	InterfaceClockRate _ 1000000.	DefaultPortNumber _ 0.! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:36'!openDefault	"Answer a new instance of me opened on the default MIDI port."	^ self openOnPortNumber: DefaultPortNumber! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:38'!openOnPortNumber: portNum	"Answer a new instance of me open on the given MIDI port."	^ super new openOnPortNumber: portNum! !Inst vars (converting to morphic events)hostView -- SketchMorph we are working on.stampForm -- Stamp is stored here.canvasRectangle -- later use boundspalette -- the PaintBox interface Morphdirty -- not usedcurrentColor ticksToDwell rotationCenter registrationPoint newPicBlock -- do this after paintingaction -- selector of painting actionpaintingForm -- our copycomposite -- now paintArea origin.  world relative.  stop using it.dimForm -- SketchMorph of the dimmed background.  Opaque.  		installed behind the editor morph.buff brush -- 1-bit Form of the brush, paintingFormPen formCanvas -- Aim it at paintingForm to allow it to draw ovals, rectangles, lines, etc.picToComp dimToComp compToDisplay -- used to composite -- obsoletepicToBuff brushToBuff buffToBuff buffToPic rotationButton scaleButton -- submorphs, handles to do these actions.strokeOrigin -- During Pickup, origin of rect. cumRot cumMag -- cumulative for multiple operations from same originalundoBuffer lastEvent currentNib -- 1 bit deep form.For now, we do not carry the SketchMorph's registration point, rotation center, or ticksToDwell.New -- using transform morphs to rotate the finished player.  How get it rotated back and the rotationDegrees to be right?  We cancel out rotationDegrees, so how remember it?Registration point convention:  In a GraphicFrame, reg point is relative to this image's origin.During painting, it is relative to canvasRectangle origin, and thus us absolute within the canvas.  To convert back, subract newBox origin.Be sure to convert back and forth correctly.  In deliverPainting. initializeFromFrame:inView: !!SketchEditorMorph methodsFor: 'initialization' stamp: 'sw 8/5/1998 20:12'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	| w aPaintBox aPal  aPosition |	(w _ aPasteUpMorph world) addMorphFront: self.	aPaintBox _ w paintBox.	(aPal _ aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPosition _ aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[aPosition _ aPaintBox position].	hostView _ aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	canvasRectangle _ bounds translateBy: w viewBox origin.	aPaintBox position: aPosition.	palette _  aPaintBox.	w addMorphFront: aPaintBox.  "bring to front"	palette position: aPosition.	paintingForm _ Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[aSketchMorph rotationDegrees: 0.		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth"		rotationCenter _ aSketchMorph rotationCenter]! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 8/2/1998 13:39'!addRotationScaleHandles	"Rotation and scaling handles"	| fwdButton pt toggle |	rotationButton _ SketchMorph new form: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep to: self.	rotationButton on: #mouseStillDown send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways to\rotate yourpicture.' withCRs.	scaleButton _ SketchMorph new form: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep to: self.	scaleButton on: #mouseStillDown send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to change\the sizeof your picture.' withCRs.	fwdButton _ PolygonMorph new.	pt _ "rotationButton topRight" bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseStillDown send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to point\in the directionI go forward.' withCRs.	toggle _ EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	"Put cursorback"	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,\how should itspicture change?\It can rotate, face left or right,\face up or down, or notchange.' withCRs.	self setProperty: #rotationStyle toValue: hostView rotationStyle.	self forward: hostView setupAngle direction: fwdButton.	"Set to its current value"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 8/5/1998 20:13'!cancelOutOfPainting	self delete.	dimForm ifNotNil: [dimForm delete].	emptyPicBlock value.	"note no args to block!!"	hostView changed.	^ nil	"Tell them we cancelled"! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 7/30/1998 16:21'!dimTheWindow	"Do not call twice!!  Installs a morph with the background behindme.  6/12/97 12:29 tk"	| dim map notTrans |	"create a dim version of the stuff on the screen"	"dim _ Form fromDisplay: canvasRectangle."	dim _ owner imageFormForRectangle: self bounds.	dim fill: dim boundingBox		rule: (dim depth < 16 ifTrue: [Form and] ifFalse: [Form under])		fillColor: (Color pixelScreenForDepth: dim depth).	map _ (Color cachedColormapFrom: dim depth to: dim depth) copy.	map _ map collect: [:c |		c = 0 ifTrue: [Color white pixelValueForDepth: dim depth]ifFalse: [c]].	notTrans _ BitBlt toForm: dim.	notTrans colorMap: map; sourceForm: dim; combinationRule: Form over;		destRect: dim boundingBox; sourceOrigin: 0@0; copyBits.	dimForm _ SketchMorph new form: dim.	dimForm position: self position.	owner privateAddMorph: dimForm atIndex: (owner submorphs indexOf:self)+1.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^true! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^true! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 7/30/1998 17:30'!forward: evt direction: button	"Move the forward direction arrow of this painting.  When the usersays forward:, the object moves in the direction of the arrow.  evt may bean Event (from the user moving the arrow), or an initial number ofdegrees."	| center dir ww ff |	center _ bounds center "+ (rotationButton width - 6 @ 0)".	evt isNumber ifTrue: [dir _ Point r: 100 degrees: evt - 90.0"convert to 0 on X axis"]		ifFalse: [dir _ evt cursorPoint - center].	ww _ (bounds height min: bounds width)//2 - 7.	button setVertices: (Array		with: (center + (Point r: ww degrees: dir degrees))		with: (center + (Point r: ww-15 degrees: dir degrees))).	(ff _ self valueOfProperty: #fwdToggle) position:		(center + (Point r: ww-7 degrees: dir degrees + 6.5)) - (ffextent // 2).	self showDirType.! !The morph that results when the user draws a color bitmap using the PaintBox (SketchEditorMorph and PaintBoxMorph).  forwardDirection is the angle at which the object will go forward.  When the rotationStyle is not #normal, then forwardDirection is any angle, while the rotation is highly restricted.  If flexed, this is remembered by the Transform morph.  For non-normal rotationStyle, it is rotationDegrees.setupAngle (a property) is where the user put the green arrow to indicate which direction on the picture is forward.  When #normal, draw the morph initially at (0.0 - setupAngle).  The enclosing TransformationMorph then rotates it to the true angle. rotationDegrees  In a #normal object, rotationDegrees is constant an equal to setupAngle.	For non-normal, it is the direction the object is going.When repainting, set it back to its original state. The green arrow is set to setupAngle, and the sketch is shown as drawn originally (rotationDegrees = 0). rotationStyle = normal (turns), leftRight, upDown, fixed.  When leftRight upDown or fixed, bit map has severe restrictions.!!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:11'!forwardDirection	"Return my forward direction.  If #normal I am not flexed."	^ rotationStyle == #normal 		ifTrue: [0.0]		ifFalse: [rotationDegrees]	"fwd dir kept here when leftRight, upDown, none"! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:52'!forwardDirection: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) abs <= 0.0001		ifTrue: [self removeProperty: #forwardDirection]		ifFalse: [self setProperty: #forwardDirection toValue: degrees].! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 9/9/1998 13:15'!originalForm: aForm	originalForm _ aForm! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 11:54'!setupAngle	"Return the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	^ (self valueOfProperty: #setupAngle) ifNil: [0.0]! !!SketchMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 12:53'!setupAngle: degrees	"Set the forward direction of the original Form. Angles are in degrees, increasing clockwise like a compass. Up is zero degrees."	(0.0 - degrees) abs <= 0.0001		ifTrue: [self removeProperty: #setupAngle]		ifFalse: [self setProperty: #setupAngle toValue: degrees].! !!SketchMorph methodsFor: 'drawing' stamp: 'tk 8/2/1998 14:35'!doesOwnRotation	"When not #normal, don't let to TransformMorph to rotate my image"	^ rotationStyle ~~ #normal! !!SketchMorph methodsFor: 'drawing' stamp: 'tk 8/2/1998 12:05'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| adjustedAngle smoothPix pair |	(rotationStyle = #normal)		ifTrue: [adjustedAngle _ 0.0 - self setupAngle]			"let TransformationMorph do directional image turn, we subtract green arrow angle"		ifFalse: [adjustedAngle _ 0.0].	"leftRight, upDown, none"	((adjustedAngle = 0.0) and: [0.0@0.0 = scalePoint])		ifTrue: [			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: ["do the actual rotation!!"			((scalePoint x < 1.0) or: [scalePoint y < 1.0])				ifTrue: [smoothPix _ 2]				ifFalse: [smoothPix _ 1].			pair _ WarpBlt				rotate: originalForm				degrees: adjustedAngle negated				center: rotationCenter				scaleBy: self scalePoint				smoothing: smoothPix.			rotatedForm _ pair first.			offsetWhenRotated _ pair last].	((rotationStyle = #leftRight) and: [rotationDegrees < 0.0]) ifTrue: [		"headed left; use flipped"		rotatedForm _ rotatedForm flipBy: #horizontal centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + 			(((2 * (rotationCenter x - (originalForm width // 2)))@0) * scalePoint).		^ self].	((rotationStyle = #upDown) and: [(rotationDegrees > 90.0) or: 		[rotationDegrees < -90.0]]) ifTrue: [			"headed down; use flipped"			rotatedForm _ rotatedForm flipBy: #vertical centerAt: 0@0.			offsetWhenRotated _ offsetWhenRotated + 				((0@(2 * (rotationCenter y - (originalForm height // 2)))) * scalePoint).			^ self].! !!SketchMorph methodsFor: 'menu' stamp: 'tk 7/6/1998 15:31'!editDrawing	self flag: #deferred.  "Don't allow this if the user is already in paint mode, because it creates a very strange situation."	"costumee ifNotNil: [self forwardDirection: costumee direction]."  "how say this?"	self editDrawingIn: self pasteUpMorph forBackground: false! !!SketchMorph methodsFor: 'menu' stamp: 'sw 9/23/1998 10:57'!editDrawingIn: aPasteUpMorph forBackground: forBackground	| w oldRotation bnds sketchEditor |	w _ aPasteUpMorph world.	w stopRunningAll; abandonAllHalos.	w displayWorld.	oldRotation _ rotationDegrees.	forBackground		ifTrue:			[bnds _ aPasteUpMorph boundsInWorld]		ifFalse:			[bnds _ (self boundsInWorld expandBy: (60 @ 60)) intersect: self world bounds.			bnds _ (aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds].	sketchEditor _ SketchEditorMorph new.	forBackground ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor initializeFor: self inBounds: bnds pasteUpMorph: aPasteUpMorph.		"self rotationDegrees: 0.  inside the init"	self rotationDegrees: oldRotation.  "restore old rotation so that cancel leaves it right"	sketchEditor		afterNewPicDo: [:aForm :aRect |			self form: aForm.			self topRendererOrSelf position: aRect origin.			self rotationStyle: sketchEditor rotationStyle.			self setupAngle: sketchEditor forwardDirection.			self rotationDegrees: sketchEditor forwardDirection.			aPasteUpMorph playfield ifNotNil: "Show the right viewer"				[self presenter drawingJustCompleted: self].			forBackground ifTrue: [self goBehind]]  "shouldn't be necessary"		ifNoBits: ["If no bits drawn.  Must keep old pic.  Can't have no picture"			aPasteUpMorph standardPalette ifNotNil:				[aPasteUpMorph standardPalette viewMorph: self]]! !!SketchMorph methodsFor: 'menu' stamp: 'di 8/1/1998 10:02'!setRotationCenter	| oldRotation p oldScale |	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	scalePoint _ 1.0@1.0.	self rotationDegrees: 0.0.	self world displayWorld.	Cursor crossHair showWhile:		[p _ Sensor waitButton - self world viewBox origin].	p _ self transformFromWorld transform: p.	Sensor waitNoButton.	self rotationCenter: p - bounds origin.	scalePoint _ oldScale.	self rotationDegrees: oldRotation.! !!SketchMorph methodsFor: 'change reporting' stamp: 'tk 7/6/1998 14:26'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	(rotationStyle == #none and: [scalePoint = (1.0@1.0)])		ifTrue: [			"zero rotation and scale; use original Form.			All normal rotation handled by TransformMorph.rotationDegrees:"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [self generateRotatedForm].	"changes offsetWhenRotated"	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SketchMorph methodsFor: 'other' stamp: 'sw 6/15/1998 15:01'!addOptionalHandlesTo: aHalo box: box	aHalo addHandleAt: box rightCenter color: Color lightGray on: #mouseDown send: #editDrawing to: aHalo innerTarget! !My instances are 30-bit numbers, stored in twos complement form. The allowable range is approximately +- 1 billion (see SmallInteger minVal, maxVal).!!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!clone! !!SmallInteger methodsFor: 'copying' stamp: 'tk 8/19/1998 16:04'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !Ordinary ReferenceStreams assume that the layout of instance variables in an object on the disk is the same as the layout of that class in memory now.  And it assumes that the class has the same name as before.  SmartRefStream allows one to bring in objects whose instance variables or class name have changed.  1/13/97 tk>>>>See SmartRefStream.aComment for an example.<<<< The basic principal is that object conversion to a new version needs to be done after the fact.  SmartRefStream records the names of the instance variables of all outgoing classes.  Adjustments are done later when the file is read in.* Allows incoming object to have fewer instance variables than the current class.* Works best with only one (large) tree of objects per file.  Can nextPut: more than once, but each gets its own class structure description, which is big.  * Writes triplets of (version, class structure array, object) on the file.* Version of a class is indicated by the first letters of all instance varaibles followed by a class version number.  Form has inst vars "bits width height depth offset", so version 2 of it has version tag #bwhdo2.* Methods to convert versions of objects are named 	Form new convertbwhdo2: aDictionary bwhdo3: aSmartRefStream.		Note that aDictionary has (old inst var name -> value) * Prompts the user to write (or file in) a conversion method when needed.* Allows a change of instance vars in a superclass to be handled by just one conversion method.  Figures out what to do to the subclasses.* Allows mixing cole for filing in, and raw objects.  The file can start out in the normal fileOut format.  Definitions of new classes on the front and an object are at the end.structures 	Dictionary of (#Rectangle -> #(<classVersionInteger> 'origin' 'corner')).  Inst 				var names are strings.steady 		Set of Classes who have the same structure now as on the incoming file.				Includes classes with same inst vars except for new ones added on the end.reshaped 	Dictionary of Classes who have a different structure now as on the incoming file.  				Includes those with same inst vars but new version number.				(old class name -> method selector to fill in data for version to version)renamed	Dictionary of Classes who have a different name. 				(old class name symbol -> new class name).  Then look new class up in reshaped.topCall		Tells if next or nextPut: are working on the top object in the tree.  			nil if outside, #marked if internal call.>>>>> See DataStream.typeIDFor: for where the tangle of objects is clipped, so the whole system will not be written on the file.No object that is written on the file is ever a class.  All class definitions are filed in.UniClasses are classes for the instance specific behavior of just one instance.  Subclasses of Player are an example.  When a UniClass is read in, and a class of the same name already exists, the incoming one is renamed.  ObjectScanner converts the filed in code.Values in instance variables of UniClasses are stored in the array that tells the class structure.  It is the fourth of the four top level objects.  #(version (class-structure) the-object ((#Player25 scripts slotInfo costumeDictionary) (#Player26 scripts slotInfo costumeDictionary))).Future:* Someday will prompt for a new version number when there are new inst vars with same initials, and tells how to make conversion work when some files have already been written.* There should be a separate subclass for doing veryDeepCopy (in memory).  Currently, any object that has objectToStoreOnDataStream return an object other than self does this:  The new object (a DiskProxy) is traced.  When it comes time to go through the fields of the old object, they are not found as keys in references (DiskProxies are there instead).  So the old field value is left in the new object.  That is OK for StrikeFont, Class, MetaClass, DisplayScreen.  But the DiskProxies are evaluated, which takes a lot of time.!!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 14:47'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs _ dummy references.	self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"	structures _ Dictionary new.	superclasses _ Dictionary new.	objCount _ refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	refs keysDo: [:each | 		cls _ each class.		cls class == Metaclass ifFalse: [			structures at: cls name put: false]].	"Save work by only computing inst vars once for each class"	newSupers _ Set new.	structures keysDo: [:nm | 		cls _ Smalltalk at: nm.		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls _ Smalltalk at: nm.		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	self saveClassInstVars.	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:09'!moreObjects	"Return true if there appears to be another object following this one on the file."	| byte |	byteStream atEnd ifTrue: [^ false].	"off end of file"	(byte _ byteStream peek) ifNil: [^ false].	"off end of file"	byte = 33 "$!! asciiValue" ifTrue: [^ false].	byte = 0 ifTrue: [^ false].	^ byte <= RefTypes size		"between 1 and 16"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall _ #marked.			version _ super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			ss _ super next.			ss class == Array ifFalse: [^ ss].  "just a regualr object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures _ ss at: 2.			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			object _ super next.	"all the action here"			self restoreClassInstVars.		"for UniClasses. version 4"			topCall _ nil.	"reset it"			object]		ifFalse:			[super next]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 09:01'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall _ anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info _ self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount _ 0.				progressBar _ bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		topCall _ progressBar _ nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:00'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall == nil 		ifTrue:			[topCall _ anObject.			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor cursorPoint				from: 0 to: 10				during: [:bar |					info _ self instVarInfo: anObject].			self uniClasesDo: [:cls | cls error: 'Class defn not written out.  Proceed?'].			'Writing an object file' displayProgressAt: Sensor cursorPoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount _ 0.					progressBar _ bar.					super nextPut: info.					super nextPut: anObject.	"<- the real writing"					"Class inst vars not written here!!"].			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall _ progressBar _ nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!noHeader	"Signal that we've already dealt with the version and structure array, and are now reading objects."	topCall _ #marked.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 9/9/1998 14:01'!restoreClassInstVars	"Install the values of the class instance variables of UniClasses (i.e. scripts slotInfo).  classInstVars is ((#Player25 scripts slotInfo) ...)"	| normal aName newName newCls trans rList |	self moreObjects ifFalse: [^ self]. 	"are no UniClasses with class inst vars" 	classInstVars _ super next.	"Array of arrays"	normal _ Object class instSize.	"might give trouble if Player class superclass changes size"	(structures at: #Player ifAbsent: #()) = #(0 'dependents' 'costume') ifTrue: [		trans _ 1].	"now (0 costume costumes).  Do the conversion of Player class 			inst vars in Update 509."	classInstVars do: [:list |		aName _ (list at: 1) asSymbol.		rList _ list.		newName _ renamed at: aName ifAbsent: [aName].		newCls _ Smalltalk at: newName 				ifAbsent: [self error: 'UniClass definition missing'].		(trans == 1 and: [newCls inheritsFrom: Player]) ifTrue: [			"remove costumeDictionary from Player class inst vars"			rList _ rList asOrderedCollection.			rList removeAt: 4].	"costumeDictionary's value"		newCls class instSize = (normal+(rList size)-1) ifFalse: [			self error: 'UniClass superclass class has changed size'].			"Need to install a conversion method mechanism"		2 to: rList size do: [:ii |			newCls instVarAt: normal+ii-1 put: (rList at: ii)]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:28'!saveClassInstVars	"Install the values of the instance variables of UniClasses.  classInstVars is an array of arrays (#Player3 (Player3 class's inst var scripts) (Player3 class's inst var slotInfo) ...) "	| normal mySize list |	classInstVars _ OrderedCollection new: 100.	normal _ Object class instSize.	self uniClasesDo: [:aUniClass | 		mySize _ aUniClass class instSize.		mySize = normal ifFalse: [			list _ OrderedCollection new.			list add: aUniClass name.	"a symbol"			normal+1 to: mySize do: [:ii | 				list addLast: (aUniClass instVarAt: ii)]].		classInstVars add: list asArray].	classInstVars _ classInstVars asArray.	! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 09:02'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	self setStream: aByteStream reading: true.	ScannedObject _ self next.	byteStream ascii.	byteStream next == $!! ifFalse: [		byteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 08:56'!setStream: aStream reading: isReading	"Initialize me. "	super setStream: aStream reading: isReading.	steady _ Set new.	#(Array Dictionary Association String SmallInteger) do: [:sym |		steady add: (Smalltalk at: sym)].		"These must stay constant.  When structures read in, then things can change."	reshaped ifNil: [reshaped _ Dictionary new].			"(old class name -> method selector to fill in data for version to version)"	renamed ifNil: [renamed _ Dictionary new].		"(old class name symbol -> new class name)"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:32'!uniClassInstVarsRefs: dummy	"If some of the objects seen so far are instances UniClasses, check the UniClasses for extra class inst vars, and send them to the steam also.  The new objects get added to (dummy references), where they will be noticed by the caller.  They will wind up in the structures array and will be written on the disk by class." | uniClasses normal more aUniClass mySize |"Any classes used in the structure of classInstVars must be written out also!!	dummy nextPut: (OrderedCollection new).But for now, only uses Arrays."uniClasses _ Set new.normal _ Object class instSize.more _ true.[more] whileTrue: [	more _ false.	dummy references keysDo: [:each | "any faster way to do this?"		(aUniClass _ each class) isSystemDefined ifFalse: [			(uniClasses includes: aUniClass name) ifFalse: [				mySize _ aUniClass class instSize.				normal+1 to: mySize do: [:ii | 					more _ true.					dummy nextPut: (aUniClass instVarAt: ii)].				uniClasses add: aUniClass name]]]]."References dictionary is modified as the loop proceeds, but we will catch any we missed on the next cycle."! !!Socket methodsFor: 'waiting' stamp: 'tk 9/22/1998 15:18'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	[self isConnected & 	 (dataArrived _ self primSocketReceiveDataAvailable: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'tk 9/22/1998 15:18'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone _ self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!Socket class methodsFor: 'instance creation' stamp: 'ls 9/14/1998 06:44'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ self new initialize.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'ls 9/12/1998 19:18'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	Socket initializeNetwork.	^ super new initialize! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/15/1998 13:03'!asByteArray	"Answer a ByteArray containing my sample data serialized in most-significant byte first order."	| sampleCount bytes dst s |	sampleCount _ self monoSampleCount.	bytes _ ByteArray new: 2 * sampleCount.	dst _ 0.	1 to: sampleCount do: [:src |		s _ self at: src.		bytes at: (dst _ dst + 1) put: ((s bitShift: -8) bitAnd: 255).		bytes at: (dst _ dst + 1) put: (s bitAnd: 255)].	^ bytes	! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:49'!downSampledLowPassFiltering: doFiltering	"Answer a new SoundBuffer half the size of the receiver consisting of every other sample. If doFiltering is true, a simple low-pass filter is applied to avoid aliasing of high frequencies. Assume that receiver is monophonic."	"Details: The simple low-pass filter in the current implementation could be improved, at some additional cost."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	doFiltering		ifTrue: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put:					(((self at: i) + (self at: i + 1)) bitShift: -1)]]		ifFalse: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put: (self at: i)]].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:52'!extractLeftChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the left channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	1 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:53'!extractRightChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the right channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	2 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer class methodsFor: 'instance creation' stamp: 'jm 8/15/1998 14:35'!fromByteArray: aByteArray	"Convert the given ByteArray (stored with the most significant byte first) into 16-bit sample buffer."	| n buf src w |	n _ aByteArray size // 2.	buf _ SoundBuffer newMonoSampleCount: n.	src _ 1.	1 to: n do: [:i |		w _ ((aByteArray at: src) bitShift: 8) + (aByteArray at: src + 1).		w > 32767 ifTrue: [w _ w - 65536].		buf at: i put: w.		src _ src + 2].	^ buf! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 9/11/1998 15:34'!initialize	"SoundPlayer initialize"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothing, especially during other activities. If it is too high, there will be an overly long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. It is typically in the range 50-200."	"SoundPlayer initialize; shutDown; startUp"	SamplingRate _ 22050.	BufferMSecs _ 100.	Stereo _ true.	UseReverb ifNil: [UseReverb _ true].! !!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 8/13/1998 15:00'!bufferMSecs	^ BufferMSecs! !!SoundPlayer class methodsFor: 'playing' stamp: 'di 8/5/1998 23:08'!isPlaying: aSound	^ ActiveSounds includes: aSound! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 17:54'!resumePlaying: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	"Implementation detail: On virtual machines that don't support the quickstart primitive, you may need to edit this method to pass false to resumePlaying:quickStart:."	self resumePlaying: aSound quickStart: true.! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 18:02'!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	Preferences disableSounds ifTrue: [^ self].	doQuickStart _ quickStart.	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		self startUp.		doQuickStart _ false].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart _ false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 8/19/1998 08:11'!startReverb	UseReverb _ true.	ReverbState _ ReverbSound new		tapDelays: #(1601 7919) gains: #(0.12 0.07).! !!SoundRecorder methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:32'!initialize	"SoundRecorder new"	stereo _ false.	samplingRate _ SoundPlayer samplingRate.	recordLevel _ 0.5.	recordedBuffers _ OrderedCollection new: 1000.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:03'!recordLevel	^ recordLevel! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:04'!recordLevel: level	"Set the desired recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	"Details: On the Macintosh, the lowest possible record level attenuates the input signal, but does not silence it entirely." 	recordLevel _ (level asFloat min: 1.0) max: 0.0.	recordProcess ifNotNil: [		self primSetRecordLevel: (1000.0 * recordLevel) asInteger].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 7/4/1998 14:35'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: (SoundPlayer samplingRate)		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 13:37'!convertssrrbpmmscn0: varDict ssrrrbpmmscn0: smartRefStrm	"These variables are automatically stored into the new instance ('stereo' 'samplingRate' 'recordedBuffers' 'recordProcess' 'bufferAvailableSema' 'paused' 'meteringBuffer' 'meterLevel' 'soundPlaying' 'currentBuffer' 'nextIndex' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('recordLevel' ) and deal with the information in ()"! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:47'!comment	comment ifNil: [^ ''] ifNotNil: [^ comment].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!comment: aString	aString isEmpty		ifTrue: [comment _ nil]		ifFalse: [comment _ aString].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:45'!contentsMorph	^ contentsMorph! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 12:41'!saveMorph: aMorph author: authorString	"Save the given morph as this page's contents. Update its thumbnail and inform references to this URL that the page has changed."	"Details: updateThumbnail releases the cached state of the saved page contents after computing the thumbnail."	| n |	contentsMorph _ aMorph.	n _ aMorph knownName.	n ifNotNil: [self title: n].	creationAuthor ifNil: [		creationAuthor _ authorString.		creationTime _ Time totalSeconds].	lastChangeAuthor _ authorString.	lastChangeTime _ Time totalSeconds.	self updateThumbnail.	self postChangeNotification.! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 17:45'!thumbnail	^ thumbnail! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 13:47'!title	title ifNil: [^ ''] ifNotNil: [^ title].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!title: aString	aString isEmpty		ifTrue: [title _ nil]		ifFalse: [title _ aString].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 10:51'!url	url ifNil: [^ ''] ifNotNil: [^ url].! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/25/1998 10:51'!url: aString	aString isEmpty		ifTrue: [url _ nil]		ifFalse: [url _ aString].! !!SqueakPage methodsFor: 'private' stamp: 'jm 6/25/1998 12:14'!postChangeNotification	"Inform all thumbnails and books that this page has been updated."	URLMorph allInstancesDo: [:m | m pageHasChanged: self].	WebBookMorph allInstancesDo: [:m | m pageHasChanged: self].! !!SqueakPage methodsFor: 'private' stamp: 'jm 6/18/1998 11:31'!updateThumbnail	"Update my thumbnail from my morph."	| f scale scaleX scaleY shrunkF |	contentsMorph ifNil: [thumbnail _ nil. ^ self].	f _ contentsMorph imageForm.	scaleX _ MaxThumbnailWidthOrHeight asFloat / f height.	scaleY _ MaxThumbnailWidthOrHeight asFloat/ f width.	scale _ scaleX min: scaleY.  "choose scale that maintains aspect ratio"	shrunkF _ (f magnify: f boundingBox by: scale@scale smoothing: 2).	thumbnail _ Form extent: shrunkF extent depth: 8.  "force depth to be 8"	shrunkF displayOn: thumbnail.	contentsMorph allMorphsDo: [:m | m releaseCachedState].! !!SqueakPage class methodsFor: 'all' stamp: 'jm 6/18/1998 11:15'!initialize	"SqueakPage initialize"	MaxThumbnailWidthOrHeight _ 60.! !!SqueakPage class methodsFor: 'all' stamp: 'sw 7/6/1998 11:49'!newURLAndPageFor: aMorph	"Create a new SqueakPage whose contents is the given morph. Assign a URL for that page, record it in the page cache, and answer its URL."	| pg newURL stamp |	pg _ self new.	stamp _ Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: aMorph author: stamp.	newURL _ SqueakPageCache generateURL.	SqueakPageCache atURL: newURL put: pg.	^ newURL ! !A global cache of web pages known to this Squeak image. All pages currently live only in memory; management of pages stored on servers and the local disk will be added later.Since there is a single, global page cache, it is implemented entirely as class methods.!!SqueakPageCache class methodsFor: 'class initialization' stamp: 'jm 6/16/1998 18:12'!initialize	"SqueakPageCache initialize"	(PageCache notNil and: [PageCache size > 0]) ifTrue: [		(self confirm: 'Are you certain that you wish to delete all SqueakPages?')			ifFalse: [^ self]].	NextURL _ 1.	PageCache _ Dictionary new: 100.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:06'!allURLs	"Answer a collection of URLs for all pages in the cache."	^ PageCache keys! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:07'!atURL: aURLString	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	^ PageCache at: aURLString		ifAbsent: [self error: 'no page with the given URL in the cache']! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/16/1998 15:39'!atURL: aURLString ifAbsent: failBlock	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	^ PageCache at: aURLString ifAbsent: failBlock! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:07'!atURL: aURLString put: aSqueakPage	"Store the given page in the cache entry for the given URL."	aSqueakPage url: aURLString.	PageCache at: aURLString put: aSqueakPage.! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/25/1998 11:08'!generateURL	"Generate an unused URL for an in-memory page."	"SqueakPageCache generateURL"	| url |	NextURL ifNil: [NextURL _ 1].	NextURL _ NextURL + 1.	url _ 'memoryPage', NextURL printString.	[PageCache includesKey: url] whileTrue: [		NextURL _ NextURL + 1.		url _ 'memoryPage', NextURL printString].	^ url! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'jm 6/16/1998 18:12'!removeURL: aURLString	"Remove the cache entry for the given URL. Do nothing if it has no cache entry."	PageCache removeKey: aURLString ifAbsent: [].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'jm 6/25/1998 11:11'!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[true] whileTrue: [		Smalltalk garbageCollect.		unreferenced _ PageCache keys.		URLMorph allInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		WebBookMorph allInstancesDo: [:book |			book urls do: [:url | unreferenced remove: url ifAbsent: []]].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]].! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'jm 6/25/1998 13:00'!releaseCachedStateOfPages	"Note: This shouldn't be necessary if we are doing a good job of releasing cached state as we go. If running this doesn't do very much, we're doing well!!"	"SqueakPageCache releaseCachedStateOfPages"	| memBytes |	memBytes _ Smalltalk garbageCollect.	PageCache do: [:pg |		pg contentsMorph allMorphsDo: [:m | m releaseCachedState]].	^ (Smalltalk garbageCollect - memBytes) printString, ' bytes recovered'! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/19/1998 17:05'!close	"Close this file."	fileID ifNotNil: [		self primClose: fileID.		fileID _ nil].! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/19/1998 17:01'!closed	"Answer true if this file is closed."	^ fileID isNil! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 16:20'!ensureOpen	"Make sure that this file really is open."	self closed ifTrue: [^ self reopen].	(self primSizeNoError: fileID) ifNotNil: [^ self].	self reopen.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:41'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	fileID _ self primOpen: fileName writable: writeMode.	fileID ifNil: [^ nil].  "allows sender to detect failure"	name _ fileName.	rwmode _ writeMode.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:58'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [self primCloseNoError: fileID].	self open: name forWrite: rwmode.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readOnly	"Make this file read-only."	rwmode _ false.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readWrite	"Make this file writable."	rwmode _ true.! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:16'!directory	"Return the directory containing this file."	^ FileDirectory forFileName: self fullName! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!fullName	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!name	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 14:11'!next	"Answer the next byte from this file, or nil if at the end of the file."	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [^ buffer1 at: 1]		ifFalse: [^ nil].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPutAll: aString	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: 1 count: aString size.	^ aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:56'!verbatim: aString	"A version of nextPutAll that can be called knowing it won't call nextPut: "	^ self nextPutAll: aString! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 150>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primClose: id	"Close this file."	<primitive: 151>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 151>! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:04'!primGetPosition: id	"Get this files current position."	<primitive: 152>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:06'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 153>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 154>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:09'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 155>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSize: id	"Answer the size of this file."	<primitive: 157>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 157>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 158>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File write failed'.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:13'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: fileName forWrite: true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:14'!isAFileNamed: fileName	"Answer true if a file of the given name exists."	| f |	f _ self new open: fileName forWrite: false.	f ifNil: [^ false].	f close.	^ true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:14'!newFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, ask the user what to do."	| dir localName choice newName |	(self isAFileNamed: fileName)		ifFalse: [^ self new open: fileName forWrite: true].	"file already exists:"	dir _ FileDirectory forFileName: fileName.	localName _ FileDirectory localNameFor: fileName.	choice _ (PopUpMenu		labels:'overwrite that filechoose another namecancel')		startUpWithCaption: localName, 'already exists.'.	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fileName forWrite: true].	choice = 2 ifTrue: [		newName _ FillInTheBlank request: 'Enter a new file name' initialAnswer: fileName.		^ self newFileNamed: newName].	self error: 'Please close this to abort file opening'.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:16'!oldFileNamed: fileName	"Open an existing file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	| selection |	(self isAFileNamed: fileName) ifTrue:		[^ self new open: fileName forWrite: true].	"File does not exist..."	selection _ (PopUpMenu labels:'create a new filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: fileName forWrite: true].	selection = 2 ifTrue:		[^ self oldFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: fileName))].	self halt! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jm 9/21/1998 13:19'!readOnlyFileNamed: fileName	"Open an existing file with the given name for reading."	| selection |	(self isAFileNamed: fileName) ifTrue:		[^ self new open: fileName forWrite: false].	"File does not exist..."	selection _ (PopUpMenu labels: 'choose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self readOnlyFileNamed:			(FillInTheBlank request: 'Enter a new file name'						initialAnswer: (FileDirectory localNameFor: fileName))].	self halt! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 6/29/1998 18:02'!frozenPlayfieldBorderColor	^ Color red! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 6/30/1998 09:50'!runningPlayfieldBorderColor	^ Color green! !!StandardScriptingSystem methodsFor: 'font & color choices' stamp: 'sw 9/14/1998 14:41'!statusColorSymbolFor: statusSymbol	#(	(normal					green)		(ticking					blue)		(paused					red)		(mouseDown				yellow)		(mouseStillDown			lightYellow)		(mouseUp				lightBlue)		(mouseEnter				lightBrown)		(mouseLeave			lightRed)		(mouseEnterDragging	lightGray)		(mouseLeaveDragging	darkGray)		(keyStroke				lightGreen)) do:			[:pair | statusSymbol == pair first ifTrue: [^ pair second]].		^ #blue! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'sw 7/4/1998 14:36'!patchInNewStandardPlayerForm	"ScriptingSystem patchInNewStandardPlayerForm"	self formDictionary at: 'standardPlayer' put:		(Form extent: 3@3	depth: 16 fromArray: #( 17969 0 1177634353 1177616384 17969 0) offset: 0@0)! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 9/10/1998 14:23'!initializeHelpStrings	"ScriptingSystem initializeHelpStrings"	HelpStrings _ IdentityDictionary new.	#((heading		number		'Which direction the object isfacing.  0 is straight up') (x				number		'The x coordinate, measured from the left of the container')(y				number'The y-coordinate, measured upwardfrom the bottom of the container')(colorUnder		color'The color under thecenter of the object')(penDown		boolean'Whether the object''s penis down (true) or up (false)')(penColor		color'The color of the object''s pen')(penSize			number'The size of the object''s pen')(colorSees		boolean'Whether a given color in theobject is over another given color')(colorSees		boolean'Whether any part of thisobject is over the specified color')(scaleFactor		number'The amount by whichthe object is scaled')(width			number'The distance between theleft and right edges of the object')(height			number'The distance between thetop and bottom edges of the object')(isOverColor		color'Whether the object isover the given color')(color			color'The object''s interior color')(borderWidth	number'The width of the object''s border')(borderColor		color'The color of the object''s border')(cursor			number'The index of the chosen element')(valueAtCursor	player'The chosen element')(leftRight		number'The horizontal displacement')(upDown		number'The vertical displacement')(angle			number'The angular displacement')(amount		number'The amount of displacement')(mouseX		number'The x coordinate ofthe mouse pointer')(mouseY		number'The y coordinate ofthe mouse pointer')(left		number'My left edge, measured fromthe left edge of the World')(right		number'My right edge, measured fromthe left edge of the world')(top		number'My top edge, measured downwardfrom the top edge of the world')(bottom		number'My bottom edge, measured downwardfrom the top edge of the world')(tryMe			command'Click here to run this script once;hold button down to run repeatedly.')(try			command'Click here to run this command once,with parameters as seen right here.Hold button down to run repeatedly')(dismiss			command'Click here to dismiss me')(addYesNoToHand	command'Press here to tear off a TEST/YES/NO unit whichyou can drop into your script')(chooseTrigger	command'Press here to choose whenthis script should be run')(offerScriptorMenu	command'Press here to get a menu ofoptions for this Scriptor')(objectNameInHalo  control'Object''s name -- To change:click here; backspace over old name,type in new name; hit ENTER')(userSlot		control'This is an instance variabledefined by you.  Click here tochange its type')		) do: [:triplet | HelpStrings at: triplet first put: triplet third]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/22/1998 22:13'!cleanupsForRelease	"Miscellaneous space cleanups to do before a release."	"EToySystem cleanupsForRelease"	Socket deadServer: ''.  "Don't reveal any specific server name"	HandMorph initialize.  "free cached ColorChart"	PaintBoxMorph releaseTemporaryForms.	PaintBoxMorph prototype stampHolder clear.  "clear stamps"	PaintBoxMorph prototype delete.  "break link to world, if any"	Smalltalk removeKey: #AA ifAbsent: [].	Smalltalk removeKey: #BB ifAbsent: [].	Smalltalk removeKey: #CC ifAbsent: [].	Smalltalk removeKey: #DD ifAbsent: [].	Smalltalk removeKey: #Temp ifAbsent: [].	ScriptingSystem reclaimSpace.	Smalltalk cleanOutUndeclared.	Smalltalk reclaimDependents.	Smalltalk forgetDoIts.	Smalltalk removeEmptyMessageCategories.	Symbol rehash! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'di 9/16/1998 00:38'!prepareForExternalReleaseNamed: aReleaseName	"ScriptingSystem prepareForExternalReleaseNamed: '2.2Beta'"	EToySystem stripMethodsForExternalRelease.	self class compile: 'guessDOLProxy	"deleted for external release"' classified: 'stripped'.	ScriptingSystem saveFormsToFileNamed: aReleaseName, '.Dis.Forms'.	ScriptingSystem stripGraphicsForExternalRelease.	ScriptingSystem cleanupsForRelease.	ScreenController initialize.! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 6/25/1998 12:29'!reasonablePaintingExtent	"Answer a reasonable maximum extent for the painting area when the user paints a new objects or repaints an old one.  Temporarily made large here in order *not* to apply any restraint, as per current sentiment"	^  1800 @ 1800! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/14/1998 14:39'!standardEventStati	^ #(mouseDown mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging keyStroke)! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 8/22/1998 22:12'!stripGraphicsForExternalRelease	"ScriptingSystem stripGraphicsForExternalRelease"	| aDict replacement |	aDict _ ScriptingSystem formDictionary.	replacement _ aDict at: 'Gets'.	#('BadgeMiniPic' 'BadgePic' 'Broom' 'CedarPic' 'CollagePic' 'CoverMain' 'CoverSpiral' 'CoverTexture' 'Fred' 'ImagiPic' 'KayaPic' 'StudioPic')		do:			[:aKey | aDict at: aKey put: replacement]! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 9/10/1998 14:42'!wordingForOperator: aString	| toTest |	toTest _ aString asString.	#(	(forward:				'forward by')		(turn:					'turn by')		(beep:					'make sound')		(bounce:				'bounce')		(stopProgramatically	'stop')		(stopScript				'stop script')		(wearCostumeOf:		'look like')		(moveToward:			'move toward')		(goToRightOf:			'align after')		(stopScript:				'stop script')		(startScript:				'start script')		(pauseScript:			'pause script')		(max:					'max')		(min:					'min')		(liftAllPens				'lift all pens')		(lowerAllPens			'lower all pens')		(clearTurtleTrails		'clear pen trails')		(seesColor:				'is over color')		(=						'=?'))	do:		[:pair | toTest = pair first ifTrue: [^ pair second]].	^ toTest! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 8/5/1998 00:10'!initializePartsBin	"ScriptingSystem initializePartsBin"	PartsBin _ Presenter new newStandardPartsBin! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 8/5/1998 00:09'!partsBin	PartsBin ifNil: [self initializePartsBin].	^ PartsBin veryDeepCopy! !!StandardScriptingSystem methodsFor: 'parts bin' stamp: 'sw 8/5/1998 00:36'!setPartsBinFrom: aMorph	PartsBin _ aMorph! !!StandardScriptingSystem methodsFor: 'stripped' stamp: 'di 9/23/1998 17:54'!guessDOLProxy	"deleted for external release"! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 9/10/1998 14:23'!initialize	"StandardScriptingSystem initialize"	"Sometimes this method is vacuously changed just to get it in a changeset so that its invocation will occur as part of an update"	self initializeSystemSlotDictionary.	self new initializeHelpStrings! !!StandardScriptingSystem class methodsFor: 'class initialization' stamp: 'sw 9/10/1998 14:21'!initializeSystemSlotDictionary	"StandardScriptingSystem initializeSystemSlotDictionary"	SystemSlotDictionary _ IdentityDictionary new.	#(		(heading		number)		(x				number)		(y				number)		(colorUnder		color)		(penDown		boolean)		(penColor		color)		(penSize			number)		(colorSees		boolean)		(seesColor		boolean)		(scaleFactor		number)		(width			number)		(height			number)		(isOverColor		color)		(color			color)		(borderWidth	number)		(borderColor		color)		(cursor			number)		(valueAtCursor	player)		(leftRight		number)		(upDown		number)		(angle			number)		(amount		number)		(left			number)		(right			number)		(top				number)		(bottom			number)		(mouseX			number)		(mouseY		number)) do:	[:pair | SystemSlotDictionary at: pair first put: pair second]! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'di 6/10/1998 15:10'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status _ #active.	view topView isCollapsed ifFalse: [model modelWakeUp].! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side _ #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:42'!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]. ].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:38'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p _ sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 _ p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 _ (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 _ f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 _ (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'jm 8/20/1998 18:29'!release	model windowIsClosing.	self isCollapsed ifTrue: [savedSubViews do: [:v | v release]].	super release.! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'framing' stamp: 'tk 8/11/1998 16:22'!expand	"If the receiver is collapsed, change its view to be that of all of its 	subviews, not its label alone. "	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame expandBy: borderWidth.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUp]! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 9/10/1998 09:43'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor.	labelText destinationForm: nil! !!Stream methodsFor: 'accessing' stamp: 'ls 9/12/1998 20:55'!upToEnd	"answer the remaining elements in the string"	| elements |	elements _ OrderedCollection new.	[ self atEnd ] whileFalse: [ 		elements add: self next ].	^elements! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 11:40'!print: anObject	anObject printOn: self! !!Stream methodsFor: 'printing' stamp: 'djp 7/21/1998 17:13'!printHtml: anObject	anObject printHtmlOn: self! !!StrikeFont methodsFor: 'accessing' stamp: 'tk 6/26/1998 16:45'!familySizeFace	"Answer an array with familyName, a String, pointSize, an Integer, and	faceCode, an Integer."	^Array with: name		with: self height		with: emphasis	"(1 to: 12) collect: [:x | (TextStyle default fontAt: x) familySizeFace]"! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:46'!objectToStoreOnDataStream	"I am about to be written on an object file.  Write a reference to a known Font in the other system instead.  "	"A path to me"	| eval |	(TextConstants at: #forceFontWriting ifAbsent: [false]) ifTrue: [^ self].		"special case for saving the default fonts on the disk.  See collectionFromFileNamed:"	emphasis > 0 ifTrue: [self error: 'Synthietic fonts do not get written out. Proceed for plain font.'].	eval _ 'StrikeFont familyName: #', self name ,' size: ', self height printString.		^ DiskProxy global: #Compiler selector: #evaluate: 			args: (Array with: eval).! !!StrikeFont methodsFor: 'file in/out' stamp: 'tk 6/26/1998 16:49'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name.	aStream space.	self height printOn: aStream.	aStream nextPut: $)! !!StrikeFont methodsFor: 'character shapes' stamp: 'di 9/20/1998 10:35'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle default fontAt: 1.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StrikeFont methodsFor: 'copying' stamp: 'tk 8/19/1998 16:15'!veryDeepCopyWith: deepCopier	"Return self.  I am shared.  Do not record me."! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tk 7/2/1998 16:44'!familyName: aName size: aSize	| aStyle both ind |	(aStyle _ TextStyle named: aName asSymbol) ifNil: [		both _ aName splitInteger.		(both at: 2) > 0 			ifTrue: ["old style"				ind _ #('ComicB' 'Comic' 'ComicAll') indexOf: (both at: 1).				ind = 0 ifTrue: [^ self familyName: (both at: 1) size: aSize].				aStyle _ TextConstants at: (#(ComicBold ComicPlain ComicPlain) at: ind)]			ifFalse: [aStyle _ TextStyle default]].	"Substitute. Read-only so OK not to copy"	^ aStyle fontOfSize: aSize! !!StrikeFont class methodsFor: 'examples' stamp: 'tk 6/26/1998 15:19'!update	"A temporary method to change the names of StrikeFonts.  New convention is that each StrikeFont is in a TextStyle that has only fonts of the same name (family).  The name of that TextStyle in TextConstants is the same name as the family name of this font.  Sizes are no longer in the name of the font."	"StrikeFont update"| sty |TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		"Transcript show: assoc key; space."		sty _ assoc value.		sty fontArray do: [:font | font name: assoc key]		]]].TextConstants associationsDo: [:assoc |	assoc value class == TextStyle ifTrue: [	(#(ComicAll DefaultTextStyle) includes: assoc key) ifFalse: [		sty _ assoc value.		sty fontArray do: [:font | 			(StrikeFont familyName: font name size: font height) == font ifFalse: [				self error: 'not same']]]]].! !!String methodsFor: 'accessing' stamp: 'wod 6/16/1998 15:24'!at: index put: aCharacter 	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	(aCharacter isKindOf: Character)		ifTrue: [				index isInteger				ifTrue: [self errorSubscriptBounds: index]				ifFalse: [self errorNonIntegerIndex]]		ifFalse: [self error: 'Strings only store Characters']! !!String methodsFor: 'accessing' stamp: 'tk 6/21/1998 11:41'!atPin: index 	"Return this element of an indexable object, letting the index wrap around from the end to the beginning.  See Object at:.  Needed here when index is not an integer and has to be coerced.  "	<primitive: 63>	^(super atWrap: index) asCharacter! !!String methodsFor: 'accessing' stamp: 'tk 8/31/1998 17:42'!findInsensitive: subStringLowercase allUpper: subStringUppercase	"Answer the index of subString within the receiver case insensitive. If the receiver does not contain subString, answer 0.  subStringLowercase and subStringUppercase must be identical except one is all lowercase and the other is all uppercase.  (pass these in so don't have to generate them every time when searching all symbols)  Caller must test for subStringLowercase being empty."	| index firstLo firstHi |	firstLo _ subStringLowercase first.	firstHi _ subStringUppercase first.	1 to: self size - subStringLowercase size + 1 do:		[:startIndex |		((self at: startIndex) = firstLo or: [(self at: startIndex) = firstHi]) ifTrue:			[index _ 1.			[(self at: startIndex+index-1) = (subStringLowercase at: index) or:				[(self at: startIndex+index-1) = (subStringUppercase at: index)]]					whileTrue:					[index = subStringLowercase size ifTrue: [^startIndex].					index _ index+1]]].	^ 0! !!String methodsFor: 'accessing' stamp: 'ls 8/17/1998 23:28'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	ans _ String indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:20'!indexOfAnyOf: aCharacterSet	"returns the index of the first character in the given set.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  ifAbsent: aBlock	"returns the index of the first character in the given set.  Returns the evaluation of aBlock if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1  ifAbsent: aBlock! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  startingAt: start	"returns the index of the first character in the given set, starting from start.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: start  ifAbsent: [ 0 ]! !!String methodsFor: 'accessing' stamp: 'ls 8/18/1998 00:27'!indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock	"returns the index of the first character in the given set, starting from start"	| ans |	ans _ String findFirstInString: self  inSet: aCharacterSet byteArrayMap startingAt: start.	ans = 0 		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!String methodsFor: 'accessing' stamp: 'ls 9/10/1998 22:27'!linesDo: aBlock	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"	| start end |	start _ 1.	[ start <= self size ] whileTrue: [		end _ self indexOf: Character cr  startingAt: start  ifAbsent: [ self size + 1 ].		end _ end - 1.		aBlock value: (self copyFrom: start  to: end).		start _ end + 2. ].! !!String methodsFor: 'comparing' stamp: 'di 9/14/1998 16:29'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	aString species == String ifFalse: [^ false].	^ (self compare: self with: aString collated: AsciiOrder) = 2! !!String methodsFor: 'comparing' stamp: 'di 9/20/1998 14:33'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^ (self compare: self with: aString collated: CaseSensitiveOrder) <= 2! !!String methodsFor: 'converting' stamp: 'ls 9/5/1998 01:19'!asIRCLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase, where 'lowercase' is by IRC's definition"	^self collect: [ :c | c asIRCLowercase ]! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 08:33'!asLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase."	^self copy asString translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'ls 6/29/1998 00:35'!asUrl	"convert to a Url"	"'http://www.cc.gatech.edu/' asUrl"	"msw://chaos.resnet.gatech.edu:9000/' asUrl"	^Url absoluteFromText: self! !!String methodsFor: 'converting' stamp: 'ls 7/15/1998 18:40'!asUrlRelativeTo: aUrl	^aUrl newFromRelativeText: self! !!String methodsFor: 'converting' stamp: 'ls 9/10/1998 08:48'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'ls 8/12/1998 23:31'!encodeForHTTP	"change dangerous characters to their %XX form, for use in HTTP transactions"	| encodedStream |	encodedStream _ WriteStream on: (String new).		self do: [ :c |		c isSafeForHTTP ifTrue: [ encodedStream nextPut: c ] ifFalse: [			encodedStream nextPut: $%.			encodedStream nextPut: (c asciiValue // 16) asHexDigit.			encodedStream nextPut: (c asciiValue \\ 16) asHexDigit.		]	].	^encodedStream contents. ! !!String methodsFor: 'converting' stamp: 'tk 7/2/1998 16:32'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.  '43Sam' yields #(43 'Sam').  'Try90' yields #('Try' 90) "	| pos |	(pos _ self findFirst: [:d | d isDigit not]) == 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 			with: (self copyFrom: pos to: self size)].	(pos _ self findFirst: [:d | d isDigit]) == 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 10:31'!translateFrom: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	String translate: self  from: start to: stop table: table! !!String methodsFor: 'converting' stamp: 'ls 8/18/1998 07:44'!translateToLowercase	"Translate all characters to lowercase, in place"	self translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 08:30'!translateWith: table	"translate the characters in the string by the given table, in place"	^self translateFrom: 1 to: self size table: table! !!String methodsFor: 'converting' stamp: 'sw 9/2/1998 17:09'!truncateWithElipsisTo: maxLength	"Return myself or a copy suitably shortened but with elipsis added"	^ self size <= maxLength		ifTrue:			[self]		ifFalse:			[(self copyFrom: 1 to: (maxLength - 3)), '...']	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"! !!String methodsFor: 'converting' stamp: 'ls 8/20/1998 10:43'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	| out pos textEnd |	self isEmpty ifTrue: [ ^self ].	out _ WriteStream on: (String new: self size).	pos _ 1.   "current position in a scan through aString"	"handle the case of initial separators"	self first isSeparator ifTrue: [		out nextPut: Character space.		pos _ self indexOfAnyOf: CSNonSeparators ifAbsent: [ self size + 1 ] ].	"central loop: handle a segment of text, followed possibly by a segment of whitespace"	[ pos <= self size ] whileTrue: [ 		"handle a segment of text..."		textEnd _ self 			indexOfAnyOf: CSSeparators			startingAt: pos 			ifAbsent: [ self size + 1 ].		textEnd _ textEnd - 1.		out nextPutAll: (self copyFrom: pos to: textEnd).		pos _ textEnd + 1.		pos <= self size ifTrue: [			pos _ self 				indexOfAnyOf: CSNonSeparators				startingAt: pos				ifAbsent: [ self size + 1 ].			out nextPut: Character space  ] ].	^out contents! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayAt: aPoint 	"Display the receiver as a DisplayText at aPoint on the display screen."	self displayOn: Display at: aPoint! !!String methodsFor: 'displaying' stamp: 'di 5/28/1998 13:25'!displayOn: aDisplayMedium at: aPoint 	"Show a representation of the receiver as a DisplayText at location	aPoint on aDisplayMedium."	(self asDisplayText foregroundColor: Color black backgroundColor: Color white)		displayOn: aDisplayMedium at: aPoint! !!String methodsFor: 'displaying' stamp: 'sw 7/3/1998 18:31'!newTileMorphRepresentative	^ TileMorph new setLiteral: self! !!String methodsFor: 'internet' stamp: 'ls 9/15/1998 02:47'!replaceHtmlCharRefs        | pos ampIndex scIndex special specialValue outString outPos newOutPos |        outString _ String new: self size.        outPos _ 0.        pos _ 1.                [ pos <= self size ] whileTrue: [                 "read up to the next ampersand"                ampIndex _ self indexOf: $& startingAt: pos ifAbsent: [0].                                ampIndex = 0 ifTrue: [                        pos = 1 ifTrue: [ ^self ] ifFalse: [ ampIndex _ self size ] ].                newOutPos _ outPos + ampIndex - pos.                outString                        replaceFrom: outPos + 1                        to: newOutPos                        with: self                        startingAt: pos.                outPos _ newOutPos.                pos _ ampIndex.                ampIndex <= self size ifTrue: [                        "find the $;"                        scIndex _ self indexOf: $; startingAt: ampIndex ifAbsent: [ self size + 1 ].                        special _ self copyFrom: ampIndex+1 to: scIndex-1.                               specialValue _ String valueOfHtmlEntity: special.                         specialValue                                ifNil: [                                        "not a recognized entity.  wite it back"								  scIndex > self size ifTrue: [ scIndex _ self size ].                                        newOutPos _ outPos + scIndex - ampIndex + 1.                                        outString                                                replaceFrom: outPos+1                                                to: newOutPos                                                with: self                                                startingAt: ampIndex.                                        outPos _ newOutPos.]                                ifNotNil: [                                        outPos _ outPos + 1.                                        outString at: outPos put: specialValue.].                                                pos _ scIndex + 1. ]. ].        ^outString copyFrom: 1 to: outPos! !!String methodsFor: 'internet' stamp: 'ls 7/22/1998 22:19'!unescapePercents	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"	| inStream ans c tok asciiVal |	inStream _ ReadStream on: self.	ans _ WriteStream on: String new.	[ c _ inStream next.  c = nil ] whileFalse: [ 		c = $+ ifTrue: [ ans nextPut: $ ] ifFalse: [			(c = $%) ifTrue: [				tok _ inStream next: 2.				asciiVal _ Integer readFrom: (ReadStream on: tok) base: 16.				ans nextPut: (Character value: asciiVal). ]			ifFalse: [				ans nextPut: c ] ] ].	^ans contents ! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:17'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably inprepration for sending a string over the Internet"	| cr lf |	cr _ Character cr.	lf _ Character linefeed.	^self class streamContents: [ :stream |		self do: [ :c |			stream nextPut: c.			c = cr ifTrue:[ stream nextPut: lf ]. ] ].! !!String methodsFor: 'internet' stamp: 'ls 7/27/1998 23:16'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are allvalid line endings.  Replace each occurence with a single CR"	| cr lf input c |	cr _ Character cr.	lf _ Character linefeed.	^String streamContents: [ :str |		input _ ReadStream on: self.		[input atEnd] whileFalse: [			c _ input next.			c == cr ifTrue: [				str cr.				input peek == lf ifTrue: [ input next ] ]			ifFalse: [				c == lf ifTrue: [ str cr ] ifFalse: [ strnextPut: c ] ] ] ]! !!String methodsFor: 'internet' stamp: 'ls 7/1/1998 02:26'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote _ self first.	(quote = $' or: [ quote = $" ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'testing' stamp: 'ls 7/4/1998 19:17'!isAllSeparators	"whether the receiver is composed entirely of separators"	self do: [ :c | c isSeparator ifFalse: [ ^false ] ].	^true! !!String class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 22:29'!crlf	"Answer a string containing a carriage return and a linefeed."	^ self with: Character cr with: Character lf! !!String class methodsFor: 'initialization' stamp: 'di 9/20/1998 14:09'!initialize  "String initialize"	| order |	AsciiOrder _ (0 to: 255) as: ByteArray.	CaseInsensitiveOrder _ AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder _ ByteArray new: 256 withAll: 255.	order _ -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order _ order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order _ order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable _ String new: 256.	Character allCharacters do: [ :c |		LowercasingTable at: (c asciiValue+1) put: c asLowercase ].		"CR and LF--characters that terminate a line"	CSLineEnders _ CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!String class methodsFor: 'primitives' stamp: 'ls 9/14/1998 07:50'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 244>	self var: #aString declareC: 'unsigned char *aString'.	self var: #inclusionMap  declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i _ start.	stringSize _ aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i _ i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!String class methodsFor: 'primitives' stamp: 'ls 8/17/1998 23:26'!indexOfAscii: num inString: aString  startingAt: start	|  stringSize |	<primitive: 245>	self var: #aCharacter  declareC: 'int num'.	self var: #aString declareC: 'char *aString'.	stringSize _ aString size.	start to: stringSize do: [ :pos |		(aString at: pos) asciiValue = num ifTrue: [ ^pos ] ].	^0.! !!String class methodsFor: 'primitives' stamp: 'ls 8/15/1998 12:15'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 243>	self var: #table  declareC: 'unsigned char *table'.	self var: #aString  declareC: 'unsigned char *aString'.	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!String class methodsFor: 'internet' stamp: 'ls 8/15/1998 20:22'!valueOfHtmlEntity: specialEntity	specialEntity = 'quot' ifTrue: [ ^$" ].	specialEntity = 'lt' ifTrue: [ ^$< ].	specialEntity = 'amp' ifTrue: [ ^$& ].	specialEntity = 'gt' ifTrue: [ ^ $>].	specialEntity = 'nbsp' ifTrue: [ ^ Character nbsp ].	(specialEntity beginsWith: '#') ifTrue: [		^Character value: (specialEntity copyFrom: 2 to: specialEntity size) asNumber ].	^nil ! !!StringHolder methodsFor: 'initialize-release' stamp: 'di 5/27/1998 21:21'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	window openInWorld! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 8/4/1998 18:21'!openAsMorphLabel: labelString  inWorld: aWorld	"Workspace new openAsMorphLabel: 'Workspace'"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	window openInWorld: aWorld! !!StringHolder methodsFor: 'code pane menu' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| shiftMenu |	^ shifted 	ifFalse: [aMenu 		labels: PluggableTextController yellowButtonMenu labelString 		lines: PluggableTextController yellowButtonMenu lineArray		selections: PluggableTextController yellowButtonMessages]	ifTrue: [shiftMenu _ PluggableTextController shiftedYellowButtonMenu.		aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: PluggableTextController shiftedYellowButtonMessages]! !!StringHolder methodsFor: 'code pane menu' stamp: 'wod 5/29/1998 16:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 8/14/1998 06:51'!copyName	"Copy the current selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[ParagraphEditor new clipboardTextPut: selector asString asText]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 9/8/1998 13:25'!messageListSelectorTitle	| selector aString aStamp |	Preferences showTimeStampsInMenuTitles		ifFalse:			[^ nil].	(selector _ self selectedMessageName) ifNotNil:		[aString _ selector truncateWithElipsisTo: 28.		^ (aStamp _ self timeStamp) size > 0			ifTrue:				[aString, String cr, aStamp]			ifFalse:				[aString]].	^ nil! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/17/1998 10:58'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:51'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/26/1998 08:46'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords codeController |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	changeRecords size <= 1 ifTrue: [self changed: #flash.  ^ self beep].	codeController _ Smalltalk isMorphic		ifTrue: [(self dependents detect: [:v | v isKindOf: PluggableTextMorph])]		ifFalse: [(self dependents detect: [:v | v isKindOf: PluggableTextView]) controller].		"later find a better way to do this!!"	self contents: (changeRecords at: 2) string notifying: codeController.	self changed: #contents! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 8/18/1998 12:16'!timeStamp	| class selector recordList |	(selector _ self selectedMessageName) ifNotNil:		[class _ self selectedClassOrMetaClass.		(recordList _ class changeRecordsAt: selector) size > 0			ifTrue:				[^ recordList first stamp]].	^ nil! !!StringMorph methodsFor: 'initialization' stamp: 'sw 6/15/1998 15:34'!addOptionalHandlesTo: aHalo box: box	self flag: #deferred.	"Eventually...	self addFontHandlesTo: aHalo box: box"! !!StringMorph methodsFor: 'accessing' stamp: 'sw 6/10/1998 18:03'!valueAsConstant	^ self contents! !SwikiAction is the action to implement a Swiki, a collaborative website.This is a web server in Squeak.  Each page served has an "Edit this Page"link.  The syntax rules for editing pages (from any web browser) are in thefile FormattingRules.The pages may be viewed from any web browser, and the URL ishttp://thisMachine:80/OurOwnArea.1  ('OurOwnArea' is the name of the Swikiarea.)  See http://guzdial.cc.gatech.edu:8080/myswiki for an examplefocused on discussing Swikis.Swiki is based on the Wiki Server, designed and implemented by WardCunningham.  See the original Wiki at http://c2.com/cgi-bin/wiki, or theSqueak-focused one at http://c2.com:8080/See PWS class howToStart.Modified by Ted Kaehler to have all state on the disk at all times.  Do notsnapshot the image during normal server operation.  Restart the server byloading all state from the disk.Each separate Wiki is a folder inside the Server folder.  The name of thefolder is the name of the Wiki.  Each page is a file.  (Inefficient on Macsbecause of large minimum page size, but that's an OS problem.)  Allversions of all pages are kept.  Each page contains chunks, just like achanges file.  Each chunk is one version of one page:self name: 'Ted''s Page' date: '1/28/1998' time: '12:47:21' by: 'tk' text:'Here is the body of the page' back: 116!!The last item is number of bytes in the chunk.  It is the number of bytesfrom the start of the chunk to just in front of the number.  This allowsback-chaining to old versions.  On startup, the chunk is executedexplicitly using evaluate:for:logged:.  It supplies the page name to aSwikiPage and installs it in the URLmap.  By doing this for all files inthe folder, the map (url->page) is built.  During operation, the chunk isnot executed.  Instead, take the file directly, look at 'back:' at the end,jump back to the start of the chunk, scan for 'text:' and read the text.The looks of the pages served are controlled by templates.  They live inthe 'swiki' folder in the 'Server' folder.  See page.html for how to changethe look of a served page.  Beware that templates are cached byHTMLformatter.  If you change a template, you will not see the effect untilyou reload the Swiki.A symbol *append here* may be added anywhere in the page.  Clicking on itwill bring up a page with a text editing form.  The what you type will beinserted just before the *append here* marker.  This allows append-onlypages, or multiple questions with places to add to the answer.!!SwikiAction methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:58'!formatter	^formatter! !!SwikiAction methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:58'!formatter: anHTMLformatter	formatter _ anHTMLformatter! !!SwikiAction methodsFor: 'accessing' stamp: 'TPR 7/21/1998 18:06'!url	"Answer the receiver's 'name'."	^name! !!SwikiAction methodsFor: 'save and restore' stamp: 'ls 7/27/1998 23:26'!fixAllLineEndings	"for each page in the swiki, fixes line endings to be CR only.This is used to bring older Swikis up to date with the newer convention.If a page has no LF's, then it is left alone"	| origText newText pagesDone |	pagesDone _ 0.	'updating pages...' displayProgressAt: Sensor cursorPoint from: 0to: urlmap pages size during: [ :bar |		urlmap pages do: [ :page |			origText _ page text.			newText _ origText withSqueakLineEndings.			origText = newText ifFalse: [ page text: newText ].			pagesDone _ pagesDone + 1.			bar value: pagesDone. ] ]! !!SwikiAction methodsFor: 'save and restore' stamp: 'mjg 8/28/1998 21:05'!restore: nameOfSwiki	"Read all files in the directory 'nameOfSwiki'.  Reconstruct theurl map."	| map page folder dir rep templateFolder |	map _ URLmap new.	self map: map.	self formatter: (HTMLformatter new initialize).	self formatter specialCharacter: $*.	self name: nameOfSwiki.	templateFolder _ 'swiki'.	self source: templateFolder,(ServerAction pathSeparator).	map action: self.	map pages: (Dictionary new).	map directory: nameOfSwiki. "This is where the pages are."	folder _ (ServerAction serverDirectory), nameOfSwiki.	dir _ FileDirectory on: folder.	dir fileNames do: [:fName |		rep _ fName detect: [:char | char isDigit not] ifNone: [$3].		rep isDigit ifTrue: ["all are digits"			page _ self class pageClass new.			page fromFileNamed: folder,(ServerActionpathSeparator),fName action: self.			(page time isNil) ifTrue: [page time: Time now].			map at: page name put: page]].	PWS link: nameOfSwiki to: self.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/28/1998 20:59'!browse: pageRef from: request	"Just reply with a page in HTML format"	| formattedPage htmlForUser |	formattedPage _ pageRef copy.	"Make a copy, then format the text."	formattedPage formatted: (formatter swikify: pageRef text			linkhandler: [:link | urlmap					linkFor: link					from: request peerName					storingTo: OrderedCollection new					page: formattedPage]).	"format using the cached formatter"	htmlForUser _ ((self formatterFor: 'page') format: formattedPage).	htmlForUser size = 0 ifTrue: [self error: 'template file''page.html'' not found'].	request reply: htmlForUser.! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 8/31/1998 15:32'!edit: pageRef from: request	request reply: (HTMLformatter evalEmbedded:							(self fileContents:source , 'edit.html')						with: pageRef).	pageRef noteEditRequest.	^ self! !!SwikiAction methodsFor: 'URL processing' stamp: 'mjg 9/10/1998 15:31'!inputFrom: request	"Take user's input and respond with a searchresult or store the edit""	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  store textin a specific place	{swikiname}.searchresult  {with a field named 'searchFor'} conducts thesearch for that text and sends back the result"	| coreRef page theText |	coreRef _ request message size < 2		ifTrue: ['1']		ifFalse: [request message at: 2].	coreRef = 'searchresult' ifTrue: [		"If contains search string, do search"		request reply: PWS crlf,			((self formatterFor: 'recent') format: (urlmapsearchFor:						(request fields at:'searchFor' ifAbsent:['nothing']))).		^ #return].	(theText _ request fields at: 'text' ifAbsent: [nil]) ifNotNil: [		"It's a response from an edit, so store the page"		page _ urlmap atID: coreRef.		page user: request peerName.  "Address is machine, user only iflogged in"		 page pageStatus = #new ifTrue: [page pageStatus: #standard].		page _ urlmap			storeID: coreRef			text: theText withSqueakLineEndings			from: request peerName.		^ self].	"return self means do serve the edited pageafterwards"	request fields keys do: [:aTag |		(aTag beginsWith: 'text-') ifTrue: [			urlmap				storeID: coreRef				text: (request fields at: aTag)withSqueakLineEndings				insertAt: (aTag copyFrom: 6 to: aTag size).	"string"			^ self]].	"oops, a new kind!!"	Transcript show: 'Unknown data from client. '; show: request fieldsprintString; cr.! !!SwikiAction methodsFor: 'URL processing' stamp: 'BJP 9/7/1998 00:55'!pageURL: aPage	"make the URL suited to aPage in this Action"	^(self name),'.',aPage coreID! !!SwikiAction methodsFor: 'URL processing' stamp: 'tk 9/16/1998 15:58'!process: request	"URLs are of the form:	{swikiname} 		browse Front Page	{swikiname}.{coreID} browse the page number coreID	{swikiname}.{coreID}.edit  request to edit the page	{swikiname}.{coreID}.versions show the last three versions of the page	{swikiname}.{coreID}  {with a field named 'text'}  store an edited page	{swikiname}.{coreID}.insert.{placeID}  request to insert text in aspecific place in a page	{swikiname}.{coreID}  {with a field named 'text-placeID'}  storetext in a specific place	-------	{swikiname}.{coreID}.all  displays the page and all its references	{swikiname}.searchresult  conducts the search and displays the result	{swikiname}.recent  to bring up the recent changes list	{swikiname}.{coreID}.searchresult  returns a search for referencesto coreID's key	{swikiname}.{picName}.gif   or .jpeg, .jpg, .jpe, .html (upper orlower case) return	the picture or static page stored in the {swikiname} folder."	| coreRef pageRef command formattedPage theLast pvtPageRef htmlForUser |	self log: request.	theLast _ request message last asLowercase.	theLast = 'gif' ifTrue: [^ self process: request MIMEtype: 'image/gif'].	theLast = 'jpeg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpg' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'jpe' ifTrue: [^ self process: request MIMEtype: 'image/jpeg'].	theLast = 'html' ifTrue: [^ self process: request MIMEtype: 'text/html'].	request reply: PWS success;		reply: PWS contentHTML.	Transcript show: 'In process: ' , request message printString; cr.	request message size < 2		ifTrue: [coreRef _ '1']		ifFalse: [coreRef _ request message at: 2].	request fields ifNotNil: ["Are there input fields?"			(self inputFrom: request) == #return ifTrue: [^ self]].	coreRef = 'recent' ifTrue:			[request reply: PWS crlf , ((self formatterFor: 'recent')						format: urlmap recent).			^ self].	request reply: PWS crlf.	"End of header.  Move this when we want to report more header"	"At this point, coreRef is a page reference"	pageRef _ urlmap atID: coreRef.	request message size > 2 ifTrue:			["SearchResult, All, Versions, or Edit"			command _ request message at: 3.			command = 'edit' ifTrue:					[request reply: ((self formatterFor: 'edit') format: pageRef).					pageRef noteEditRequest.					^ self].			command = 'versions' ifTrue:					[request reply: ((self formatterFor: 'versions') format: pageRef).					^self].			command = 'insert' ifTrue:					[pvtPageRef _ pageRef clone.					pvtPageRef placeID: (request message at: 4).	"so <?request placeID?> can get it"					htmlForUser _ ((self formatterFor: 'insert') format: pvtPageRef).					htmlForUser size = 0 ifTrue: [						self error: 'template file ''insert.html'' not found'].					request reply: htmlForUser.					pageRef noteEditRequest.					^ self].			command = 'searchresult' ifTrue:					[request reply: ((self formatterFor: 'results')						format: (urlmap searchFor: pageRef name)).					^ self].			command = 'all' ifTrue:					[formattedPage _ urlmap allPagesFrom: pageRef for: request.					request reply: ((self formatterFor: 'page') format: formattedPage).					^ self].			(request message at: 1) = (request message at: 2) ifTrue: [				request reply: '<h1>Your original url has a slash after it.  Please remove it.</h1>'.				request message: (request message copyFrom: 2 to: request message size).				^ self process: request].	"(success and contentHTML will be sent twice!!)"			Transcript show: 'Unknown command: ' , command; cr.			^ self].	"Just a browse"	^ self browse: pageRef from: request! !!SwikiAction methodsFor: 'URL processing' stamp: 'ls 4/18/98 18:09'!smtlk: request	"Return Smalltalk sourcecode.  URL =machine:80/myswiki.smtlk.Point|at;  included are:  Point|at:Point|Comment   Point|Hierarchy  Point|Definition   Point|class|x;y;  NOTE:use ; instead of : in selector names!!!!!!"	| classAndMethod set |	classAndMethod _ request message atPin: 3.	classAndMethod _classAndMethod copyReplaceAll: '|' with: ' '.	classAndMethod _classAndMethod copyReplaceAll: ';' with: ':'.	set _ LinkedMessageSetmessageList: (Array with: classAndMethod).	request reply: PWS crlf,((self formatterFor: 'smtlk') format: set).! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 5/5/98 17:20'!clearFormatterCache	"remove all formatters"	formatters _ nil.! !!SwikiAction methodsFor: 'formatters' stamp: 'ls 5/7/98 22:04'!formatterFor: formatterName	"get the formatter for the given name.uses lazy initialization.  Could eventually check whether the on-disk filehas been updated."	| fileName fileModTime |		"first,create the dictionary of formatters if it isn't already"	formatters== nil ifTrue: [		formatters _ Dictionary new. ].	"get the filename for the template source"	fileName _formatterName, '.html'.	"get its modification time"	fileModTime_ ((FileDirectory on: ServerAction serverDirectory, source) entryAt:fileName) at: 3.	"create the formatter if necessary"	((formatters includesKey: formatterName) not or: [	((formatters at: formatterName) at: 2) < fileModTime ])	ifTrue: [		Transcript show: '(recompiling formatter ',formatterName, ')'; cr.		formatters at: formatterName put:(Array with:			(HTMLformatter forEvaluatingEmbedded: (selffileContents: (source, formatterName, '.html')))	with: fileModTime)	].	"return the formatter"	^(formatters at: formatterName) at: 1! !!SwikiAction class methodsFor: 'initialization' stamp: 'BJP 9/9/1998 21:41'!setUp: actionName	"Set up a named Swiki"	| action map page dir |	action _ self new.	map _ self mapClass new.	"URLmap or PURLmap"	action formatter: (HTMLformatter new initialize).	action formatter specialCharacter: $*.	action map: map.	action name: actionName.	action source: 'swiki',(ServerAction pathSeparator).	map action: action.	map pages: (Dictionary new).	map directory: actionName.	dir _ FileDirectory on: (ServerAction serverDirectory).	(dir directoryNames includes: actionName) ifFalse: [		^ self inform: 'You need to create a folder in Server called ',actionName].		"A directory in the ServerDirectory for storing pages."	page _ map newpage: actionName,': Front Page' from: 'Beginning'.	page pageStatus: #standard.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerActionserverDirectory),'swiki',				(ServerAction pathSeparator),'FrontPage')contentsOfEntireFile) with:actionName).	page _ map newpage: 'Formatting Rules' from: 'Beginning'.	page pageStatus: #standard.	page text: (HTMLformatter evalEmbedded:			((FileStream fileNamed: (ServerActionserverDirectory),'swiki',				(ServerAction pathSeparator),'FormattingRules')contentsOfEntireFile)with: actionName).	PWS link: actionName to: action.	^action! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/3/1998 21:32'!by	| who |	who _ user class == String					ifFalse: [address]					ifTrue: [user].		who ifNil: [who _ 'unknown user'].	^who.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 9/10/1998 15:26'!by: who	self address: who.! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 18:34'!date: anObject	"Set the receiver's instance variable 'date' to be anObject."		(anObject isKindOf: String)			ifTrue: [date _ anObject asDate]			ifFalse: [date := anObject]! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 9/1/1998 09:58'!name: anObject	"Set the receiver's instance variable 'name' to be anObject."	name := anObject.	^''! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/10/1998 14:14'!outputFormat	^self class outputFormat! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 19:41'!pageStatus	"The basic stati ;) are #new and #standard. If the pageStatus is nil,we make make the page #standard, as that is the old behavior. You could addother types to get e.g., different kinds of URLs, or to exclude pages froma search, or alter the formatter, or..."	pageStatus ifNil: [pageStatus _ #standard].	^pageStatus! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/3/1998 13:55'!pageStatus: aSymbol	"While I'm trying to be careful about default behavior if the type isunknown, one should still be careful to check all the places that pageTypeis used."	pageStatus _ aSymbol.! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID	"Temporarily hold onto the placeID value.  For putting into theFORM in insert.html"	^ temp! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/12/1998 22:50'!placeID: idNum	"Temporarily hold onto the placeID value.  For putting into theFORM in insert.html"	temp _ idNum! !!SwikiPage methodsFor: 'accessing' stamp: 'tk 7/13/1998 12:37'!text: aString	"Add onto the end of the file"	| this aFile start end realString |	realString _ self uniqueInsertionPoints: aString.	this _ String streamContents: [:ss |		ss nextPutAll: self chunk1.		realString storeOn: ss.		ss nextPutAll: ' back: '].	(aFile _ FileStream fileNamed: file) setToEnd.	start _ aFile position.	aFile nextChunkPut: this; skip: -1.	"undo the !! at end"	end _ aFile position.	aFile nextPutAll: (end - start) printString; nextPut: $!!; cr; close.! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 8/28/1998 20:37'!textVersion: steps	"One step back gets the original"	| theFile theText real bb gotTo |	theFile _ FileStream oldFileNamed: file.	theFile setToEnd.	steps timesRepeat: [bb _ self backupAChunk: theFile.].	bb = 0 ifTrue: ["Went back beyond beginning"		theFile close.		^'<Too Far Back>'.].	bb _ bb - 7.		"before the back:"	"Be careful about occurances of 'text:' in the name or other field"	[theFile match: 'text:'.	gotTo _ theFile position.	theFile upTo: $'; skip: -1.	theText _ theFile nextDelimited: $'.	real _ (ReadStream on: theText) nextDelimited: $!!.	"Removedouble !!"	theFile skipSeparators.	theFile position >= bb] whileFalse: [theFile position: gotTo].	theFile close.	^ real! !!SwikiPage methodsFor: 'accessing' stamp: 'mjg 8/28/1998 19:41'!time	"Answer the receiver's 'time'."	^time! !!SwikiPage methodsFor: 'accessing' stamp: 'BJP 9/8/1998 18:29'!time: anObject	"Set the receiver's instance variable 'time' to be anObject."	(anObject isKindOf: String)		ifTrue: [time _ anObject asTime]		ifFalse: [time := anObject]! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 20:36'!backupAChunk: aFile	"We are positioned at the end of a chunk.  Read the size of thischunk from its end.  Back up one chunk.  Return the position of the spacebefore the back number."	| back pp aPiece isDigitFlag |	aFile skip: -2.	isDigitFlag _ false.	[isDigitFlag] whileFalse:	[aPiece := aFile next. aPiece isNil ifTrue: [^0].	aPiece isDigit ifFalse: [aFile skip: -2] ifTrue: [isDigitFlag _true].].	"[aFile next isDigit] whileFalse: [aFile skip: -2]." "This wasTed's elegant version.									Theuglier one above is to be able to test backing up too far."	aFile skip: -2.	[pp _ aFile position + 1. aFile next isDigit] whileTrue: [		aFile skip: -2].	back  _ (aFile upTo: $!!) asNumber.	aFile position: pp; skip: 0-back.	^ pp "now positioned at the end"! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/7/1998 11:30'!chunk1	^self formatForOutput	"| who |	^ String streamContents: [:ss |		ss nextPutAll: 'self name: '; nextPutAll: name printString;		nextPutAll: ' date: '''; nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.  time print24: true on: ss.		who _ user class == String ifFalse: [address] ifTrue: [user].		who ifNil: [who _ 'unknown user'].		ss nextPutAll: ''' by: '; nextPutAll: who printString.		ss nextPutAll: ' text: ']"! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/10/1998 14:16'!formatForOutput	^ String streamContents: [:ss |		ss nextPutAll: 'self '.		self outputFormat do: [:block |							ss nextPutAll:(block value: self)					"ifError: [:msg :rec |							 ss nextPutAll:'*** ', rec asString, ': ', msgasString ]"].		ss nextPutAll: 'text: ']."		   nextPutAll: name printString;		   nextPutAll: ' date: ''';		   nextPutAll: date mmddyyyy.		ss nextPutAll: ''' time: '''.		     Time now print24: true on: ss.		who _ user class == String					ifFalse: [address]					ifTrue: [user].		who ifNil: [who _ 'unknown user'].		ss nextPutAll: ''' by: ';		   nextPutAll: who printString.		ss nextPutAll: ' text: ']"! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 20:15'!fromFileNamed: filePath action: aSwikiAction	"Fill in all parts of this page from the info in its file"	| theFile |	map _ aSwikiAction urlmap.	file _ filePath.	theFile _ FileStream oldFileNamed: file.	coreID _ theFile localName.	url _ aSwikiAction name, '.', coreID.	self scanFrom: theFile.	"name, date"! !!SwikiPage methodsFor: 'save & restore' stamp: 'mjg 8/28/1998 19:43'!name: pageName date: dateString time: timeString by: who text: theStringback: bytes	"Record the name of this page during startup.  When reading thepage in order to serve it, this is NOT executed.  The text is read from thefile explicitly."	name _ pageName.	date _ dateString asDate.	time _ timeString asTime.	address _ who! !!SwikiPage methodsFor: 'save & restore' stamp: 'BJP 9/8/1998 18:08'!text: theString back: bytes	"Record the name of this page during startup.  When reading the page inorder to serve it, this is NOT executed.  The text is read from the fileexplicitly.""Which means that you'd better not cascade text & back or you're royallyscrewed ;) BJP"! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/13/1998 13:33'!unique: aTag in: aSet	"If aTag is not in aSet, put it in and return aTag.  If it's there,make up a new tag, insert it, and return it.  For keeping insertion pointsin text unique, so can tell where to put incoming text."	| base new |	((aSet includes: aTag) not and: [aTag size > 0]) ifTrue: [aSet add:aTag.  ^ aTag].	base _ 0.	[new _ (100 atRandom + base) printString.		aSet includes: new] whileTrue:			[base _ base + 50].	aSet add: new.	^ new! !!SwikiPage methodsFor: 'insertion points' stamp: 'tk 7/14/1998 20:52'!uniqueInsertionPoints: aString	"Find all occurances of '*append here'.  Make them lower case.  Ifthey don't have a number after them, assign one.  Don't use the same numbertwice in this page.  Place ID can actually be any string."| sourceStream targetStream ids char pos inside rest |sourceStream := ReadStream on: aString.targetStream := WriteStream on: String new.ids _ Set new.	"id numbers that have been used"[sourceStream atEnd	] whileFalse: [	targetStream nextPut: (char _ sourceStream next).	char == $* ifTrue: [		pos _ sourceStream position.		inside _ sourceStream upTo: $*.		(inside asLowercase beginsWith: 'append here')			ifFalse: [sourceStream position: pos.	"ignore"				((inside = '') and: [sourceStream atEndnot]) ifTrue: [					targetStream nextPut: (char _sourceStream next)]]	"Honor **"			ifTrue: ["See if it has a number"				targetStream nextPutAll: 'append here '.				rest _ inside copyFrom: (13 min: insidesize +1) to: inside size.				targetStream nextPutAll: (self unique: restin: ids); nextPut: $*]]].^ targetStream contents! !!SwikiPage class methodsFor: 'initialization' stamp: 'BJP 9/7/1998 12:23'!initialize	"SwikiPage initialize"	OutputFormat _ OrderedCollection new.	OutputFormat		add: [:thePage | 'name: ', thePage name printString, '; '];		add: [:thePage | 'date: ', thePage date mmddyyyyprintString, '; '];		add: [:thePage | 'time: ''', thePage time asString, '''; '];		add: [:thePage | 'by: ', thePage by printString, '; '];		add: [:thePage | 'pageStatus: #', thePage pageStatus, '; ']";		add: [:thePage | 'text: ']."! !!SwikiPage class methodsFor: 'accessing' stamp: 'BJP 9/7/1998 11:32'!outputFormat	^OutputFormat! !!Symbol methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Symbol class methodsFor: 'access' stamp: 'tk 8/11/1998 22:12'!possibleSelectorsFor: misspelled	"Answer an ordered collection of possible corrections for the misspelled selector in order of likelyhood."	| numArgs table lookupString list binary |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	numArgs < 0 ifTrue: [ ^ OrderedCollection new: 0 ].	table _ (SelectorTables at: (numArgs + 1 min: SelectorTables size))				at: (lookupString at: 1) asciiValue - "($a asciiValue - 1)" 96.	list _ lookupString correctAgainst: table.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary _ misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | list addFirst: him]].	^ list! !!Symbol class methodsFor: 'access' stamp: 'tk 8/31/1998 17:48'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them.  Case-insensitive."	| size table candidate selectorList selectorTable keyLo keyHi |	keyLo _ aString asLowercase.	keyHi _ aString asUppercase.	selectorList _ OrderedCollection new.	keyLo size = 0 ifTrue: [^ selectorList].	"this test is necessary!!"	size _ keyLo size.	(SelectorTables size to: 1 by: -1) do:		[:j | selectorTable _ SelectorTables at: j.		1 to: 26 do: [:index |		table _ selectorTable at: index.		1 to: table size do: 			[:t | 			((candidate _ table at: t) == nil) ifFalse:				[candidate size >= size ifTrue:					[((candidate findInsensitive: keyLo 						allUpper: keyHi) > 0) ifTrue:							[selectorList add: candidate]]]]]].	^ selectorList"Symbol selectorsContaining: 'scon'    "! !!SyntaxError methodsFor: 'other' stamp: 'di 8/17/1998 10:28'!contents: aString notifying: aController	"Compile the code in aString and notify aController of any errors. If there are no errors, then automatically proceed."	(class compile: aString classified: category notifying: aController)		ifNil: [^ false]		ifNotNil: [aController hasUnacceptedEdits: false.  self proceed].! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 8/17/1998 10:22'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Syntax Error') model: aSyntaxError.	window addMorph: (PluggableListMorph on: aSyntaxError list: #list			selected: #listIndex changeSelected: nil menu: #listMenu:)		frame: (0@0 corner: 1@0.15).	window addMorph: (PluggableTextMorph on: aSyntaxError text: #contents			accept: #contents:notifying: readSelection: #contentsSelection			menu: #codePaneMenu:shifted:)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 8/17/1998 10:10'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"	World ifNotNil:		[self buildMorphicViewOn: aSyntaxError.		Project current spawnNewProcess.		^ Processor activeProcess suspend].	topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend.! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 8/5/1998 18:41'!browseChangedMessages	"Create and schedule a message browser on each method that has been 	changed."	SystemChanges isEmpty ifTrue: [^ self inform: 'There are no changed messagesin the current change set.'].	ChangedMessageSet openFor: SystemChanges! !!SystemDictionary methodsFor: 'browsing' stamp: 'jm 5/29/1998 14:30'!browseMethodsWithString: aString	"Launch a browser on all methods that contain string literals with aString as a substring. The search is case-sensitive, unless the shift key is pressed, in which case the search is case-insensitive (and consequently somewhat slower)."	| caseBlind testString suffix |	(caseBlind _ Sensor controlKeyPressed)		ifTrue:			[testString _ aString asLowercase.			suffix _ ' (case-blind)']		ifFalse:			[testString _ aString.			suffix _ ' (case-sensitive)'].	self browseAllSelect:			[:method |				method  hasLiteralSuchThat: [:lit |					lit class == String and:					[lit includesSubstring: testString caseSensitive: caseBlind not]]]		name:  'Methods with string ''', aString, '''', suffix		autoSelect: aString.! !!SystemDictionary methodsFor: 'class names' stamp: 'sw 8/11/1998 13:23'!removeClassFromSystemUnlogged: aClass	"Delete the class, aClass, from the system, but log the removal neither to the current change set nor to the changes log"	SystemOrganization removeElement: aClass name.	self removeKey: aClass name.	self flushClassNameCache! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 13:00'!discardMorphic	"Discard Morphic."	| subs |	subs _ OrderedCollection new.	Morph allSubclassesWithLevelDo: [:c :i | subs addFirst: c]		startingLevel: 0.	subs do: [:c | c removeFromSystem].	SystemOrganization removeCategoriesMatching: 'User Objects'.	SystemOrganization removeCategoriesMatching: 'Experimental-'.	SystemOrganization removeCategoriesMatching: 'Morphic-*'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/16/1998 14:59'!discardNetworking	"Discard the support for TCP/IP networking."	Smalltalk discardPluggableWebServer.	SystemOrganization removeCategoriesMatching: 'HTML-*'.	SystemOrganization removeCategoriesMatching: 'NetTools-*'.	SystemOrganization removeCategoriesMatching: 'Network-*'.	SystemOrganization removeCategoriesMatching: 'System-Network'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 13:27'!discardOddsAndEnds	"This method throws out lots of classes that are not frequently used."	"Smalltalk discardOddsAndEnds"	SystemOrganization removeCategoriesMatching: 'System-Serial Port'.	"old Form editor:"	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	Form removeSelector: #edit.	Smalltalk at: #FormView ifPresent:		[:c | c compile: 'defaultControllerClass  ^ NoController'			classified: 'controller access'].	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'Graphics-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	SystemDictionary removeSelector: #viewImageImports.	ScreenController removeSelector: #viewImageImports.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"curve fitting:"	Smalltalk at: #FormEditor ifPresent: [:c | c removeSelector: #curve].	Smalltalk removeClassNamed: #CurveFitter.	Smalltalk removeClassNamed: #LinearFit.	Smalltalk removeClassNamed: #Spline.	"experimental hand-drawn character recoginizer:"	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	Smalltalk removeClassNamed: #CharRecog.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"HTML formatted fileout support:"	StandardFileStream removeSelector: #asHtml.	Smalltalk removeClassNamed: #HtmlFileStream.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SystemMonitor.	Smalltalk at: #SampledSound ifPresent: [:c |		(Smalltalk confirm: 'Remove all sounds from the SampledSound library?')		ifTrue: [c initialize]].	#(Helvetica Palatino ComicAll Courier) do:		[:k | TextConstants removeKey: k].	(TextConstants at: #ComicBold) newFontArray:		((TextConstants at: #ComicBold) fontArray copyFrom: 1 to: 5).! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 11:55'!discardSoundSynthesis	"Discard the sound synthesis facilities, and the methods and classes that use it. This also discards MIDI."	Smalltalk discardMIDI.	Smalltalk removeClassNamed: #EnvelopeLineMorph.	Smalltalk removeClassNamed: #EnvelopeEditorMorph.	Smalltalk removeClassNamed: #PianoKeyboardMorph.	Smalltalk removeClassNamed: #WaveEditor.	Smalltalk removeClassNamed: #SoundSequencerMorph.	Smalltalk removeClassNamed: #SoundMorph.	Smalltalk removeClassNamed: #SoundLoopMorph.	Smalltalk removeClassNamed: #InterimSoundMorph.	Smalltalk removeClassNamed: #RecordingControlsMorph.	Smalltalk removeClassNamed: #PermanentRecordingControlsMorph.	Smalltalk removeClassNamed: #SoundDemoMorph.	Smalltalk at: #GraphMorph ifPresent: [:graphMorph |		#(loadCoffeeCupClink play playBach playOnce		  readDataFromFile registerWaveform stopPlaying)			do: [:sel | graphMorph removeSelector: sel]].	Smalltalk at: #TrashCanMorph ifPresent: [:trashMorph |		trashMorph class removeSelector: #samplesForDelete.		trashMorph class removeSelector: #samplesForMouseEnter.		trashMorph class removeSelector: #samplesForMouseLeave].	SystemOrganization removeCategoriesMatching: 'System-Sound'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/16/1998 13:50'!discardVMConstruction	"Discard the virtual machine construction classes and the Smalltalk-to-C translator. These are only needed by those wishing to build or study the Squeak virtual machine, or by those wishing to construct new primitives via Smalltalk-to-C translation."	"remove the code for virtual machines"	Smalltalk removeKey: #InterpreterLog ifAbsent: [].	SystemOrganization removeCategoriesMatching: 'Squeak-Jitter'.	SystemOrganization removeCategoriesMatching: 'Squeak-Interpreter'.	"remove the Smalltalk-to-C translator"	Smalltalk at: #CCodeGenerator ifPresent: [:codeGen | codeGen removeCompilerMethods].	SystemOrganization removeCategoriesMatching: 'Squeak-Translation to C'.	Smalltalk removeClassNamed: #SystemTracer.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 15:38'!majorShrink    "Smalltalk majorShrink; abandonSources; lastRemoval"	"This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  The shrink process is being improved and, in conjunction with removeAllUnSentMessages, yields an image around ?? in size."Smalltalk discardVMConstruction.  "663k"Smalltalk discardSoundSynthesis.  "330k"Smalltalk discardOddsAndEnds.  "228k"Smalltalk discardNetworking.  "261k"Smalltalk discardMorphic.  "2,231k""Above altogether saves 3,541k"	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	FileList removeSelector: #fileIntoNewChangeSet.	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewImageImports.	"Now delete lots of classes.."	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	SystemOrganization removeSystemCategory: 'Graphics-Files'.	SystemOrganization removeSystemCategory: 'Interface-Projects'.	SystemOrganization removeSystemCategory: 'System-Object Storage'.	Smalltalk removeClassNamed: #FormSetFont.	Smalltalk removeClassNamed: #FontSet.	Smalltalk removeClassNamed: #InstructionPrinter.	Smalltalk removeClassNamed: #ChangeSorter.	Smalltalk removeClassNamed: #DualChangeSorter.	Smalltalk removeClassNamed: #EmphasizedMenu.	Smalltalk removeClassNamed: #MessageTally.	StringHolder class removeSelector: #originalWorkspaceContents.	CompiledMethod removeSelector: #symbolic.	RemoteString removeSelector: #makeNewTextAttVersion.	Utilities class removeSelector: #absorbUpdatesFromServer.	Smalltalk removeClassNamed: #PenPointRecorder.	Smalltalk removeClassNamed: #Path.	Smalltalk removeClassNamed: #Base64MimeConverter.	Smalltalk removeClassNamed: #EToySystem.	Smalltalk removeClassNamed: #RWBinaryOrTextStream.	Smalltalk removeClassNamed: #AttributedTextStream.	TextStyle allInstancesDo:		[:ts | ts newFontArray: (ts fontArray copyFrom: 1 to: 2)].	ListParagraph initialize.	PopUpMenu initialize.	StandardSystemView initialize.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets 		put: (OrderedCollection with: Smalltalk changes).	[self removeAllUnSentMessages > 0] whileTrue.	Smalltalk allClassesDo: [:c | c zapOrganization].	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:33'!printSpaceAnalysis	"Smalltalk printSpaceAnalysis"	^ Smalltalk printSpaceAnalysis: 0 on: 'STspace.text'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:32'!printSpaceAnalysis: threshold on: fileName	"Smalltalk printSpaceAnalysis: 1000 on: 'STspace.text0'"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n stats totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	stats _ OrderedCollection new.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during: [:bar |	self allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x size*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		stats add: (Array with: cl name with: codeSpace) , (Array with: instCount with: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	f _ FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		stats _ (stats select: [:s | s third >= threshold])				asSortedCollection: [:s :s2 | s fourth > s2 fourth]].	stats do:		[:s | f nextPutAll: (s first padded: #right to: 30 with: $ );			nextPutAll: (s second printString padded: #left to: 12 with: $ );			nextPutAll: (s third printString padded: #left to: 12 with: $ );			nextPutAll: (s fourth printString padded: #left to: 12 with: $ ).		percent _ s fourth*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalPercent printString padded: #left to: 8 with: $ ).	f close! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:37'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream oldFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream oldFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 15:46'!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages" 	"Remove all implementations of unsent messages."	| sels n |	sels _ self allUnSentMessages.	"The following should be preserved for doIts, etc"	#(printSpaceAnalysis		dragon: hilberts: mandala: web test3 factorial benchmark benchFib		newDepth: restoreAfter: forgetDoIts		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. Smalltalk allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	MethodDictionary allInstancesDo: [:d | d rehash].	^ sels size! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 6/17/1998 13:16'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user now unprotected until the low space watcher is re-installed"	Project current interruptName: 'Space is low'.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 9/23/1998 16:49'!version	"Answer the version of this release."	^ 'Squeak 2.2 of Sept 23, 1998'! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'tk 9/22/1998 23:15'!processShutDownList	"Call the shutDown method on each object that needs to gracefully shut itself down before a snapshot."	Smalltalk at: #MailDB ifPresent: [:mailDB |		mailDB allInstancesDo: [:db | db saveDB]].  "snapshot all mail databases to disk"	Smalltalk at: #PWS ifPresent: [:pws | pws stopServer].	Smalltalk at: #Password ifPresent: [:password | password shutDown].	Smalltalk at: #HttpUrl ifPresent: [:urlClass | urlClass shutDown].	self shutDownSound.	Delay shutDown.	Smalltalk shutDown.	Color shutDown.	StrikeFont shutDown.	Smalltalk isMorphic ifFalse: [ControlManager shutDown].	Form shutDown.	DisplayScreen shutDown.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'sw 8/22/1998 22:41'!readDocumentFile	"Process system updates. Read a document file, if one was provided. Start application."	| fileName object |	self processUpdates.	fileName _ Smalltalk getSystemAttribute: 2.	((fileName ~~ nil) and: [fileName size > 0])		ifTrue: [			(fileName asLowercase beginsWith: 'http://')				ifTrue: [					"fetch remote file"					HTTPSocket httpFileIn: fileName]				ifFalse: [					"read local file"					object _ (FileStream oldFileNamed: fileName) fileInObjectAndCode.					"if launching a .sqo document, send open to the final object"					(fileName endsWith: '.sqo') ifTrue: [object open]]]		ifFalse: [			(Preferences valueOfFlag: #startImagineeringStudio)				ifTrue: [ScriptingSystem openImagineeringStudio]].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'TPR 5/10/1998 21:33'!saveAs	| dir newName newImageName newChangesName |	dir _ FileDirectory default.	newName _ (FillInTheBlank		request: 'New File Name?'		initialAnswer: 'NewImageName') asFileName.	newName _ FileDirectory baseNameFor: newName.	newImageName _ newName, FileDirectory dot, FileDirectory imageSuffix.	newChangesName _ newName, FileDirectory dot, FileDirectory changeSuffix.	((dir includesKey: newImageName) or:	 [dir includesKey: newChangesName]) ifTrue: [		^ self notify: newName, ' is already in use.Please choose another name.'].	dir copyFileNamed: self changesName toFileNamed: newChangesName.	self logChange: '----SAVEAS ', newName, '----', Date dateAndTimeNow printString.	self imageName: (dir fullNameFor: newImageName).	LastImageName _ self imageName.	self closeSourceFiles; openSourceFiles.  "so SNAPSHOT appears in new changes file"	self snapshot: true andQuit: false.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 9/23/1998 15:23'!makeExternalRelease		"Smalltalk makeExternalRelease"	(self confirm: self version , 'Is this the correct version designation?If not, choose no, and fix it.') ifFalse: [^ self].	(Object classPool at: #DependentsFields) size > 1 ifTrue: [self halt].	Browser initialize.	Undeclared isEmpty ifFalse: [self halt].	Smalltalk garbageCollect.	Smalltalk obsoleteClasses isEmpty ifFalse: [self halt].	Display newDepth: 8.	Project allInstancesDo: [:p | p displayDepth: 8].	Utilities removeDisney.	ScriptingSystem prepareForExternalReleaseNamed: 'Squeak2.2beta'.	StandardScriptingSystem removeSelector: #serverUrls.	EToySystem class removeSelector: #serverUrls.	ServerDirectory removeServerNamed: 'UpdatesAtDOL'.	ServerDirectory removeServerNamed: 'UpdatesAtWebPage'.	#(Helvetica Palatino ComicAll Courier) do:		[:k | TextConstants removeKey: k].	(TextConstants at: #ComicBold) newFontArray:		((TextConstants at: #ComicBold) fontArray copyFrom: 1 to: 5).	SystemDictionary removeSelector: #makeExternalRelease.	Symbol rehash.	self halt: 'Ready to condense sources'.	Smalltalk condenseSources! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/23/1998 14:35'!testDecompiler    "Smalltalk testDecompiler"	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."	 | methodNode oldMethod newMethod badOnes oldCodeString n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Decompiling all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldMethod _ cls compiledMethodAt: selector.			oldCodeString _ (cls decompilerClass new								decompile: selector in: cls method: oldMethod)							decompileString.			methodNode _ cls compilerClass new						compile: oldCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldCodeString = (cls decompilerClass new								decompile: selector in: cls method: newMethod)							decompileString ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Decompiler Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/23/1998 14:35'!testFormatter    "Smalltalk testFormatter"	"Reformats the source for every method in the system, and then	compiles that source and verifies that it generates identical code"	 | newCodeString methodNode oldMethod newMethod badOnes n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			oldMethod = newMethod ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/28/1998 06:06'!testFormatter2    "Smalltalk testFormatter2"	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged"	 | newCodeString badOnes n oldCodeString oldTokens newTokens |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldCodeString _ (cls sourceCodeAt: selector) asString.			newCodeString _ (cls compilerClass new)				format: oldCodeString				in: cls notifying: nil.			oldTokens _ oldCodeString findTokens: Character separators.			newTokens _ newCodeString findTokens: Character separators.			oldTokens = newTokens ifFalse:					[Transcript cr; show: '***' , cls name , ' ' , selector.					badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 9/23/1998 16:11'!handleUserInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: [[Project current interruptName: 'User Interrupt'] fork]			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'sw 9/21/1998 11:04'!hasMorphic	"Answer whether the Morphic classes are available in the system (they may have been stripped, such as by a call to Smalltalk removeMorphic"	^ ((Smalltalk at: #WorldMorph ifAbsent: [nil]) isKindOf: Class)! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:42'!imageImports	"Answer the global dictionary of image imports, creating it if necessary.  7/24/96 sw"	"Smalltalk viewImageImports"	(self includesKey: #ImageImports)		ifFalse:			[self at: #ImageImports put: Dictionary new].	^ self at: #ImageImports! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:26'!imageReaderClass	"Answer, if present, a class to handle the importing of various graphic image files	from disk. If none, return nil.   tao 10/26/97"	| aClass |	^ ((aClass _ self at: #ImageReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:23'!jpegReaderClass	"Answer, if present, a class to handle the importing of JPEG files from disk. If none, return nil.   9/18/96 sw"	| aClass |	^ ((aClass _ self at: #JPEGReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'sw 9/21/1998 11:03'!verifyMorphicAvailability	"If Morphic is available, return true; if not, put up an informer and return false"	self hasMorphic ifFalse:		[self beep.		self inform: 'Sorry, Morphic mustbe present to use this feature'.		^ false].	^ true! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:53'!viewImageImports	"Open up a special Form inspector on the dictionary of image imports."	self imageImports inspectFormsWithLabel: 'Image Imports'! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:48'!actualObject	^ nil! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/11/1998 16:42'!associatedPlayer	^ nil! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:46'!initialize	super initialize.	self removeAllMorphs.	resultType _ #boolean! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:50'!isBoolean	^ true! !!SystemQueryPhrase methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 14:51'!storeCodeOn: aStream indent: tabCount	submorphs first storeCodeOn: aStream indent: tabCount! !!SystemTracer methodsFor: 'initialization' stamp: 'di 9/8/1998 16:56'!initCompactClasses	| c |	c _ Array new: 31.		"These classes have a short name (their index in this table.  It is not their oop.)	Thus their instances can use just a single word as their header in memory."	c at: 1 put: CompiledMethod.  c at: 2 put: Symbol. c at: 3 put: Array.	c at: 4 put: Float.  c at: 5 put: LargePositiveInteger.  c at: 6 put: String.	c at: 7 put: MethodDictionary.  c at: 8 put: Association.  c at: 9 put: Point.	c at: 10 put: Rectangle.  c at: 11 put: ClassOrganizer.  c at: 12 put: TextLineInterval.	c at: 13 put: BlockContext.  c at: 14 put: MethodContext.  c at: 15 put: PseudoContext.	compactClasses _ c.	"Leave 16 to 31 for user defined compact classes."	"Attempt to correctly write contextCache image.."	"compactClasses _ Smalltalk compactClassesArray"! !!SystemTracer methodsFor: 'initialization' stamp: 'di 9/8/1998 16:55'!writeFileHeader	file position: 0.  "info in header page"	self write4Bytes: ($A asciiValue *100) + 2.  "version number:  6500+2"	self write4Bytes: imageHeaderSize.  "File offset (bytes) of start of data"							"same as base address (byte) of first object"	self write4Bytes: maxOop.  "Length of data segment in words"	self write4Bytes: 0.		"what you have to add to an oop to get"							"an offset in the data portion of this file"	self write4Bytes: (self mapAt: specialObjects).	self write4Bytes: (hashGenerator next * 16rFFF asFloat) asInteger.  "next hash"	self write4Bytes: Display width * 16r10000 + Display height.  "display size"	file position > imageHeaderSize ifTrue: [self error: 'Header ran over allotted length'].	file padTo: imageHeaderSize put: 0.  "Pad header page"	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: file fullName		type: 'STim'		creator: 'FAST'.	file close.! !!SystemWindow methodsFor: 'geometry' stamp: 'ls 9/16/1998 05:01'!extent: newExtent	| inner panelRect labelRect paneColor |	self removeHandles.	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	panelRect _ self panelRect.	paneColor _ Color perform: model defaultBackgroundColor.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: paneColor.	closeBox align: closeBox topLeft with: inner topLeft + (4@0).	collapseBox align: collapseBox topRight with: inner topRight - (4@0).	label fitContents; setWidth: (label width min: bounds width - 50).	label align: label bounds topCenter with: inner topCenter.	paneMorphs with: paneRects do:		[:m :frame |  "m color: paneColor."		m bounds: (((frame scaleBy: panelRect extent) translateBy: panelRect topLeft)) truncated].	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [fullFrame _ self bounds].	self isActive ifTrue: [self addHandles]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:56'!labelRect	^ self innerBounds withHeight: self labelHeight.! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:55'!panelRect	"Return the area below title bar, devoted to panes"	^ self innerBounds topLeft + (0@(self labelHeight))					corner: self innerBounds bottomRight! !!SystemWindow methodsFor: 'label' stamp: 'di 6/10/1998 13:53'!relabel	| newLabel |	newLabel _ FillInTheBlank request: 'New label for this window'						initialAnswer: labelString.	(model windowReqNewLabel: newLabel)		ifTrue: [self setLabel: newLabel]! !!SystemWindow methodsFor: 'open/close' stamp: 'jm 8/20/1998 18:32'!delete	| thisWorld |	model okToChange ifFalse: [^self].	thisWorld _ self world.	model windowIsClosing; release.	model _ nil.	super delete.	SystemWindow noteTopWindowIn: thisWorld.! !!SystemWindow methodsFor: 'open/close' stamp: 'ls 7/21/1998 00:29'!openInWorld	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVC].	self bounds: (RealEstateAgent initialFrameFor: self).	World addMorph: self.	self activate.	World startSteppingSubmorphsOf: self.! !!SystemWindow methodsFor: 'open/close' stamp: 'sw 8/12/1998 14:40'!openInWorld: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	self bounds: (RealEstateAgent initialFrameFor: self).	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self! !!SystemWindow methodsFor: 'open/close' stamp: 'ls 7/21/1998 00:30'!openInWorldExtent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVCExtent: extent].	self position: (RealEstateAgent initialFrameFor: self) topLeft; extent: extent.	World addMorph: self.	self activate.	World startSteppingSubmorphsOf: self.! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 7/3/1998 01:29'!addHandles 	| pt handle |	isCollapsed ifTrue: [^ self "no handles if collapsed"].	#(topLeft topRight bottomLeft bottomRight rightCenter leftCenter		topLeft topRight bottomLeft bottomRight topCenter bottomCenter)		withIndexDo: [:ptName :i | pt _ self bounds perform: ptName.			handle _ Morph new color: Color yellow; extent: (i<=6 ifTrue: [1@20] ifFalse: [20@1]).			handle align: (handle bounds perform: ptName) with: pt.			handle on: #mouseEnter send: #enterHandle:morph:pointName:					to: self withValue: ptName.			self addMorphBack: handle].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 6/24/1998 21:30'!collapseOrExpand	isCollapsed	ifTrue:		["Expand -- restore panes to morphics structure"		isCollapsed _ false.		super bounds: fullFrame.		paneMorphs reverseDo: [:m | self addMorph: m].		self activate "-- mainly for findWindow"]	ifFalse:		["Collapse -- remove panes from morphics structure"		isCollapsed _ true.		paneMorphs do: [:m | m delete; releaseCachedState].		collapsedFrame			ifNil:	[self extent: (label width + 50) @ (self labelHeight + 2).					self position: (RealEstateAgent assignCollapsePointFor: self)]			ifNotNil: [super bounds: collapsedFrame]]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jm 6/17/1998 11:55'!mouseLeaveEvent: event fromPane: pane	"For backward compatibility only.  Not used by any newly created window"	(pane isKindOf: ScrollPane) ifTrue: [pane mouseLeave: event].! !!SystemWindow methodsFor: 'top window' stamp: 'di 6/24/1998 22:27'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop |	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	owner firstSubmorph == self ifFalse: [owner addMorphFront: self].	self submorphsDo: [:m | m unlock].	self setStripeColorsFrom: self paneColor.	self removeHandles; addHandles.	self isCollapsed ifFalse: [model modelWakeUp]! !!SystemWindow methodsFor: 'top window' stamp: 'di 7/3/1998 01:30'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColor.	"Note - the following code is equiv to simply:		self removeHandles.	It has been rewritten so that only 4 damage rects will get repainted, 	all within this window, and none within its subpanes"	"First do the top and bottom handles, together with the label"	self invalidRect: (self bounds topLeft corner: self right@(self top+1)).	self invalidRect: (self left@(self bottom-1) corner: self bounds bottomRight).	(self submorphs select: [:m | (m isMemberOf: Morph)			and: [m bottom <= (self top+1) or: [m top >= (self bottom-1)]]])		do: [:m | m delete].self world displayWorld.	"Now do the left and right handles"	self invalidRect: (self bounds topLeft corner: (self left+1)@self bottom).	self invalidRect: ((self right-1)@self top corner: self bounds bottomRight).	self removeHandles.  "Only these are left"self world displayWorld.	self submorphsDo: [:m | m lock].! !!SystemWindow methodsFor: 'events' stamp: 'di 9/21/1998 22:49'!handlesMouseDown: evt	"If I am not the topWindow, then my mouseDown action dominates"	Preferences fastDragWindowForMorphic ifTrue: [^ true].	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!SystemWindow methodsFor: 'events' stamp: 'di 9/21/1998 22:51'!mouseDown: evt	| cp offset newBounds |	self activate.	(Sensor redButtonPressed "If mouse is really still down after activate"		and: [self labelRect containsPoint: evt cursorPoint]) ifTrue:		[Preferences fastDragWindowForMorphic		ifTrue: [offset _ self position - Sensor cursorPoint.				newBounds _ self bounds newRectFrom:					[:f | Sensor cursorPoint + offset extent: self extent].				^ self position: newBounds topLeft]		ifFalse: [^ evt hand grabMorph: self]].	model windowActiveOnFirstClick ifTrue:		["Normally window keeps control of first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseMove: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseMove: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseUp: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseUp: evt]]]! !!SystemWindow methodsFor: 'stepping' stamp: 'ls 8/3/1998 21:49'!stepTime	(model respondsTo: #stepTime) ifTrue: [ ^model stepTime ].	^ 200 "milliseconds"! !!SystemWindow methodsFor: 'stepping' stamp: 'ls 9/16/1998 04:47'!wantsSteps	"Return true if the model responds to step (except if it is a debugger)."	| c |	(model respondsTo: #wantsSteps) ifTrue: [ ^model wantsSteps ].	c _ model class.	[c == nil] whileFalse:		[(c includesSelector: #step) ifTrue: [^ c ~= Debugger].		c _ c superclass].	^ false! !!SystemWindow methodsFor: 'menu' stamp: 'di 5/27/1998 15:46'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'relabel' action: #relabel.! !!SystemWindow methodsFor: 'drawing' stamp: 'di 8/16/1998 01:14'!areasRemainingToFill: aRectangle	| areas |	(areas _ super areasRemainingToFill: aRectangle) isEmpty		ifTrue: [^ areas "good news -- complete occlusion"].	"Check for special case that this is scrollbar damage"	((bounds topLeft - (14@0) corner: bounds bottomRight) containsRect: aRectangle) ifTrue:		[paneMorphs do: [:p | ((p isKindOf: ScrollPane) and: [p scrollBarFills: aRectangle])							ifTrue: [^ Array new]]].	^ areas! !A tab in a palette.  The contents is the name to be shown.  If it represents a book, that book is pointed to in my morphToInstall.!!TabMorph methodsFor: 'all' stamp: 'sw 7/2/1998 15:28'!morphToInstall	^ morphToInstall! !!TabMorph methodsFor: 'all' stamp: 'sw 7/2/1998 15:38'!morphToInstall: m	morphToInstall _ m.	self contents: m externalName.	self actionSelector: #tabSelected.	self target: self! !!TabMorph methodsFor: 'all' stamp: 'sw 7/3/1998 11:42'!representsBook	^ morphToInstall ~~ nil! !!TabMorph methodsFor: 'all' stamp: 'sw 8/11/1998 16:59'!tabSelected	"Called when the receiver is hit.  First, bulletproof against someone having taken the structure apart.  My own action basically requires that my grand-owner be a TabbedPalette"	self player ifNotNil: [self player runAllOpeningScripts ifTrue: [^ self]].	(owner isKindOf: IndexTabs) ifFalse: [^ self beep].	(owner owner isKindOf: TabbedPalette) ifFalse: [^ self beep].	owner owner selectTab: self! !!TabMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/2/1998 16:48'!defaultNameStemForInstances	^ 'tab'! !!TabMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/3/1998 11:49'!forBook: aBook	^ self new morphToInstall: aBook! !A sorter for the tabs of a TabbedPalette!!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:05'!acceptSort	"Reconstitute the palette based on what is found in the sorter"	| rejects toAdd oldOwner tabsToUse |	tabsToUse _ OrderedCollection new.	rejects _ OrderedCollection new.	pageHolder submorphs doWithIndex: [:m :i |		toAdd _ nil.		(m isKindOf: BookMorph) ifTrue:			[toAdd _ TabMorph forBook: m].		(m isKindOf: TabTokenMorph) ifTrue:			[toAdd _ m tabRepresented contents: m contents].		toAdd ifNil:				[rejects add: m]			ifNotNil:				[tabsToUse add: toAdd]].	tabsToUse size == 0 ifTrue: [^ self inform: 'Sorry, must have at least one tab'].	book newTabs: tabsToUse.	oldOwner _ owner.	self delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 15:24'!addControls	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Okay';	actionSelector: #acceptSort).	r addMorphBack: (b fullCopy label: 'Cancel';	actionSelector: #cancelSort).	self addMorphFront: r.! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:06'!cancelSort	| oldOwner |	oldOwner _ owner.	self delete.	oldOwner addMorphFront: book! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 18:51'!initialize	super initialize.	self removeAllMorphs.	self extent: 300@100.	pageHolder _ PasteUpMorph new.	pageHolder resizeToFit: true; autoLineLayout: true; fixLayout; layoutChanged.	pageHolder extent: self extent - borderWidth.	pageHolder padding: 8.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/5/1998 15:57'!sortTabsFor: aTabbedPalette	| actualTabs |	actualTabs _ aTabbedPalette tabMorphs.	self book: aTabbedPalette morphsToSort:		(actualTabs collect:			[:aTab | TabTokenMorph new forTab: aTab]).	self position: aTabbedPalette position.	self setNameTo: 'Tab Sorter for ', aTabbedPalette externalName.	aTabbedPalette owner addMorphFront: self! !!TabSorterMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:30'!substituteForMorph: aMorph beingDroppedOn: aPage	(aMorph isKindOf: BookMorph) ifFalse: [^ nil].	^ TabTokenMorph new forTab: (TabMorph new morphToInstall: aMorph)! !An element of a TabSorter.!!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:02'!forTab: aTab	tabRepresented _ aTab.	self contents: aTab contents! !!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/5/1998 15:51'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	super justDroppedInto: aMorph event: anEvent.	self world ifNotNil: [self world abandonAllHalos]! !!TabTokenMorph methodsFor: 'all' stamp: 'sw 7/3/1998 16:03'!tabRepresented	^ tabRepresented! !A structure of tabs and associated books.  Pressing a tab brings into focus the associated book.  Some tabs can have simple actions rather than books as their focus -- in this case, the palette is cleared and the action taken. !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/2/1998 17:52'!addTabForBook: aBook	| aTab |	aTab _ tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage _ aBook].	^ aTab! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:19'!addTabNamed: str color: aColor atIndex: anIndex	| aBook |	aBook _ BookMorph new setNameTo: str.	aBook color: aColor.	self addTabForBook: aBook! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/3/1998 18:05'!defaultPageSize	^ 156 @ 232! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/3/1998 18:10'!initialize	super initialize.	pageSize _ self defaultPageSize.	self removeEverything.	color _ Color r: 0.0 g: 0.6 b: 0.6.  "background for menu bar, primarily"	borderWidth _ 1.	tabsMorph _ IndexTabs new.	self addMorph: tabsMorph! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/4/1998 14:57'!newTabs: tabsList	"Reconstitute the palette based on info in the tabs list"	| itsBook color1 color2 |	pages _ pages species new.	tabsMorph ifNotNil:		[color1 _ tabsMorph  highlightColor.		color2 _ tabsMorph regularColor.		tabsMorph delete].	tabsMorph _ IndexTabs new.	self addMorphFront: tabsMorph.	color1 ifNotNil:		[tabsMorph highlightColor: color1 regularColor: color2].	currentPage ifNotNil:		[currentPage delete.		currentPage _ nil].	tabsList do:		[:aTab |			tabsMorph addTab: aTab.			(itsBook _ aTab morphToInstall) ifNotNil:					[pages add: itsBook.					currentPage ifNil: [currentPage _ itsBook]]].! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 9/14/97 01:12'!setInitialState	super setInitialState.	inset _ 0.	pageSize _ 156 @ 232! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 7/3/1998 16:55'!addScrapsTab	| scrapsBook |	scrapsBook _ BookMorph new pageSize: pageSize; setNameTo: 'scraps'.	scrapsBook removeEverything; insertPage.	scrapsBook setProperty: #scraps toValue: true.	self addTabForBook: scrapsBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 7/3/1998 18:13'!addToTrash: aMorph	"Paste the object onto a page of my Scraps tab. This is only called in situations where a presenter has a standard palette specified."	| aPage aBook |	self hasScrapsTab ifFalse:		[self addScrapsTab].	aBook _ self scrapsBook.	aMorph position: aBook pages first position + (0@40).	aBook pages do: [:pp | 		(pp submorphs size = 1 and: [pp hasProperty: #trash]) ifTrue:  "perhaps remove that property here"			["page is blank"			^ pp addMorph: aMorph]].	aPage _ aBook insertPageLabel: 'From Trash Can:'		morphs: (Array with: aMorph).	aPage setProperty: #trash toValue: true! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 6/24/1998 18:36'!hasScrapsTab	pages detect: [:p | (p hasProperty: #scraps)] ifNone: [^ false].	^ true! !!TabbedPalette methodsFor: 'scraps tab' stamp: 'sw 6/24/1998 18:42'!scrapsBook	^ pages detect: [:p | p hasProperty: #scraps] ifNone: [nil]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 7/3/1998 11:18'!addViewerTab	| viewerBook |	viewerBook _ ViewerBook new removeEverything setNameTo: 'view'.	self addTabForBook: viewerBook.	self standardPalette ifNil:		[self becomeStandardPalette]! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 6/16/1998 16:02'!hasViewerTab	pages detect: [:p | (p isKindOf: ViewerBook)] ifNone: [^ false].	^ true! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 7/3/1998 11:17'!selectViewerTab	| viewerTab |	viewerTab _ tabsMorph submorphs detect: [:m | m morphToInstall isKindOf: ViewerBook] ifNone: [^ self beep].	^ self selectTab: viewerTab! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'sw 8/11/1998 16:47'!viewMorph: aMorph	"The receiver is expected to have a viewer tab; select it, and target it to aMorph"	self hasViewerTab ifFalse: [self addViewerTab].	self selectViewerTab.	currentPage setPlayer: aMorph assuredPlayer.	self presenter flushPlayerListCache.  "A precaution in case aMorph is no longer in world, owing to palette sharing.  This is not very attractive"	self layoutChanged.	self ownerChanged.! !!TabbedPalette methodsFor: 'viewer tab' stamp: 'tk 8/3/1998 15:56'!viewerBook	^ pages detect: [:p | (p isKindOf: ViewerBook)] ifNone: [nil]! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 17:12'!addBookMenuItemsTo: aCustomMenu hand: aHandMorph	self hasMenuTab		ifFalse:			[aCustomMenu add: 'add palette menu' action: #addMenuTab].	aCustomMenu add: 'become the Standard palette' action: #becomeStandardPalette! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 21:00'!addMenuTab	| aTab |	aTab _ self tabsMorph addActionTabWithTitle: '<>'.	aTab target: self; actionSelector: #showPaletteMenu;		setProperty: #tabsMenu toValue: true;		actWhen: #buttonDown! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 9/11/1998 16:02'!addScriptableTab	^ self addScriptableTabWithTitle: 'aTab'! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 8/30/1998 09:11'!addScriptableTabWithTitle: aTitle	| aTab |	aTab _ tabsMorph addActionTabWithTitle: aTitle.	aTab actionSelector: #tabSelected; target: aTab.	^ aTab! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/3/1998 17:11'!hasMenuTab	^ self hasSubmorphWithProperty: #tabsMenu! !!TabbedPalette methodsFor: 'palette menu' stamp: 'sw 7/15/1998 19:45'!showPaletteMenu	| aMenu evt |	evt _ self primaryHand lastEvent.	aMenu _ MenuMorph new defaultTarget: self.	self currentPalette ifNotNil:		[aMenu add:  'clear' action: #showNoPalette.		aMenu addLine].	aMenu add:  'sort tabs' action: #sortTabs:.	aMenu add:  'choose new colors for tabs' action: #recolorTabs.	(self presenter standardPaletteIsAlready: self) ifFalse:		[aMenu add:  'make me the Standard palette' action: #becomeStandardPalette].	aMenu addLine.	self hasViewerTab ifFalse:	[aMenu add:  'add "view" tab' action: #addViewerTab].	self hasScrapsTab ifFalse:	[aMenu add:  'add "scraps" tab' action: #addScrapsTab].	aMenu add: 'add a tab for me to script' action: #addScriptableTab.	aMenu addTitle: 'Palette'.	aMenu popUpAt: self cursorPoint event: evt! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 6/16/1998 16:17'!becomeStandardPalette	self presenter standardPalette: self! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/4/1998 14:12'!recolorTabs	"Prompt the user for new on and off colors for tabs"	| onColor offColor |	self inform: 'Choose the ''on'' color'.	onColor _ Color fromUser.	self inform: 'Okay, now please choosethe ''off'' color'.	offColor _ Color fromUser.	tabsMorph highlightColor: onColor regularColor: offColor.	currentPage ifNotNil:		[tabsMorph highlightTabFor: currentPage]! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/8/1998 13:22'!showNoPalette	| aMenuTab |	currentPage ifNotNil: [currentPage delete].	currentPage _ nil.	(aMenuTab _ tabsMorph submorphWithProperty: #tabsMenu) ifNotNil:		[tabsMorph highlightTab: aMenuTab].	self snapToEdgeIfAppropriate! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/3/1998 18:17'!sortTabs: evt	TabSorterMorph new sortTabsFor: self.  "it directly replaces me"	self delete! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 10/18/97 18:03'!repelsMorph: aMorph event: ev	^ openToDragNDrop not! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/8/1998 13:27'!selectTab: aTab	| currentPalette |	self currentPalette ifNotNil: [self currentPalette currentPlayerDo:		[:aPlayer | aPlayer runAllClosingScripts]].	tabsMorph selectTab: aTab.	self goToPageMorph: aTab morphToInstall.	(currentPalette _ self currentPalette) ifNotNil:		[currentPalette layoutChanged.		currentPalette currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].	self snapToEdgeIfAppropriate! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:38'!selectTabNamed: aName	"For bkwrd compat with etoys"	| aTab |	aTab _ self tabMorphs detect: [:m | m contents = aName] ifNone: [nil].	aTab ifNil: [self error: 'tab not found'].	tabsMorph selectTab: aTab! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:40'!selectTabOfBook: aBook	self tabMorphs do:		[:aTab | aTab morphToInstall == aBook ifTrue: [^ self selectTab: aTab]]! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 7/5/1998 15:38'!tabMorphs	^ tabsMorph tabMorphs! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 5/31/1998 00:20'!wantsDroppedMorph: aMorph event: evt	(tabsMorph bounds containsPoint: evt cursorPoint) ifTrue:		[^ false  "unless it's a book, perhaps, someday"].	^ currentPage wantsDroppedMorph: aMorph event: evt! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 6/23/1998 12:31'!currentPalette	"A stylistic convenience to reduce confusion caused by the fact that a palette is a book of books"	^ currentPage! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'tk 8/3/1998 22:30'!releaseCachedState	| vv |	(vv _ self viewerBook) ifNotNil: [		(self currentPage ~~ vv) ifTrue: [vv removeEverything]].	super releaseCachedState! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 9/30/97 10:10'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	(PageFlipSoundOn and: [oldOrigin ~~ nil])		ifTrue:			[Display fadeImageHorFine: currentPage imageForm at: oldOrigin]! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'sw 7/5/1998 15:40'!succeededInRevealing: aPlayer	| result |	result _ super succeededInRevealing: aPlayer.	result ifTrue:		["BookMorph code will have called goToPageNumber:; here, we just need to get the tab selection right here"		self selectTabOfBook: self currentPalette].	^ result! !!TabbedPalette methodsFor: 'miscellaneous' stamp: 'jm 11/16/97 17:59'!tabsMorph	^ tabsMorph! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 7/4/1998 16:36'!authoringPrototype	| aTabbedPalette aBook aTab |	aTabbedPalette _ self new markAsPartsDonor.	aTabbedPalette pageSize: 180 @ 88.	aTabbedPalette tabsMorph highlightColor: Color red regularColor: Color blue.	aTabbedPalette addMenuTab.	aBook _ BookMorph new setNameTo: 'one'; pageSize: aTabbedPalette pageSize.	aBook color: Color blue muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: EllipseMorph authoringPrototype.	aTab _ aTabbedPalette addTabForBook: aBook.	aBook _ BookMorph new setNameTo: 'two'; pageSize: aTabbedPalette pageSize.	aBook color: Color red muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: CurveMorph authoringPrototype.	aTabbedPalette addTabForBook: aBook.	aTabbedPalette selectTab: aTab.	aTabbedPalette beSticky.	^ aTabbedPalette! !!TabbedPalette class methodsFor: 'all' stamp: 'sw 6/3/1998 21:27'!defaultNameStemForInstances	^ 'tabbedPalette'! !!TempoEvent methodsFor: 'all' stamp: 'jm 9/10/1998 08:37'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': tempo '.	((120.0 * (500000.0 / tempo)) roundTo: 0.01) printOn: aStream.	aStream nextPut: $).! !!Text methodsFor: 'accessing' stamp: 'ls 7/29/1998 01:17'!embeddedMorphs	"return the list of morphs embedded in me"	| morphs |	morphs _ IdentitySet new.	runs withStartStopAndValueDo: [ :start :stop :attribs | attribs do: [ :attrib |		(attrib isKindOf: TextAnchor) ifTrue: [  morphs add: attrib anchoredMorph ] ] ].	^morphs select: [ :m | m isKindOf: Morph ]! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:17'!asUrl	^self asString asUrl! !!Text methodsFor: 'converting' stamp: 'ls 7/14/1998 03:20'!asUrlRelativeTo: aUrl	^self asString asUrlRelativeTo: aUrl! !!Text methodsFor: 'emphasis' stamp: 'ls 7/4/1998 16:13'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle fontAt: 1].	"null text tolerates access"	attributes _ runs at: characterIndex.	font _ aTextStyle fontAt: 1.  "default"	attributes do: 		[:att | att forFontInStyle: aTextStyle do: [:f | font _ f]].	^ font	! !!TextAnchor methodsFor: 'all' stamp: 'di 7/1/1998 14:35'!= other 	^ (other class == self class) 		and: [other anchoredMorph == anchoredMorph]! !create a hanging indent. !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount	"number of tab spaces to indent by"	^amount! !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount: anInteger	"change the number of tabs to indent by"	amount _ anInteger! !!TextIndent methodsFor: 'printing' stamp: 'ls 6/22/1998 18:03'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' amount: '.	amount printOn: aStream! !!TextIndent methodsFor: 'setting indentation' stamp: 'ls 6/22/1998 18:56'!emphasizeScanner: scanner	scanner indentationLevel: amount! !!TextIndent methodsFor: 'condensing' stamp: 'ls 6/22/1998 19:27'!dominates: anAttribute	^(self class == anAttribute class)! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:55'!amount: amount	"create a TextIndent which will indent by the given amount.  Currently this is a number of tabs, but may change in the futur"	^super new amount: amount! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:54'!tabs: numTabs	"create an indentation by the given number of tabs"	^self amount: numTabs! !!TextIndent class methodsFor: 'example' stamp: 'ls 6/24/1998 18:06'!example	"TextIndent example"	| text pg |	"create an example text with some indentation"	text _ 'abcdao euoaeuo aeuo aeuoaeu o aeuoeauefgh bcd efghi'  asText.	text addAttribute: (TextColor red)  from: 3 to: 8.	text addAttribute: (TextIndent amount: 1) from: 1 to: 2.	text addAttribute: (TextIndent amount: 2) from: 20 to: 35.	"stick it in a paragraph and display it"	pg _ text asParagraph.	pg compositionRectangle: (0@0 extent: 100@200).	pg textStyle alignment: 2.	pg displayAt: 0@0.! !a textual input; it takes text input straight from the user via a PluggableText!!TextInput methodsFor: 'private-initialization' stamp: 'ls 8/5/1998 04:01'!name: name0  defaultValue: defaultValue0  textMorph: textMorph0	name _ name0.	defaultValue _ defaultValue0.	textMorph _ textMorph0.! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 06:34'!name	^name! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/5/1998 09:02'!reset	textMorph setText: defaultValue! !!TextInput methodsFor: 'input handling' stamp: 'ls 8/6/1998 09:31'!value	textMorph hasUnacceptedEdits ifTrue: [ textMorph accept ].	^textMorph getText withInternetLineEndings! !!TextInput class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 06:23'!name: name0  defaultValue: defaultValue  textMorph: textMorph	^self new name: name0  defaultValue: defaultValue  textMorph: textMorph	! !!TextKern methodsFor: 'as yet unclassified' stamp: 'di 6/30/1998 22:03'!writeScanOn: strm	kern > 0 ifTrue: [		1 to: kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		1 to: 0-kern do: [:kk | strm nextPut: $-]].! !!TextMorph methodsFor: 'accessing' stamp: 'ls 9/15/1998 19:36'!newContents: stringOrText	"Accept new text contents."	| newText |	newText _ stringOrText asText.	text = newText ifTrue: [^ self].  "No substantive change"	text ifNotNil: [		text embeddedMorphs do: [ :m | m delete ] ].	text _ newText.	"add all morphs off the visible region; they'll be moved into the right place when they become visible"	stringOrText asText embeddedMorphs do: [ :m | 		self addMorph: m. 		m position: (-1000@-1000)].	self releaseParagraph.  "update the paragraph cache"	self paragraph.  "re-instantiate to set bounds"	self world ifNotNil: [ 		self world startSteppingSubmorphsOf: self ].! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:55'!drawBoundsOn: aCanvas	"Shows where line boundaries are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:39'!drawNullTextOn: aCanvas	"make null text frame visible"	aCanvas fillRectangle: bounds color: Color lightRed! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 12:37'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: color].! !!TextMorph methodsFor: 'editing' stamp: 'di 8/11/1998 13:04'!handlesMouseDown: evt	self isPartsDonor ifTrue: [^ false].	^ self uncoveredAt: evt cursorPoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 8/14/1998 15:50'!defaultLineHeight	^ textStyle lineGrid! !!TextMorph methodsFor: 'menu' stamp: 'sw 6/15/1998 15:13'!addOptionalHandlesTo: aHalo box: box	self addFontHandlesTo: aHalo box: box! !!TextMorph methodsFor: 'private' stamp: 'di 9/14/1998 11:35'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		editor storeSelectionInParagraph: self paragraph.		editor _ nil].! !!TextMorph methodsFor: 'private' stamp: 'di 6/22/1998 20:22'!updateFromParagraph  	| newStyle sel oldLast |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [sel _ editor selectionInterval.					editor storeSelectionInParagraph].	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				sel ifNotNil: [self installEditor selectFrom: sel first to: sel last]].	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast orLineAbove: false.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self releaseEditor.		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditor selectFrom: sel first to: sel last.							m selectionChanged.							^ self passKeyboardFocusTo: m]].		^ self].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditor selectFrom: sel first to: sel last.		self editor setEmphasisHere]! !!TextMorph methodsFor: 'containment' stamp: 'sw 6/25/1998 10:44'!ownerChanged	super ownerChanged.	container ifNotNil:		[self releaseParagraph]! !!TextMorph methodsFor: 'anchors' stamp: 'tk 6/30/1998 17:06'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self addMorphFront: aMorph fromWorldPosition: aMorph position.		"Make a TextAnchor and install it in a run."! !!TextMorph class methodsFor: 'as yet unclassified' stamp: 'sw 8/3/1998 17:16'!authoringPrototype	| t |	t _ super authoringPrototype."Strangeness here in order to avoid two offset copies of the default contents when operating in an mvc project before cursor enters the morphic window"	t paragraph.	^ t! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	self closeTypeIn.  "probably not necess"	sensor leftShiftDown		ifFalse:			[stopBlock _ startBlock _ pivotBlock _				paragraph characterBlockAtPoint: clickPoint]		ifTrue:			[(paragraph characterBlockAtPoint: clickPoint) <= startBlock			ifTrue: [stopBlock _ startBlock.					pivotBlock _ stopBlock]			ifFalse: [startBlock _  stopBlock.					pivotBlock _ startBlock]].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseMove: evt 	"Change the selection in response to moue-down drag"	| dragBlock |	pivotBlock ifNil: [^ self].  "Patched during clickAt: repair"	dragBlock _ paragraph characterBlockAtPoint: (evt cursorPoint).	dragBlock > pivotBlock		ifTrue: [stopBlock _ dragBlock.  startBlock _ pivotBlock]		ifFalse: [startBlock _ dragBlock.  stopBlock _ pivotBlock].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(startBlock = stopBlock 		and: [oldInterval = (startBlock stringIndex to: startBlock stringIndex-1)])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:11'!readKeyboard	super readKeyboard.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/22/1998 01:32'!againOrSame: bool	super againOrSame: bool.	morph editView selectionInterval: self selectionInterval! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/14/1998 13:12'!selectFrom: start to: stop	"Select the specified characters inclusive."	self selectInvisiblyFrom: start to: stop.	self closeTypeIn.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 9/14/1998 12:02'!storeSelectionInParagraph: aParagraph	paragraph == aParagraph		ifTrue: [self storeSelectionInParagraph]		ifFalse: ["Should never get here."				aParagraph selectionStart: nil selectionStop: nil]! !!TextMorphEditor methodsFor: 'binding' stamp: 'ls 7/24/1998 21:06'!bindingOf: aString	^model bindingOf: aString! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:42'!acceptOnCR: trueOrFalse	acceptOnCR _ trueOrFalse! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 10:44'!drawNullTextOn: aCanvas	"Just run the normal code to show selection in a window"	aCanvas paragraph: self paragraph bounds: bounds color: color! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/22/1998 01:31'!editView	^ editView! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 8/16/1998 21:17'!handleInteraction: interActionBlock fromEvent: evt	"Overridden to pass along a model to the editor for, eg, link resolution, doits, etc"	self installEditor.  "Make sure editor is installed"	self editor sensor: (KeyboardBuffer new startingEvent: evt).  "Fool MVC"	self editor model: editView model.  "For evaluateSelection"	self selectionChanged.  "Note old selection"		interActionBlock value.	self selectionChanged.  "Note new selection"! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:43'!initialize	super initialize.	acceptOnCR _ false! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 9/11/1998 15:49'!keyStroke: evt	| view |	self editor model: editView model.  "For evaluateSelection"	view _ editView.  "Copy into temp for case of a self-mutating doit"	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	super keyStroke: evt.	view scrollSelectionIntoView! !!TextMorphForEditView methodsFor: 'all' stamp: 'di 6/30/1998 08:50'!mouseDown: event	event yellowButtonPressed ifTrue: [^ editView yellowButtonActivity: event shiftPressed].	^ super mouseDown: event! !!TextOnCurve methodsFor: 'all' stamp: 'di 9/14/1998 11:46'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint _ self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb _ (CharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint _ curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultStartBlock]! !!TextStyle methodsFor: 'accessing' stamp: 'tk 6/26/1998 15:03'!fontNamesAndSizes  "TextStyle default fontNames"	^ fontArray collect: [:x | x name, ' ', x height printString]! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'tk 6/26/1998 15:58'!collectionFromFileNamed: fileName	"Read the file.  It is an TextStyle whose StrikeFonts are to be added to the system.  (Written by fooling SmartRefStream, so it won't write a DiskProxy!!)  These fonts will be added to the master TextSytle for this font family.  	To write out fonts: 		| ff | ff _ ReferenceStream fileNamed: 'new fonts'.		TextConstants at: #forceFontWriting put: true.		ff nextPut: (TextConstants at: #AFontName).			'do not mix font families in the TextStyle written out'.		TextConstants at: #forceFontWriting put: false.		ff close.	To read: (TextStyle default collectionFromFileNamed: 'new fonts')*** Do not remove this method *** "	| ff this newName style heights |	ff _ ReferenceStream fileNamed: fileName.	this _ ff nextAndClose.	"Only works if file created by special code above"	newName _ this fontArray first name.	this fontArray do: [:aFont | aFont name = newName ifFalse: [		self error: 'All must be same family']].	style _ TextConstants at: newName asSymbol ifAbsent: [		^ TextConstants at: newName asSymbol put: this].		"new family"	this fontArray do: [:aFont | "add new fonts"		heights _ style fontArray collect: [:bFont | bFont height].		(heights includes: aFont height) ifFalse: [			style fontAt: style fontArray size + 1 put: aFont]].! !!TextStyle methodsFor: 'Disk I/O' stamp: 'tk 8/20/1998 08:48'!veryDeepCopyWith: deepCopier	"All inst vars are meant to be shared"	| new absent |	new _ deepCopier references at: self ifAbsent: [absent _ true].	absent ifNil: [^ new].	"already done"	new _ self clone.	deepCopier references at: self put: new.	"remember"	^ new! !!TextURL methodsFor: 'as yet unclassified' stamp: 'di 9/19/1998 16:19'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m browser | 		"if it's a web browser, tell it to jump"		anObject isWebBrowser ifTrue: [			anObject jumpToUrl: url.			^true ].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m _ anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [ 					m  jumpToUrl: url.  					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m _ m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	(self confirm: 'open a browser to view this URL?') ifTrue: [		browser _ Scamper new.		browser jumpToUrl: url.		browser openAsMorph.		^ true ].		"couldn't display in a browser.  Offer to put up just the source"		response _ (PopUpMenu labels: 'View web page as source\Cancel' withCRs)		startUpWithCaption: 'Couldn''t find a web browser.  View page as source?'.	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 6/24/1998 17:05'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| actualViewee diag viewedMorphBox myBox scale c shrunkForm |	super drawOn: aCanvas.	actualViewee _ self actualViewee.	actualViewee ifNil: [^ self]. 	actualViewee isInWorld		ifTrue:			[(RecursionDepth _ RecursionDepth + 1) > RecursionMax ifTrue: [^ self].			(actualViewee isKindOf: SketchMorph)				ifTrue:					[diag _ actualViewee form extent r asInteger.					viewedMorphBox _						(actualViewee bounds center - (diag // 2)) extent: diag@diag]				ifFalse:					[viewedMorphBox _ actualViewee fullBounds].			myBox _ self innerBounds.			scale _ myBox width / (viewedMorphBox width max: viewedMorphBox		height).			c _ FormCanvas extent: viewedMorphBox extent depth: aCanvas depth.			c _ c copyOffset: viewedMorphBox topLeft negated.			actualViewee fullDrawOn: c.		"recursion happens here"			shrunkForm _ c form magnify: c form boundingBox by: scale smoothing: 1.			lastFormShown _ shrunkForm.			RecursionDepth _ RecursionDepth - 1]		ifFalse:			[lastFormShown ifNotNil: [shrunkForm _ lastFormShown]].	shrunkForm ifNotNil:		[aCanvas image: shrunkForm at: self center - shrunkForm boundingBoxcenter]! !!ThumbnailMorph methodsFor: 'all' stamp: 'sw 6/15/1998 15:18'!tearOffTile	(objectToView isKindOf: Player) ifTrue: [^ objectToView tearOffTileForSelf].	objectToView ifNil: [^ nil].	^ objectToView isMorph		ifTrue:			[objectToView]		ifFalse:			[objectToView costume]! !!TileMorph methodsFor: 'misc' stamp: 'sw 9/10/1998 08:33'!colorChangedForSubmorph: aSubmorph	"Invoked when the user selects a new color on a colorTile or a color-seer-tile; need to recompile the script."	self acceptNewLiteral! !!TileMorph methodsFor: 'initialization' stamp: 'di 8/11/1998 22:13'!bePossessive	possessive _ true.	self line1: actualObject externalName, '''s'! !!TileMorph methodsFor: 'initialization' stamp: 'sw 6/11/1998 18:00'!bringUpToDate	| newLabel |	type == #objRef ifTrue:		[newLabel _ actualObject externalName.		self isPossessive ifTrue:			[newLabel _ newLabel, '''s'].		self line1: newLabel]	! !!TileMorph methodsFor: 'initialization' stamp: 'di 8/11/1998 22:13'!isPossessive	possessive == nil ifTrue: [^ false].	^ possessive! !!TileMorph methodsFor: 'initialization' stamp: 'sw 7/2/1998 09:50'!setLiteral: anObject	| m |	type _ #literal.	m _ UpdatingStringMorph contents: ' ' font: ScriptingSystem fontForTiles.  "BUT this doesn't do it, damnit"	m target: self; getSelector: #literal; putSelector: #literal:.	(anObject isKindOf: String) ifTrue: [m useStringFormat].	self addMorph: m.	self literal: anObject.! !!TileMorph methodsFor: 'accessing' stamp: 'sw 7/4/1998 18:01'!resultType	type == #literal ifTrue:		[(literal isKindOf: Number) ifTrue: [^ #number].		(literal isKindOf: String) ifTrue: [^ #string].		(literal isKindOf: Point) ifTrue: [^ #point].		(literal isKindOf: String) ifTrue: [^ #string].		(literal isKindOf: Boolean) ifTrue: [^ #boolean].		(literal isKindOf: Morph) ifTrue: [^ #costume]  "This last one dubious!!"].	type == #expression ifTrue:		[^ #number].	type == #objRef ifTrue: [^ #player].	^ #unknown! !!TileMorph methodsFor: 'arrows' stamp: 'sw 7/15/1998 19:24'!showSuffixChoices	| plus phrase pad outer num |	(phrase _ self ownerThatIsA: PhraseTileMorph) ifNil: [^ self].	(type == #literal) & (literal isNumber) ifTrue: ["Tile is a constant number"		phrase lastSubmorph == owner "pad"			ifTrue: ["we are adding the first time (at end of our phrase)"				plus _ self presenter phraseForReceiver: literal 						op: #+ arg: 1 resultType: #number.				owner acceptDroppingMorph: plus event: self primaryHand lastEvent.				num _ plus firstSubmorph firstSubmorph.				num deleteSuffixArrow]].	type == #operator ifTrue: ["Tile is accessor of an expression"		phrase resultType == #number ifTrue:			[outer _ phrase ownerThatIsA: PhraseTileMorph.			pad _ self ownerThatIsA: TilePadMorph.			outer ifNotNil:				[outer lastSubmorph == pad ifTrue: [ "first time"					plus _ self presenter phraseForReceiver: 1 							op: #+ arg: 1 resultType: #number.					pad acceptDroppingMorph: plus event: self primaryHand lastEvent.					(plus firstSubmorph) removeAllMorphs.					(plus firstSubmorph) addMorph: phrase.	"car's heading"					self deleteSuffixArrow]]]].	phrase presenter coloredTilesEnabled ifFalse:		[phrase topEditor			ifNotNil:				[phrase topEditor makeAllTilesGreen]			ifNil:				[phrase makeAllTilesGreen]]! !!TileMorph methodsFor: 'code generation' stamp: 'jm 5/28/1998 19:12'!codeString	| s |	s _ WriteStream on: ''.	self storeCodeOn: s indent: 1.	^ s contents! !!TileMorph methodsFor: 'code generation' stamp: 'jm 5/28/1998 19:04'!storeCodeOn: aStream indent: tabCount	| op refType playerBearingCode |	"Must determine whom is scripted for what follows to work"	playerBearingCode _ self playerBearingCode.  "If it's ever nil, we've got trouble"	type = #expression ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: operatorOrExpression;			nextPut: $)].	type = #literal ifTrue:		[^ aStream			nextPut: $(;			nextPutAll: literal printString;			nextPut: $)].	type == #objRef ifTrue:		[^ (playerBearingCode == actualObject)			ifTrue:				["This is the critical point -- if the object is the method's own 'self' then we MUST, rather than just MAY, put out self rather than the referencer call, though the latter will temporarily work as long we have true uniclasses."				aStream nextPutAll: 'self']			ifFalse:				[aStream nextPutAll: 'self class '.				aStream nextPutAll: (playerBearingCode class referenceSelectorFor: actualObject)]].	type = #operator ifTrue:		[((UpdatingOperators includesKey: operatorOrExpression) and:		 [self precedingTileType = #slotRef])			ifTrue: [op _ UpdatingOperators at: operatorOrExpression]			ifFalse: [op _ operatorOrExpression].		^ op isEmpty			ifTrue: [aStream position: aStream position - 1]			ifFalse: [aStream nextPutAll: op]]."The following branch has long been disused	type = #slotRef ifTrue:		[self isThisEverCalled.		refType _ self slotRefType.		refType = #get ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities getterSelectorFor: slotName)].		refType = #set ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: (Utilities setterSelectorFor: slotName);				nextPut: $:].		refType = #update ifTrue:			[^ aStream				nextPutAll: targetName;				space;				nextPutAll: slotName;				nextPutAll: ': ';				nextPutAll: targetName;				space;				nextPutAll: slotName]]"! !!TileMorph methodsFor: 'private' stamp: 'sw 6/26/1998 16:26'!updateLiteralLabel	"now works for operator tiles also"	|  desiredW leader myLabel |	(myLabel _ self labelMorph) ifNil: [^ self].	myLabel contents:		(type == #literal			ifTrue:				[literal stringForReadout] 			ifFalse: [operatorReadoutString 				ifNil:		[ScriptingSystem wordingForOperator: operatorOrExpression]				ifNotNil:  	[operatorReadoutString]]).	leader _ (upArrow ifNil: [0] ifNotNil: [UpArrowAllowance]) + 4.	desiredW _ leader + myLabel width.	suffixArrow ifNotNil: [desiredW _ desiredW + SuffixArrowAllowance].	self extent: (desiredW max: self minimumWidth) @ self class defaultH.	myLabel position: (self left + (leader + 0)) @ (bounds top + 3); fullBounds.	suffixArrow ifNotNil: [suffixArrow align: suffixArrow topRight with:				bounds topRight + (-2 @ (self height // 2)) - (0 @ (suffixArrow height // 2))].	self changed! !!TileMorph methodsFor: 'object fileIn' stamp: 'tk 8/12/1998 10:17'!convertbosfcepcbbtsloadustlno0: varDict bosfcebbtsloadustlnop0: smartRefStrm	"These variables are automatically stored into the new instance ('type' 'slotName' 'literal' 'operatorOrExpression' 'actualObject' 'downArrow' 'upArrow' 'suffixArrow' 'typeColor' 'lastArrowTick' 'nArrowTicks' 'operatorReadoutString' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('possessive' ) and deal with the information in ()"	"Morph's conversion method already deals with this, so no extra code here."! !!TilePadMorph methodsFor: 'all' stamp: 'sw 6/15/1998 09:21'!acceptDroppingMorph: aMorph event: evt	| editor wasPossessive |	wasPossessive _ submorphs size > 0 and: [submorphs first isPossessive].	self prepareToUndoDropOf: aMorph.	self removeAllMorphs.	aMorph position: self position.	self addMorph: aMorph.	wasPossessive ifTrue: [aMorph bePossessive].	(editor _ self topEditor) ifNotNil: [editor install]! !!TilePadMorph methodsFor: 'all' stamp: 'di 7/3/1998 14:25'!handlesDragOver: evt	^ true! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TilePadMorph methodsFor: 'all' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!TilePadMorph methodsFor: 'all' stamp: 'jm 5/28/1998 19:10'!storeCodeOn: aStream indent: tabCount	submorphs do: [:m | m storeCodeOn: aStream indent: tabCount].! !!TilePadMorph class methodsFor: 'all' stamp: 'sw 9/9/1998 17:35'!initialize	"TilePadMorph initialize"	ColorsForType _ IdentityDictionary new.	#(		(command		(0.065 0.258 1.0)		(0.065 0.258 1.0))	(number		(0.8 0.4 0.2)			(1.0	0.6 0.2))	(boolean		(0.94 1.0 0.06)		(0.94 1.0 0.06))  		"some kind of yellowish"	(player			(1.0  0 0.065)		(1.0  0 0.065)) 	(color			(1.0  0 0.065)		(0.806 1.0 0.806))  	"some damn dark red"	(sound			(1.0 0.06 0.84)		(1.0 0.06 0.84))   	"a kind of magenta"	(point			(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(rotationStyle	(1.0 0.26 0.98)		(1.0 0.26 0.98))   	"arbitrary"	(string			(0.0 0.0 1.0)			(0.0 0.0 1.0))      "not in use"	(group			(0.0 0.0 1.0)			(0.0 0.0 1.0))		 "not in use"	(costume		(0.806 1.0 0.806)	(0.806 1.0 0.806))		 "not in use")			do:		[:t | ColorsForType at: t first put:			(Array 	with: 	((Color fromRgbTriplet: t second) mixed: self colorFudge with: ScriptingSystem uniformTileInteriorColor)					with:	(Color fromRgbTriplet: t third))]! !!Time class methodsFor: 'general inquiries' stamp: 'ls 7/25/1998 01:16'!dateAndTimeFromSeconds: secondCount	^ Array		with: (Time fromSeconds: secondCount \\ 86400)		with: (Date fromSeconds: secondCount)! !!Time class methodsFor: 'general inquiries' stamp: 'ls 7/25/1998 01:16'!dateAndTimeNow	"Answer a two-element Array of (Date today, Time now)."	| secondCount d t |	secondCount _ self primSecondsClock.	d _ Date fromSeconds: secondCount.	t _ Time fromSeconds: secondCount \\ 86400.	^ Array with: d with: t! !an input from a toggle button!!ToggleButtonMorph class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 07:33'!fixTargetPresenters	"ToggleButtonMorph fixTargetPresenters"	"Repair faulty instances from the first 'etoy-template' experiment, such that the instances refer to the local presenter rather than to a phantom and irrelevant world"	self allInstancesDo:		[:m | (m target isKindOf: Presenter) ifTrue:			[m target: m presenter]]! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: nil accept: nil			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	World ifNotNil: [^ (self openAsMorphLabel: aString) openInWorld].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/29/1998 17:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'di 9/9/1998 22:37'!morphsIn: aRectangle addTo: mList	"Return a collection of all morphs in this morph structure that intersect the given rectangle, possibly including the receiver itself.  Map through my transform.  "	| r |	(self bounds intersects: aRectangle) ifFalse:		["TransformMorph clips to bounds"		^ mList].	r _ Rectangle encompassing: (aRectangle corners collect: [:p | transform transform: p]).	submorphs do: [:m | m morphsIn: r addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'drawing' stamp: 'jm 6/17/1998 12:22'!fullDrawOn: aCanvas	"Overridden to clip submorph drawing to my bounds,	and to translate, rotate and scale as appropriate."	| clippingCanvas sourceQuad imageForm imageQuad warp innerRect |	(aCanvas isVisible: self bounds) ifFalse: [^ self].	self drawOn: aCanvas.	transform isPureTranslation		ifTrue:		[clippingCanvas _ aCanvas copyOffset: transform offset negated truncated									clipRect: self innerBounds.		submorphs reverseDo: [:m | m fullDrawOn: clippingCanvas]]		ifFalse:		[innerRect _ self innerBounds.		sourceQuad _ transform sourceQuadFor: innerRect.		submorphs reverseDo:			[:m | imageForm _ m imageForm.			imageQuad _ sourceQuad collect: [:p | p - imageForm offset].			warp _ aCanvas warpFrom: imageQuad toRect: innerRect.			warp cellSize: smoothing;  "installs a colormap if smoothing > 1"				sourceForm: imageForm;				warpBits]]	! !!TransformationMorph methodsFor: 'accessing' stamp: 'tk 7/31/1998 12:35'!forwardDirection	"Same as rotationDegrees"| m |^ (((m _ self renderedMorph) isKindOf: SketchMorph) and: [m rotationStyle ~~ #normal]) 			ifTrue: [m rotationDegrees]			ifFalse: [self angle radiansToDegrees negated]! !!TransformationMorph methodsFor: 'accessing' stamp: 'sw 8/20/1998 13:44'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' on ', submorphs first printString! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 9/3/1998 00:19'!referencePosition	^ transform invert: self renderedMorph referencePosition! !!TransformationMorph methodsFor: 'accessing' stamp: 'di 9/3/1998 00:18'!referencePosition: aPoint	self position: self position + (aPoint - self referencePosition)! !!TransformationMorph methodsFor: 'accessing' stamp: 'tk 8/2/1998 14:37'!rotationDegrees: degrees	| m |	self adjustAfter:		[(m _ self renderedMorph) doesOwnRotation			ifTrue: ["is SketchMorph and rotationStyle is not #normal"				m rotationDegrees: degrees.				"self angle: 0.0 or not flexed"]			ifFalse: [self angle: degrees degreesToRadians negated]]	"usual case"! !!TransformationMorph methodsFor: 'menu' stamp: 'di 9/9/1998 19:53'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed anActorState aName |	oldHalo _ self halo.	submorphs isEmpty ifTrue: [^ self delete].	unflexed _ self firstSubmorph.	self submorphs copy do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m].	(anActorState _ self actorStateOrNil) ifNotNil:		[unflexed actorState: anActorState].	(aName _ self knownName) ifNotNil:		[unflexed setNameTo: aName].	unflexed player: self player.	self player ifNotNil:		[self player rawCostume: unflexed.		self player: nil].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	self delete.! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/3/1998 10:02'!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos _ self referencePosition.	changeBlock value.	(self scale < 1.0 or: [self angle ~= (self angle roundTo: Float pi / 2.0)])		ifTrue: [smoothing _ 2]		ifFalse: [smoothing _ 1].	self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)].	self layoutChanged.! !!TranslucentColor methodsFor: 'printing' stamp: 'jm 6/2/1998 08:26'!storeOn: aStream	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: self alpha printString;		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions' stamp: 'jm 6/2/1998 08:35'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works at a bit-depth of 32; this color will appear opaque at all other depths."	| basicPixelWord |	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!TrashCanMorph methodsFor: 'initialization' stamp: 'di 7/3/1998 14:28'!initialize	super initialize.	self image: TrashPicOn;		offImage: TrashPic;		pressedImage: TrashPicOn.	self setNameTo: 'Trash'.	self setProperty: #scriptingControl toValue: true.	self setBalloonText:'The Trash CanTo remove an object, drag itover the Trash, and drop it,and it will disappear.'.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:17'!handlesDragOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 7/3/1998 13:33'!handlesMouseOver: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ self inPartsBin not! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 8/4/1998 18:42'!mouseEnter: event	"Present feedback for potential deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue: [			self presenter soundsEnabled ifTrue: [self class playMouseEnterSound].			hand startDisplaySuppression.			self world abandonAllHalos.			self state: #pressed]		ifFalse: [			self showStampIn: hand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!TrashCanMorph methodsFor: 'event handling' stamp: 'sw 8/4/1998 18:42'!mouseLeave: event	"Present feedback for aborted deletion."	| hand |	hand _ event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue:			[self presenter soundsEnabled ifTrue: [self class playMouseLeaveSound].			hand endDisplaySuppression.			self state: #off]		ifFalse:			[self stopShowingStampIn: hand].! !!TrashCanMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!TrashCanMorph methodsFor: 'dropping' stamp: 'sw 8/4/1998 18:42'!acceptDroppingMorph: aMorph event: evt	| palette |	self presenter soundsEnabled ifTrue: [self class playDeleteSound].	evt hand endDisplaySuppression.	self state: #off.	aMorph delete.	palette _ self standardPalette.	palette ifNotNil: [palette addToTrash: aMorph].! !!TrashCanMorph methodsFor: 'private' stamp: 'sw 8/22/1998 22:44'!findActivePaintBox	"If painting, return the active PaintBoxMorph. If not painting, or if the paint box cannot be found, return nil."	| w m |	w _ self world.	w ifNil: [^ nil].	(w findA: SketchEditorMorph) ifNil: [^ nil].  "not painting"	(m _ w findA: PaintBoxMorph) ifNotNil: [^ m].	^ nil! !!TrashCanMorph methodsFor: 'private' stamp: 'sw 8/22/1998 22:45'!openTrash	"User wants to see what is in the trash."	| paintBox |	"See if a stamp is being dropped into the trash. It is not held by the hand."	(paintBox _ self findActivePaintBox) ifNotNil: [		paintBox getSpecial == #stamp: ifTrue: [			paintBox deleteCurrentStamp.  "throw away stamp..."			self primaryHand showTemporaryCursor: nil.			^ self]].	  "... and don't open trash"! !!TrashCanMorph methodsFor: 'other' stamp: 'sw 9/14/1998 12:02'!printOn: aStream	aStream nextPutAll: 'a TrashCanMorph'! !This morph represents a URL for a SqueakPage. It displays the thumbnail for the associated page, if available. Used in page sorters and for bookmarks.This morph has several options:  a. It can act like a thumbnail for sorting (in which case it can be picked up and dragged) or it acts as a bookmark (in which case clicking on it activates it).  b. If it is a bookmorph, it can act on a particular book or it can act on whatever book it happens to be in at the time. The former is primarily used for making a graphical page index allowing random access to any page in the book.!!URLMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 07:16'!initialize	super initialize.	color _ Color lightGray.	isBookmark _ false.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 21:49'!book	^ book! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 21:49'!book: aWebBookMorph	"Set the book morph to be invoked when this url is used as a bookmark. If nil, then this bookmark operates on whatever book it is currently in."	book _ aWebBookMorph.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:16'!isBookmark	^ isBookmark! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:17'!isBookmark: aBoolean	"Make this morph behave as a clickable bookmark if the argument is true."	isBookmark _ aBoolean.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:07'!page	"Answer the cached page that this morph represents."	^ page! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:05'!url	"Answer the URL for the page that this morph represents."	^ url! !!URLMorph methodsFor: 'drawing' stamp: 'jm 6/25/1998 11:14'!drawOn: aCanvas	"Draw thumbnail for my page, if it is available. Otherwise, just draw a rectangle." 	| thumbnail |	aCanvas frameRectangle: bounds width: 1 color: Color blue.	thumbnail _ self thumbnailOrNil.	thumbnail		ifNil: [aCanvas fillRectangle: (bounds insetBy: 1) color: color]		ifNotNil: [aCanvas image: thumbnail at: bounds origin + 1].! !!URLMorph methodsFor: 'event handling' stamp: 'jm 6/17/1998 07:18'!handlesMouseDown: evt	^ isBookmark! !!URLMorph methodsFor: 'event handling' stamp: 'jm 6/17/1998 21:50'!mouseDown: evt	| bk |	book		ifNil: [bk _ self enclosingBook]		ifNotNil: [bk _ book].	bk ifNotNil: [bk goToURL: url].! !!URLMorph methodsFor: 'updating' stamp: 'jm 6/17/1998 14:15'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| thumbnail |	page == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	thumbnail _ self thumbnailOrNil.	thumbnail ifNotNil: [		self extent: (thumbnail extent + 2).		self changed].! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 07:28'!enclosingBook	"Answer the inner-most book that contains this morph, or nil if there isn't one."	| m |	m _ owner.	[m == nil] whileFalse: [		(m isKindOf: WebBookMorph) ifTrue: [^ m].		m _ m owner].	^ nil! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 14:21'!setURL: aURLString page: aSqueakPage	"Initialize the receiver for the given URL and page."	url _ aURLString.	page _ aSqueakPage.	self pageHasChanged: page.! !!URLMorph methodsFor: 'private' stamp: 'jm 6/17/1998 07:05'!thumbnailOrNil	"Answer the thumbnail Form for the page this morph represents. Answer nil if no thumbnail is available."	page ifNil: [^ nil].	^ page thumbnail! !!URLMorph class methodsFor: 'instance creation' stamp: 'jm 6/17/1998 07:35'!newBookmarkForURL: aURLString	^ (self newForURL: aURLString) isBookmark: true! !!URLMorph class methodsFor: 'instance creation' stamp: 'jm 6/17/1998 07:09'!newForURL: aURLString	| pg |	pg _ SqueakPageCache		atURL: aURLString		ifAbsent: [^ self new setURL: aURLString page: nil].	^ self new setURL: aURLString page: pg! !!URLmap methodsFor: 'linking' stamp: 'mjg 9/1/1998 12:41'!linkFor: string from: peer storingTo: aList	| uString newpage |	uString _ string asUppercase.	(self isStringRooted: uString)		ifTrue: ["an external URL"			(self isStringAnImage: uString)				ifTrue: ["Looks like an image URL"						^self imageURL: string]				ifFalse: [^self externalURL: string]]		ifFalse: [ "Serious!! Gotta provide-a-link!! But check forimage or local action first"				(self isStringAnImage: uString)					ifTrue: [^self localImageURL: string].				(self isStringALocalAction: uString)					ifTrue:[^self localActionURL: string].			newpage _ pages at: string asLowercase ifAbsent: [nil].			newpage isNil				ifTrue: [ "Create a new page"					newpage _ self newpage: stringfrom: peer.].			(aList indexOf: newpage) ~= 0				ifFalse: [aList add: newpage]. "Add only ifnot there"			^self pageURL: newpage]! !!URLmap methodsFor: 'linking' stamp: 'mjg 9/1/1998 12:47'!linkFor: string from: peer storingTo: aList page: aPage	| uString placeID |	uString _ string asUppercase.	(uString beginsWith: 'APPEND HERE') ifTrue: [		placeID _ uString copyFrom: (13 min: uString size) to:uString size.		^'<a href="', aPage url, '.insert.', placeID ,'">','AppendHere','</a>'].			"later an image here"	^self linkFor: string from: peer storingTo: aList.! !!URLmap methodsFor: 'searching' stamp: 'BJP 9/7/1998 01:06'!recent	| response sortedPages currentDate |	sortedPages _ pages reject: [:page | page pageStatus = #new]."We definitely want the reject: first, so we sort a smaller collection.Having the variable name be 'sortedPages' is a bit of a misnomer, though.""I think we shouldn't do all this for each call to recent changes. Afterall, most of the time, it's *hasn't* changed, and when it *has*, it'spretty much only added something to the end. At the very least we shouldcache the sorted, filtered collection.""And really, why is this in URLmap? Recent Changes is a kind of page. I'drather see it as a swikipage, perhaps standardly defined (that is, when youset up a swiki, you get a front page, a formatting page, and a RecentChanges page). That is, SwikiPages could store text (as they do now) orcgi-ish functions (like recent). That way, we could design custom templatesfor them, etc.At the very least, there needs to be better labeling. Why not call thecategory with these page functions, 'dynamic pages', or somethign similar?""A different condsideration: It would be nice to have arbitrary filters:e.g., 'past ten days', 'all pages *not* yet edited', etc., and be able tocombine them. Would work as a 'search for various attributes' feature whichone might or might not expose to the user."	sortedPages _ sortedPages asSortedCollection: [:a :b | (a date = bdate) ifTrue: [a time > b time]			ifFalse: [a date > b date]].	response _ WriteStream on: String new.	response nextPutAll: '<h2>Recent Changes</h2><ul>'.	currentDate _ Date new.	sortedPages do: [:page |		(currentDate ~= page date)		ifTrue: [			currentDate _ page date.			response nextPutAll: '</ul><p><b>',(currentDateprintString),'</b><p><ul>'.].		response nextPutAll: '<li>',(self pageURL: page),'...',(pageaddress).].	response nextPutAll: '</ul>'.	^response contents		! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:16'!externalURL: aString	"make a non-local  URL"	^'<a href="',aString,'">',aString,'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:15'!imageURL: aString	"make a non-local image URL"	^'<img src="', aString,'" alt="', aString,'">'! !!URLmap methodsFor: 'accessing' stamp: 'TPR 7/27/1998 15:10'!localActionURL: aString	|string|	"fake up a more ordinary URL by dropping the shriek chars"	string _ aString copyWithout: $!!.	^'<a href="',string,'">',string,'</a>'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 9/1/1998 12:32'!localImageURL: aString	"make a local image URL"	^'<img src="',action name, '/', aString,'" alt="', action name,'/',aString,'">'! !!URLmap methodsFor: 'accessing' stamp: 'mjg 9/11/1998 10:32'!pageURL: aPage	(aPage pageStatus = #new)		ifTrue:			[^'<u>',(aPage name),'</u><a href="', (actionpageURL: aPage),'.edit">?</a>'] "Underlines new but not yet edited pages"		ifFalse:			[^'<a href="', (action pageURL: aPage),'">',(aPagename),'</a>']"Logically, there should be editPageUrl in SwikiAction as well. After all,we might want to define other URL schemes." ! !!URLmap methodsFor: 'creating' stamp: 'BJP 9/7/1998 00:52'!allPagesFrom: pageRef for: request	| formattedPage refPages allPages peer |	(request isKindOf: PWS) ifTrue: [peer _ request peerName] ifFalse:[peer_''].	formattedPage _ pageRef copy.  "Make a copy, then format the text."	refPages _ OrderedCollection new.	formattedPage formatted: (action formatter swikify: (pageRef text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo: refPages]).	"This filtering should be generalized a tad, methinks. Perhapsincorparated into the	linkhandler."	refPages _ refPages reject: [:page | page pageStatus = #new].	"Now, put all referenced pages into the page"	allPages _ WriteStream on: String new.	allPages nextPutAll: '<h2>',(pageRef name),'</h2>', formattedPageformatted.	refPages do: [:page |		allPages nextPutAll: '<h2>',(page name),'</h2>'.		allPages nextPutAll: (HTMLformatter swikify: (page text)	linkhandler: [:link | self linkFor: link				from: peer				storingTo:(OrderedCollection new)]).].	formattedPage formatted: allPages contents. "Put all the pages into THEpage"	^formattedPage! !!URLmap methodsFor: 'creating' stamp: 'mjg 9/10/1998 15:24'!newpage: label from: peer	| newpage newfile |	newfile _ ((pages inject: 0 into: [:max :p |		p coreID asNumber > max ifTrue: [p coreID asNumber]				ifFalse: [max]]) + 1) printString.	newpage _ SwikiPage new.	self at: label put: newpage.	newpage address: peer.	newpage date: (Date today).	newpage time: (Time now).	newpage coreID: newfile.	newpage name: label.	newpage file: ((ServerAction serverDirectory),		directory, (ServerAction pathSeparator), newfile).	newpage pageStatus: #new.	newpage text: 'Describe ',label,' here'.	newpage map: self.	newpage url: (action name),'.',newfile.	^newpage! !!URLmap methodsFor: 'creating' stamp: 'mjg 8/28/1998 19:48'!storeID: id text: text from: peer	| page |	page _ self atID: id.	page date: (Date today).	page time: (Time now).	page text: text.	page address: peer.	^ page! !!URLmap methodsFor: 'creating' stamp: 'tk 7/14/1998 19:32'!storeID: id text: insertedText insertAt: idString	"Insert in a place in the text.  Just before '*append here 34*' ifidString is '34'."	| page bigText ind toInsert |	page _ self atID: id.	page date: (Date today).	bigText _ page text.	ind _ bigText findString: '*append here ',idString,'*' startingAt:1.	"always lower case"	ind = 0 ifTrue: [^ page].		"could not find that place"	"Make sure new text surrounded by line feeds"	toInsert _ (insertedText last == Character linefeed)		ifTrue: [insertedText]		ifFalse: [insertedText, (String with: Character linefeed)].	((insertedText first == Character linefeed) or: [		(bigText at: (ind-1 max: 1)) == Character linefeed])			ifFalse: [toInsert _ (String with: Characterlinefeed), toInsert].	page text: (bigText copyReplaceFrom: ind to: ind-1 with: toInsert).	"page address: peer.  Don't sign with person who only added"	^ page! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:51'!isStringALocalAction: anUpperCasedString	"check the string to see if it starts and end with  a shriek - codefor a Swiki action such as Comment or whatever"	^(anUpperCasedString size >=2) and:	[anUpperCasedString first = $!! and:	[anUpperCasedString last= $!!]]! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:39'!isStringAnImage: anUpperCasedString	"check the string to see if it end with something that makes itlkely to be an image URL"	^(anUpperCasedString endsWith: 'GIF') or:		[(anUpperCasedString endsWith: 'JPEG') or:		[anUpperCasedString endsWith: 'JPG']]! !!URLmap methodsFor: 'private' stamp: 'TPR 7/27/1998 14:37'!isStringRooted: anUpperCasedString	"check the string to see if it starts with something that makes itlkely to be a rooted URL"	^(anUpperCasedString indexOfSubCollection: 'HTTP' startingAt: 1) =1 or:	[(anUpperCasedString indexOfSubCollection: 'FTP' startingAt: 1) = 1 or:	[(anUpperCasedString indexOfSubCollection: 'MAILTO' startingAt: 1)= 1]]! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 8/31/1998 16:53'!addToGlossary: myName as: myURL	|aStream |	"Add to a CR-delimited file of 'pageName' and 'URL' separated byvertical bars '|'"	aStream _ directory oldFileNamed: 'glossary'.	aStream open.	aStream setToEnd.	aStream nextPutAll: myName,'|',myURL; cr.	aStream close.	! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 9/1/1998 09:44'!readGlossary: aStream	|aLine pieces name url newpage|	"Expect a CR-delimited file of 'pageName' and 'URL' separated byvertical bars '|'"	self pages: (Dictionary new).	aStream open.	[aStream atEnd] whileFalse:		[aLine := aStream upTo: (Character cr).		pieces _ aLine findTokens: '|'.		name _ pieces at: 1.		url _ pieces at: 2.		newpage _ SwikiPage new.		newpage coreID: url.		newpage map: self.		newpage name: name.		pages at: name asLowercase put: newpage].	aStream close.	! !!URLmap methodsFor: 'fileRendering' stamp: 'mjg 9/1/1998 09:47'!writeGlossary	"Write out the pages dictionary as a CR-delimited file of pagenameand URL"	|aStream |	aStream _ directory oldFileNamed: 'glossary'.	aStream open.	pages keys asSortedCollection do: [:each |		aStream nextPutAll: (pages at: each) name,'|',(pages at:each) coreID; cr.].	aStream close.	! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'copying' stamp: 'tk 8/20/1998 16:07'!veryDeepCopyWith: deepCopier	"Return self.  I can't be copied.  Do not record me."! !Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!!UnloadedSound class methodsFor: 'as yet unclassified' stamp: 'jm 9/12/1998 23:05'!default	"UnloadedSound default play"	| snd p |	snd _ super new modulation: 1 multiplier: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !My instances are Player objects that have not been scripted, and which hence do not require a unique scripts dictionary, etc.  As soon as the needed, I am transformed automatically into a unique subclass of Player.!!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 9/15/1998 13:21'!assureUniClass	| anInstance |	anInstance _ Player instanceOfUniqueClass.	anInstance initializeCostumesFrom: self.	self become: anInstance.	^ anInstance! !!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 8/10/1998 16:23'!belongsToUniClass	^ false! !!UnscriptedPlayer methodsFor: 'all' stamp: 'sw 9/15/1998 13:13'!copyUniClass	self error: 'oops, copyUniClass sent to an UnscriptedPlayer'! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/10/1998 16:23'!acceptsLoggingOfCompilation	^ true! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/17/1998 07:33'!isSystemDefined	^ true! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 9/15/1998 13:33'!newUserInstance	"Answer an instance of an appropriate class to serve as a user object in the containment hierarchy"	^ self new! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 8/17/1998 07:34'!officialClass	^ self! !!UnscriptedPlayer class methodsFor: 'all' stamp: 'sw 9/15/1998 13:49'!wantsChangeSetLogging	^ true! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'sw 6/10/1998 17:45'!valueAsConstant	^ self readFromTarget! !!UpdatingStringMorph methodsFor: 'initialization' stamp: 'sw 6/26/1998 07:41'!initialize	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ putSelector _ nil.	growable _ true! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 6/11/1998 16:27'!valueAsConstant	^ self valueFromContents! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!step	| s |	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse:			[self updateContentsFrom: s]]! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 6/26/1998 07:31'!updateContentsFrom: aValue	self growable		ifTrue:			[self contents: aValue]		ifFalse:			[self contentsClipped: aValue]! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 6/26/1998 07:22'!addCustomMenuItems: menu hand: aHandMorph	| prefix |	super addCustomMenuItems: menu hand: aHandMorph.	prefix _ self growable		ifTrue:			['stop']		ifFalse:			['start'].	menu add: prefix, ' being growable' action: #toggleGrowability! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 6/26/1998 07:47'!toggleGrowability	growable _ self growable not.	self updateContentsFrom: self readFromTarget.	growable ifTrue: [self fitContents]! !A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.!!Url methodsFor: 'parsing' stamp: 'ls 8/5/1998 00:57'!newFromRelativeText: aString	"return a URL relative to the current one, given by aString.  For instance, if self is 'http://host/dir/file', and aString is '/dir2/file2', then the return will be a Url for 'http://host/dir2/file2'"	"if the scheme is the same, or not specified, then use the same class"	| newSchemeName remainder fragmentStart newFragment newUrl bare |	bare _ aString withBlanksTrimmed.	newSchemeName _ Url schemeNameForString: bare.	(newSchemeName isNil not and: [ newSchemeName ~= self schemeName ]) ifTrue: [		"different scheme -- start from scratch"		^Url absoluteFromText: aString ].	remainder _ bare.	"remove the fragment, if any"	fragmentStart _ remainder indexOf: $#.	fragmentStart > 0 ifTrue: [		newFragment _ remainder copyFrom: fragmentStart+1 to: remainder size. 		remainder _ remainder copyFrom: 1 to: fragmentStart-1].	"remove the scheme name"	newSchemeName ifNotNil: [		remainder _ remainder copyFrom: (newSchemeName size + 2) to: remainder size ].	"create and initialize the new url"	newUrl _ self class new privateInitializeFromText: remainder  relativeTo: self.	"set the fragment"	newUrl privateFragment: newFragment.	^newUrl! !!Url methodsFor: 'parsing' stamp: 'ls 8/4/1998 00:50'!privateInitializeFromText: aString	^self subclassResponsibility! !!Url methodsFor: 'parsing' stamp: 'ls 8/4/1998 00:55'!privateInitializeFromText: aString relativeTo: aUrl	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"	"by default, just do regular initialization"	^self privateInitializeFromText: aString! !!Url methodsFor: 'classification' stamp: 'ls 6/16/1998 16:22'!scheme	"return a string with the scheme of this URL.  For instance, HTTP"	^self subclassResponsibility! !!Url methodsFor: 'classification' stamp: 'ls 7/3/1998 21:11'!schemeName	"return a lowercase string with the scheme of this URL.  For instance, 'http'"	^self subclassResponsibility! !!Url methodsFor: 'printing' stamp: 'ls 6/20/1998 19:55'!printOn: aStream	aStream nextPutAll: self toText! !!Url methodsFor: 'printing' stamp: 'ls 6/20/1998 19:55'!toText	"give a String representation of the Url, suitable for printing, etc."	^self subclassResponsibility! !!Url methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:41'!activate	"spawn an external handler for this URL"	! !!Url methodsFor: 'downloading' stamp: 'ls 8/4/1998 20:40'!hasContents	"whether this URL can download contents to be displayed; if not, it fundamentally requires an outside application to deal with it.  For example, mailto: and telnet: urls"	^false! !!Url methodsFor: 'downloading' stamp: 'ls 7/23/1998 20:14'!retrieveContents	"return a MIMEObject with the object's contents, or nil if the object could not be retrieved"	^nil! !!Url methodsFor: 'downloading' stamp: 'ls 7/23/1998 20:14'!retrieveContentsForBrowser: aBrowser	"return a MIMEObject with the object's contents, or nil if the object could not be retrieved.  Since aBrowser is specified, this could do browser specific things"	^self retrieveContents! !!Url methodsFor: 'converting' stamp: 'ls 7/14/1998 03:17'!asText	^self asString asText! !!Url methodsFor: 'converting' stamp: 'ls 6/29/1998 00:36'!asUrl	^self! !!Url methodsFor: 'converting' stamp: 'ls 7/3/1998 21:11'!asUrlRelativeTo: aUrl	^self! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:41'!fragment	^fragment! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:02'!privateFragment: aString	fragment _ aString! !!Url class methodsFor: 'parsing' stamp: 'ls 8/4/1998 20:42'!absoluteFromText: aString	"Url absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 	"Url absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"	"Url absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"	"Url absoluteFromText: 'file:/etc/passwd'"	| remainder scheme fragment ind newUrl |	"trim surrounding whitespace"	remainder _ aString withBlanksTrimmed.		"extract the fragment, if any"	ind _ remainder indexOf: $#.	ind > 0 ifTrue: [		fragment _ remainder copyFrom: ind+1 to: remainder size.		remainder _ remainder copyFrom: 1 to: ind-1 ].	"choose class based on the scheme name, and let that class do the bulk of the parsing"	scheme _ self schemeNameForString: remainder.	scheme = nil ifTrue: [		newUrl _ HttpUrl new privateInitializeFromText: remainder ].	(scheme = 'http') ifTrue: [ newUrl _ HttpUrl new privateInitializeFromText: remainder ].	(scheme = 'msw') ifTrue: [ newUrl _ MswUrl new privateInitializeFromText: remainder ]. 	(scheme = 'ftp') ifTrue:[ newUrl _ FtpUrl new privateInitializeFromText: remainder ].	(scheme = 'file') ifTrue: [newUrl _ FileUrl new privateInitializeFromText: remainder ].		(scheme = 'browser') ifTrue: [ newUrl _ BrowserUrl new privateInitializeFromText: remainder ].	(scheme = 'mailto') ifTrue: [ newUrl _ MailtoUrl new privateInitializeFromText: remainder ].	newUrl ifNil: [  newUrl _ GenericUrl new privateInitializeFromText: remainder ].	"set the fragment"	newUrl privateFragment: fragment.	"all done"	^newUrl! !!Url class methodsFor: 'parsing' stamp: 'ls 7/26/1998 20:37'!schemeNameForString: aString	"get the scheme name from a string, or return nil if it's not specified.  used in internal parsing routines--an outsider may as well use asUrl.  lowercases the return value."	"Url schemeNameForString: 'http://www.yahoo.com'"	"Url schemeNameForString: '/etc/passwed'"	"Url schemeNameForString: '/etc/testing:1.2.3'"	| idx schemeName |	idx _ aString indexOf: $:.	idx = 0 ifTrue: [ ^nil ].	schemeName _ aString copyFrom: 1 to: idx-1.	schemeName do: [ :c |		"make sure it is all alphabetic"		c isLetter ifFalse: [ ^nil ]. ].	^schemeName asLowercase! !!Url class methodsFor: 'testing' stamp: 'ls 8/4/1998 02:42'!quickieTest	"run some quick tests on the Url hierarchy"	"	Url quickieTest	"	| tests url block correct actual numCorrect numWrong baseUrl |	"each item in tests in a two-element array.  it has a block, followed by the string the block should evaluate to"	tests _ OrderedCollection new.	"parsing absolute urls of various kinds"	tests add: (Array with: 		[url _ 'hTTp://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part' asUrl.		url schemeName, '|', url authority, '|', url path first, '|', url path size printString, '|', url query, '|',url fragment.]		with: 'http|chaos.resnet.gatech.edu:8000|docs|3|A%20query%20|part').	tests add: (Array with:		[url _ 'ftP://some.server/some/directory/' asUrl.		url schemeName, '|', url class name, '|', url authority, '|', url path first , '|', url path size printString]		with: 'ftp|FtpUrl|some.server|some|3').	tests add: (Array with:		[url _ 'telNet:chaos.resnet.gatech.edu#goo' asUrl.		url schemeName, '|', url locator, '|', url fragment] 		with: 'telnet|chaos.resnet.gatech.edu|goo').	tests add: (Array with:		[url _ Url absoluteFromText: 'file:/etc/passwd#foo'.		url schemeName, '|', url path first, '|', url path size printString, '|', url fragment]		with: 'file|etc|2|foo').	tests add: (Array with: 		[url _ Url absoluteFromText: 'browser:bookmarks#mainPart'.		url schemeName, '|', url locator, '|', url fragment, '|', url class name ]		with: 'browser|bookmarks|mainPart|BrowserUrl').	tests add: (Array with:		[url _ 'fILE:/foo/bar//zookie/?fakequery/#fragger' asUrl.		url schemeName, '|', url class name, '|', url path first, '|', url path size printString, '|', url fragment]		with: 'file|FileUrl|foo|5|fragger').	"relative urls of each kind, relative to the original"	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'ftp://a.b'.		url toText]		with: 'ftp://a.b/').	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'ftp:xyz'.		url toText.]		with: 'ftp://somewhere/some/dir/xyz').	tests add: (Array with: [		baseUrl _ 'http://some.where/some/dir?query1#fragment1' asUrl.		url _ baseUrl newFromRelativeText: '../another/dir/?query2#fragment2'.		url toText]		with: 'http://some.where/another/dir/?query2#fragment2').	tests add: (Array with: [		baseUrl _ 'file:/some/dir#fragment1' asUrl.		url _ baseUrl newFromRelativeText: 'file:../another/dir/#fragment2'.		url toText]		with: 'file:/another/dir/#fragment2').	"relative urls of a different scheme"	tests add: (Array with: [		baseUrl _ 'ftp://somewhere/some/dir/?query#fragment' asUrl.		url _ baseUrl newFromRelativeText: 'http:xyz'.		url toText.]		with: 'http://xyz/').	"run the tests"	numCorrect _ 0.	numWrong _ 0.	tests do: [ :test |		block _ test at: 1.		correct _ test at: 2.		actual _ block value.		Transcript show: actual.		correct = actual 			ifTrue: [ numCorrect _ numCorrect + 1 ]			ifFalse: [				numWrong _ numWrong + 1.				Transcript show: '<-- should be: ', correct ].		Transcript cr. ].	Transcript show: numCorrect printString, ' correct, ', numWrong printString, ' wrong.', String cr.	numWrong > 0 		ifTrue: [ Transcript show: 'happy hacking!!' ]		ifFalse: [ Transcript show: 'yay!!!!!!' ].	Transcript cr.! !!UserScript methodsFor: 'initialization' stamp: 'tk 6/13/1998 14:25'!donorActor: player1 ownActor: player2	player _ player2.	currentScriptEditor ifNotNil: [		currentScriptEditor == #textuallyCoded ifFalse: [			currentScriptEditor donorActor: player1 ownActor: player2]].	self allScriptVersionsDo: [:anEditor | anEditor donorActor: player1 ownActor: player2]! !!UserScript methodsFor: 'initialization' stamp: 'tk 8/13/1998 13:06'!initializeForPlayer: aPlayer afterShallowCopyFrom: aDonorUserScript	player _ aPlayer.	formerScriptEditors _ nil.	aDonorUserScript isTextuallyCoded		ifFalse:			[currentScriptEditor _ currentScriptEditor fullCopy.				"We have a rule that ScriptEditors can't have Players in them"			currentScriptEditor playerScripted: aPlayer.			currentScriptEditor donorActor: aDonorUserScript player ownActor: aPlayer]		! !!UserScript methodsFor: 'script editor' stamp: 'sw 8/21/1998 16:35'!instantiatedScriptEditor	"return the current script editor, creating it if necessary"	self isAnonymous ifTrue:		[currentScriptEditor _ ScriptEditorMorph new playerScripted: player].	self isTextuallyCoded ifTrue: ["path thought not to be reached now"								^ player costume pasteUpMorph scriptorForTextualScript: selector ofPlayer: player].	currentScriptEditor ifNil:		[currentScriptEditor _ ScriptEditorMorph  new			setMorph: player costume			scriptName: selector.		status == #ticking ifTrue: [player costume arrangeToStartStepping]].		^ currentScriptEditor! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 8/22/1998 22:10'!absorbUpdatesFromServer	"Go to two common servers and look for updates.  Do not bring themto the user's disk.  A file on the server called updates.list has the namesof the last N update files.  We look backwards for the first one we do nothave, and start there bringing them in.  tk 9/10/97""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""wod 6/18/1998: stop after first failure""Utilities absorbUpdatesFromServer"| doc urls failed loaded str |Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"Cursor wait showWhile: [	(Smalltalk includesKey: #EToySystem)		ifTrue: [ScriptingSystem guessDOLProxy].	urls _ self newUpdatesOn: 		(Utilities serverUrls collect: [:url | url, 'updates/']).	loaded _ 0.	failed _ nil.	urls do: [:this |		failed ifNil: [			doc _ HTTPSocket httpGet: this accept: 'application/octet-stream'.			"check here that it worked"			doc class == String				ifTrue: [failed _ this]	"an error loading"				ifFalse: [					doc reset; text.					doc peek asciiValue = 4	"pure object file"						ifTrue: [failed _ this]	"Must be fileIn, not pure object file"						ifFalse: [							"(this endsWith: '.html') ifTrue: [doc _ doc asHtml]."								"HTML source code not supported here yet"							ChangeSorter newChangesFromStream: doc								named: (this findTokens: '/') last.							self saveUpdate: doc onFile: (this findTokens: '/') last.	"if wanted"							loaded _ loaded + 1]]]].	].str _ 'Loaded ', loaded printString ,' new update files.'.failed ifNotNil: [str _ str, '\Could not load ' withCRs, (urls size - loaded) printString ,' update files.',					'\Starting with "' withCRs, failed, '".'].self inform: str.! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 6/30/1998 15:49'!broadcastUpdatesFrom: n1 to: n2 except: skipList"	ChangeSorter removeChangeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger > 412]].	Utilities absorbUpdatesWriteFiles: true zapNums: false.	Utilities broadcastUpdatesFrom: 413 to: 999 except: #()."	| fileNames fileNamesInOrder fileNamesUnnumbered names choice |	names _ ServerDirectory groupNames asSortedArray.	choice _ (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	fileNames _ FileDirectory default fileNames select:		[:n | n first isDigit			and: [(n initialInteger between: n1 and: n2)			and: [(skipList includes: n initialInteger) not]]].	fileNamesInOrder _ fileNames asSortedCollection.	fileNamesUnnumbered _ fileNamesInOrder collect:		[:n | n copyFrom: (n findFirst: [:c | c isDigit not]) to: n size].	fileNamesInOrder with: fileNamesUnnumbered do:		[:n :nu | FileDirectory default rename: n toBe: nu].	(ServerDirectory groupNamed: choice) putUpdateMulti: fileNamesUnnumbered! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/23/1998 08:55'!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from.  Put it at the front of the list. Return false if the user aborted"	| index him |	UpdateUrlLists size > 1 ifTrue: [		index _ (PopUpMenu labelArray: (UpdateUrlLists collect: [:each | each first]) lines: #()) 			startUpWithCaption: 'Choose a group of serversfrom which to fetch updates.'.		index > 0 ifTrue: [			him _ UpdateUrlLists at: index.			UpdateUrlLists removeAt: index.			UpdateUrlLists addFirst: him].		^ index > 0].	^ true! !!Utilities class methodsFor: 'fetching updates' stamp: 'wod 5/21/1998 18:38'!saveUpdate: doc onFile: fileName	"See if the user wants the update stored on a local file.  With or without the update number on the front."	| file fName pos |	(Preferences valueOfFlag: #updateSavesFile) ifFalse: [^ self].	fName _ fileName.	(Preferences valueOfFlag: #updateRemoveSequenceNum) ifTrue: [		pos _ fName findFirst: [:c | c isDigit not].		fName _ fName copyFrom: pos to: fName size].	doc reset; ascii.	(FileDirectory default fileExists: fName) ifFalse: [		file _ FileStream newFileNamed: fName.		file nextPutAll: doc contents.		file close].! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 9/14/1998 13:27'!serverUrls	"Return the current list of server URLs.  For code updates.  Format of UpdateUrlLists is #( ('squeak updates' ('url1' 'url2'))    ('some other updates' ('url3' 'url4')))"	^ UpdateUrlLists first last! !!Utilities class methodsFor: 'identification' stamp: 'sw 7/6/1998 11:49'!authorInitialsPerSe	"Answer the currently-prevailing author initials, such as they, empty or not"	^ AuthorInitials! !!Utilities class methodsFor: 'support windows' stamp: 'di 5/28/1998 12:11'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keysa	Select allb	Browse itc	Copyd	Do ite	Exchangef	Findg	Find againh	Set Search Stringi	Inspect itj	Again oncek	Set fontl	Cancelm	Implementors of itn	Senders of ito	Spawnp	Print itq	Query symbolr	Recognizers	Save (i.e. accept)u	Alignv	Pastew	Delete preceding wordx	Cuty	Swap charactersz	UndoUpper-case command keys (Hold down Cmd & Shift, or Ctrl key)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'J	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing itX	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selection<return>		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)esc			Select current type-inshift-delete	Forward delete characterEnclose the selection in a kind of bracket.  Each is a toggle.Control-(	Enclose within ( and ), or remove enclosing ( and )[	Enclose within [ and ], or remove enclosing [ and ]{	Enclose within { and }, or remove enclosing { and }<	Enclose within < and >, or remove enclosing < and >'	Enclose within ' and ', or remove enclosing ' and '""	Enclose within "" and "", or remove enclosing "" and ""(Double click just inside any of the above delimiters to select the text inside it.)Text Emphasis...1	10 point font2	12 point font3	18 point font  (not in base image)4	24 point font  (not in base image)5	36 point font  (not in base image)6	color, action-on-click, link to class comment, link to method, url	Brings up a menu.  To remove these properties, select	more than the active part and then use command-0.7	bold8	italic9	narrow (same as negative kern)0	plain text (resets all emphasis)-	underlined (toggles it)=	struck out (toggles it)Cmd-shift_ (aka shift -)	negative kern (letters 1 pixel closer)+		positive kern (letters 1 pixel larger spread)"! !!Utilities class methodsFor: 'support windows' stamp: 'di 9/23/1998 01:53'!openCommandKeyHelp	"Open a window giving command key help."	"Utilities openCommandKeyHelp"	(StringHolder new contents: self commandKeyMappings)		openLabel: 'Command Key Actions'! !!Utilities class methodsFor: 'support windows' stamp: 'di 9/23/1998 02:02'!openStandardWorkspace 	"Open up a throwaway workspace with useful expressions in it.  1/22/96 sw"	"Utilities openStandardWorkspace"	(StringHolder new contents: self standardWorkspaceContents)		openLabel: 'Useful Expressions ', Date today printString! !!Utilities class methodsFor: 'support windows' stamp: 'sw 9/22/1998 16:44'!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 5000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.(FileStream oldFileNamed: 'DryRot.cs') edit.(FileStream oldFileNamed: 'change.cs') fileInChangeList browseFile: 'Elvis.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspectSystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[Smalltalk allCallsOn: #asOop]MessageTally spyOn: [Smalltalk allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 7/22/1998 17:12'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict _ Dictionary new.	report _ ReadWriteStream on: ''.	f _ FileStream oldFileNamed: fileName1.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f _ FileStream oldFileNamed: fileName2.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className _ items first.			newInstCount _ items third asNumber.			newSpace _ items fourth asNumber.			oldPair _ instCountDict at: className ifAbsent: [nil].			oldInstCount _ oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace _ oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'common requests' stamp: 'di 9/22/1998 16:04'!closeAllDebuggers	"Utilities closeAllDebuggers"	Smalltalk isMorphic	ifTrue:		[(SystemWindow allInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w delete]]	ifFalse:		[(StandardSystemController allInstances select: [:w | w model isKindOf: Debugger])			do: [:w | w closeAndUnscheduleNoTerminate]]! !!Utilities class methodsFor: 'common requests' stamp: 'di 9/22/1998 16:06'!initializeCommonRequestStrings	"Initialize an array of common request strings.  2/1/96 sw	 5/10/96 sw: converted over to new format of StringHolder"	CommonRequestStrings _ StringHolder new contents: 'Utilities emergencyCollapseUtilities closeAllDebuggersSensor keyboardCursor normal show----------------------------------ScriptingSystem inspectFormDictionaryPreferences enable: #showTimeStampsInMenuTitlesPreferences enable: #cmdDotEnabledForm fromUser bitEditDisplay border: (0@0 extent: 640@480) width: 2----------------------------------Undeclared inspectUndeclared removeUnreferencedKeys; inspectTranscript clearChangeSorter removeEmptyUnnamedChangeSets'"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'di 9/23/1998 02:03'!fontSizeSummary	"Utilities fontSizeSummary"	| aStream aList |	aStream _ ReadWriteStream on: ''.	aList _ Utilities knownTextStyles.	aList do: [:aStyleName |		aStream nextPutAll:			aStyleName, '  ',			(Utilities fontSizesFor: aStyleName) asArray storeString.		aStream cr].	(StringHolder new contents: aStream contents)		openLabel: 'Font styles and sizes'! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:49'!windowFromMenu: aMenu target: aTarget title: aTitle	"Supply a default list of colors"	^ self windowFromMenu: aMenu target: aTarget title: aTitle		colorPattern: #(lightRed lightGreen lightBlue lightYellow lightGray lightCyan lightMagenta lightOrange)! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:48'!windowFromMenu: aMenu target: aTarget title: aTitle colorPattern: aColorPattern	| labelList targetList selectionList i |	selectionList _ aMenu selections.	labelList _ (1 to: selectionList size) collect:		[:ind | aMenu labelString lineNumber: ind].	targetList _  (1 to: selectionList size) collect: [:ind | aTarget].	(i _ labelList indexOf: 'keep this menu up') > 0 ifTrue:		[selectionList _ selectionList copyReplaceFrom: i to: i with: Array new.		labelList _ labelList copyReplaceFrom: i to: i with: Array new.		targetList _ targetList copyReplaceFrom: i to: i with: Array new].	self windowMenuWithLabels:  labelList colorPattern: aColorPattern targets: targetList selections: selectionList title: aTitle! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:44'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld colorList  pos delta aButton  rightmost widthToUse |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aWorld _ WorldMorph new.	colorList _  (1 to: labelList size) collect:		[:ind | Color perform: (colorPattern at: (ind \\ colorPattern size + 1))].				pos _ 4 @ 6.	delta _ 0 @ 30.	rightmost _ 0.	1 to: labelList size do:		[:index |			aButton _ SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost _ rightmost max: aButton right.			pos _ pos + delta.			aWorld addMorphBack: aButton].	widthToUse _ rightmost + 10.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle cautionOnClose: false! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents	^contents! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents: newContents	contents _ newContents.	self changed: #contents! !Serves as the container for displaying one or more viewers in a tabbed palette.!!ViewerBook methodsFor: 'all' stamp: 'sw 6/19/1998 18:25'!partsViewer	^ submorphs size == 0 ifTrue: [nil] ifFalse: [submorphs first]! !!ViewerBook methodsFor: 'all' stamp: 'sw 7/21/1998 23:21'!repelsMorph:  aMorph event: evt	^ true! !!ViewerBook methodsFor: 'all' stamp: 'sw 7/1/1998 18:04'!setPlayer: aPlayer	| aPartsViewer |	"currentPage ifNotNil: [currentPage partsViewer scriptedPlayer == aPlayer ifTrue: [^ self]]."	self flag: #deferred.  "viewer cache soon"	"self presenter viewerCache at: aPlayer ifPresent:		[^ self ".	self world "temporarily, so it can get initialized!!" addMorph:		(aPartsViewer _ PartsViewer newSticky).	aPartsViewer setPlayer: aPlayer.	self presenter coloredTilesEnabled ifFalse:		[aPartsViewer makeAllTilesGreen].	self removeAllMorphs.	self newPages: (OrderedCollection with: aPartsViewer) currentIndex: 1! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 8/17/1998 17:29'!computeSlopeAtMSecs: mSecs	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [  "past end"			targetVol _ points last y * decayScale.			mSecsForChange _ 0.			nextRecomputeTime _ mSecs + 1000000.			^ self].		targetVol _ (points at: i) y * decayScale.		mSecsForChange _ (((points at: i) x - t) min: (endMSecs - mSecs)) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		^ self].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.		targetVol _ (points at: i) y.		mSecsForChange _ ((points at: i) x - mSecs) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		((loopEndMSecs ~~ nil) and: [nextRecomputeTime > loopEndMSecs])			ifTrue: [nextRecomputeTime _ loopEndMSecs].		^ self].	"sustain and loop phase"	noChangesDuringLoop ifTrue: [		targetVol _ (points at: loopEndIndex) y.		mSecsForChange _ 10.		loopEndMSecs == nil			ifTrue: [nextRecomputeTime _ mSecs + 10]  "unknown end time"			ifFalse: [nextRecomputeTime _ loopEndMSecs].		^ self].	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	targetVol _ (points at: i) y.	mSecsForChange _ ((points at: i) x - t) max: 4.	nextRecomputeTime _ (mSecs + mSecsForChange) min: loopEndMSecs.! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 9/10/1998 07:04'!updateTargetAt: mSecs	"Update the volume envelope slope and limit for my target. Answer false."	mSecs < nextRecomputeTime ifTrue: [^ false].	self computeSlopeAtMSecs: mSecs.	mSecsForChange < 5 ifTrue: [mSecsForChange _ 5].  "don't change instantly to avoid clicks"	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.	^ false! !!VolumeEnvelope methodsFor: 'all' stamp: 'jm 8/17/1998 08:00'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope."	scale _ aNumber asFloat.! !This tool was created to aid in the preparation of LoopedSampledSound objects. It includes support for finding good loop points with a little help from the user.  Namely, the user must identify a good ending point for the loop (typically just before the decay phase begins) and identify one cycle of the waveform. After that, the  "choose loop point" menu command can be invoked to search backwards to find and rank all possible loop starting points. Some experimentation is usually required to find a loop that "breaths" in a natural way.This tool can also be used as a general viewer of numerical sequences of any kind, such as time-varying functions, FFT data, etc.!!WaveEditor methodsFor: 'initialization' stamp: 'jm 7/9/1998 09:16'!addControls	| slider b r m |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'X';					actionSelector: #delete).	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;															actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Play';				actionSelector: #play).	r addMorphBack: (b fullCopy label: 'Play Before';		actionSelector: #playBeforeCursor).	r addMorphBack: (b fullCopy label: 'Play After';			actionSelector: #playAfterCursor).	r addMorphBack: (b fullCopy label: 'Play Loop';			actionSelector: #playLoop).	r addMorphBack: (b fullCopy label: 'Test';				actionSelector: #playTestNote).	r addMorphBack: (b fullCopy label: 'Save';				actionSelector: #saveInstrument).	r addMorphBack: (b fullCopy label: 'Set Loop End';		actionSelector: #setLoopEnd).	r addMorphBack: (b fullCopy label: 'One Cycle';			actionSelector: #setOneCycle).	r addMorphBack: (b fullCopy label: 'Set Loop Start';		actionSelector: #setLoopStart).	self addMorphBack: r.	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Index: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #cursor; putSelector: #cursor:;		growable: false; width: 71; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Value: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #valueAtCursor; putSelector: #valueAtCursor:;		growable: false; width: 50; step.	r addMorphBack: m.	slider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #scrollTime:.	r addMorphBack: slider.	m _ Morph new color: r color; extent: 10@5.  "spacer"	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #startIndex; putSelector: #startIndex:;		width: 40; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 8/17/1998 20:31'!addLoopPointControls	| r m |	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Loop end: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopEnd; putSelector: #loopEnd:;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop length: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopLength; putSelector: #loopLength:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop cycles: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopCycles; putSelector: #loopCycles:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Frequency: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #perceivedFrequency; putSelector: #perceivedFrequency:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 7/9/1998 08:27'!initialize	super initialize.	samplingRate _ SoundPlayer samplingRate.	loopEnd _ loopLength _ 0.	loopCycles _ 1.	perceivedFrequency _ 0.  "zero means unknown"	self extent: 5@5;		orientation: #vertical;		centering: #topLeft;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		inset: 3;		color: Color lightGray;		borderWidth: 2.	graph _ GraphMorph new extent: 450@100.	graph cursor: 0.	graph cursorColorAtZeroCrossings: Color blue.	self addControls.	self addLoopPointControls.	self addMorphBack: graph.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:43'!chooseLoopStart	| bestLoops menu secs choice start |	possibleLoopStarts ifNil: [		Utilities			informUser: 'Finding possible loop points...'			during: [possibleLoopStarts _ self findPossibleLoopStartsFrom: graph cursor]].	bestLoops _ possibleLoopStarts copyFrom: 1 to: (100 min: possibleLoopStarts size).	menu _ CustomMenu new.	bestLoops do: [:entry |		secs _ ((loopEnd - entry first) asFloat / self samplingRate) roundTo: 0.01.		menu add: secs printString, ' secs' action: entry].	choice _ menu startUp.	choice ifNil: [^ self].	loopCycles _ choice at: 3.	start _ self fractionalLoopStartAt: choice first.	self loopLength: (loopEnd asFloat - start) + 1.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/18/1998 07:04'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('play straight through'		play)		('play before cursor'		playBeforeCursor)		('play after cursor'			playAfterCursor)		('play test note'				playTestNote)		('play loop'					playLoop)		('trim before cursor'		trimBeforeCursor)		('trim after cursor'			trimAfterCursor)		('choose loop start'			chooseLoopStart)		('jump to loop start'			jumpToLoopStart)		('jump to loop end'			jumpToLoopEnd)		('make unlooped'			setUnlooped)		('make unpitched'			setUnpitched)		('show envelope'			showEnvelope)		('show FFT'					showFFTAtCursor)).	aMenu invokeOn: self defaultSelection: nil.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:42'!jumpToLoopEnd	graph cursor: loopEnd; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 10:09'!jumpToLoopStart	graph cursor: (loopEnd - loopLength) truncated; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 09:23'!play	graph data size < 2 ifTrue: [^ self].	(SampledSound samples: graph data samplingRate: samplingRate) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:40'!playAfterCursor	self playFrom: graph cursor to: graph data size.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:39'!playBeforeCursor	self playFrom: 1 to: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:02'!playFrom: start to: end	| sz i1 i2 snd |	sz _ graph data size.	i1 _ ((start + 1) min: sz) max: 1.	i2 _ ((end + 1) min: sz) max: i1.	(i1 + 2) >= i2 ifTrue: [^ self].	snd _ SampledSound		samples: (graph data copyFrom: i1 to: i2)		samplingRate: samplingRate.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:39'!playLoop	| sz i1 i2 snd len |	sz _ graph data size.	i1 _ ((loopEnd - loopLength) truncated min: sz) max: 1.	i2 _ (loopEnd min: sz) max: i1.	len _ (i2 - i1) + 1.	len < 2 ifTrue: [^ self].	snd _ LoopedSampledSound new		samples: (graph data copyFrom: i1 to: i2)		loopEnd: len		loopLength: loopLength		pitch: 100.0		samplingRate: samplingRate.	"sustain for the longer of four loops or two seconds"	snd setPitch: 100.0		dur: (((4.0 * loopLength) / samplingRate) max: 2.0)		loudness: 0.5.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:38'!playTestNote	| data end snd loopDur dur |	(loopEnd = 0 or: [loopLength = 0]) ifTrue: [^ self].	data _ graph data.	end _ (loopEnd min: data size) max: 1.	snd _ LoopedSampledSound new		samples: data loopEnd: end loopLength: loopLength		pitch: 100.0 samplingRate: samplingRate.	loopDur _ (4.0 * loopLength / samplingRate) max: 2.0.  "longer of 4 loops or 2 seconds"	dur _ (data size / samplingRate) + loopDur.	(snd		addReleaseEnvelope;		setPitch: 100.0 dur: dur loudness: 0.5) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 14:24'!saveInstrument	| name data end snd basePitch |	name _ FillInTheBlank request: 'Instrument name?'.	name isEmpty ifTrue: [^ self].	data _ graph data.	((loopEnd = 0) or: [loopLength = 0])		ifTrue: [  "save as unlooped"			loopLength * loopCycles = 0				ifTrue: [basePitch _ 100.0]				ifFalse: [basePitch _ (samplingRate * loopCycles) / loopLength].			snd _ LoopedSampledSound new				unloopedSamples: data pitch: basePitch samplingRate: samplingRate]		ifFalse: [			end _ (loopEnd min: data size) max: 1.			basePitch _ (samplingRate * loopCycles) / loopLength.			snd _ LoopedSampledSound new				samples: data loopEnd: end loopLength: loopLength				pitch: basePitch samplingRate: samplingRate].	snd addReleaseEnvelope.	AbstractSound soundNamed: name put: snd.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 11:06'!setLoopEnd	graph cursor: (self zeroCrossingAfter: graph cursor) - 1.	self loopEnd: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 08:21'!setLoopStart	"Assuming that the loop end and approximate frequency have been set, this method uses the current cursor position to determine the loop length and the number of cycles."	| start len |	start _ graph cursor.	((start >= loopEnd) or: [perceivedFrequency = 0]) ifTrue: [		^ self inform:'Please set the loop end and the approximate frequencyfirst, then position the cursor one or more cyclesbefore the loop end and try this again.'].	len _ (loopEnd - start) + 1.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setOneCycle	"Set the approximate frequency based on a single cycle specified by the user. To use this, first set the loop end, then place the cursor one full cycle before the loop end and invoke this method."	| len |	len _ loopEnd - graph cursor.	len > 0 ifTrue: [		loopCycles _ 1.		self loopLength: len].! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnlooped	"Make this sound play straight through without looping."	loopLength _ 0.	loopCycles _ 1.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnpitched	"Make this instrument be unpitched and unlooped. Suitable for percussive sounds that should not be pitch-shifted when played. By convention, such sounds are played at a pitch of 100.0 to obtain their original pitch."	loopLength _ 0.	loopCycles _ 0.	perceivedFrequency _ 100.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!showEnvelope	"Show an envelope wave constructed by collecting the maximum absolute value of the samples in fixed-size time windows of mSecsPerQuanta."	| data mSecsPerQuanta samplesPerQuanta result endOfQuanta maxThisQuanta s |	data _ graph data.	mSecsPerQuanta _ 10.	samplesPerQuanta _ (mSecsPerQuanta / 1000.0) * self samplingRate.	result _ WriteStream on: (Array new: data size // samplesPerQuanta).	endOfQuanta _ samplesPerQuanta.	maxThisQuanta _ 0.	1 to: data monoSampleCount do: [:i |		i asFloat > endOfQuanta ifTrue: [			result nextPut: maxThisQuanta.			maxThisQuanta _ 0.			endOfQuanta _ endOfQuanta + samplesPerQuanta].		s _ data at: i.		s < 0 ifTrue: [s _ 0 - s].		s > maxThisQuanta ifTrue: [maxThisQuanta _ s]].	WaveEditor openOn: result contents.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/18/1998 07:21'!showFFTAtCursor	| data start availableSamples nu n fft r |	data _ graph data.	start _ graph cursor max: 1.	availableSamples _ (data size - start) + 1.	nu _ 12.	nu > (availableSamples highBit - 1) ifTrue:		[^ self inform: 'Too few samples after the cursor to take an FFT.'].	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((start to: start + n - 1) collect: [:i | data at: i]).	fft transformForward: true.	r _ (1 to: n // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	WaveEditor openOn: r.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:48'!trimAfterCursor	graph data: (graph data copyFrom: 1 to: graph cursor).! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:52'!trimBeforeCursor	graph data: (graph data copyFrom: graph cursor to: graph data size).	graph cursor: 1.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/5/1998 12:43'!data: newData	graph data: newData.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/3/2004 18:16'!graph	^ graph! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 09:48'!loopCycles	^ loopCycles! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:21'!loopCycles: aNumber	loopCycles _ aNumber.	self loopLength: loopLength.  "updates frequency"! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 6/30/1998 17:20'!loopEnd	^ loopEnd! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/31/1998 14:01'!loopEnd: aNumber	loopEnd _ (aNumber asInteger max: 1) min: graph data size.	possibleLoopStarts _ nil.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 08:38'!loopLength	^ loopLength! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 21:03'!loopLength: aNumber	loopLength _ aNumber.	((loopCycles > 0) and: [loopLength > 0]) ifTrue: [		perceivedFrequency _ samplingRate asFloat * loopCycles / loopLength].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 10:08'!loopStart	^ (loopEnd - loopLength) truncated + 1! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:46'!loopStart: index	| start len |	start _ self fractionalLoopStartAt: index.	len _ (loopEnd asFloat - start) + 1.0.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:31'!perceivedFrequency	^ perceivedFrequency! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:32'!perceivedFrequency: aNumber	perceivedFrequency _ aNumber.	(loopCycles > 0) ifTrue: [		loopLength _ samplingRate asFloat * loopCycles / perceivedFrequency].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate	^ samplingRate! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate: samplesPerSecond	samplingRate _ samplesPerSecond.! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/30/1998 18:51'!autoCorrolationBetween: index1 and: index2 length: length	"Answer the cummulative error between the portions of my waveform starting at the given two indices and extending for the given length. The larger this error, the greater the difference between the two waveforms."	| data error i1 e |	data _ graph data.	error _ 0.	i1 _ index1.	index2 to: (index2 + length - 1) do: [:i2 |		e _ (data at: i1) - (data at: i2).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e.		i1 _ i1 + 1].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/28/1998 02:29'!errorBetween: sampleArray1 and: sampleArray2	"Answer the cummulative error between the two sample arrays, which are assumed to be the same size."	| error e |	error _ 0.	1 to: sampleArray1 size do: [:i |		e _ (sampleArray1 at: i) - (sampleArray2 at: i).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:25'!findPossibleLoopStartsFrom: index	"Assume loopEnd is one sample before a zero-crossing."	| r postLoopCycleStart i postLoopCycleLength cycleLength cycleCount err oldI |	r _ OrderedCollection new.	"Record the start and length of the first cycle after the loop endpoint."	postLoopCycleStart _ loopEnd + 1.  "Assumed to be a zero-crossing."	i _ self zeroCrossingAfter: postLoopCycleStart + (0.9 * samplingRate / perceivedFrequency) asInteger.	postLoopCycleLength _ i - loopEnd - 1.	"Step backwards one cycle at a time, using zero-crossings to find the	 beginning of each cycle, and record the auto-corrolation error between	 each cycle and the cycle following the loop endpoint. Assume pitch may shift gradually."	i _ self zeroCrossingAfter: postLoopCycleStart - (1.1 * postLoopCycleLength) asInteger.	cycleLength _ postLoopCycleStart - i.	cycleCount _ 1.	[cycleLength > 0] whileTrue: [		err _ self autoCorrolationBetween: i and: postLoopCycleStart length: postLoopCycleLength.		r add: (Array				with: i				with: err				with: cycleCount				with: (((loopEnd - i) asFloat / self samplingRate) roundTo: 0.01)).		oldI _ i.		i _ self zeroCrossingAfter: oldI - (1.1 * cycleLength) asInteger.		cycleLength _ oldI - i.  "will be zero when start of data is encountered"		cycleCount _ cycleCount + 1].	r _ r asSortedCollection: [:e1 :e2 | (e1 at: 2) < (e2 at: 2)].	^ r asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:27'!fractionalLoopStartAt: index	"Answer the fractional index starting point near the given integral index that results in the closest match with the cycle following the loop end."	"Note: could do this more efficiently by sliding downhill on the error curve to find lowest error."	| oneCycle w1 minErr w2 err bestIndex |	oneCycle _ (samplingRate / perceivedFrequency) rounded.	w1 _ self interpolatedWindowAt: loopEnd + 1 width: oneCycle.	minErr _ SmallInteger maxVal.	((index - 2) max: 1) to: ((index + 2) min: graph data size) by: 0.01 do: [:i |		w2 _ self interpolatedWindowAt: i width: oneCycle.		err _ self errorBetween: w1 and: w2.		err < minErr ifTrue: [			bestIndex _ i.			minErr _ err]].	^ bestIndex! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/31/1998 11:54'!interpolatedWindowAt: index width: nSamples	"Return an array of N samples starting at the given index in my data."	| scale data baseIndex scaledFrac scaledOneMinusFrac prevSample nextSample v |	scale _ 10000.	data _ graph data.	index isInteger		ifTrue: [^ (index to: index + nSamples - 1) collect: [:i | data at: i]].	baseIndex _ index truncated.	scaledFrac _ ((index asFloat - baseIndex) * scale) truncated.	scaledOneMinusFrac _ scale - scaledFrac.	prevSample _ data at: baseIndex.	^ (baseIndex + 1 to: baseIndex + nSamples) collect: [:i |		nextSample _ data at: i.		v _ ((nextSample * scaledFrac) + (prevSample * scaledOneMinusFrac)) // scale.		prevSample _ nextSample.		v].! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/19/1998 15:03'!normalize: sampleArray	"Return a copy of the given sample array scaled to use the maximum 16-bit sample range. Remove any D.C. offset."	| max abs scale out |	max _ 0.	sampleArray do: [:s |		s > 0 ifTrue: [abs _ s] ifFalse: [abs _ 0 - s].		abs > max ifTrue: [max _ abs]].	scale _ ((1 << 15) - 1) asFloat / max.	out _ sampleArray species new: sampleArray size.	1 to: sampleArray size do: [:i |		out at: i put: (scale * (sampleArray at: i)) truncated].	^ out! !!WaveEditor methodsFor: 'other' stamp: 'jm 6/30/1998 16:11'!scrollTime: relativeValue	graph startIndex: relativeValue * (graph data size - (graph width // 2)).! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/20/1998 09:13'!stretch: sampleArray by: stretchFactor	"Return an array consisting of the given samples \stretched in time by the given factor."	| out end incr i frac index |	out _ OrderedCollection new: (stretchFactor * sampleArray size) asInteger + 1.	end _ (sampleArray size - 1) asFloat.	incr _ 1.0 / stretchFactor.	i _ 1.0.	[i < end] whileTrue: [		frac _ i fractionPart.		index _ i truncated.		i _ i + incr.		out addLast:			(((1.0 - frac) * (sampleArray at: index)) + (frac * (sampleArray at: index + 1))) rounded].	^ out asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/10/1998 15:08'!zeroCrossingAfter: index	"Find the index of the next negative-to-non-negative transition at or after the current index. The result is the index, i, of a zero crossing such that the sample at i-1 is negative and the sample at i is zero or positive. Answer the index of the last sample if the end of the array is encountered before finding a zero crossing."	| data end i |	data _ graph data.	end _ data size.	index <= 1 ifTrue: [^ 1].	i _ index - 1.	[(i <= end) and: [(data at: i) >= 0]] whileTrue: [i _ i + 1].  "find next negative sample"	i >= end ifTrue: [^ end].	i _ i + 1.	[(i <= end) and: [(data at: i) < 0]] whileTrue: [i _ i + 1].  "find next non-negative sample"	^ i! !!WaveEditor class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 21:04'!openOn: dataCollection	"Open a new WaveEditor on the given sequencable collection of data."	(self new data: dataCollection) openInWorld.! !A viewer for a collection of URLs for SqueakPages. Pages can be stepped through in sequence or a bookmark can be used to jump to a specific page.!!WebBookMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 14:35'!initialize	super initialize.	self setInitialState.	self showPageControls.	self class turnOffSoundWhile: [self insertPage].! !!WebBookMorph methodsFor: 'initialization' stamp: 'sw 6/25/1998 17:01'!removeEverything	self setInitialState.	urls _ OrderedCollection new.	self removeAllMorphs! !!WebBookMorph methodsFor: 'initialization' stamp: 'jm 6/17/1998 14:18'!setInitialState	orientation _ #vertical.	centering _ #topLeft.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	inset _ 5.	color _ Color white.	urls _ OrderedCollection new.	currentURL _ nil.	currentContents _ nil.	pageSize _ 200@250.! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 14:04'!currentPage	^ currentContents! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/16/1998 14:28'!urls	^ urls! !!WebBookMorph methodsFor: 'accessing' stamp: 'jm 6/25/1998 13:27'!urls: urlList	urls _ urlList copy asOrderedCollection.	self class turnOffSoundWhile: [		urls size = 0 ifTrue: [self insertPage].		self goToPage: 1].! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/17/1998 15:21'!acceptSortedContentsFrom: aHolderMorph	"Update my url list from the given page sorter."	| newURLs |	newURLs _ urls species new.	aHolderMorph submorphsDo: [:m |		(m isKindOf: URLMorph) ifTrue: [newURLs add: m url]].	urls _ newURLs.	urls isEmpty ifTrue: [^ self insertPage].	self goToPage: aHolderMorph cursor.! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/17/1998 22:23'!bookmarksForAllPages	| mList sorter |	mList _ self morphsForPageSorter.	mList do: [:m | m isBookmark: true; book: self].	sorter _ BookPageSorterMorph new book: self morphsToSort: mList.	sorter closeButtonOnly.	sorter pageHolder cursor: (urls indexOf: currentURL ifAbsent: [0]).	self presentResultMorph: sorter.! !!WebBookMorph methodsFor: 'page sorting' stamp: 'sw 7/4/1998 16:07'!indexOfCurrentPage	^ urls indexOf: currentURL ifAbsent: [0]! !!WebBookMorph methodsFor: 'page sorting' stamp: 'jm 6/16/1998 18:18'!morphsForPageSorter	| pg sorterMorphs |	sorterMorphs _ OrderedCollection new: urls size.	urls do: [:url |		pg _ SqueakPageCache atURL: url ifAbsent: [nil].		pg ifNotNil: [sorterMorphs addLast: (URLMorph newForURL: url)]].	^ sorterMorphs! !!WebBookMorph methodsFor: 'menu' stamp: 'jm 6/17/1998 22:25'!invokeBookMenu	"Answer the menu for the the book-control panel."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('save page'					savePage)		('reload page'				reloadPage)		('bookmark for this page'	bookmarkForThisPage)		('bookmarks for all pages'	bookmarksForAllPages)		('sort pages'					sortPages)		('text'						newTextMorph)		('hide page controls'			hidePageControls)		('save book'					saveBookToFile)).	aMenu add: 'save as new-page prototype' action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' action: #clearNewPagePrototype].	aMenu invokeOn: self defaultSelection: nil.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 22:23'!bookmarkForThisPage	"Make a Bookmark for the current URL."	| b |	currentURL ifNil: [^ self].	self savePage.	b _ URLMorph newBookmarkForURL: currentURL.	self presentResultMorph: b.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 14:50'!deletePage	| oldURL |	(self confirm: 'Really delete this page?') ifFalse: [^ self].	oldURL _ currentURL.	self nextPage.	urls remove: oldURL ifAbsent: [].	urls isEmpty ifTrue: [self insertPage].! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 10:37'!goToPage: pageNumber	| i |	urls isEmpty ifTrue: [^ self].	i _ pageNumber asInteger.	pageNumber < 1 ifTrue: [i _ urls size].	pageNumber > urls size ifTrue: [i _ 1].	self goToURL: (urls at: i).! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 11:57'!goToURL: aURLString	| newIndex ascending oldIndex pg |	newIndex _ urls indexOf: aURLString.	newIndex = 0		ifTrue: [ascending _ nil]		ifFalse: [			oldIndex _ urls indexOf: currentURL ifAbsent: [0].			ascending _ newIndex > oldIndex].	self savePageIfNecessary.	pg _ SqueakPageCache atURL: aURLString ifAbsent: [^ self].	currentURL _ aURLString.	self revealPage: pg contentsMorph ascending: ascending.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 18:20'!lastPage	self goToPage: urls size.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/17/1998 22:23'!newTextMorph	"Create a new, empty TextMorph that can be placed in this book."	self presentResultMorph: (TextMorph new extent: currentContents width@30).! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 14:04'!nextPage	| i |	currentURL == nil ifTrue: [^ self goToPage: 1].	i _ (urls indexOf: currentURL ifAbsent: [0]) + 1.	self goToPage: i.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/16/1998 14:04'!previousPage	| i |	currentURL == nil ifTrue: [^ self goToPage: 1].	i _ (urls indexOf: currentURL ifAbsent: [2]) - 1.	self goToPage: i.! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 12:46'!reloadPage	"Reload the current page."	currentContentsChanged _ false.  "don't ask about changes"	self goToURL: currentURL. ! !!WebBookMorph methodsFor: 'commands' stamp: 'tk 8/13/1998 13:11'!saveBookToFile	"Save this book in a file."	| fileName fileStream |	self ensurePagesAreExternal ifFalse: [^ self].	fileName _ FillInTheBlank request: 'File name for this Book?'.	fileName isEmpty ifTrue: [^ self].  "abort"	self allMorphsDo: [:m | m prepareToBeSaved].	fileStream _ FileStream newFileNamed: fileName,'.morph'.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!WebBookMorph methodsFor: 'commands' stamp: 'jm 6/25/1998 10:45'!savePage	"Save the current page."	currentContentsChanged _ true.  "force save to happen"	self savePageIfNecessary.! !!WebBookMorph methodsFor: 'commands' stamp: 'tk 8/13/1998 13:16'!setNewPagePrototype	"Record the current page as the prototype to be copied when inserting new pages."	currentContents ifNotNil:		[newPagePrototype _ currentContents veryDeepCopy].! !!WebBookMorph methodsFor: 'updating' stamp: 'jm 6/25/1998 12:44'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| myPage |	myPage _ SqueakPageCache atURL: currentURL ifAbsent: [nil].	myPage == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	currentContentsChanged ifFalse: [		myPage contentsMorph == originalContents ifTrue: [^ self].		self class turnOffSoundWhile: [self goToURL: currentURL]]. ! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/16/1998 18:21'!ensurePagesAreExternal	"Check that all the pages referred to by this book have external homes, and answer false if they do not. Answer true if all pages have external homes or if the user decides to proceed anyway. Pages without external homes will be missing when the book is read back in."	self halt: 'not yet implemented'.! !!WebBookMorph methodsFor: 'private' stamp: 'tk 8/13/1998 13:07'!insertPageColored: aColor	| sz bw bc newContents newURL |	newPagePrototype		ifNil: [			currentContents				ifNil: [					sz _ pageSize.					bw _ 0.					bc _ Color blue muchLighter]				ifNotNil: [					sz _ currentContents extent.					bw _ currentContents borderWidth.					bc _ currentContents borderColor].			newContents _ PasteUpMorph new extent: sz; color: aColor.			newContents borderWidth: bw; borderColor: bc]		ifNotNil: [			newContents _ newPagePrototype veryDeepCopy].	newContents resizeToFit: false.	newURL _ SqueakPage newURLAndPageFor: newContents.	urls isEmpty		ifTrue: [urls add: newURL]		ifFalse: [urls add: newURL after: currentURL].	self nextPage.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/17/1998 14:05'!insertPageLabel: labelString morphs: morphList	| pg m c labelAllowance |	self insertPage.	pg _ currentContents.	labelString ifNotNil:			[m _ (TextMorph new extent: pg width@20; contents: labelString).		m lock.		m position: pg position + (((pg width - m width) // 2) @ 5).		pg addMorph: m.		labelAllowance _ 40]		ifNil:			[labelAllowance _ 0].	"use a column to align the given morphs, then add them to the page"	c _ AlignmentMorph newColumn centering: #center.	c addAllMorphs: morphList.	c position: pg position + (0 @ labelAllowance).	pg addAllMorphs: morphList.	^ pg! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/18/1998 12:10'!layoutChanged	super layoutChanged.	currentContentsChanged _ true.! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/17/1998 22:22'!presentResultMorph: aMorph	"Add the given morph to the world."	aMorph position: self fullBounds topRight + (5@0).	self world addMorphFront: aMorph.! !!WebBookMorph methodsFor: 'private' stamp: 'tk 8/13/1998 13:07'!revealPage: aMorph ascending: ascending	| w r oldOrigin |	w _ self world.	w ifNotNil: [self primaryHand newKeyboardFocus: nil].	currentContents ifNotNil: [		(r _ currentContents screenRectangle) ifNotNil: [oldOrigin _ r origin].		currentContents delete].	originalContents _ aMorph.	currentContents _ aMorph veryDeepCopy.	self addMorphBack: currentContents.	w ifNotNil: [		w startSteppingSubmorphsOf: currentContents.		self showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending].	currentContentsChanged _ false.! !!WebBookMorph methodsFor: 'private' stamp: 'tk 8/13/1998 13:16'!savePageIfNecessary	"About to go to a new page; save the current page if necessary."	| oldPage morphToSave |	currentContentsChanged ifNil: [currentContentsChanged _ false].	currentContentsChanged ifFalse: [		"no need to save, but do release cached state of viewed page"		originalContents allMorphsDo: [:m | m releaseCachedState].		^ self].	oldPage _ SqueakPageCache atURL: currentURL ifAbsent: [^ self].	oldPage contentsMorph ~~ originalContents ifTrue: [		(self confirm: 'Someone else has changed this page; save this copy?')			ifFalse: [^ self]].	morphToSave _ currentContents fullCopy.		self flag: #noteToTed.	"Must use veryDeepCopy.  Saving must write Player code too."  	currentContentsChanged _ false.	originalContents _ morphToSave.	oldPage saveMorph: morphToSave author: Utilities authorInitials. ! !!WebBookMorph methodsFor: 'private' stamp: 'jm 6/18/1998 12:31'!showPageTurningFeedbackFromOrigin: oldOrigin ascending: ascending	| f |	((ascending == nil) | (oldOrigin == nil) | (currentContents == nil))		ifTrue: [^ self].	PageFlipSoundOn ifTrue: [		f _ currentContents imageForm.		self playPageFlipSound.		Display wipeImage: f				at: oldOrigin				delta: (ascending ifTrue: [0@-10] ifFalse: [0@10])].! !!WebBookMorph class methodsFor: 'all' stamp: 'sw 6/25/1998 17:25'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book _ self new markAsPartsDonor.	book removeEverything; pageSize: 128@102; color: Color white.	book borderWidth: 1; borderColor: Color black.	book showPageControls; insertPage.	book layoutChanged.	^ book! !!WebBookMorph class methodsFor: 'all' stamp: 'jm 9/24/97 08:42'!initialize	"WebBookMorph initialize"	PageFlipSoundOn _ true.! !!WebBookMorph class methodsFor: 'all' stamp: 'tk 8/13/1998 13:06'!newFromOldBook: oldBookMorph	"Make a new instance of me whose pages are copies of the pages in the given book. Does not modify the original book."	| urlList |	urlList _ oldBookMorph pages collect:		[:oldPg | SqueakPage newURLAndPageFor: oldPg veryDeepCopy].	^ self new urls: urlList! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 9/14/1998 12:36'!configureForConstruction	| aPanel aCan |	self addMorph: (self presenter newStandardPartsBin position: 10@10).	presenter standardPlayer.	aPanel _ presenter controlPanel.	self addMorph: aPanel.	self positionControlPanel: aPanel.	aCan _ self presenter addTrashCan.	aCan position: (Display boundingBox bottomRight - aCan extent).  "This oddity necessary to avoid the trashcan's showing up at top-left until an ownerChanged is sent to it; the problem is that addTrashCan: is called too early otherwise."! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 8/5/1998 07:29'!initialize	super initialize.	color _ (Color r:0.937 g: 0.937 b: 0.937).	fillColor2 _ color.	hands _ Array new.	self addHand: HandMorph new.	viewBox _ canvas _ nil.	damageRecorder _ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ 0.	balloonHelpEnabled _ true.	self setProperty: #automaticPhraseExpansion toValue: true.	model _ nil.! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 9/21/1998 17:55'!openWithTitle: aString cautionOnClose: aBoolean	"Open a view on this WorldMorph with the given title."	MorphWorldView openOn: self label: aString cautionOnClose: aBoolean! !!WorldMorph methodsFor: 'initialization' stamp: 'sw 8/3/1998 14:12'!positionControlPanel: aPanel	| referencePos |	referencePos _ bounds width > 200		ifTrue:		[bounds bottomRight]		ifFalse:		[Display boundingBox bottomRight].	aPanel position:  (referencePos - ((70 + aPanel width) @ (aPanel height + 4)))! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:28'!exit	self sleep.	Project current exit.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 6/23/1998 09:28'!goBack	self sleep.	Project returnToPreviousProject.! !!WorldMorph methodsFor: 'install / exit' stamp: 'di 9/10/1998 16:38'!sleep	canvas ifNil: [^ self  "already called (clean this up)"].	Cursor normal show.	"restore the normal cursor"	(turtleTrailsForm ~~ nil and: [self confirm: 'May I clear the pen trailsin this project to save space?']) ifTrue: [self clearTurtleTrails].	self canvas: nil.		"free my canvas to save space"	self fullReleaseCachedState.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 8/16/1998 00:12'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		hands do: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: canvas.  "repair world's damage on canvas"	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r translateBy: viewBox origin)]]		ifFalse: [canvas showAt: viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldMorph methodsFor: 'drawing' stamp: 'di 9/10/1998 16:27'!drawInvalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: viewBox extent).	damageRecorder reset.	n _ self submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				(mm fullBounds intersects: r) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ aCanvas copyClipRect: rectToFill.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0]].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ aCanvas copyClipRect: r.				c fillColor: color.				turtleTrailsForm ifNotNil: [c image: turtleTrailsForm at: 0@0].				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!WorldMorph methodsFor: 'events' stamp: 'jm 6/10/1998 07:57'!mouseDown: evt	"Handle a mouse down event on the world."	evt hand newKeyboardFocus: self.	evt hand invokeMetaMenu: evt.! !!WorldMorph methodsFor: 'stepping' stamp: 'sw 8/21/1998 16:32'!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list.   Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [m arrangeToStartSteppingIn: self]]! !!WorldMorph methodsFor: 'hands' stamp: 'di 6/14/1998 12:56'!activeHand: aHandMorph	activeHand _ aHandMorph! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/12/1998 08:21'!doOneCycle	self interCyclePause.	self doOneCycleNow.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/13/1998 00:50'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	lastCycleTime _ Time millisecondClockValue.	"process user input events"	hands do: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorld.! !!WorldMorph methodsFor: 'interaction loop' stamp: 'ls 7/13/1998 00:45'!interCyclePause	"delay enough that the next interaction cycle won't happen too soon after the original; thus, if all the system is doing is polling for interaction, the overall CPU usage of Squeak will be low"	| currentTime wait |	MinCycleLapse ifNotNil: [		lastCycleTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastCycleTime + MinCycleLapse - currentTime.			wait > 0 ifTrue: [ 				wait < MinCycleLapse  "big waits happen after a snapshot"					ifTrue: [ (Delay forMilliseconds: wait) wait ]. ]. ]. ].! !!WorldMorph methodsFor: 'painting support' stamp: 'sw 8/22/1998 22:45'!paintBox	"Return the painting controls widget (PaintBoxMorph) to be used for painting in this world. If there is not already a PaintBox morph, or if it has been deleted from this world, create a new one."	| newPaintBox refPoint aPalette |	self allMorphsDo: [:m | (m isKindOf: PaintBoxMorph) ifTrue: [^ m]].	refPoint _ (aPalette _ self standardPalette)		ifNotNil:			[aPalette showNoPalette.			aPalette topRight + (0 @ 12)]		ifNil:			[self topRight].	newPaintBox _ PaintBoxMorph new.	newPaintBox position: (refPoint - (newPaintBox width @ 0)). 	self addMorph: newPaintBox.	^ newPaintBox! !!WorldMorph methodsFor: 'sensing' stamp: 'di 9/9/1998 22:45'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	^ (self patchAt: (aPoint extent: 1@1) belowMorph: aMorph) colorAt: 0@0! !!WorldMorph methodsFor: 'sensing' stamp: 'di 9/9/1998 22:43'!patchAt: patchRect belowMorph: aMorph	"Return the image of the given patch rectangle immediately behind the given morph."	| c root |	c _ FormCanvas extent: patchRect extent depth: Display depth.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	c fillColor: color.  "Fill bounds with world color."	root _ aMorph root.	submorphs reverseDo: [:m |		m == root ifTrue: [			(m morphsIn: patchRect) reverseDo:				[:subM |				subM == aMorph ifTrue: [^ c form].				subM drawOn: c]].		m fullDrawOn: c].	hands reverseDo: [:h |		h submorphsReverseDo: [:m |			m == root ifTrue: [				(m morphsIn: patchRect) reverseDo:					[:subM |					subM == aMorph ifTrue: [^ c form].					subM drawOn: c]].			m fullDrawOn: c]].	^ c form! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'sw 7/19/1998 12:46'!addMorphsAndModel: aMorphOrList	"Dump in submorphs, model, and stepList from aMorphOrList.  Used to bring a world, paste-up, or other morph in from an object file."	aMorphOrList isMorph		ifTrue:			[aMorphOrList isWorldMorph				ifFalse:					["one morph, put on hand"					"aMorphOrList installModelIn: self.  	a chance to install model pointers"					aMorphOrList privateOwner: nil.					self hands first attachMorph: aMorphOrList.					self startSteppingSubmorphsOf: aMorphOrList]				ifTrue: 					[model == nil						ifTrue:							[self setModel: (aMorphOrList modelOrNil)]						ifFalse:							[aMorphOrList modelOrNil ifNotNil:								[aMorphOrList modelOrNil privateOwner: nil.								self addMorph: (aMorphOrList modelOrNil)]].					aMorphOrList privateSubmorphs reverseDo: [:m |						m privateOwner: nil.						self addMorph: m.						m changed].					(aMorphOrList instVarNamed: 'stepList') do:						[:entry | entry first startSteppingIn: self]]]		ifFalse:  "list, add them all"			[aMorphOrList reverseDo: [:m |				m privateOwner: nil.				self addMorph: m.				self startSteppingSubmorphsOf: m.	"It may not want this!!"				m changed]]! !!WorldMorph methodsFor: 'fileIn/Out' stamp: 'tk 8/20/1998 22:18'!veryDeepCopyWith: deepCopier	"Does a WorldMorph really need to be veryDeepCopied?  If so, only copy submorphs, model, and stepList.  Lots of special stuff.  See storeDataOn:"	^ self error: 'not specialized yet'! !!WorldMorph methodsFor: 'etoy support' stamp: 'sw 6/25/1998 08:35'!slotNamesAndTypesForBank: aNumber	"Return an array of part names and part types for use in a viewer on the receiver's costumee; here we only put the costume-specific parts."	^ aNumber == 2		ifTrue:			[#(	(color			color		readWrite	getColor				setColor:)				(mouseX			number		readOnly	getMouseX			unused)				(mouseY		number		readOnly	getMouseY			unused))]		ifFalse:			[Array new]! !!WorldMorph methodsFor: 'object fileIn' stamp: 'tk 9/9/1998 17:11'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslp0: varDict bosfcebbfgccpmcpbttloiairfidcuwhavcdsllb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('lastCycleTime' 'balloonHelpEnabled' ) and deal with the information in ('playerList' )"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 7/15/1998 19:39'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslp0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdslpl0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'playerList' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('lastCycleTime' ) and deal with the information in ()"! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 18:56'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslpl0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdslplb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'playerList' 'lastCycleTime' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in ('balloonHelpEnabled' ) and deal with the information in ()"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'object fileIn' stamp: 'sw 8/5/1998 20:33'!convertbosfcepcbbfgccpmcpbttloiairfidcuwhavcdslplb0: varDict bosfcepcbbfgccpmcpbttloiairfidcuwhavcdsllb0: smartRefStrm	"These variables are automatically stored into the new instance ('hands' 'activeHand' 'viewBox' 'canvas' 'damageRecorder' 'stepList' 'lastStepTime' 'lastCycleTime' 'balloonHelpEnabled' ).	This method is for additional changes. Use statements like (foo _ varDict at: 'foo')."	"Be sure to to fill in () and deal with the information in ('playerList' )"	balloonHelpEnabled _ true! !!WorldMorph methodsFor: 'balloon help' stamp: 'sw 8/5/1998 07:31'!balloonHelpEnabled	^ balloonHelpEnabled ~~ false! !!WorldMorph methodsFor: 'balloon help' stamp: 'sw 8/5/1998 07:31'!toggleShowBalloons	balloonHelpEnabled _ self balloonHelpEnabled not! !!WorldMorph class methodsFor: 'all' stamp: 'ls 7/13/1998 00:44'!MinCycleLapse: milliseconds	"set the minimum amount of time that may transpire between two calls to doOneCycle"	MinCycleLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!WorldMorph class methodsFor: 'all' stamp: 'ls 9/20/1998 11:36'!initialize	"WorldMorph initialize"	self MinCycleLapse: 20.		"allows 50 frames per second..."! !!WorldMorph class methodsFor: 'all' stamp: 'sw 8/3/1998 14:12'!openWithStandardPartsBinShowing	"WorldMorph openWithStandardPartsBinShowing"	| aWorld anExtent aPanel |	anExtent _  700 @ 500.	aWorld _ self new setProperty: #initialExtent toValue: anExtent.	aWorld extent: anExtent.	aWorld presenter addTrashCan.	aPanel _ aWorld presenter controlPanel.	aWorld addMorph: aPanel.	aWorld positionControlPanel: aPanel.	aWorld addMorph: ((aWorld presenter newStandardPartsBin) position: 10@10).	MorphWorldView openOn: aWorld label: 'Construction' extent: anExtent! !Serves as a model for a WorldView -- a morphic world viewed within an mvc project.!!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:50'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	^ (0@0 extent: DisplayScreen actualScreenSize) copy! !!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:51'!initialExtent	initialExtent ifNotNil: [^ initialExtent].	^ super initialExtent! !!WorldViewModel methodsFor: 'all' stamp: 'sw 9/21/1998 17:51'!initialExtent: anExtent	initialExtent _ anExtent! !!WriteStream methodsFor: 'accessing' stamp: 'ls 8/20/1998 10:19'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse: [		^super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > writeLimit ifTrue: [		collection _ collection,			(collection species new: (newEnd - writeLimit + (collection size max: 20)) ).		writeLimit _ collection size ].	collection replaceFrom: position+1 to: newEnd  with: aCollection.	position _ newEnd.! !Smalltalk condenseChanges!Browser initialize!----QUIT----(23 September 1998 6:05:10 pm ) priorSource: 1892340!'From Squeak 2.2beta of Sept 16, 1998 on 24 September 1998 at 6:41:22 am'!!Utilities class methodsFor: 'fetching updates' stamp: 'tk 9/24/1998 06:26' prior: 22228964!position: updateStrm atVersion: version	"Set the stream to the end of the last line of updates names for this version.  Usually the end of the file.  We will add a new update name.   Return the contents of the rest of the file."	| char foundIt where data |	updateStrm reset; ascii.	foundIt _ false.	[char _ updateStrm next.	 updateStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updateStrm peek == $# ifTrue: [				foundIt ifTrue: ["Next section"					where _ updateStrm position.					data _ updateStrm upTo: (255 asCharacter).					updateStrm position: where.					^ data].	"won't be found -- copy all the way to the end"				updateStrm next.				(updateStrm nextMatchAll: version) ifTrue: [					(updateStrm atEnd or: [(updateStrm peek = Character cr) | 						(updateStrm peek = Character lf)]) ifTrue: [							foundIt _ true					]]]]].	foundIt ifTrue: [		updateStrm setToEnd.		^ ''].	self error: 'The current version does not have a section in the Updates file'.! !'From Squeak 2.2 of Sept 23, 1998 on 24 September 1998 at 8:13:48 am'!!HTMLformatter methodsFor: 'translating' stamp: 'tk 9/24/1998 08:08' prior: 34034666!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to: start+1 						with: specialCharacter asString.					start_start + 1. ]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString) 					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>']			ifFalse: [targetStream nextPutAll: aLine].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>'; cr.]]].	^targetStream contents.! !!LessHTMLformatter methodsFor: 'translating' stamp: 'tk 9/24/1998 08:11' prior: 34535609!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to: start+1 						with: specialCharacter asString.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString) 					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll: '<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll: '<h4>',(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll: '<h3>',(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll: '<h2>',(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll: '<h1>',aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll: '<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [targetStream nextPutAll: aLine].]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream cr.]]].	^targetStream contents.! !!URLmap methodsFor: 'private' stamp: 'mjg 9/21/1998 10:47' prior: 35362830!isStringAnImage: anUpperCasedString	"check the string to see if it end with something that makes it likely to be an image URL"	^(anUpperCasedString endsWith: '.GIF') or:		[(anUpperCasedString endsWith: '.JPEG') or:		[anUpperCasedString endsWith: '.JPG']]! !'From Squeak 2.2beta of Sept 16, 1998 on 24 September 1998 at 6:41:22 am'!!Utilities class methodsFor: 'fetching updates' stamp: 'tk 9/24/1998 06:26' prior: 35447058!position: updateStrm atVersion: version	"Set the stream to the end of the last line of updates names for this version.  Usually the end of the file.  We will add a new update name.   Return the contents of the rest of the file."	| char foundIt where data |	updateStrm reset; ascii.	foundIt _ false.	[char _ updateStrm next.	 updateStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updateStrm peek == $# ifTrue: [				foundIt ifTrue: ["Next section"					where _ updateStrm position.					data _ updateStrm upTo: (255 asCharacter).					updateStrm position: where.					^ data].	"won't be found -- copy all the way to the end"				updateStrm next.				(updateStrm nextMatchAll: version) ifTrue: [					(updateStrm atEnd or: [(updateStrm peek = Character cr) | 						(updateStrm peek = Character lf)]) ifTrue: [							foundIt _ true					]]]]].	foundIt ifTrue: [		updateStrm setToEnd.		^ ''].	self error: 'The current version does not have a section in the Updates file'.! !'From Squeak 2.2 of Sept 23, 1998 on 24 September 1998 at 8:13:48 am'!!HTMLformatter methodsFor: 'translating' stamp: 'tk 9/24/1998 08:08' prior: 35448215!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to: start+1 						with: specialCharacter asString.					start_start + 1. ]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString) 					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>']			ifFalse: [targetStream nextPutAll: aLine].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream nextPutAll: '<br>'; cr.]]].	^targetStream contents.! !!LessHTMLformatter methodsFor: 'translating' stamp: 'tk 9/24/1998 08:11' prior: 35450099!swikify: aStringOrStream linkhandler: aBlock	| sourceStream aLine targetStream start end forbidden ignore |	(aStringOrStream isKindOf: Stream)		ifTrue: [sourceStream := aStringOrStream]		ifFalse: [sourceStream := ReadStream on: aStringOrStream].	forbidden _ self rangesOfAngleBrackets: sourceStream.	targetStream := WriteStream on: String new.	[sourceStream atEnd] whileFalse:		[aLine := sourceStream upTo: (Character cr).		" Now, look for links "		start _ 1.		[(start _ aLine indexOfSubCollection: (specialCharacter asString) 				startingAt: start ifAbsent: [0]) ~= 0			and: [start < aLine size]]		whileTrue:			[(aLine at: start+1) = specialCharacter			ifTrue: [aLine _ aLine copyReplaceFrom: start to: start+1 						with: specialCharacter asString.					start_start + 1.]			ifFalse: [				(end _ aLine indexOfSubCollection: (specialCharacter asString) 					startingAt: (start+1) ifAbsent: [0]) ~= 0				ifTrue: [aLine _ aLine copyReplaceFrom: start to: end						with: (aBlock value: (aLine copyFrom: start+1 to: end-1))]				ifFalse: [start _ start + 1]]].		"If it's at least 4 dashes, make it a horizontal rule"		(aLine indexOfSubCollection: '----' startingAt: 1) = 1			ifTrue: [targetStream nextPutAll: '<hr>' ; cr.]			ifFalse: [				(aLine beginsWith: '-')				ifTrue: [targetStream nextPutAll: '<li>',aLine allButFirst; cr.]				ifFalse: [				(aLine beginsWith: '====')				ifTrue: [targetStream nextPutAll: '<h4>',(aLine copyFrom: 5 to: aLine size),'</h4>';cr.]				ifFalse: [				(aLine beginsWith: '===')				ifTrue: [targetStream nextPutAll: '<h3>',(aLine copyFrom: 4 to: aLine size),'</h3>';cr.]				ifFalse: [				(aLine beginsWith: '==')				ifTrue: [targetStream nextPutAll: '<h2>',(aLine copyFrom: 3 to: aLine size),'</h2>';cr.]				ifFalse: [				(aLine beginsWith: '=')				ifTrue: [targetStream nextPutAll: '<h1>',aLine allButFirst,'</h1>';cr.]				ifFalse: [				(aLine beginsWith: '!!')				ifTrue: [targetStream nextPutAll: '<b>',aLine allButFirst,'</b>';cr.]				ifFalse: [targetStream nextPutAll: aLine].]]]]]].		"Should there be a <br> after this line?"		(ignore _ sourceStream peek = $<) ifTrue: [			"If just before a tag, ignore the newline"			targetStream nextPut: $ ].	"but do put in a separator"		forbidden do: [:interval |			(interval includes: sourceStream position) ifTrue: [ignore _ true]].		ignore ifFalse: [			(sourceStream peek) = (Character cr)				ifTrue: [sourceStream next. targetStream nextPutAll: '<p>'; cr.]				ifFalse: [targetStream cr.]]].	^targetStream contents.! !!URLmap methodsFor: 'private' stamp: 'mjg 9/21/1998 10:47' prior: 35452724!isStringAnImage: anUpperCasedString	"check the string to see if it end with something that makes it likely to be an image URL"	^(anUpperCasedString endsWith: '.GIF') or:		[(anUpperCasedString endsWith: '.JPEG') or:		[anUpperCasedString endsWith: '.JPG']]! !'From Squeak 2.0 of May 22, 1998 on 23 September 1998 at 11:28:01 pm'!!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!! 9/23/1998 23:05' prior: 17302009!addClass: class 	"Include indication that a new class was created."	self atClass: class add: #add.	self addCoherency: class name! !!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!! 9/23/1998 23:06' prior: 17303270!changeClass: class 	"Include indication that a class definition has been changed. 	 6/10/96 sw: don't accumulate this information for classes that don't want logging	 7/12/96 sw: use wantsChangeSetLogging flag"	class wantsChangeSetLogging ifTrue: 		[			self atClass: class add: #change.			self addCoherency: class name		]! !!ChangeSet methodsFor: 'change management' stamp: 'SqR!!!! 9/23/1998 23:16'!verifyClassRemoves	"Verify the internal collection of classes to be	removed. For every class name there, check if	a class named like that exists. If it does, then	remove it from the classRemoves. If it doesn't, 	leave it alone. Use this to fix change sets broken	by classes deleted and then added back.	Also, delete the deleted items that are not symbols (?!!)"	classRemoves _ classRemoves reject: [:one | (Smalltalk at: one ifAbsent: []) isNil not or: [one ~~ one asSymbol]]! !!ChangeSet methodsFor: 'private' stamp: 'SqR!!!! 9/23/1998 23:08'!addCoherency: className	"SqR!! 19980923: If I recreate the class then don't remove it"	classRemoves remove: className ifAbsent: [].	(classChanges includesKey: className) ifTrue:		[(classChanges at: className) remove: #remove ifAbsent: []]! !'From Squeak 2.2 of Sept 23, 1998 on 24 September 1998 at 8:22:19 am'!"Change Set:		New ChangesDate:			24 September 1998Author:			Dan IngallsChanged the screenMenu item 'open window...' to 'open...' to differentiate better from the following 'windows...' item."!!HandMorph methodsFor: 'world menu' stamp: 'di 9/24/1998 08:19' prior: 34088536!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'previous project' target: owner action: #goBack.	menu add: 'jump to project...' action: #jumpToProject.	menu add: 'restore display' target: World action: #fullRepaintNeeded.	menu addLine.	menu add: 'new morph...' action: #newMorph.	menu add: 'scripting...' action: #scriptingDo.	menu add: 'remote...' action: #remoteDo.	menu add: 'debug...' action: #debugDo.	menu addLine.	menu add: 'open...' action: #openWindow.	menu add: 'windows...' action: #windowsDo.	menu add: 'changes...' action: #changesDo.	menu add: 'help...' action: #helpDo.	menu add: 'do...' target: Utilities action: #offerCommonRequests.	menu addLine.	menu add: 'save' action: #saveSession.	menu add: 'save as...' action: #saveAs.	menu add: 'save and quit' action: #saveAndQuit.	menu add: 'quit' action: #quitSession.	^ menu! !!ScreenController methodsFor: 'nested menus' stamp: 'di 9/24/1998 08:18' prior: 35069949!projectScreenMenu	"Answer the project screen menu."	^ SelectionMenu labelList:		#(	'keep this menu up'			'previous project'			'jump to project...'			'restore display'			'open...'			'windows...'			'changes...'			'help...'			'do...'			'save'			'save as...'			'save and quit'			'quit')		lines: #(1 4 9)		selections: #(durableScreenMenureturnToPreviousProject jumpToProject restoreDisplaypresentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu commonRequestssnapshot saveAs snapshotAndQuit quit )"ScreenController new projectScreenMenu startUp"! !'From Squeak 2.2 of Sept 23, 1998 on 24 September 1998 at 8:28:50 am'!"Change Set:		shrinkFix-diDate:			24 September 1998Author:			Dan IngallsSeveral tweaks to support for shrinking the system...Fixes a bug in qCompress due to the do: protocol change.Makes discardOddsAndEnds tolerant to missing textStyles in TextConstants.Makes abandonSources disable the warning for no source file (duh)."!!CompiledMethod methodsFor: 'source code management' stamp: 'di 9/23/1998 19:22' prior: 17604218!qCompress: str	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble."	| charTable odd ix oddNibble |	charTable _  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd _ true.  "Flag for odd or even nibble out"		str do:			[:char | ix _ (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [Array with: ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd _ odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble _ nibble]]].		strm nextPut: strm position]"  | m s |  m _ CompiledMethod new.s _ 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 21:55' prior: 21745897!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	 | oldCodeString argsAndTemps bTotal bCount oldMethods newMethods m |	(self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, hit Yes.If you have any doubts, hit No,to back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor cursorPoint	from: 0 to: bTotal	during: [:bar |	Smalltalk allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "		[:cl |  bar value: (bCount _ bCount + 1).		cl selectors do:			[:selector |			m _ cl compiledMethodAt: selector.			m fileIndex > 0 ifTrue:			[oldCodeString _ cl sourceCodeAt: selector.			argsAndTemps _ (cl compilerClass new				parse: oldCodeString in: cl notifying: nil)				tempNames.			oldMethods addLast: m.			newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk condenseChanges.	Preferences disable: #warnIfNoSourcesFile.	Smalltalk allBehaviorsDo: [: b | b zapOrganization]."In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/23/1998 18:51' prior: 35262373!discardOddsAndEnds	"This method throws out lots of classes that are not frequently used."	"Smalltalk discardOddsAndEnds"	SystemOrganization removeCategoriesMatching: 'System-Serial Port'.	"old Form editor:"	SystemOrganization removeSystemCategory: 'Graphics-Symbols'.	Form removeSelector: #edit.	Smalltalk at: #FormView ifPresent:		[:c | c compile: 'defaultControllerClass  ^ NoController'			classified: 'controller access'].	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'Graphics-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	SystemDictionary removeSelector: #viewImageImports.	ScreenController removeSelector: #viewImageImports.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"curve fitting:"	Smalltalk at: #FormEditor ifPresent: [:c | c removeSelector: #curve].	Smalltalk removeClassNamed: #CurveFitter.	Smalltalk removeClassNamed: #LinearFit.	Smalltalk removeClassNamed: #Spline.	"experimental hand-drawn character recoginizer:"	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	Smalltalk removeClassNamed: #CharRecog.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"HTML formatted fileout support:"	StandardFileStream removeSelector: #asHtml.	Smalltalk removeClassNamed: #HtmlFileStream.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SystemMonitor.	Smalltalk at: #SampledSound ifPresent: [:c |		(Smalltalk confirm: 'Remove all sounds from the SampledSound library?')		ifTrue: [c initialize]].	#(Helvetica Palatino ComicAll Courier) do:		[:k | TextConstants removeKey: k ifAbsent: []].	(TextConstants at: #ComicBold) newFontArray:		((TextConstants at: #ComicBold) fontArray copyFrom: 1 to: 5).! !----QUIT----(24 September 1998 9:15:41 am ) priorSource: 1892389!	Display newDepth: 8.	Project allInstancesDo: [:p | p displayDepth: 8].!----QUIT----(24 September 1998 1:46:17 pm ) priorSource: 1914895!Time millisecondsToRun: [		Interpreter translate: 'interp.c' doInlining: true.		Smalltalk beep]!InterpreterSupportCode writeMacSourceFiles!